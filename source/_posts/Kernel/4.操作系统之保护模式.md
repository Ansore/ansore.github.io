---
title: 操作系统之保护模式
tags:
  - Kernel
categories:
  - Kernel
cover: https://images.ansore.top/i/2022/04/26/626811caa8353.jpg
abbrlink: 15f5ac65
date: 2022-03-13 00:13:10
---

- 实模式（Real Mode)：又名 Real Address Mode，在此模式下地址访问的是真实地内存地址所在位置。在此模式下，可以使用20位（1MB）的地址空间，软件可以不受限制的操作所有地址的空间和IO设备。
- 保护模式（Protected Mode)：又名 Protected Virtual Address Mode，采用虚拟内存、页等机制对内存进行了保护，比起实模式更为安全可靠，同时也增加了灵活性和扩展性。

> **现在的64位处理器，拥有三种基本模式（保护模式、实模式、系统管理模式）和一种扩展模式（IA-32e模式（又分兼容模式和64位模式**

在8086中，实模式采取内存段来管理 0 - 0xFFFFF的这1M内存空间，但是由于只有16位寄存器，所以最大地址只能表示为0xFFFFF（64KB)，因此不得不采取将内存按段划分为64KB的方式来充分利用1M空间。也就是上所示的，采取段选择子 + 偏移量的表示法，直接输出的就是物理地址，CPU 可以直接用此地址访问内存 ，计算如下：

```c
PhysicalAddress = Segment Selector * 16 + Offset
```

而在保护模式下,"段基址+段内偏移地址”称为线性地址,不过,此时的段基址已经不再是真正的地址了,而是一个称为选择子的东西 。 它本质是个索引,类似于数组下标,通过这个索引便能在 GDT 中找到相应的段描述符，在该描述符中记录了该段的起始、大小等信息，这样便得到了段基址。若没有开启地址分页功能,此线性地址就被 当作物理地址来用,可直接访问内存。 若开启了分页功能,此线性地址又多了 一个名字,就是虚拟地址 ( 虚拟地址、线性地址在分页机制下都是一 回事) 。 虚拟地址要经过 CPU 页部件转换成具体的物理地址,这样 CPU 才能将其送上地址总线去访问内存。

![Screenshot_20210411_174013](https://s2.loli.net/2022/03/13/MLfgJlN1iSTnFUW.png)

考虑到各种属性和需要设置的操作，32位保护模式下对一个内存段的描述需要8个字节，其称之为段描述符（Segment Descriptor）。段描述符分为数据段描述符、指令段描述符和系统段描述符三种，大致相同，个体差异。

![img](https://s2.loli.net/2022/03/13/yX1QLPNB6Jqovwb.png)

寄存器不足以存放N多个内存段的描述符集合，所以这些描述符的集合（称之为描述符表）被放置在内存里了。在很多描述符表中，最重要的就是所谓的全局描述符表（Global Descriptor Table，GDT），它为整个软硬件系统服务。

- 这些描述符表放置在内存哪里？答案是没有固定的说法，可以任由程序员安排在任意合适的位置。
- 既然没有指定固定位置，CPU如何知道全局描述符表在哪？答案是Intel干脆设置了一个48位的专用的全局描述符表寄存器（GDTR）来保存全局描述符表的信息。
- 48位怎么分配呢？如图所示，0-15位表示GDT的边界位置（数值为表的长度-1，因为从0计算），16-47位这32位存放的就是GDT的基地址（恰似数组的首地址）。

![img](https://s2.loli.net/2022/03/13/xItuvlfQKRFNM18.png)

既然用16位来表示表的长度，那么2的16次方就是65536字节，除以每一个描述符的8字节，那么最多能创建8192个描述符。

寻址方式：

![img](https://s2.loli.net/2022/03/13/VUDo4SY3dB8l9pI.png)
