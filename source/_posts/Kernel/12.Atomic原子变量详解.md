---
title: Atomic原子变量详解
tags:
  - Kernel
categories:
  - Kernel
cover: https://img.ansore.top/2022/04/27/62692c1359d83.jpg
date: 2022-06-13 00:02:56
---

# 原子变量

适用于针对int变量进行同步的场景 

# Atomic使用

```c
atomic_t ac = ATOMIC_INIT(1);

// 将原子变量-1，如果结果为0，返回true，否则返回false
// 原子操作
atomic_dec_and_test(&ac);
// 原子变量+1
// 原子操作
atomic_inc(&ac)
```

# Atomic实现

## atomic_t定义

定义在`include/linux/types.h`中

```c
typedef struct {
	int counter;
} atomic_t;
```

## 初始化

不同体系下实现不同，x86实现如下：

```c

/*
 * Atomic operations that C can't guarantee us.  Useful for
 * resource counting etc..
 */

#define ATOMIC_INIT(i)	{ (i) }
```

## 嵌入是汇编代码语法

```c
asm("汇编语言"
   :输出寄存器
   :输入寄存器
   :会被修改的寄存器)
```

汇编代码：x86或者arm的汇编代码指令

输出寄存器：表示汇编代码执行完成后，哪些寄存器用于存放输出数据。这些寄存器会分别对应一个C语言表达式或者一个内存地址

输入寄存器：表示开始执行汇编代码时，这里指定的一些寄存器用于存放输入值，也分别对应一个C变量或常数值

会被修改的寄存器：也叫clober list，描述了汇编代码对寄存器的修改情况

## atomic_inc实现

`include/linux/atomic/atomic-instrumented.h`:

```c
static __always_inline void
atomic_inc(atomic_t *v)
{
	instrument_atomic_read_write(v, sizeof(*v));
    // 不同体系下实现不同
	arch_atomic_inc(v);
}
```

采用汇编实现，x86实现如下：

```c
/**
 * arch_atomic_inc - increment atomic variable
 * @v: pointer of type atomic_t
 *
 * Atomically increments @v by 1.
 */
static __always_inline void arch_atomic_inc(atomic_t *v)
{
	asm volatile(LOCK_PREFIX "incl %0"
		     : "+m" (v->counter) :: "memory");
}
#define arch_atomic_inc arch_atomic_inc
```

## atomic_dec实现

```c
static __always_inline void
atomic_dec(atomic_t *v)
{
	instrument_atomic_read_write(v, sizeof(*v));
	arch_atomic_dec(v);
}
```

x86实现如下：

```c
/**
 * arch_atomic_dec - decrement atomic variable
 * @v: pointer of type atomic_t
 *
 * Atomically decrements @v by 1.
 */
static __always_inline void arch_atomic_dec(atomic_t *v)
{
	asm volatile(LOCK_PREFIX "decl %0"
		     : "+m" (v->counter) :: "memory");
}
#define arch_atomic_dec arch_atomic_dec
```

