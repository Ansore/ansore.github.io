---
title: 基本运算原理
tags:
  - 操作系统
categories:
  - 操作系统
cover: 'https://img.ansore.de/2022/04/27/62692c1359d83.jpg'
abbrlink: 6c643e9e
date: 2022-01-03 01:23:19
---

# 基本运算原理

![Untitled](https://img.ansore.de/2022/05/15/6280e376b19f8.png)

![Screenshot_20220103_131456.png](https://img.ansore.de/2022/05/15/6280e37b8a7eb.png)

![Untitled](https://img.ansore.de/2022/05/15/6280e37f7189e.png)

我们可以用一个与门、一个或门，来搭建一个2位的加法器。异或门来计算和 ，与门计算进位。

这个电路称为半加器

![Untitled](https://img.ansore.de/2022/05/15/6280e3824bb68.png)

半加器有2个输入X、Y，2个输出，分别是和以及进位。它能产生进位，但是不能处理进位。这是另一层抽象，我们可以把半加器作为一个元件来使用。我们再进一步，制造一个可以做3位加法的电路。 

![Untitled](https://img.ansore.de/2022/05/15/6280e388becab.png)

3个1位二进制数相加，最大值就是1+1+1=11，同样可以用2位保存结果。具体电路实现，我们可以用2个半加器和1个或门来搭建。一共有3个输入X、Y、Z，我们把X、Y输入到第一个半加器，输出的和跟Z一起输入到第二个半加器。然后把两个半加器的进位输入到或门，第二个半加器输出的和就是最终的和，而或门的输出就是进位。 

![Untitled](https://img.ansore.de/2022/05/15/6280e38b39e2a.png)

两个进位是不可能同时为1的，因为任意两个输入相加，如果产生了进位，那么和一定是0。再加上一位无论是0还是1，都不会产生进位。

我们把3个1位数相加的所有情况都列出来，一共有8种。然后再把电路拉出来，X、Y、Z是三个输入位，XOR 1跟AND 1组成了第一个半加器，XOR 2跟AND 2组成了第二个半加器，OR 1处理两个半加器的进位，这就是全加器的所有电路。

XOR 1的输出是X+Y的和，作为XOR 2还有AND 2的输入。AND 1的输出是X+Y的进位，作为OR 1的输入。Z是XOR 2的第2个输入，XOR 2的输出是最终的和。同时，Z也是AND 2的输入。AND 2的输出和AND 1的输出共同作为OR 1的输入，OR 1的输出就是最终的进位。 

全加器可以接收3个输入，并产生和以及进位，同时它也可以处理计算中产生的进位。 

![Untitled](https://img.ansore.de/2022/05/15/6280e38fef4da.png)

它接受3个输入，并输出和与进位，它也能处理计算过程中的进位。有了半加器和全加器，我们又可以更上一层楼了。计算机中1个1位的二进制数称为1个比特（Bit），也可以叫1位，而8个比特长度的二进制数称为1个字节（Byte）。 

现在我们来搭建一个8位的计算单元，也就是可以接受2个单字节的数A、B作为输入，然后计算它们的和。1个字节共有8个比特，即8位，而计算机中序号是从0开始的。就是说，1个字节的第1位，序号是0。而第8位，序号是7，这个序号我们称为索引（Index）。

A0+B0可以用一个半加器处理，因为不需要处理来自上次计算的进位。而A1+B1需要处理A0+B0的进位以及A1、B1本身，所以需要1个全加器，来处理这3个输入。从A1、B1到A7、B7，都需要处理进位，所以必须都用全加器处理。

我们用1个半加器和7个全加器，就制造了一个可以处理两个字节A、B加法的计算单元。同时我们注意到，最后一个全加器的进位是没有被处理的。所以这可能会导致计算错误，我们称之为溢出。

![Untitled](https://img.ansore.de/2022/05/15/6280e395409d4.png)

那么，它可以做减法吗？可以，但是跟我们平常做减法不一样。计算机里的减法，也是通过加法来实现的，比如我们8-3等价于8+（-3）。那么计算机是怎么表示负数的呢？简单起见，我们以一个4位的计算机为例。 

4位的计算机，能处理的最大的数是1111。我们从0000开始，每次加1，在加了15次之后，我们得到了1111。那么1111+1等于多少呢？正常应该是10000，但是这是一个4位的计算机。所以最高位的1是没法存储的，所以被丢弃了。那么最后结果就是0000，这就又回到了最初的起点。 

![Untitled](https://img.ansore.de/2022/05/15/6280e397aa678.png)

就像钟表一样，指针转完一圈就开始新的一圈，我们也做一个4位二进制表盘。从0000开始顺时针旋转，一直到1111一共16个数字。但是计算机只认识0和1，它可不知道正负数。表盘的16个数字，我们以0000为分界线做个切分。拿出一部分来表示负数，比如最高位是1的部分。那么最高位就成了一个标志位，是0就是正数，是1就表示负数，0的二进制就是0000。 

![Untitled](https://img.ansore.de/2022/05/15/6280e3999859c.png)

而0向右依次加1，就得到了正整数。向左依次减1，就得到了负整数。然后我们把这些数字铺下去，以0为基准，顺时针旋转1下，得到1，再转一下得到2，以此类推。以0为基准，逆时针旋转一下，得到-1，再转一下得到-2，很合理吧。而数学里是没有+0和-0之分的，所以1000不是表示-0，而是表示-8。

我们在这个表盘上做个减法，比如2-3，先把当前位置定到2，-3的话就是逆时针旋转3下，就来到了-1这里。这个很简单，因为我们这个表盘是个循环，所以我们还有另一种方法到达-1。就是从2的位置，继续顺时针旋转，13下之后就到了-1。 

因为从2出发，转一整圈还会回到2，就如同钟表一样。所以2+16其实就等效于2，所以2-3也等于2+16-3，这里结合咱们的表盘，停下来想一想。 

而对于-1～-7，如何计算它在表盘上的二进制数呢？我们以-1为例，+1的二进制数为0001。那么我们先把标志位切换为1，得到1001，这个叫做-1的原码。然后把1001除了标志位外的3位取反，得到1110，这个叫做-1的反码。然后再把反码加1，得到1111，这就是-1的补码。 

![Untitled](https://img.ansore.de/2022/05/15/6280e39d28eb6.png)

1～-7在表盘上对应的二进制数字，就是补码。0和正整数1～7的原码、反码、补码都是一样的。-8有点不一样，1000本来是表示-0，但是只有1个0。所以-8的原码、反码、补码都是一个码1000。其实1000也等于+7的码0111+1。 

4位计算机下的整数表示。范围是-8～7，共计16个数字。同时，这个理论也适用于任何多位的计算机，无论是8位、32位、64位，方法都一样

![Screenshot_20220103_132312.png](https://img.ansore.de/2022/05/15/6280e39e73893.png)

那我们来做个减法 7-3，首先我们获取-3的原码1011，然后取反得到-3的反码1100，在把反码+1得到-3的补码1101。7的补码是0111，0111+1101=10100，最高位的1会被丢弃，所以最后结果是0100，也就是4。 

![Untitled](https://img.ansore.de/2022/05/15/6280e3a08195b.png)

这里做一个把4位机拓展到N位机的小总结

![Untitled](https://img.ansore.de/2022/05/15/6280e3a64bd1a.png)

那我们那个8位的计算单元，能做乘除法吗？必须的，只不过乘法是通过拆成加法来做的，比如4x5，就是4个5相加。而除法是先拆成减法，比如20/5，就是20持续的减5，再把减法通过加法实现。

总而言之，这个8位计算单元，加减乘除都能做。而更先进的CPU，可以通过搭建专业的电路来做乘除法 

同时，计算机除了做计算之外，还需要做一些逻辑判断。比如判断计算结果是否溢出，这个我们在全加器那提到过。判断结果是否为0，可以额外搭建一个电路。判断奇偶性则可以通过判断最终结果的最低位是否为0。我们来看看判0电路怎么做，8位的计算单元输出是8位，我们用7个或门，依次计算其中任意一位是否为1，就可以得出结论了。 

![Untitled](https://img.ansore.de/2022/05/15/6280e3a97908a.png)

而计算单元+逻辑单元，组合起来就得到了一个ALU。全称是逻辑运算单元，既能做逻辑判断也能做加减乘除等计算，我们用一个大V来表示。它接受2个8位也就是1字节的输入，同时输出1个8位的结果。它接受1个4位的操作码，比如1000代表加。也会输出诸如结果是否为0或者为负值等逻辑状态，这就是一个基本全功能的ALU了。

![Untitled](https://img.ansore.de/2022/05/15/6280e3adbf896.png)

而诸如我们提到的1000代表加法，这就是计算机指令。世界上第一个封装到单芯片中的完整ALU，是英特尔的74181芯片，它使用了70个晶体管，是一个4位的ALU。
