---
title: MIT6.S081 XV6 lab3 page tables
tags:
  - XV6
  - 操作系统
categories:
  - 操作系统
abbrlink: 800f9d20
date: 2022-04-11 22:34:32
---

# Speed up system calls

> When each process is created, map one read-only page at USYSCALL (a VA defined in `memlayout.h`). At the start of this page, store a `struct usyscall` (also defined in `memlayout.h`), and initialize it to store the PID of the current process. For this lab, `ugetpid()` has been provided on the userspace side and will automatically use the USYSCALL mapping. You will receive full credit for this part of the lab if the `ugetpid` test case passes when running `pgtbltest`.

> Some hints:
>
> - You can perform the mapping in `proc_pagetable()` in `kernel/proc.c`.
> - Choose permission bits that allow userspace to only read the page.
> - You may find that `mappages()` is a useful utility.
> - Don't forget to allocate and initialize the page in `allocproc()`.
> - Make sure to free the page in `freeproc()`.

加速系统调用，在内核和用户之间建立一个共享的只读页，这样内核往这个页写入数据的时候，用户程序就可以不经过复杂的系统调用，直接读取。

实验要求我们映射一个只读页`USYSCALL`，用户程序可以直接调用它。用户态调用`ugetpid()`如下：

```c
#ifdef LAB_PGTBL
int
ugetpid(void)
{
  struct usyscall *u = (struct usyscall *)USYSCALL;
  return u->pid;
}
#endif
```

读取时直接从`USYSCALL`这个地址里读取数据。`TRAMPOLINE`意为蹦床，用来进行trap to the kernel操作的。下面的`TRAPFRAME`保存了一些进程的参数。`USYSCALL`是紧挨着`trapframe`下端的一页。

```c
// map the trampoline page to the highest address,
// in both user and kernel space.
#define TRAMPOLINE (MAXVA - PGSIZE)

// map kernel stacks beneath the trampoline,
// each surrounded by invalid guard pages.
#define KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)

// User memory layout.
// Address zero first:
//   text
//   original data and bss
//   fixed-size stack
//   expandable heap
//   ...
//   USYSCALL (shared with kernel)
//   TRAPFRAME (p->trapframe, used by the trampoline)
//   TRAMPOLINE (the same page as in the kernel)
#define TRAPFRAME (TRAMPOLINE - PGSIZE)
#ifdef LAB_PGTBL
#define USYSCALL (TRAPFRAME - PGSIZE)

struct usyscall {
  int pid;  // Process ID
};
#endif
```

内存分布如下所示：

![Screenshot_20220411_224716](https://s2.loli.net/2022/04/11/Fymicjeal6qX3Vw.png)

`proc_pagetable`里面设置映射：

```c
  // map the trampoline code (for system call return)
  // at the highest user virtual address.
  // only the supervisor uses it, on the way
  // to/from user space, so not PTE_U.
  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
              (uint64)trampoline, PTE_R | PTE_X) < 0){
    uvmfree(pagetable, 0);
    return 0;
  }

  // map the trapframe just below TRAMPOLINE, for trampoline.S.
  if(mappages(pagetable, TRAPFRAME, PGSIZE,
              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
    uvmfree(pagetable, 0);
    return 0;
  }
```

xv6先给`TRAPFRAME`分配一块内存，再白`TRAPFRAME`映射到这块内存上。`allocproc()`中，首先会搜索进程表，搜索到UNUSED进程就为其分配内存，然后给进程表p赋值：

```c
  p->pid = allocpid();
  p->state = USED;

  // Allocate a trapframe page.
  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }
```

具体思路如下：

1. 进程表中添加usyscall的成员变量

```c
// Per-process state
struct proc {
  ...
  struct trapframe *trapframe; // data page for trampoline.S
  struct usyscall *usyscall;   // usyscall
  ...
};
```

2. 为usyscall分配一页内存，并把进程的pid保存到页表中。

```c
  // allocate a usyscall page
  if((p->usyscall = (struct usyscall *)kalloc()) == 0){
    freeproc(p);
    release(&p->lock);
    return 0;
  }
  p->usyscall->pid = p->pid;
```

3. 添加映射。如果映射失败，需要释放`TRAMPOLINE`和`TRAPFRAME`的映射

```c
  // map the usyscall just below TRAMPOLINE, for trampoline.S.
  if(mappages(pagetable, USYSCALL, PGSIZE,
              (uint64)(p->usyscall), PTE_R | PTE_U) < 0){
    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
    uvmunmap(pagetable, TRAPFRAME, 1, 0);
    uvmfree(pagetable, 0);
    return 0;
  }
```

4. `freeproc`的时候需释放`usyscall`页

```c
  if(p->usyscall)
    kfree((void*)p->usyscall);
```

5. `proc_freepagetable`取消映射页表的时候，添加USYSCALL的映射关系

```c
// Free a process's page table, and free the
// physical memory it refers to.
void
proc_freepagetable(pagetable_t pagetable, uint64 sz)
{
  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
  uvmunmap(pagetable, TRAPFRAME, 1, 0);
  uvmunmap(pagetable, USYSCALL, 1, 0);
  uvmfree(pagetable, sz);
}
```

# Print a page table
