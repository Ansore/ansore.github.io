---
title: Redis数据结构-简单动态字符串（SDS）
tags:
  - Redis
  - SDS
categories:
  - Redis
cover: >-
  https://img.ansore.de/2022/06/19/f9ebe28562201c21e8b13111cdaa3c8ea9bfd66d.jpeg
abbrlink: 46daf9d5
date: 2022-06-01 00:02:56
---


# 简单动态字符串（SDS）

简单动态字符串（simple dynamic string,SDS）作为Redis默认字符串表示。C字符串只会作为字符串常量（String literal）用在一些无需对字符串值进行修改的地方，如日志打印

包含字符串的键值对在底层都是由SDS实现的

如：

```bash
redis> SET msg "hello world"
OK
```

- 键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串`msg`的SDS
- 键值对的值是一个字符串对象，对象的底层实现是一个保存着字符串`hello world`的SDS

```bash
redis> RPUSH fruits "apple" "banana" "cherry"
(integer) 3
```

- 键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串`fruits`的SDS
- 键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现，第一个SDS保存`apple`....

除了用来保存数据库中的字符串以外，SDS还被用作缓冲区（buffer）：AOF模块的中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是由SDS实现

# SDS的定义

```c
/*
 * 保存字符串对象的结构
 */
struct sdshdr {
    // buf 中已占用空间的长度
    int len;
    // buf 中剩余可用空间的长度
    int free;
    // 数据空间
    char buf[];
};
```

![Screenshot_20211219_200621.png](https://img.ansore.de/2022/06/19/d03a878cb23ff387159bf549438f2676.png)

- free属性的值为0，表示这个SDS没有分配任何使用空间
- len属性的值为5，表示这个SDS保存了一个五字节长的字符串
- buf属性是一个char类型的数组，数组的前5个字节分别保存了R、e、d、i、s五个字符，而最后一个字节则保存了空字符’\0’

SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。

# SDS与C字符串的区别

C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符’\0’

## 常数复杂度获取字符串长度

因为C字符串并不记录自身长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O(N)。

SSD在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度为O(1)。

## 杜绝缓冲区溢出

除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题容易造成缓冲区溢出（buffer overflow）。

如<string.h>/strcat函数可以将src字符串中的内容拼接到dest字符串末尾：

```c
char *strcat(char *dest, const char *src);
```

因为字符串不记录自身长度，所以strcat假定用户在执行这个函数时，已经为dest分配了组够多的内存，可以容纳src字符串中的所有内容，而一旦这个假定不成立，就会产生缓冲区溢出；

与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。

## 减少修改字符串时带来的内存重分配次数

C字符串并不记录自身长度，所以对于一个包含了N个字符的C字符来说，这个C字符串的底层实现总是一个N+1个字符长度的数组（额外的一个字符空间用于保存空字符）。因为C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作。

- 如果程序执行的是增长字符串的操作，比如拼接操作，那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小—如果没有这步就会产生缓冲区溢出
- 如果程序执行的是缩短字符串的操作，比如截断操作，那么在执行这个操作后，程序需要通过程序重分配来释放字符串不再使用那部分空间—如果忘了这一步则会产生内存泄露

因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以是一个比较耗时的操作。为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符串数量加1，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。

通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。

### 1.空间预分配

空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所需要的空间，还会为SDS分配额外的未使用空间。其中，额外分配的未使用空间数量由以下公式决定：

- 如果对SDS进行修改之后，SDS的长度降小于1M，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性值将和free属性的值相同。如果进行修改后，SDS的len将变成13字节，那么程序也会分配13字节未使用空间，SDS的buf数组的实际长度将变成13+13+1=27字节（额外的1字节用于保存空字符）
- 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。如果进行修改之后，SDS的len将变成30MB，那么程序分配1MB的未使用空间，SDS的buf数组的实际长度为30MB+1MB+1byte

通过空间预分配策略，Redis可以减少连续执行字符串增长追做所需的内存重分配次数。

在扩展SDS空间之前。SDS API会先检查未使用空间是否足够，如果足够的话，API就会直接使用未使用空间，而无需执行内存重分配。通过这种分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。

### 2.惰性空间释放

惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回缩短后出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。

通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来有可能的增长操作提供了优化。 

## 二进制安全

C字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使用C字符串智能保存文本数据，而不能保存图像、音频、视频这样的二进制数据。

SDS所有的API都是二进制安全的，所有的SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤等。不仅可以保存文本数据，还可以保存任意格式二进制数据。

## 兼容部分C字符串函数

通过遵循C字符串以空字符结尾的惯例，SDS可以在有需要时重用<string.h>函数库，从而避免了不必要的代码重复。
