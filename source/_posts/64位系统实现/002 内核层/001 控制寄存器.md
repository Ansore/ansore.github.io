---
title: 控制寄存器
tags:
  - 64位系统实现
  - 操作系统
categories:
  - 操作系统
cover: 'https://img.ansore.top/2022/04/27/62692c1359d83.jpg'
abbrlink: ea957129
date: 2022-07-28 10:26:06
---


 `GDT`、`LDT`和`IDT`表都是描述符表。描述符表是由若干个描述符组成，每个描述符占用8个字节的内存空间，每个描述符表内最多可以有（8K）8129个描述符。描述符是描述一个段的大小，地址及各种状态的。

# 控制寄存器

CR0～4：

![Screenshot_20220725_003011](https://img.ansore.top/2022/07/25/daa8767af692da6ae6f43fd0008a21a5.png)

`GDTR`、`IDTR`等：

![Screenshot_20220725_002823](https://img.ansore.top/2022/07/25/b7d8383b21e74abe2fe9a8d5da176e93.png)

# GDT

## 全局描述符GDT

全局描述表（GDT Global Descriptor Table）。在整个系统中，全局描述符表`GDT`只有一张(一个处理器对应一个GDT)，`GDT`可以被放在内存的任何位置。系统用`GDTR`寄存器存放当前`GDT`表的基地址。在保护模式下，对一个段的描述包括3个方面的因素：Base Address、Limit、Access，它们加在一起被放在一个64-bit长的数据结构中，被称为段描述符。段描述符结构如下：

![GDT](https://img.ansore.top/2022/07/16/905187cc02cb7aed4156b74d2d9b4e5b.png)

![Screenshot_20220724_234640](https://img.ansore.top/2022/07/24/a06576c7eb380b99b8051096b29616ba.png)

## GDTR

`GDTR`是一个长度为48bit的寄存器，内容为一个32位的基地址和一个16位的段限。其中32位的基址是指`GDT`在内存中的地址。基地址指定`GDT`表中字节0在线性地址空间中的地址，表长度指明`GDT`表的字节长度值。指令`LGDT`和`SGDT`分别用于加载和保存`GDTR`寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成`0xFFFF`。在保护模式初始化过程中必须给`GDTR`加载一个新值。

段描述符使用数组存储，使用`LGDT`指令将`GDT`的入口地址装入`GDTR`寄存器。基地址指定`GDT`表中字节0在线性地址空间中的地址，表长度指明`GDT`表的字节长度值。指令`LGDT`和`SGDT`分别用于加载和保存`GDTR`寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成`0xFFFF`。在保护模式初始化过程中必须给`GDTR`加载一个新值。

## 段选择子

![Screenshot_20220724_234238](https://img.ansore.top/2022/07/24/c14511da8b81d3d2ca08189e8b5d21c9.png)

段选择子是一个16位的数据结构，其索引号作为GDT表的下标，索引号只有13位，所以GDT表最多有8192个元素，其结构如下：

![段选择子](https://img.ansore.top/2022/07/16/f2f5153bed0b2eecb342a35a3186936a.png)

段选择子包括三部分：描述符索引（`index`）、`TI`、请求特权级（`RPL`）。他的`index`（描述符索引）部分表示所需要的段的描述符在描述符表的位置，由这个位置再根据在`GDTR`中存储的描述符表基址就可以找到相应的描述符。然后用描述符表中的段基址加上逻辑地址（`SEL:OFFSET`）的`OFFSET`就可以转换成线性地址，段选择子中的`TI`值只有一位0或1，0代表选择子是在`GDT`选择，1代表选择子是在`LDT`选择。请求特权级（`RPL`）则代表选择子的特权级，共有4个特权级（0级、1级、2级、3级）。

> 特权级：任务中的每一个段都有一个特定的级别。每当一个程序试图访问某一个段时，就将该程序所拥有的特权级与要访问的特权级进行比较，以决定能否访问该段。系统约定，CPU只能访问同一特权级或级别较低特权级的段。

如给出逻辑地址：`21h:12345678h`转换为线性地址

1. 选择子`SEL=21h=0000000000100 0 01b` 他代表的意思是：选择子的`index=4`即`100b`选择`GDT`中的第4个描述符；`TI=0`代表选择子是在`GDT`选择；左后的`01b`代表特权级`RPL=1`
2. `OFFSET=12345678h`若此时`GDT`第四个描述符中描述的段基址（`Base`）为`11111111h`，则`线性地址=11111111h+12345678h=23456789h`

# LDT

局部描述符表`LDT`（Local Descriptor Table）局部描述符表可以有若干张，每个任务可以有一张。在相应的段寄存器装入段选择子，安装索引号到`GDT`或`LDT`中找到对应的段描述符，得到`Base Address`再加上Offset，就得到了内存地址。

由于每个进程都有自己的一套程序段、数据段、堆栈段，有了局部描述符表则可以将每个进程的程序段、数据段、堆栈段封装在一起，只要改变`LDTR`就可以实现对不同进程的段进行访问。

`LDT`和`GDT`从本质上说是相同的，只是`LDT`嵌套在`GDT`之中。`LDTR`记录局部描述符表的起始位置，与`GDTR`不同，`LDTR`的内容是一个段选择子。由于`LDT`本身同样是一段内存，也是一个段，所以它也有个描述符描述它，这个描述符就存储在`GDT`中，对应这个表述符也会有一个选择子，`LDTR`装载的就是这样一个选择子。`LDTR`可以在程序中随时改变，通过使用`lldt`指令。如上图，如果装载的是`Selector 2`则`LDTR`指向的是表`LDT2`。

如果我们想在表LDT2中选择第三个描述符所描述的段的地址12345678h：

1. 首先需要装载`LDTR`使它指向`LDT2`，使用指令`lldt`将`Select2`装载到`LDTR`
2. 通过逻辑地址（`SEL:OFFSET`）访问时`SEL`的`index=3`代表选择第三个描述符；TI=1代表选择子是在LDT选择，此时LDTR指向的是`LDT2`,所以是在`LDT2`中选择，此时的`SEL`值为`1Ch`(二进制为`11 1 00b`)。OFFSET=12345678h。逻辑地址为1C:12345678h
3. 由SEL选择出描述符，由描述符中的基址（Base）加上`OFFSET`可得到线性地址，例如基址是11111111h，则`线性地址=11111111h+12345678h=23456789h`
4. 此时若再想访问`LDT1`中的第三个描述符，只要使用lldt指令将选择子`Selector 1`装入再执行2、3两步就可以了（因为此时`LDTR`又指向了`LDT1`）

当进行任务切换时，处理器会把新任务`LDT`的段选择符和段描述符自动地加载进`LDTR`中。在机器加电或处理器复位后，段选择符和基地址被默认地设置为0，而段长度被设置成`0xFFFF`。

# IDT

IDT，Interrupt Descriptor Table，即中断描述符表，和`GDT`类似，他记录了0~255的中断号和调用函数之间的关系。整个系统IDT表也只有一张，`GDT`表也可以被放在内存的任何位置寄存器。`IDTR`寄存器存放IDT表的基地址。x86 CPU最大可以支持256种中断ISR(中断处理程序)，每个表项为8字节。Intel指定或保留了前32个中断号的作用，操作系统可以指定其余的中断号的作用。

![IDT](https://img.ansore.top/2022/07/16/da9f7dab19119141e7e889eafcc51adb.png)

## IDTR

与`GDTR`的作用类似，`IDTR`寄存器用于存放中断描述符表`IDT`的32位线性基地址和16位表长度值。指令`LIDT`和`SIDT`分别用于加载和保存`IDTR`寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成`0xFFFF`。

# TR

`TR`用于寻址一个特殊的任务状态段（`Task State Segment，TSS`）。`TSS`中包含着当前执行任务的重要信息。

`TR`寄存器用于存放当前任务`TSS`段的16位段选择符、32位基地址、16位段长度和描述符属性值。它引用`GDT`表中的一个`TSS`类型的描述符。指令`LTR`和`STR`分别用于加载和保存TR寄存器的段选择符部分。当使用`LTR`指令把选择符加载进任务寄存器时，`TSS`描述符中的段基地址、段限长度以及描述符属性会被自动加载到任务寄存器中。当执行任务切换时，处理器会把新任务的`TSS`的段选择符和段描述符自动加载进任务寄存器TR中。

# 分页

64位4级页表分页模式如下：

![Screenshot_20220717_123739](https://img.ansore.top/2022/07/17/f3cc66c5587172a41a044ed809c0a0ca.png)

1. PML4：这是IA-32e模式新增的页转换表，每个表4K字节，包含512个PML4E结构
2. PDPT：每个表4K字节，包含512个PDPTE结构
3. PDT：每个表4K字节，包含512个PDE结构
4. PT：每个表4K字节，包含512个PTE结构

当前的x64体系中，如果使用4级分页，处理器64位线性地址空间只实现了48位，高16位被用作Bit 47位的符号扩展位，要么全是0，要么全是1。每个页表项结构都是8个字节64位宽，而虚拟地址中的每个页表项索引值都是9位，因此每个页表都是512 * 8 = 4K字节。

## CR3

- 如果设置寄存器`CR0.PG = 1, CR4.PAE = 1, IA32_EFER.LME = 1, and CR4.LA57 = 0`，则处理器使用4级分页，4级分页将48位线性地址转换位52位物理地址。虽然52位对应4个字节，但是线性地址只有48位，最多可以访问256TB的线性地址空间。
- 如果设置寄存器`CR0.PG = 1, CR4.PAE = 1, IA32_EFER.LME = 1, and CR4.LA57 = 1`，则处理器使用5级分页，5级分页将57位线性地址空间转换为52位物理地址。5级分页的线性地址空间足够访问整个物理地址空间。

如果是4级页表，CR3的第一个寻呼地址PML4；如果是5级页表，CR3第一个寻呼地址为PML4。

`CR3`的使用取决于是否设置处理器上下文标识符（PCID）。

如果`CR4.PCIDE = 0`，则CR3寄存器位使用如下：

![Screenshot_20220717_132906](https://img.ansore.top/2022/07/17/097c86a46eb1dbb16af9f099b666e518.png)

![Screenshot_20220717_132929](https://img.ansore.top/2022/07/17/a0e0a956f3a8de49f9e70bface60cb78.png)

如果`CR4.PCIDE = 1`，则CR3寄存器位使用如下：

![Screenshot_20220717_133023](https://img.ansore.top/2022/07/17/14dc2c8fa5892b029299fff33ab9ee12.png)

IA-32e模式下CR3以及各页表的结构：

![Screenshot_20220717_131048](https://img.ansore.top/2022/07/17/41220ac1c2c03d6a4e87de24ec446c95.png)

## PML5E

PML5E位说明如下：

![Screenshot_20220717_133121](https://img.ansore.top/2022/07/17/c82829d9e080b4624e1abf5c5a1eea36.png)

## PML4E

PML4E位说明如下：

![Screenshot_20220717_133155](https://img.ansore.top/2022/07/17/1eb94257a6900131a9aca34d69e07e39.png)

![Screenshot_20220717_133207](https://img.ansore.top/2022/07/17/af58053ff951773aa4561ca059df7739.png)

## PDPTE

PDPTE位说明：

![Screenshot_20220717_133325](https://img.ansore.top/2022/07/17/cb95ea538c073a6642d8e3d099a8f907.png)

## PDE

PDE位说明：

![Screenshot_20220717_133401](https://img.ansore.top/2022/07/17/de63bf4142f71470533c79c2545cbe1b.png)

## PTE

PTE位说明：

![Screenshot_20220717_133427](https://img.ansore.top/2022/07/17/1b78c24ed83d3cd64df10f0c0229cf5c.png)

