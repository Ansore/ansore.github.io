---
title: 由先序遍历和后序遍历推中序遍历
tags:
  - 编程
  - 算法
categories:
  - 编程
cover: https://images.ansore.top/i/2022/04/27/62692f1609241.jpg
abbrlink: c77bb8b4
date: 2018-03-21 15:55:31
---

### 问题描述

给定一棵二叉树的前序遍历和后序遍历，给出一种可能的中序遍历结果

输入示例：

> A B D C E
>
> D B E C A

输出示例：

> 一种可能的中序遍历结果为：D B A E C

<!--more-->

### C语言实现

```c
#include <stdio.h> 
#include <stdlib.h>
#include <string.h>

typedef struct TreeNode {
  struct TreeNode* left;  
  struct TreeNode* right;  
  char  elem;  
} TreeNode;

/**
 * 截取s字符串子串 n <= x <= m
 */
char * getString(char * s, int n, int m) {
    n ++;
    m ++;
    char *r = (char *) malloc(sizeof(char) * (m - n));
    s = s + (n - 1);
    for(int i = 0; i < m - (n - 1); i ++) {
        r[i] = s[i];
    }
    return r;
}

// 递归中序遍历
// 定义中序遍历结果为全局变量 结果保存到 inorder中
int tempIndex = 0;
char *inorder;
void inTree(TreeNode *tree) {
    if(tree != NULL) {
        // left
        inTree(tree->left);

        printf(" %c ", tree->elem);
        if(tempIndex == 0) {
            inorder = (char *) malloc(sizeof(char));
        } else {
            inorder = (char *) realloc(inorder, sizeof(char)*(tempIndex+1));
        }
        inorder[tempIndex] = tree->elem;
        tempIndex ++;
        // printf(" --%c-- ", inorder[tempIndex]);
        //right
        inTree(tree->right);
    }
    // printf("\n---%d-----\n", tempIndex);
}
/**
 * 由先序 后序构造树
 */
TreeNode * buildTree(char* preorder, char* postorder){
    // 如果长度为 1 证明没有孩子
    if(strlen(preorder) == 1 || strlen(postorder) == 1) {
        // printf("%c ", preorder[0]);
        TreeNode * r = (TreeNode *) malloc(sizeof(TreeNode));
        r->elem = preorder[0];
        return r;
    }

    TreeNode *node = (TreeNode *) malloc(sizeof(TreeNode));
    // 第一个为根节点
    node->elem = preorder[0];

    //左右子数都有, 先序第二个元素为左子树根
    if(preorder[1] != postorder[strlen(postorder) - 2]) {
        // m左子树长度 n左子树根
        int m=0, n=1;
        for(int i=0; i<strlen(postorder); i++) {
            if(preorder[1] == postorder[i]) {
                m = i + 1;
            }
        }
        // 左子树先后序
        printf("左子树先后序:\n");
        printf("---%s----\n", getString(postorder, 0, m-1));
        printf("---%s----\n", getString(preorder, n, m));
        // 右子数先后序
        printf("右子树先后序:\n");
        printf("---%s----\n", getString(preorder, m+1, strlen(preorder)-1));
        printf("---%s----\n", getString(postorder, m, strlen(postorder) - 2));

        //递归
        node->left = buildTree(getString(preorder, n, m),getString(postorder, 0, m-1));
        // printf("%c ", preorder[0]);
        node->right = buildTree(getString(preorder, m+1, strlen(preorder)-1),getString(postorder, m, strlen(postorder) - 2));
    } else { //只有左子数
        node->left = buildTree(getString(preorder, 1, strlen(preorder)-1),getString(postorder, 0, strlen(postorder) - 2));
        node -> right = NULL;
    }

    return node;
}

int main() {
    char *pr = "ABDGHECKFIJ";
    char *po = "GHDEBKJIFCA";
    TreeNode * t = buildTree(pr,po);
    printf("\n\n中序遍历结果为:");
    inTree(t);
    printf("\n");
    return 0;
}
```

