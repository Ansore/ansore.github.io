<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>64位操作系统-屏幕显示 | Ansore</title><meta name="keywords" content="操作系统,64位系统实现"><meta name="author" content="Ansore"><meta name="copyright" content="Ansore"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="为了在屏幕上显示颜色，必须通过桢缓冲存储器完成。桢缓冲存储器（Frame Buffer），简称桢缓存或桢存。它是屏幕显示画面的一个内存映像，桢缓存的每个存储单元对应屏幕的一个像素，整个桢缓存对应一幅图像。桢缓存的特点是可对每个像素点进行操作，不仅可以借助它在屏幕上画出屏幕上色彩，还可以在屏幕上用像素点绘制文字以及图片。 此前设置说显示芯片的显示模式（模式号：0x180，分辨率：1400*900，颜">
<meta property="og:type" content="article">
<meta property="og:title" content="64位操作系统-屏幕显示">
<meta property="og:url" content="https://blog.ansore.top/posts/6e1a5d82.html">
<meta property="og:site_name" content="Ansore">
<meta property="og:description" content="为了在屏幕上显示颜色，必须通过桢缓冲存储器完成。桢缓冲存储器（Frame Buffer），简称桢缓存或桢存。它是屏幕显示画面的一个内存映像，桢缓存的每个存储单元对应屏幕的一个像素，整个桢缓存对应一幅图像。桢缓存的特点是可对每个像素点进行操作，不仅可以借助它在屏幕上画出屏幕上色彩，还可以在屏幕上用像素点绘制文字以及图片。 此前设置说显示芯片的显示模式（模式号：0x180，分辨率：1400*900，颜">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png">
<meta property="article:published_time" content="2022-08-13T02:26:06.000Z">
<meta property="article:modified_time" content="2024-01-03T14:54:50.100Z">
<meta property="article:author" content="Ansore">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="64位系统实现">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://blog.ansore.top/posts/6e1a5d82"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "bmljz8fd92");</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '64位操作系统-屏幕显示',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-03 22:54:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5371728450390652" crossorigin="anonymous"></script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Ansore" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/logo.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">176</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-th"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ansore</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-th"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">64位操作系统-屏幕显示</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-13T02:26:06.000Z" title="发表于 2022-08-13 10:26:06">2022-08-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-03T14:54:50.100Z" title="更新于 2024-01-03 22:54:50">2024-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="64位操作系统-屏幕显示"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>为了在屏幕上显示颜色，必须通过桢缓冲存储器完成。桢缓冲存储器（Frame Buffer），简称桢缓存或桢存。它是屏幕显示画面的一个内存映像，桢缓存的每个存储单元对应屏幕的一个像素，整个桢缓存对应一幅图像。桢缓存的特点是可对每个像素点进行操作，不仅可以借助它在屏幕上画出屏幕上色彩，还可以在屏幕上用像素点绘制文字以及图片。</p>
<p>此前设置说显示芯片的显示模式（模式号：<code>0x180</code>，分辨率：<code>1400*900</code>，颜色深度：<code>32bit</code>），而且内核执行头程序还将桢缓存的物理基地址映射到线性地址<code>0xffff800000000000</code>和<code>0xa00000</code>处。</p>
<h1 id="屏幕上显示色彩"><a href="#屏幕上显示色彩" class="headerlink" title="屏幕上显示色彩"></a>屏幕上显示色彩</h1><p>桢缓存格式：一个像素点能够显示的颜色值位宽。Loader引导加载程序设置的显示模式可支持32位颜色深度的像素点，其中0~7位代表蓝色，8~15位代表吝啬，16~23位代表红色，24~31位是保留位。</p>
<p>如果想设置屏幕上某个像素点的颜色，必须知道这个点在屏幕上的位置，并计算处该点距离屏幕原点的偏移值。屏幕坐标位于左上角。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/07/17/f0cb431f8823fce8937065a5dc12a1cb.png" alt="Screenshot_20220717_202647"></p>
<p>显示屏幕色带如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> *addr = (<span class="type">int</span> *)<span class="number">0xffff800000a00000</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>桢缓存区被映射的线性地址是<code>0xffff800000a00000</code>，在显示模式的过程中，有个寄存器位可以在设置显示模式后清除屏幕上的数据。Loader引导加载程序已将该寄存器位置位，所以先前在屏幕上显示的信息已经被清除。</p>
<h1 id="在屏幕上显示LOG"><a href="#在屏幕上显示LOG" class="headerlink" title="在屏幕上显示LOG"></a>在屏幕上显示LOG</h1><p>在一个固定像素方块内用像素点画出字符，即可实现屏幕上的字符显示功能。</p>
<h2 id="ASCII字符库"><a href="#ASCII字符库" class="headerlink" title="ASCII字符库"></a>ASCII字符库</h2><p>ASCII字符集共有256个字符，其中包括字母、数字、符号和一些非显示信息。当前只显示一些常用的显示字符。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/07/17/f8954db257145db17c014f52bb72f95e.png" alt="Screenshot_20220717_204028"></p>
<p>数字0和一个8*16的像素点矩阵，像素点矩阵中的黑色像素点在屏幕上映射组成了数字0，它们是数字0的字体颜色。只要根据像素点矩阵的映射原理，计算出每行的16进制数值，再将这16行数值组合起来就构成了字符像素位图。一行刚好一个字节，所以只需要保留16字节的位图即可。</p>
<h2 id="显示彩色字符"><a href="#显示彩色字符" class="headerlink" title="显示彩色字符"></a>显示彩色字符</h2><p>实现color_printk函数前，需要先准备一个用于屏幕信息的结构体struct position。该结构体记录这当前屏幕的分辨率、字符光标所在位置、字符像素矩阵尺寸、桢缓冲区起始地址和桢缓冲区容量大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">position</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> XResolution; <span class="comment">// 配置屏幕的分辨率</span></span><br><span class="line">  <span class="type">int</span> YResolution;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> XPosition; <span class="comment">// 光标所在列</span></span><br><span class="line">  <span class="type">int</span> YPosition; <span class="comment">// 光标所在行</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> XCharSize; <span class="comment">//一个字符的宽度</span></span><br><span class="line">  <span class="type">int</span> YCharSize; <span class="comment">// 一个字符的高度</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *FB_addr; <span class="comment">//帧缓冲区起始线性地址</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> FB_length; <span class="comment">//每个像素点需要4字节的值进行控制</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化全局屏幕信息描述：</p>
<p><code>kernel/main.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">position</span> <span class="title">pos</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> *addr = (<span class="type">int</span> *)<span class="number">0xffff800000a00000</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// 配置屏幕的分辨率/光标位置/字符矩阵的尺寸/帧缓冲区起始线性地址/缓冲区长度</span></span><br><span class="line">  pos.x_resolution = <span class="number">1440</span>; <span class="comment">// 从左到右横向1440</span></span><br><span class="line">  pos.y_resolution = <span class="number">900</span>; <span class="comment">// 从上到下纵向900</span></span><br><span class="line">  pos.x_position = <span class="number">0</span>; <span class="comment">// 光标所在列</span></span><br><span class="line">  pos.y_position = <span class="number">0</span>; <span class="comment">// 光标所在行</span></span><br><span class="line">  pos.x_char_size = <span class="number">8</span>; <span class="comment">//一个字符的宽度</span></span><br><span class="line">  pos.y_char_size = <span class="number">16</span>; <span class="comment">// 一个字符的高度</span></span><br><span class="line">  pos.fb_addr = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0xffff800000a00000</span>; <span class="comment">//帧缓冲区起始线性地址</span></span><br><span class="line">  pos.fb_length = (pos.x_resolution * pos.y_resolution * <span class="number">4</span>); <span class="comment">//每个像素点需要4字节的值进行控制</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  color_printk(YELLOW, BLACK, <span class="string">&quot;Hello\t\t World!\n&quot;</span>);</span><br><span class="line">  color_printk(GREEN, BLACK, <span class="string">&quot;Hello %c World!\n&quot;</span>, <span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印字符函数实现：</p>
<p><code>kernel/printk.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print character of paramters required</span></span><br><span class="line"><span class="comment"> * @param fb 帧缓存线性地址</span></span><br><span class="line"><span class="comment"> * @param x_size 行分辨率</span></span><br><span class="line"><span class="comment"> * @param x 列像素点位置</span></span><br><span class="line"><span class="comment"> * @param y 行像素点位置</span></span><br><span class="line"><span class="comment"> * @param fb_color 颜色</span></span><br><span class="line"><span class="comment"> * @param bk_color 背景</span></span><br><span class="line"><span class="comment"> * @param font 字符位图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">putchar</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *fb, <span class="type">int</span> x_size, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> fb_color,</span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> bk_color, <span class="type">unsigned</span> <span class="type">char</span> font)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *addr = <span class="literal">NULL</span>; <span class="comment">//指向32位内存空间的指针,用于写入一个像素点的颜色</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *fontp = <span class="literal">NULL</span>;</span><br><span class="line">  fontp = font_ascii[font]; <span class="comment">//字符位图中的一行</span></span><br><span class="line">  <span class="type">int</span> testval; <span class="comment">//用来测试比特位是否有效(是否要填充)</span></span><br><span class="line">  <span class="comment">//这段程序使用到了帧缓存区首地址,将该地址加上字符首像素位置(首像素位置是指字符像素矩阵左上角第一个像素点)的偏移( Xsize * ( y + i ) + x ),可得到待显示字符矩阵的起始线性地址</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    addr = fb + x_size * (y + i) + x;</span><br><span class="line">    testval = <span class="number">0x100</span>; <span class="comment">//256=&gt;1 0000 0000</span></span><br><span class="line">    <span class="comment">//for循环从字符首像素地址开始,将字体颜色和背景色的数值按字符位图的描绘填充到相应的线性地址空间中,每行8个像素点,每个像素点写入32比特位控制颜色</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">      testval = testval &gt;&gt; <span class="number">1</span>; <span class="comment">//右移1位</span></span><br><span class="line">      <span class="keyword">if</span> (*fontp &amp; testval) &#123; <span class="comment">//如果对应的位是1则填充字体颜色,如果字体有颜色,则该位置将不再填充背景</span></span><br><span class="line">        *addr = fb_color;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *addr = bk_color; <span class="comment">//对应的位为0填充背景颜色</span></span><br><span class="line">      &#125;</span><br><span class="line">      addr++; <span class="comment">//填充完一位自增到下一个位置,addr是int类型32位</span></span><br><span class="line">    &#125;</span><br><span class="line">    fontp++; <span class="comment">//字符位图下一个char序列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能将数值字母转换成整数值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c) ((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * convert numeric letters to integer values</span></span><br><span class="line"><span class="comment"> * @param s string address of numeric</span></span><br><span class="line"><span class="comment"> * @return number after conversion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **s)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (is_digit(**s)) &#123; <span class="comment">//判断是否是数值字母</span></span><br><span class="line">    i = i * <span class="number">10</span> + *((*s)++) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 将当前字符转换成数值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get string length</span></span><br><span class="line"><span class="comment"> * @param str the point of string</span></span><br><span class="line"><span class="comment"> * @return string length</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//repne不相等则重复,重复前判断ecx是否为零,不为零则减1,scasb查询di中是否有al中的字符串结束字符0,如果有则退出循环,将ecx取反后减去1得到字符串长度</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">int</span> __res;</span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;cld \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;repne \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;scasb \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;notl %0 \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;decl %0 \n\t&quot;</span></span><br><span class="line">                       : <span class="string">&quot;=c&quot;</span>(__res)</span><br><span class="line">                       : <span class="string">&quot;D&quot;</span>(str), <span class="string">&quot;a&quot;</span>(<span class="number">0</span>), <span class="string">&quot;0&quot;</span>(<span class="number">0xffffffff</span>)); <span class="comment">//输入约束:寄存器约束D令String的首地址约束在edi,立即数约束令al=0,通用约束0令ecx=0xffff ffff</span></span><br><span class="line">  <span class="keyword">return</span> __res; <span class="comment">//ecx=0xffff ffff,al=0,edi指向String首地址,方向从低到高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>strlen</code>先将AL寄存器赋值为0，随后借助<code>scasb</code>汇编指令逐字节扫描字符串，每次扫描都会与AL寄存器进行对比，并根据对比结果置位相应的标志位，如果扫描的数值与AL寄存器的数值相等，ZF标志位被置位。<code>repne</code>对一直重复执行<code>scasb</code>指令，知道ecx寄存器递减为0或ZF标志位被置位。又因为ecx寄存器的初始值是负值（0xffffffff），<code>repne</code>指令执行结束后，ecx寄存器依然是负值（ecx寄存器在函数执行过程中递减，使用负值可统计出扫描次数），对ECX寄存器取反减1后得到字符串长度。</p>
<p>将长整型变量值转换成指定进制规格的字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * converts the value of a long integer variable to a string with a spacified</span></span><br><span class="line"><span class="comment"> * hexadecimal spacifition</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param str buffer of save parse result</span></span><br><span class="line"><span class="comment"> * @param num convert variable</span></span><br><span class="line"><span class="comment"> * @param base base number</span></span><br><span class="line"><span class="comment"> * @param field_width</span></span><br><span class="line"><span class="comment"> * @param precision dipaly precision</span></span><br><span class="line"><span class="comment"> * @param flags</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 不管number函数将整数值转换成大写还是小写字母,它最高支持36进制的数值转换</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">number</span><span class="params">(<span class="type">char</span> *str, <span class="type">long</span> num, <span class="type">int</span> base, <span class="type">int</span> field_width,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> precision, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">  <span class="type">char</span> c, sign, tmp[<span class="number">50</span>]; <span class="comment">// c用来存放填充的进制前缀后前导字符,sign正负</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *digits = <span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>; <span class="comment">//默认大写共36个符号(36进制)</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">36</span>) &#123; <span class="comment">//不支持小于2或大于36的进制</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; SMALL) &#123; <span class="comment">// 定义了使用小写字母</span></span><br><span class="line">    digits = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; LEFT) &#123; <span class="comment">// 对齐后字符放在左边则字符前面将不填充0,而在后面填充空格,填充0将破坏数据大小,则令ZEROPAD位域为0表示不填充0</span></span><br><span class="line">    flags &amp;= ~ZEROPAD; <span class="comment">// 显示的字符前面填充0取代空格,对于所有的数字格式用前导零而不是空格填充字段宽度,如果出现-标志或者指定了精度(对于整数)则忽略该标志</span></span><br><span class="line">  &#125;</span><br><span class="line">  c = (flags &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span>; <span class="comment">//c用来存放填充的进制前缀后前导字符,如果左对齐,则前面已经令ZEROPAD位域为0,这个表达式c=空格,如果右对齐且ZEROPAD位域为1,这个表达式c=0,表示显示的字符前面填充0取代空格,因为右对齐的话字符显示在右边,前导用0填充不会破坏数据</span></span><br><span class="line">  sign = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; SIGN &amp;&amp; num &lt; <span class="number">0</span>) &#123; <span class="comment">//如果是有符号数且获取到的数小于0</span></span><br><span class="line">    sign = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    num = -num; <span class="comment">//将负数转换成一般正数</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果是无符号数或者获取到的是正数再根据对齐方式决定前导填充什么符号</span></span><br><span class="line">    sign = (flags &amp; PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((flags &amp; SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sign) &#123; <span class="comment">//如果要在正数前面补充显示的是+号或者空格,这个符号占用一个宽度,则数据域宽度减去1,如果是0符号则留给后面的来填充,此次不管</span></span><br><span class="line">    field_width--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; SPECIAL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">16</span>) &#123; </span><br><span class="line">      field_width -= <span class="number">2</span>; <span class="comment">// 十六进制的0x占用两个宽度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base == <span class="number">8</span>) &#123;</span><br><span class="line">      field_width--; <span class="comment">// 八进制的0占用一个宽度</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (num == <span class="number">0</span>) &#123; <span class="comment">//如果取出的数等于0,将字符串结束符&#x27;0&#x27;存入临时数组tmp第一位中</span></span><br><span class="line">    tmp[i++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123; <span class="comment">//如果取出的数不等于0则除去进制直到num=0</span></span><br><span class="line">      tmp[i++] = digits[do_div(num, base)]; <span class="comment">//将整数值转换成字符串(按数值倒序排列),然后再将tmp数组中的字符倒序插入到显示缓冲区,do_div(num,base)的值等于num除以base的余数,余数部分即是digits数组的下标索引值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; precision) &#123; <span class="comment">//进制转换完的数值的长度大于精度,则精度等于进制转换完的数值的长度,比如%5.3限定,1000转十进制=&gt;1000,i=4大于精度3,精度变成4,再由剩下的数据域宽度 = 剩下的数据域宽度 - 精度,得到剩下的数据域宽度等于1,也就是要填充的位数1</span></span><br><span class="line">    precision = i; <span class="comment">//否则精度不变,比如%5.3限定,10转十进制=&gt;10,i=2小于精度3,精度还是3,再由剩下的数据域宽度 = 剩下的数据域宽度 - 精度,得到剩下的数据域宽度等于2,也就是要填充的位数2</span></span><br><span class="line">  &#125;</span><br><span class="line">  field_width -= precision; <span class="comment">//剩下的数据域宽度 = 数据域宽度 - 精度,至此得到数据域宽度,也就是要填充的位数</span></span><br><span class="line">  <span class="keyword">if</span> (!(flags &amp; (ZEROPAD + LEFT))) &#123; <span class="comment">//如果显示的字符前面填充的是空格且对齐后字符放在右边才可以在前导填充空格,否则放到后边if (!(flags &amp; LEFT))再填充,因为如果对齐后字符放在左边还有进制前缀未填充</span></span><br><span class="line">    <span class="keyword">while</span> (field_width-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sign) &#123; <span class="comment">//填充前面决定的前导符号,空格或者+号,如果既不是空格也不是+号,而是0就不填充避免破坏数据,前面的if(sign)也没有执行,至此已经填充完毕(包括0 + 空格)</span></span><br><span class="line">    *str++ = sign;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; SPECIAL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">8</span>) &#123;</span><br><span class="line">      *str++ = <span class="string">&#x27;0&#x27;</span>; <span class="comment">//八进制前缀0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base == <span class="number">16</span>) &#123;</span><br><span class="line">      *str++ = <span class="string">&#x27;0&#x27;</span>; <span class="comment">//十六进制前缀0x或0X</span></span><br><span class="line">      *str++ = digits[<span class="number">33</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(flags &amp; LEFT)) &#123; <span class="comment">//对齐完字符在右边的情况可以用前导0填充而不破坏数据</span></span><br><span class="line">    <span class="keyword">while</span> (field_width-- &gt; <span class="number">0</span>) &#123; <span class="comment">//c用来存放填充的进制前缀后前导字符,如果左对齐,则前面已经令ZEROPAD位域为0,这个表达式c=空格,如果右对齐且ZEROPAD位域为1,这个表达式c=0,表示显示的字符前面填充0取代空格,因为右对齐的话字符显示在右边,前导用0填充不会破坏数据</span></span><br><span class="line">      *str++ = c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//比如%5.3限定,10转十进制=&gt;10,i=2小于精度3,精度还是3,再由剩下的数据域宽度 = 剩下的数据域宽度 - 精度,得到剩下的数据域宽度等于2,也就是要填充的位数2,至此要填充进制前缀后的数值部分了</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; precision--) &#123; <span class="comment">//i等于除去进制得到几位,precision精度</span></span><br><span class="line">    *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123; <span class="comment">//填充完前缀后的前导符,逆序复制有效数值过去</span></span><br><span class="line">    *str++ = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (field_width-- &gt; <span class="number">0</span>) &#123; <span class="comment">//前面会改变field_width数据的条件是(填充空格且右对齐/填充0且右对齐),而此处的条件是剩下的条件左对齐,则填充空格</span></span><br><span class="line">    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于解析<code>color_printk</code>函数所提供的格式化字符串及其参数，<code>vsprintf</code>函数会将格式化后(就像汇编语言用db定义的一串字符那样，可以直接搬运到显存输出那样)的字符串结果保存到一个4096B的缓冲区中buf，并返回字符串长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * parse the formatted string and paramters provided by color_printk function</span></span><br><span class="line"><span class="comment"> * @param buf buffer of save parse result</span></span><br><span class="line"><span class="comment"> * @param fmt the format</span></span><br><span class="line"><span class="comment"> * @param args the paramters</span></span><br><span class="line"><span class="comment"> * @return string length</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *str, *s;</span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line">  <span class="type">int</span> field_width; <span class="comment">//宽度</span></span><br><span class="line">  <span class="type">int</span> precision;</span><br><span class="line">  <span class="type">int</span> len, i; <span class="comment">//len用在格式符s,i用在临时循环</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> qualifier; <span class="comment">//&#x27;h&#x27;, &#x27;l&#x27;, &#x27;L&#x27; or &#x27;Z&#x27; for integer fields//基本上只实现了l</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (str = buf; *fmt; fmt++) &#123; <span class="comment">//str直接指向缓冲区buf</span></span><br><span class="line">    <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">//该循环体会逐个解析字符串,如果字符不为%就认为它是个可显示字符,直接将其存入缓冲区buf中,否则进一步解析其后的字符串格式</span></span><br><span class="line">      *str++ = *fmt;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flags = <span class="number">0</span>;<span class="comment">//按照字符串规定,符号%后面可接 - + 空格 # 0等格式符,如果下一个字符是上述格式符,则设置标志变量flags的标志位(标志位定义在printk.h),随后计算出数据区域的宽度</span></span><br><span class="line">  repeat:</span><br><span class="line">    fmt++; <span class="comment">//后续的自增都是指向下一地址</span></span><br><span class="line">    <span class="keyword">switch</span> (*fmt) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">      flags |= LEFT; <span class="comment">//对齐后字符放在左边</span></span><br><span class="line">      <span class="keyword">goto</span> repeat;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">      flags |= PLUS; <span class="comment">//有符号的值若为正则显示带加号的符号,若为负则显示带减号的符号</span></span><br><span class="line">      <span class="keyword">goto</span> repeat;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">      flags |= SPACE;<span class="comment">//有符号的值若为正则显示时带前导空格但是不显示符号,若为负则带减号符号,+标志会覆盖空格标志</span></span><br><span class="line">      <span class="keyword">goto</span> repeat;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">      flags |= SPECIAL; <span class="comment">//0x</span></span><br><span class="line">      <span class="keyword">goto</span> repeat;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">      flags |= ZEROPAD; <span class="comment">//显示的字符前面填充0取代空格,对于所有的数字格式用前导零而不是空格填充字段宽度。如果出现-标志或者指定了精度(对于整数)则忽略该标志</span></span><br><span class="line">      <span class="keyword">goto</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这部分程序可提取出后续字符串中的数字,并将其转化为数值以表示数据区域的宽度,如果下一个字符不是数字而是字符*,那么数据区域的宽度将由可变参数提供,根据可变参数值亦可判断数据区域的对齐显示方式(左/右对齐)</span></span><br><span class="line">    <span class="comment">// get fied with</span></span><br><span class="line">    field_width = <span class="number">-1</span>; <span class="comment">//不限定宽度默认为-1</span></span><br><span class="line">    <span class="keyword">if</span> (is_digit(*fmt)) &#123;</span><br><span class="line">      field_width = skip_atoi(&amp;fmt); <span class="comment">//得到数据域的宽度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">//如果下一个字符不是数字而是字符*,那么数据区域的宽度将由可变参数提供,例如printf(&quot;dnumber = %*.*f\n&quot;, width, precision, dnumber);</span></span><br><span class="line">      fmt++; <span class="comment">//有限定*号则指向下一位</span></span><br><span class="line">      field_width = va_arg(args, <span class="type">int</span>); <span class="comment">//通过可变参数取得数据域宽度</span></span><br><span class="line">      <span class="keyword">if</span> (field_width &lt; <span class="number">0</span>) &#123; <span class="comment">//数据域宽度是负数</span></span><br><span class="line">        field_width = -field_width; <span class="comment">//数据域宽度必须是正数,负负得正</span></span><br><span class="line">        flags |= LEFT; <span class="comment">//字符放在左边</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取数据区宽度后,下一步提取出显示数据的精度,如果数据区域的宽度后面跟有字符.,说明其后的数值是显示数据的精度,这里采用与计算数据区域宽度相同的方法计算出显示数据的精度,随后还要获取显示数据的规格</span></span><br><span class="line">    precision = <span class="number">-1</span>; <span class="comment">//不限定精度默认为-1,如果有写.但没有后续精度限定则前两个if都不执行,精度设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">      fmt++; <span class="comment">//有限定小数点则指向下一位</span></span><br><span class="line">      <span class="keyword">if</span> (is_digit(*fmt)) &#123;</span><br><span class="line">        precision = skip_atoi(&amp;fmt); <span class="comment">//int skip_atoi(const char **s)//将数值字母转换成整数值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        fmt++;</span><br><span class="line">        field_width = va_arg(args, <span class="type">int</span>); <span class="comment">//通过可变参数取得数据域精度</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (field_width &lt; <span class="number">0</span>) &#123; <span class="comment">//如果精度小于0则精度设置为0</span></span><br><span class="line">        precision = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取显示数据的规格,比如%ld格式化字符串中的字母l,就表示显示数据的规格是长整型</span></span><br><span class="line">    qualifier = <span class="number">-1</span>; <span class="comment">//不限定规格默认为-1</span></span><br><span class="line">    <span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span> || *fmt == <span class="string">&#x27;l&#x27;</span> || *fmt == <span class="string">&#x27;L&#x27;</span> || *fmt == <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">      qualifier = *fmt; <span class="comment">//获得数据规格</span></span><br><span class="line">      fmt++; <span class="comment">//有限定规格则指向下一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经过逐个格式符的解析,数据区域的宽度和精度等信息皆已获取,现在将遵照这些信息把可变参数格式化成字符串,并存入buf缓冲区,下面进入可变参数的字符串转化过程,目前支持的格式符有c s o p x X d i u n %等</span></span><br><span class="line">    <span class="keyword">switch</span> (*fmt) &#123;</span><br><span class="line">    <span class="comment">// char</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (!(flags &amp; LEFT)) &#123; <span class="comment">//如果对齐后字符要放在右边</span></span><br><span class="line">        <span class="comment">// on the right</span></span><br><span class="line">        <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>) &#123; <span class="comment">//比如宽度是2,那么将会填充1个空格凑成两个宽度</span></span><br><span class="line">          *str++ = <span class="string">&#x27; &#x27;</span>; <span class="comment">//补齐前面得空格</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      *str++ = (<span class="type">unsigned</span> <span class="type">char</span>)va_arg(args, <span class="type">int</span>); <span class="comment">//从可变参数列表取出一个字符结合填充到缓冲区</span></span><br><span class="line">      <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>) &#123; <span class="comment">//如果对齐后字符要放在左边,补齐后面的空格</span></span><br><span class="line">        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// string</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: <span class="comment">//整个显示过程会把字符串的长度与显示精度进行比对,根据数据区的宽度和精度等信息截取待显示字符串的长度并补齐空格符,涉及到内核通用库函数strlen</span></span><br><span class="line">      s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">      <span class="keyword">if</span> (!s) &#123; <span class="comment">//如果字符串只有结束符</span></span><br><span class="line">        *s = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      len = <span class="built_in">strlen</span>(s); <span class="comment">//字符串不是只有一个结束符则获取长度</span></span><br><span class="line">      <span class="keyword">if</span> (precision &lt; <span class="number">0</span>) &#123; <span class="comment">//如果不限定精度默认为-1,改写成字符串长度</span></span><br><span class="line">        precision = len;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision) &#123; <span class="comment">//如果限定了精度并且len大于精度则精度由len决定</span></span><br><span class="line">        len = precision;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(flags &amp; LEFT)) &#123; <span class="comment">//如果对齐后字符要放在右边则先填充空格</span></span><br><span class="line">        <span class="keyword">while</span> (len &lt; field_width--) &#123;</span><br><span class="line">          *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">//将字符串依次复制到缓冲区buf</span></span><br><span class="line">        <span class="comment">// copy the string to the buffer</span></span><br><span class="line">        *str++ = *s++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (len &lt; field_width--) &#123; <span class="comment">//如果对齐后字符要放在左边则最后填充空格</span></span><br><span class="line">        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// octal number</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (qualifier == <span class="string">&#x27;l&#x27;</span>) &#123; <span class="comment">//如果规格是长整型</span></span><br><span class="line">        str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">8</span>, field_width,</span><br><span class="line">                     precision, flags);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">8</span>, field_width, precision,</span><br><span class="line">                     flags);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// address</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (field_width == <span class="number">-1</span>) &#123; <span class="comment">//如果未限定数据域宽度</span></span><br><span class="line">        field_width = <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">        flags |= ZEROPAD; <span class="comment">//显示的字符前面填充0取代空格,对于所有的数字格式用前导零而不是空格填充字段宽度,如果出现-标志或者指定了精度(对于整数)则忽略该标志</span></span><br><span class="line">      &#125;</span><br><span class="line">      str = number(str, (<span class="type">unsigned</span> <span class="type">long</span>)va_arg(args, <span class="type">void</span> *), <span class="number">16</span>, field_width,</span><br><span class="line">                   precision, flags);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">//十六进制的处理过程x设置为小写,其余跟X一样</span></span><br><span class="line">      flags |= SMALL;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (qualifier == <span class="string">&#x27;l&#x27;</span>) &#123; <span class="comment">//如果规格是长整型</span></span><br><span class="line">        str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">16</span>, field_width,</span><br><span class="line">                     precision, flags);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">16</span>, field_width,</span><br><span class="line">                     precision, flags);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">//十进制</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">//有符号处理过程跟无符号差别在于flags的SIGN域</span></span><br><span class="line">      flags |= SIGN;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (qualifier == <span class="string">&#x27;l&#x27;</span>) &#123; <span class="comment">//如果规格是长整型</span></span><br><span class="line">        str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">10</span>, field_width,</span><br><span class="line">                     precision, flags);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">10</span>, field_width,</span><br><span class="line">                     precision, flags);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//函数的最后一部分代码负责格式化字符串的扫尾工作</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="comment">//格式符%n的功能是把目前已格式化的字符串长度返回给函数的调用者,意思是把刚刚接收的数据的字符个数赋给对应的变量</span></span><br><span class="line">      <span class="keyword">if</span> (qualifier == <span class="string">&#x27;l&#x27;</span>) &#123; <span class="comment">//如果规格是长整型</span></span><br><span class="line">					&#123;</span><br><span class="line">        <span class="type">long</span> *ip = va_arg(args, <span class="type">long</span> *); <span class="comment">//对应的变量,CLanguageMINEOS项目里有标准库printf的测试程序</span></span><br><span class="line">        *ip = (str - buf);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> *ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">        *ip = (str - buf);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// if appear %%, the first % as an escape character, after formatting, only</span></span><br><span class="line">    <span class="comment">// one character %</span></span><br><span class="line">    <span class="comment">//如果格式化字符串中出现字符%%,则把第一个格式符%视为转义符,经过格式化解析后,最终只显示一个字符%</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">      *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// if not support, direct output without any processing</span></span><br><span class="line">    <span class="comment">//如果在格式符解析过程中出现任何不支持的格式符,比如f,则不做任何处理,直接将其视为字符串输出到buf缓冲区</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (*fmt) &#123;</span><br><span class="line">        *str++ = *fmt;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//碰到字符串结束符fmt指针回退并break,退出外层循环后又因为碰到结束符,for循环结束,整个函数结束</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> str - buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>color_printk</code>函数实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">color_printk</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fr_color, <span class="type">unsigned</span> <span class="type">int</span> bk_color, <span class="type">const</span> <span class="type">char</span> *fmt,</span></span><br><span class="line"><span class="params">                 ...)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> line = <span class="number">0</span>;</span><br><span class="line">  va_list args;</span><br><span class="line">  va_start(args, fmt);</span><br><span class="line">  i = <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">  va_end(args);</span><br><span class="line">  <span class="comment">//缓冲区里存放的是已经格式化后的字符串,接下来color_printk开始检索buf缓冲区里的格式化字符串,从中找出\n \b \t等转义字符,并在打印过程中解析这些转义字符 </span></span><br><span class="line">  <span class="comment">//通过for语句逐个字符检测格式化后的字符串,&lt;运算符优先级高于逻辑或||,i是buf缓冲区的字符串的长度</span></span><br><span class="line">  <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; i || line; count++) &#123; <span class="comment">//字符串还未输出完或者当前光标距下一个制表位还需要填充空格</span></span><br><span class="line">    <span class="keyword">if</span> (line &gt; <span class="number">0</span>) &#123; <span class="comment">//line保存当前光标距下一个制表位需要填充的空格符数量,如果要填充的空格数大于0</span></span><br><span class="line">      count--; <span class="comment">//因为这里处理的是填充空格符,但是会影响到循环变量count,此处将count自减避免影响</span></span><br><span class="line">      <span class="keyword">goto</span> label_tab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">char</span>)*(buf + count) == <span class="string">&#x27;\n&#x27;</span>) &#123; <span class="comment">//如果发现某个待显示字符是\n转移字符,则将光标行数加1,列数设置为0,否则判断待显示字符是否为\b转义符</span></span><br><span class="line">      pos.y_position++; <span class="comment">//将光标行数加1</span></span><br><span class="line">      pos.x_position = <span class="number">0</span>; <span class="comment">//列数设置为0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">char</span>)*(buf + count) == <span class="string">&#x27;\b&#x27;</span>) &#123; <span class="comment">//如果确定待显示字符是\b转义字符,那么调整列位置并调用putchar函数打印空格符覆盖之前的字符,如果既不是\n也不是\b,则继续判断其是否为\t转义字符</span></span><br><span class="line">		&#123;</span><br><span class="line">      pos.x_position--; <span class="comment">//列数减去1</span></span><br><span class="line">      <span class="keyword">if</span> (pos.x_position &lt; <span class="number">0</span>) &#123; <span class="comment">//列数小于0(本来就在第0列),则回退到上一行的最后一列</span></span><br><span class="line">        pos.x_position = pos.x_resolution / pos.x_char_size - <span class="number">1</span>; <span class="comment">//列数 = 从左到右横向1440 / 从左到右横向8 - 1 =&gt;最后一列</span></span><br><span class="line">        pos.y_position--;</span><br><span class="line">        <span class="keyword">if</span> (pos.y_position &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          pos.y_position = pos.y_position * pos.x_char_size - <span class="number">1</span>; <span class="comment">//行数 = 从上到下纵向900 / 从上到下纵向16 - 1 =&gt;最后一行</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//因为这里在给putchar传递光标位置时是乘上了位图尺寸的,所以上面的不可以再乘</span></span><br><span class="line">      <span class="built_in">putchar</span>(pos.fb_addr, pos.x_resolution, pos.x_position * pos.x_char_size,</span><br><span class="line">              pos.y_position * pos.y_char_size, fr_color, bk_color, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">char</span>)*(buf + count) == <span class="string">&#x27;\t&#x27;</span>) &#123; <span class="comment">//如果确定待显示字符是\t转义字符,则计算当前光标距下一个制表位需要填充的空格符数量,将计算结果保存到局部变量line中,再结合for循环和if判断,把显示位置调整到下一个制表位,并使用空格填补调整过程中占用的字符显示空间</span></span><br><span class="line">      <span class="comment">//8表示一个制表位占用8个显示字符</span></span><br><span class="line">      line = ((pos.x_position + <span class="number">8</span>) &amp; ~(<span class="number">8</span> - <span class="number">1</span>)) - pos.x_position;</span><br><span class="line">    <span class="comment">//需要填充的空格符数量 = ((列数 + 8) &amp; ~(8 - 1)) - 列数),比如现在光标在(2, 2),则需要填充的空格符数量 = ((2 + 8) &amp; ~(8 - 1)) - 2) = (8 - 2) = 6</span></span><br><span class="line">    label_tab:</span><br><span class="line">      line--;</span><br><span class="line">      <span class="built_in">putchar</span>(pos.fb_addr, pos.x_resolution, pos.x_position * pos.x_char_size,</span><br><span class="line">              pos.y_position * pos.y_char_size, fr_color, bk_color, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      pos.x_position++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//排除待显示字符是\n\b\t转义字符之后,那么它就是一个普通字符,使用putchar函数将字符打印在屏幕上,参数帧缓存线性地址/行分辨率/屏幕列像素点位置/屏幕行像素点位置/字体颜色/字体背景色/字符位图</span></span><br><span class="line">      <span class="built_in">putchar</span>(pos.fb_addr, pos.x_resolution, pos.x_position * pos.x_char_size,</span><br><span class="line">              pos.y_position * pos.y_char_size, fr_color, bk_color,</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">char</span>)*(buf + count));</span><br><span class="line">      pos.x_position++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//收尾工作:字符显示结束还要为下次字符显示做准备,更新当前字符的显示位置,此处的字符显示位置可理解为光标位置,下面这段程序负责调整光标的列位置和行位置</span></span><br><span class="line">    <span class="keyword">if</span> (pos.x_position &gt;= (pos.x_resolution / pos.x_char_size)) &#123; <span class="comment">//列数 &gt;= (1440 / 8),也就是最后一列了,则换到下一行并令列数=0,相当于回车换行</span></span><br><span class="line">      pos.y_position++;</span><br><span class="line">      pos.x_position = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos.y_position &gt;= (pos.y_resolution / pos.y_char_size)) &#123; <span class="comment">//行数 &gt;= (900 / 16),也就是最后一行了,则行数=0,列数不变,相当于换行</span></span><br><span class="line">      pos.y_position = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Ansore</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.ansore.top/posts/6e1a5d82.html">https://blog.ansore.top/posts/6e1a5d82.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.ansore.top" target="_blank">Ansore</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/">64位系统实现</a></div><div class="post_share"><div class="social-share" data-image="https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/70237c47.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">64位操作系统-系统异常</div></div></a></div><div class="next-post pull-right"><a href="/posts/181cefd9.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">64位操作系统-内核主程序</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/ea957129.html" title="64位操作系统-写一个BOOT引导程序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-12</div><div class="title">64位操作系统-写一个BOOT引导程序</div></div></a></div><div><a href="/posts/86db78d0.html" title="64位操作系统-FAT12文件系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-14</div><div class="title">64位操作系统-FAT12文件系统</div></div></a></div><div><a href="/posts/9afe7748.html" title="64位操作系统-BOOT加载LOADER"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-17</div><div class="title">64位操作系统-BOOT加载LOADER</div></div></a></div><div><a href="/posts/de9aab27.html" title="64位操作系统-Loader引导加载程序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-24</div><div class="title">64位操作系统-Loader引导加载程序</div></div></a></div><div><a href="/posts/d23baf17.html" title="64位操作系统-内核头程序"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-02</div><div class="title">64位操作系统-内核头程序</div></div></a></div><div><a href="/posts/9ed871c4.html" title="64位操作系统-lds链接脚本"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-04</div><div class="title">64位操作系统-lds链接脚本</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Ansore</div><div class="author-info__description">纵然时光倒流<br>我还是想象不出一切最开始的模样</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">176</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ansore"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Ansore" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:aansore@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一枕邯郸，一生荒唐</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%98%BE%E7%A4%BA%E8%89%B2%E5%BD%A9"><span class="toc-number">1.</span> <span class="toc-text">屏幕上显示色彩</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%98%BE%E7%A4%BALOG"><span class="toc-number">2.</span> <span class="toc-text">在屏幕上显示LOG</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ASCII%E5%AD%97%E7%AC%A6%E5%BA%93"><span class="toc-number">2.1.</span> <span class="toc-text">ASCII字符库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%BD%A9%E8%89%B2%E5%AD%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">显示彩色字符</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/e060854e.html" title="Archlinux安装btrfs文件系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/04/25/6266bea760d6c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Archlinux安装btrfs文件系统"/></a><div class="content"><a class="title" href="/posts/e060854e.html" title="Archlinux安装btrfs文件系统">Archlinux安装btrfs文件系统</a><time datetime="2023-12-03T14:42:08.000Z" title="发表于 2023-12-03 22:42:08">2023-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/18aaf2d9.html" title="KVM与实体机共享目录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/04/25/6266bea760d6c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="KVM与实体机共享目录"/></a><div class="content"><a class="title" href="/posts/18aaf2d9.html" title="KVM与实体机共享目录">KVM与实体机共享目录</a><time datetime="2023-05-06T14:43:03.000Z" title="发表于 2023-05-06 22:43:03">2023-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4cb3e1a1.html" title="Linux中找到并删除重复文件的工具"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/04/25/6266bea760d6c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux中找到并删除重复文件的工具"/></a><div class="content"><a class="title" href="/posts/4cb3e1a1.html" title="Linux中找到并删除重复文件的工具">Linux中找到并删除重复文件的工具</a><time datetime="2023-02-11T12:44:11.000Z" title="发表于 2023-02-11 20:44:11">2023-02-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/28e97253.html" title="QEMU搭建ARM32环境"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/04/25/6266bea760d6c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="QEMU搭建ARM32环境"/></a><div class="content"><a class="title" href="/posts/28e97253.html" title="QEMU搭建ARM32环境">QEMU搭建ARM32环境</a><time datetime="2023-01-03T14:40:02.000Z" title="发表于 2023-01-03 22:40:02">2023-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/330229db.html" title="64位操作系统-地址空间"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="64位操作系统-地址空间"/></a><div class="content"><a class="title" href="/posts/330229db.html" title="64位操作系统-地址空间">64位操作系统-地址空间</a><time datetime="2022-09-18T02:31:20.000Z" title="发表于 2022-09-18 10:31:20">2022-09-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://img.ansore.de/2022/09/11/f01cf15d850f0ce8f2c97c93a206411c8d3bf927.png')"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2024 By Ansore</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>