<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Archlinux交换esc和CapsLock键</title>
    <url>/posts/66617a24.html</url>
    <content><![CDATA[<p>作为一个neovim重度用户，实在觉得ESC键太远了，而且CapsLock键没啥用还占了个黄金位置，所以就交换了两个键的位置。</p>
<p>我用的X11，设置如下</p>
<p>在用户目录下创建文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.Xmodmap</span><br></pre></td></tr></table></figure>

<p>编辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remove Lock = Caps_Lock</span><br><span class="line"></span><br><span class="line">keysym Escape = Caps_Lock</span><br><span class="line">keysym Caps_Lock = Escape</span><br><span class="line"></span><br><span class="line">add Lock = Caps_Lock</span><br></pre></td></tr></table></figure>

<p>保存重新登录即可</p>
<h1 id="KDE系统设置"><a href="#KDE系统设置" class="headerlink" title="KDE系统设置"></a>KDE系统设置</h1><p>后来发现KDE系统设置里可以设置两个键交换的选项：</p>
<p><code>System Settings &gt; Input Devices &gt; Keyboard &gt; Advanced &gt;  Config keyboard options &gt; caps lock behavior &gt; Swap Esc and Caps Lock</code></p>
]]></content>
      <categories>
        <category>Archlinux</category>
      </categories>
      <tags>
        <tag>Archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>Archlinux安装btrfs文件系统</title>
    <url>/posts/e060854e.html</url>
    <content><![CDATA[<p>以北外镜像站为例，在<code>/etc/pacman.d/mirrorlist</code>文件最开头添加这样一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure>
<p>硬盘分区如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">sda      8:0    0 465.8G  0 disk</span><br><span class="line">├─sda1   8:1    0   512M  0 part /boot</span><br><span class="line">├─sda2   8:2    0    16G  0 part [SWAP]</span><br><span class="line">└─sda3   8:3    0 449.3G  0 part /home</span><br><span class="line">                                 /var/log</span><br><span class="line">                                 /var/cache/pacman/pkg</span><br><span class="line">                                 /</span><br></pre></td></tr></table></figure>
<p>格式化分区:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkfs.fat -F 32 /dev/sda1    # 格式化 boot 分区</span><br><span class="line">mkswap /dev/sda2    # 格式化 swap 分区</span><br><span class="line">mkfs.btrfs /dev/sda3    # 格式化主分区</span><br></pre></td></tr></table></figure>
<p>然后是挂载分区，btrfs 分区的挂载比较复杂，首先挂载整个 btrfs 分区到 <code>/mnt</code>，这样才可以创建子卷：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount /dev/sda3 /mnt    # 挂载分区</span><br><span class="line"># 创建子卷</span><br><span class="line">btrfs subvolume create /mnt/@</span><br><span class="line">btrfs subvolume create /mnt/@home</span><br><span class="line">btrfs subvolume create /mnt/@log</span><br><span class="line">btrfs subvolume create /mnt/@pkg</span><br><span class="line">umount /dev/sda3    # 卸载分区</span><br></pre></td></tr></table></figure>
<p>于子卷的划分，我打算使用 Timeshift 来管理快照，而 Timeshift 只支持 Ubuntu 类型的子卷布局，也就是根目录挂载在 @ 子卷上，<code>/home</code> 目录挂载在 @home 子卷上；另外我还打算使用 grub-btrfs来为快照自动创建 grub 目录，grub-btrfs 要求 <code>/var/log</code> 挂载在单独的子卷上；还有 @pkg 子卷挂载在 <code>/var/cache/pacman/pkg</code> 目录下，这个目录下保存的是下载的软件包缓存，也没什么保存快照的必要，所以也单独划分了个子卷。<br>接下来就是挂载子卷了，使用 <code>subvol</code> 挂载选项来指定挂载的子卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载根目录</span></span><br><span class="line">mount /dev/sda3 /mnt -o subvol=@,noatime,discard=async,compress=zstd</span><br><span class="line"><span class="comment"># 挂载家目录</span></span><br><span class="line"><span class="built_in">mkdir</span> /mnt/home</span><br><span class="line">mount /dev/sda3 /mnt/home -o subvol=@home,noatime,discard=async,compress=zstd</span><br><span class="line"><span class="comment"># 挂载 /var/log 目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /mnt/var/log</span><br><span class="line">mount /dev/sda3 /mnt/var/log -o subvol=@<span class="built_in">log</span>,noatime,discard=async,compress=zstd</span><br><span class="line"><span class="comment"># 挂载 /var/cache/pacman/pkg 目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /mnt/var/cache/pacman/pkg</span><br><span class="line">mount /dev/sda3 /mnt/var/cache/pacman/pkg -o subvol=@pkg,noatime,discard=async,compress=zstd</span><br></pre></td></tr></table></figure>
<p>除了 <code>subvol</code> 选项用来指定挂载的子卷，我还添加了其他的挂载选项用于优化 btrfs 文件系统的性能：<code>noatime</code> 选项可以降低数据读取和写入的访问时间；<code>discard=async</code> 选项可以在闲时释放磁盘中未使用的区块，也就是 TRIM，另外也可以不添加这个选项，而是在系统安装完成后启用 <code>fstrim.timer</code> 服务从而定时执行 TRIM，可以根据自己的喜好选择；<code>compress</code> 选项可以在数据写入前进行压缩，减少磁盘的写入量，增加磁盘寿命，在某些场景下还能优化一些性能，支持的压缩算法有 <code>zlib</code>、<code>lzo</code> 和 <code>zstd</code>，<code>zstd</code> 算法是最快的。在系统安装完成后也可以编辑 <code>/etc/fstab</code> 文件修改挂载选项。<br>接下来挂载其他分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载 boot 分区</span></span><br><span class="line"><span class="built_in">mkdir</span> /mnt/boot</span><br><span class="line">mount /dev/sda1 /mnt/boot</span><br><span class="line"><span class="comment"># 启用 swap 分区</span></span><br><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure>
<p>生成fstab文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure>
<p>因为 <code>/var/log</code> 和 <code>/var/cache/pacman/pkg</code> 在将来并不会被保存快照，也可以选择为这两个目录禁用写时复制：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chattr +C /mnt/var/log</span><br><span class="line">chattr +C /mnt/var/cache/pacman/pkg</span><br></pre></td></tr></table></figure>
<p>管理 btrfs 文件系统，比较推荐安装 btrfs-progs，其包含了很多用于管理 btrfs 文件系统的命令，前文用到的 <code>btrfs subvolume create</code> 命令就是来自这个软件包，Arch 官方的的安装镜像已经集成了这个软件包。可以在 <code>pacstrap</code> 步骤中安装这个包，我一般会在这个步骤装上如下的软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacstrap -K /mnt base base-devel linux-lts linux-lts-headers linux-firmware neovim btrfs-progs intel-ucode</span><br></pre></td></tr></table></figure>
<p>使用<code>arch-chroot</code>进入系统，对于 btrfs 文件系统，需要编辑 mkinitcpio 文件，通常位于 <code>/etc/mkinitcpio.conf</code>，找到 <code>MODULES=()</code> 一行，在括号中添加 btrfs，这是为了在系统启动时提前加载 btrfs 内核模块，从而正常启动系统。记得每次编辑完 mkinitcpio 文件后都需要手动重新生成 initramfs：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkinitcpio -P</span><br></pre></td></tr></table></figure>
<p>配置完成后，再进行安装GRUB:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S grub</span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Archlinux</category>
      </categories>
      <tags>
        <tag>Archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>Archlinux软件包制作</title>
    <url>/posts/d20bd34e.html</url>
    <content><![CDATA[<h1 id="Archlinux软件包制作"><a href="#Archlinux软件包制作" class="headerlink" title="Archlinux软件包制作"></a>Archlinux软件包制作</h1><p><code>PKGBUILD</code> 文件是为 Arch Linux 及其衍生版（如 Manjaro）构建和创建软件包的方式。</p>
<h1 id="PKGBUILD-基础知识"><a href="#PKGBUILD-基础知识" class="headerlink" title="PKGBUILD 基础知识"></a>PKGBUILD 基础知识</h1><p><code>PKGBUILD</code> 文件由变量和函数组成，所有这些都是用来定义软件包本身，以及如何构建它。</p>
<p>为了从 <code>PKGBUILD</code> 中创建一个软件包，需要使用 <strong><a href="https://mp.weixin.qq.com/s/QRnrBKU5ybWp1PoF6bcZxw">makepkg</a></strong> 命令行工具。在获得 <code>PKGBUILD</code> 文件后，你只需在包含 <code>PKGBUILD</code> 的目录中运行 <code>makepkg</code>，就可以得到一个可安装的软件包了。</p>
<h1 id="制作软件包例子"><a href="#制作软件包例子" class="headerlink" title="制作软件包例子"></a>制作软件包例子</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先，你需要创建一个名为 <code>PKGBUILD</code> 的文件，它将作为构建你的软件包的“配方”。</p>
<p>你需要做的另一个文件是一个叫 <code>hello-world.sh</code> 的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> PKGBUILD hello-world.sh</span><br></pre></td></tr></table></figure>

<h2 id="设置PKGBUILD文件"><a href="#设置PKGBUILD文件" class="headerlink" title="设置PKGBUILD文件"></a>设置PKGBUILD文件</h2><h3 id="pkgname"><a href="#pkgname" class="headerlink" title="pkgname"></a>pkgname</h3><p>首先是 <code>pkgname</code> 变量。这是安装时定义软件包名称的东西，也是 Arch Linux 的软件包管理器 pacman 跟踪软件包的方式。</p>
<p>这个变量（以及其他一些变量）的格式是 <code>variable=value</code>，变量名在左边，变量的值在右边，用等号隔开。</p>
<p>要设置包的名称，请在 <code>PKGBUILD</code> 中输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkgname=hello-world</span><br></pre></td></tr></table></figure>

<ul>
<li>要设置一个不同的软件包名称，用你的软件包的名称替换 <code>hello-world</code>。</li>
<li>这并不设置用于运行程序的命令，这将在下面的 <code>package()</code> 部分中处理。</li>
</ul>
<h3 id="pkgver"><a href="#pkgver" class="headerlink" title="pkgver"></a>pkgver</h3><p>正如变量名称本身所述，它设置了你的软件包的版本（即 <code>1.0.0</code>）。这在用户更新他们的系统时很有用，因为设置更高的版本会提示用户升级。</p>
<p>要设置版本号，请在 <code>PKGBUILD</code> 中输入以下内容（在前一行之后）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkgver=1.0.0</span><br></pre></td></tr></table></figure>

<h3 id="pkgrel"><a href="#pkgrel" class="headerlink" title="pkgrel"></a>pkgrel</h3><p>这与 <code>pkgver</code> 变量有关，通常不需要知道。不过和 <code>pkgver</code> 变量一样，如果它被换到一个更高的数字，就将通知用户进行升级。</p>
<p>它适用于任何需要保持 <code>pkgver</code> 不变的情况下，例如 <code>PKGBUILD</code> 本身发生了变化。如果你为一个你使用的程序创建了一个 <code>PKGBUILD</code>（并希望保持软件包的版本相同），而你需要修复 <code>PKGBUILD</code> 本身的一个错误，这将是非常有用的。</p>
<p>要设置这个变量，请在 <code>PKGBUILD</code> 中输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkgver=1</span><br></pre></td></tr></table></figure>

<p>这个变量应该 <strong>总是</strong> 从 <code>1</code> 开始，然后一次一次地向上移动。当 <code>pkgver</code> 本身向上移动时，这个变量可以（也应该）重置为 <code>1</code>，因为 <code>pkgver</code> 本身会通知用户升级。</p>
<h3 id="pkgdesc"><a href="#pkgdesc" class="headerlink" title="pkgdesc"></a>pkgdesc</h3><p>这将设置软件包的描述，用于帮助更好地识别该软件包。</p>
<p>要设置它，只需将描述放在引号内：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkgdesc=<span class="string">&quot;Hello world in your terminal!&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="arch"><a href="#arch" class="headerlink" title="arch"></a>arch</h3><p>这个变量设置软件包所兼容的硬件架构。如</p>
<p>无论如何，**<a href="https://mp.weixin.qq.com/s/QRnrBKU5ybWp1PoF6bcZxw">makepkg</a>** 仍然需要设置它，这样它就知道这个软件包与我们的系统是兼容的。</p>
<p>这个变量支持设置多个值，所以 <strong><a href="https://mp.weixin.qq.com/s/QRnrBKU5ybWp1PoF6bcZxw">makepkg</a></strong> 需要一个不同的语法，如下所示。</p>
<p>要设置它，请在 <code>PKGBUILD</code> 中输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">arch</span>=(<span class="string">&quot;x86_64&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果你要设置多个值，需要用空格和引号分隔每个值，像这样。<code>arch=(“x86_x64&quot; &quot;arm&quot;)</code>。</p>
<h3 id="depends"><a href="#depends" class="headerlink" title="depends"></a>depends</h3><p>这列出了提供了我们的软件包所需功能的所有软件包。与 <code>arch</code> 一样，它也可以包含多个值，因此必须使用括号语法。</p>
<p>由于我们的软件包没有任何依赖关系，所以我们不需要在 <code>PKGBUILD</code> 中输入这个字段。然而，如果我们的软件包有依赖关系，我们就会使用与 <code>arch</code> 相同的语法。</p>
<h3 id="optdepends"><a href="#optdepends" class="headerlink" title="optdepends"></a>optdepends</h3><p>这里列出了那些并不是提供所需功能而是额外功能的软件包。</p>
<p>这与 <code>depends</code> 的语法相同。</p>
<h3 id="conflicts"><a href="#conflicts" class="headerlink" title="conflicts"></a>conflicts</h3><p>这告诉 <code>pacman</code> 哪些软件包会导致我们的软件包出现问题，或者以我们不希望的方式行事。</p>
<p>这里列出的任何软件包都会在我们的软件包被安装之前被卸载。</p>
<p>这与 <code>depends</code> 的语法相同。</p>
<h3 id="license"><a href="#license" class="headerlink" title="license"></a>license</h3><p>这定义了你的程序所采用的 <a href="https://mp.weixin.qq.com/s/QRnrBKU5ybWp1PoF6bcZxw">软件许可证</a>。如果你需要帮助你选择一个许可证，<a href="https://mp.weixin.qq.com/s/QRnrBKU5ybWp1PoF6bcZxw">Arch 维基</a> 提供了一些信息。如果你不知道该怎么设置，将其设置为 <code>custom</code> 也可以。</p>
<p>这与 <code>arch</code> 和 <code>depends</code> 的语法相同：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">license=(<span class="string">&quot;custom&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>这就是 <strong><a href="https://mp.weixin.qq.com/s/QRnrBKU5ybWp1PoF6bcZxw">makepkg</a></strong> 如何知道要用什么文件来构建我们的软件包。它可以包含各种不同类型的源，包括本地文件和 URL。</p>
<p>在添加本地文件时，要输入相对于 <code>PKGBUILD</code> 文件的文件路径，比如以下目录布局：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PKGBUILD</span><br><span class="line">file.txt</span><br><span class="line">src/file.sh</span><br></pre></td></tr></table></figure>

<p>如果你想在我们的 <code>PKGBUILD</code> 中包括 <code>file.sh</code>，你需要输入 <code>src/file.sh</code> 作为其名称。</p>
<p>当输入 URL 时，你只需输入完整的 URL，</p>
<p>即 <code>https://mirrors.creativecommons.org/presskit/logos/cc.logo.large.png</code>。</p>
<p>你的这个软件包只需要 <code>hello-world.sh</code> 文件，由于它和 <code>PKGBUILD</code> 在同一个目录中，你只需输入它的名字作为 <code>source</code> 的值。</p>
<p>这个变量也使用与 <code>arch</code> 和 <code>depends</code> 相同的语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>=(<span class="string">&quot;hello-world.sh&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="sha512sums"><a href="#sha512sums" class="headerlink" title="sha512sums"></a>sha512sums</h3><p>这是用来验证 <code>source</code> 中的文件没有被修改或下载错误。如何获得这个值的信息可以在 <a href="https://mp.weixin.qq.com/s/QRnrBKU5ybWp1PoF6bcZxw">Arch 维基关于 PKGBUILD 的文章</a>中找到。</p>
<p>如果你宁愿不设置这个（或者你只是不需要，例如对于本地文件），你可以为 <code>source</code> 变量中的每个文件输入 <code>SKIP</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sha512sums=(<span class="string">&quot;SKIP&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="package"><a href="#package" class="headerlink" title="package()"></a>package()</h3><p>这是最后一个，也是实际制作我们的包的最重要的部分。在处理这个问题时，知道两个变量很重要。</p>
<ul>
<li><code>$&#123;srcdir&#125;</code>：这是 <strong><a href="https://mp.weixin.qq.com/s/QRnrBKU5ybWp1PoF6bcZxw">makepkg</a></strong> 放置 <code>source</code> 变量中文件的地方。在这个目录中，你可以与这些文件进行交互，并对文件进行任何其他需要的修改。</li>
<li><code>$&#123;pkgdir&#125;</code>：这是我们放置将被安装在系统中的文件的地方。 <code>$&#123;pkgdir&#125;</code> 的文件夹结构是按照实际系统中的情况设置的（例如，使用 <code>pacman</code> 安装时，<code>$&#123;pkgdi</code></li>
</ul>
<p><code>package()</code> 包含一个用于创建软件包的命令列表。</p>
<p>因此，如果（假设）你需要有个在 <code>/usr/share/motto.txt</code> 写着 “Linux is superior to Windows ”的文件，你会运行这样的东西：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">package</span></span>() &#123;</span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;pkgdir&#125;</span>/usr/share&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Linux is superior to Windows&quot;</span> | <span class="built_in">tee</span> <span class="string">&quot;<span class="variable">$&#123;pkgdir&#125;</span>/usr/share/motto.txt&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于上述命令的一些说明：</p>
<ul>
<li><code>$&#123;pkgdir&#125;</code> 里面最初是 <strong>不包含</strong> 目录的。如果你跳过了 <a href="https://mp.weixin.qq.com/s/QRnrBKU5ybWp1PoF6bcZxw">mkdir 命令</a>，<code>tee</code> 会输出一个错误，说这个目录不存在。</li>
<li>在指定目录时，<strong>总是</strong> 在它们前面加上 <code>$&#123;pkgdir&#125;</code> 或 <code>$&#123;srcdir&#125;</code> 变量。如果输入 <code>/usr/share/motto.txt</code>，就会按照字面意义指向你当前运行的系统中的 <code>/usr/share/motto.txt</code>。</li>
</ul>
<p>对于你的 <code>PKGBUILD</code>，你将把 <code>hello-world.sh</code> 文件放在目标系统的 <code>/usr/bin/hello-world</code> 中。你还将使该文件在运行时说 “Hello to you!”。</p>
<p>要做到这一点，请在 <code>PKGBUILD</code> 中输入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">package</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;Hello to you!&#x27;</span> &gt; <span class="string">&quot;<span class="variable">$&#123;srcdir&#125;</span>/hello-world.sh&quot;</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;pkgdir&#125;</span>/usr/bin&quot;</span></span><br><span class="line">  <span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$&#123;srcdir&#125;</span>/hello-world.sh&quot;</span> <span class="string">&quot;<span class="variable">$&#123;pkgdir&#125;</span>/usr/bin/hello-world&quot;</span></span><br><span class="line">  <span class="built_in">chmod</span> +x <span class="string">&quot;<span class="variable">$&#123;pkgdir&#125;</span>/usr/bin/hello-world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就完成了！用 <strong><a href="https://mp.weixin.qq.com/s/QRnrBKU5ybWp1PoF6bcZxw">makepkg -si</a></strong> 构建和安装软件包，然后在终端运行 <code>hello-world</code>，查看其输出。</p>
]]></content>
      <categories>
        <category>Archlinux</category>
      </categories>
      <tags>
        <tag>Archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>我与Archlinux</title>
    <url>/posts/fb00bd86.html</url>
    <content><![CDATA[<p>不知不觉使用Archlinux已经五六年了，一直使用Archlinux+KDE桌面的组合，从之前的三天一小崩、五天一大崩，到现在已经基本不会出现崩溃的情况（除非很久不更新）。用心去维护一个自己的系统也挺有意思的，感觉就像养个孩子似的。</p>
<p>我的主题配置如下：</p>
<div style="position:relative; padding-bottom: 75%; width:100%; height:0;">
  <iframe src="//player.bilibili.com/player.html?aid=585924344&bvid=BV1bz4y1z7oV&cid=276101028&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe>
</div>

<p>使用插件和配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Global Theme: Moe</span><br><span class="line">Plasma Style: Moe</span><br><span class="line">Kvantum: Moe</span><br><span class="line">Winows Decorations: Moe</span><br><span class="line">Color: Moe</span><br><span class="line">Icons: McMuse-circle-red</span><br><span class="line">Cursors: McMojave Cursors</span><br><span class="line">dock: latte-dock-git</span><br><span class="line">Latte Dock Layout: Moe</span><br><span class="line">Konsole Theme: Moe</span><br><span class="line">widgets: System Tray, Application Luncher, Window Buttons, Window Title, Global Menu, Event Calendar, NetspeedWidget, separator, sidebarbutton</span><br><span class="line">Other Plugin:</span><br><span class="line">https://github.com/zzag/kwin-effects-yet-another-magic-lamp.git</span><br><span class="line">https://github.com/psifidotos/applet-window-buttons.git</span><br><span class="line">https://github.com/tcorreabr/Parachute.git</span><br><span class="line">https://github.com/wsdfhjxc/virtual-desktop-bar.git</span><br></pre></td></tr></table></figure>

<p>注意：4K或者2K分辨率下进行缩放以后窗口装饰有问题，建议更换为Breeze窗口装饰，搭配也还不错</p>
]]></content>
      <categories>
        <category>Archlinux</category>
      </categories>
      <tags>
        <tag>Archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel链表list.h分析</title>
    <url>/posts/ad3383b3.html</url>
    <content><![CDATA[<h1 id="Kernel中链表的声明和初始化"><a href="#Kernel中链表的声明和初始化" class="headerlink" title="Kernel中链表的声明和初始化"></a>Kernel中链表的声明和初始化</h1><p><code>list.h</code>定义在<code>include/linux/list.h</code>中</p>
<p>Kernel中的链表定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>仅仅只有两个指针没有数据的双向循环链表。因此，如果需要定义一个能存储链表的结构，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data_list</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链表初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name) \</span></span><br><span class="line"><span class="meta">	struct list_head name = LIST_HEAD_INIT(name)</span></span><br></pre></td></tr></table></figure>

<p>此处初始化声明了一个首尾都是指向自己的链表。在<code>list.h</code>中，除了初始化链表宏，还有初始化函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __WRITE_ONCE(x, val)						\</span></span><br><span class="line"><span class="meta">do &#123;									\</span></span><br><span class="line"><span class="meta">	*(volatile typeof(x) *)&amp;(x) = (val);				\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_ONCE(x, val)						\</span></span><br><span class="line"><span class="meta">do &#123;									\</span></span><br><span class="line"><span class="meta">	compiletime_assert_rwonce_type(x);				\</span></span><br><span class="line"><span class="meta">	__WRITE_ONCE(x, val);						\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * INIT_LIST_HEAD - Initialize a list_head structure</span></span><br><span class="line"><span class="comment"> * @list: list_head structure to be initialized.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initializes the list_head to point to itself.  If it is a list header,</span></span><br><span class="line"><span class="comment"> * the result is an empty list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">INIT_LIST_HEAD</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	WRITE_ONCE(<span class="built_in">list</span>-&gt;next, <span class="built_in">list</span>);</span><br><span class="line">	<span class="built_in">list</span>-&gt;prev = <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们的作用完全相同</p>
<h1 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h1><h2 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Insert a new entry between two known consecutive entries.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is only for internal list manipulation where we know</span></span><br><span class="line"><span class="comment"> * the prev/next entries already!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_add(<span class="keyword">struct</span> list_head *new,</span><br><span class="line">			      <span class="keyword">struct</span> list_head *prev,</span><br><span class="line">			      <span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!__list_add_valid(new, prev, next))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	next-&gt;prev = new;</span><br><span class="line">	new-&gt;next = next;</span><br><span class="line">	new-&gt;prev = prev;</span><br><span class="line">	WRITE_ONCE(prev-&gt;next, new);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_add - add a new entry</span></span><br><span class="line"><span class="comment"> * @new: new entry to be added</span></span><br><span class="line"><span class="comment"> * @head: list head to add it after</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Insert a new entry after the specified head.</span></span><br><span class="line"><span class="comment"> * This is good for implementing stacks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_add(new, head, head-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_add_tail - add a new entry</span></span><br><span class="line"><span class="comment"> * @new: new entry to be added</span></span><br><span class="line"><span class="comment"> * @head: list head to add it before</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Insert a new entry before the specified head.</span></span><br><span class="line"><span class="comment"> * This is useful for implementing queues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_add_tail</span><span class="params">(<span class="keyword">struct</span> list_head *new, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_add(new, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>list_add</code>和<code>list_add_tail</code>分别实现头插和微差，都是由<code>__list_add</code>实现的。</p>
<p><code>__list_add(new, head, head-&gt;next)</code>实现在<code>head</code>和<code>head-&gt;next</code>之间添加节点。</p>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Delete a list entry and clear the &#x27;prev&#x27; pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is a special-purpose list clearing method used in the networking code</span></span><br><span class="line"><span class="comment"> * for lists allocated as per-cpu, where we don&#x27;t want to incur the extra</span></span><br><span class="line"><span class="comment"> * WRITE_ONCE() overhead of a regular list_del_init(). The code that uses this</span></span><br><span class="line"><span class="comment"> * needs to check the node &#x27;prev&#x27; pointer instead of calling list_empty().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_del_clearprev(<span class="keyword">struct</span> list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">	__list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">	entry-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_del_entry(<span class="keyword">struct</span> list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!__list_del_entry_valid(entry))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	__list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_del - deletes entry from list.</span></span><br><span class="line"><span class="comment"> * @entry: the element to delete from the list.</span></span><br><span class="line"><span class="comment"> * Note: list_empty() on entry does not return true after this, the entry is</span></span><br><span class="line"><span class="comment"> * in an undefined state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_del</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_del_entry(entry);</span><br><span class="line">	entry-&gt;next = LIST_POISON1;</span><br><span class="line">	entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_del_init - deletes entry from list and reinitialize it.</span></span><br><span class="line"><span class="comment"> * @entry: the element to delete from the list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_del_init</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_del_entry(entry);</span><br><span class="line">	INIT_LIST_HEAD(entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__list_del_entry</code>函数将<code>entry</code>的前一个节点和后一个节点之间关联。在<code>__list_del_entry</code>函数中出现的<code>__list_del_entry_valid</code>函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LIST</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">bool</span> __list_del_entry_valid(<span class="keyword">struct</span> list_head *entry);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> __list_del_entry_valid(<span class="keyword">struct</span> list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在文件<code>/lib/list_debug.c</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __must_check <span class="type">bool</span> <span class="title function_">check_data_corruption</span><span class="params">(<span class="type">bool</span> v)</span> &#123; <span class="keyword">return</span> v; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_DATA_CORRUPTION(condition, fmt, ...)			 \</span></span><br><span class="line"><span class="meta">	check_data_corruption((&#123;					 \</span></span><br><span class="line"><span class="meta">		bool corruption = unlikely(condition);			 \</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span> (corruption) &#123;					 \</span></span><br><span class="line"><span class="meta">			<span class="keyword">if</span> (IS_ENABLED(CONFIG_BUG_ON_DATA_CORRUPTION)) &#123; \</span></span><br><span class="line"><span class="meta">				pr_err(fmt, ##__VA_ARGS__);		 \</span></span><br><span class="line"><span class="meta">				BUG();					 \</span></span><br><span class="line"><span class="meta">			&#125; <span class="keyword">else</span>						 \</span></span><br><span class="line"><span class="meta">				WARN(1, fmt, ##__VA_ARGS__);		 \</span></span><br><span class="line"><span class="meta">		&#125;							 \</span></span><br><span class="line"><span class="meta">		corruption;						 \</span></span><br><span class="line"><span class="meta">	&#125;))</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> __list_del_entry_valid(<span class="keyword">struct</span> list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">	prev = entry-&gt;prev;</span><br><span class="line">	next = entry-&gt;next;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (CHECK_DATA_CORRUPTION(next == LIST_POISON1,</span><br><span class="line">			<span class="string">&quot;list_del corruption, %px-&gt;next is LIST_POISON1 (%px)\n&quot;</span>,</span><br><span class="line">			entry, LIST_POISON1) ||</span><br><span class="line">	    CHECK_DATA_CORRUPTION(prev == LIST_POISON2,</span><br><span class="line">			<span class="string">&quot;list_del corruption, %px-&gt;prev is LIST_POISON2 (%px)\n&quot;</span>,</span><br><span class="line">			entry, LIST_POISON2) ||</span><br><span class="line">	    CHECK_DATA_CORRUPTION(prev-&gt;next != entry,</span><br><span class="line">			<span class="string">&quot;list_del corruption. prev-&gt;next should be %px, but was %px\n&quot;</span>,</span><br><span class="line">			entry, prev-&gt;next) ||</span><br><span class="line">	    CHECK_DATA_CORRUPTION(next-&gt;prev != entry,</span><br><span class="line">			<span class="string">&quot;list_del corruption. next-&gt;prev should be %px, but was %px\n&quot;</span>,</span><br><span class="line">			entry, next-&gt;prev))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非debug模式下，函数直接返回true。在debug模式下，检查了链表四种不合法的情况，并根据情况输出对应的调试信息。</p>
<p><code>LIST_POISON1</code>和<code>LIST_POISON2</code>定义如下<code>tools/include/linux/poison.h</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Architectures might want to move the poison pointer offset</span></span><br><span class="line"><span class="comment"> * into some well-recognized area such as 0xdead000000000000,</span></span><br><span class="line"><span class="comment"> * that is also not mappable by user-space exploits:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ILLEGAL_POINTER_VALUE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> POISON_POINTER_DELTA _AC(CONFIG_ILLEGAL_POINTER_VALUE, UL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> POISON_POINTER_DELTA 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These are non-NULL pointers that will result in page faults</span></span><br><span class="line"><span class="comment"> * under normal circumstances, used to verify that nobody uses</span></span><br><span class="line"><span class="comment"> * non-initialized list entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_POISON1  ((void *) 0x100 + POISON_POINTER_DELTA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_POISON2  ((void *) 0x122 + POISON_POINTER_DELTA)</span></span><br></pre></td></tr></table></figure>

<p>使用这两个地址可能会造成内存分页错误，这样保证了这两个地址不被访问到。</p>
<h2 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_replace - replace old entry by new one</span></span><br><span class="line"><span class="comment"> * @old : the element to be replaced</span></span><br><span class="line"><span class="comment"> * @new : the new element to insert</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @old was empty, it will be overwritten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_replace</span><span class="params">(<span class="keyword">struct</span> list_head *old,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> list_head *new)</span></span><br><span class="line">&#123;</span><br><span class="line">	new-&gt;next = old-&gt;next;</span><br><span class="line">	new-&gt;next-&gt;prev = new;</span><br><span class="line">	new-&gt;prev = old-&gt;prev;</span><br><span class="line">	new-&gt;prev-&gt;next = new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_replace_init - replace old entry by new one and initialize the old one</span></span><br><span class="line"><span class="comment"> * @old : the element to be replaced</span></span><br><span class="line"><span class="comment"> * @new : the new element to insert</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If @old was empty, it will be overwritten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_replace_init</span><span class="params">(<span class="keyword">struct</span> list_head *old,</span></span><br><span class="line"><span class="params">				     <span class="keyword">struct</span> list_head *new)</span></span><br><span class="line">&#123;</span><br><span class="line">	list_replace(old, new);</span><br><span class="line">	INIT_LIST_HEAD(old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将前后两个指针分别指向新节点，新节点自身的两个指针指向前后即可。</p>
<h2 id="节点交换"><a href="#节点交换" class="headerlink" title="节点交换"></a>节点交换</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_swap - replace entry1 with entry2 and re-add entry1 at entry2&#x27;s position</span></span><br><span class="line"><span class="comment"> * @entry1: the location to place entry2</span></span><br><span class="line"><span class="comment"> * @entry2: the location to place entry1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_swap</span><span class="params">(<span class="keyword">struct</span> list_head *entry1,</span></span><br><span class="line"><span class="params">			     <span class="keyword">struct</span> list_head *c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">pos</span> =</span> -&gt;prev;</span><br><span class="line"></span><br><span class="line">	list_del(entry2);</span><br><span class="line">	list_replace(entry1, entry2);</span><br><span class="line">	<span class="keyword">if</span> (pos == entry1)</span><br><span class="line">		pos = entry2;</span><br><span class="line">	list_add(entry1, pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先从列表中删除<code>entry2</code>，在将<code>entry1</code>替换为<code>entry2</code>，然后<code>entry1</code>添加到<code>entry2</code>的位置。</p>
<h2 id="节点移动"><a href="#节点移动" class="headerlink" title="节点移动"></a>节点移动</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_move - delete from one list and add as another&#x27;s head</span></span><br><span class="line"><span class="comment"> * @list: the entry to move</span></span><br><span class="line"><span class="comment"> * @head: the head that will precede our entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_move</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>, <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_del_entry(<span class="built_in">list</span>);</span><br><span class="line">	list_add(<span class="built_in">list</span>, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_move_tail - delete from one list and add as another&#x27;s tail</span></span><br><span class="line"><span class="comment"> * @list: the entry to move</span></span><br><span class="line"><span class="comment"> * @head: the head that will follow our entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_move_tail</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	__list_del_entry(<span class="built_in">list</span>);</span><br><span class="line">	list_add_tail(<span class="built_in">list</span>, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用<code>__list_del_entry(list)</code>，将节点从list中删除，然后调用<code>list_add(list, head)</code>将list添加到head的链表中。</p>
<h2 id="检测是否为第一个节点"><a href="#检测是否为第一个节点" class="headerlink" title="检测是否为第一个节点"></a>检测是否为第一个节点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_is_first -- tests whether @list is the first entry in list @head</span></span><br><span class="line"><span class="comment"> * @list: the entry to test</span></span><br><span class="line"><span class="comment"> * @head: the head of the list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">list_is_first</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">					<span class="type">const</span> <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>-&gt;prev == head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检测是否最后一个节点"><a href="#检测是否最后一个节点" class="headerlink" title="检测是否最后一个节点"></a>检测是否最后一个节点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_is_last - tests whether @list is the last entry in list @head</span></span><br><span class="line"><span class="comment"> * @list: the entry to test</span></span><br><span class="line"><span class="comment"> * @head: the head of the list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">list_is_last</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> list_head *<span class="built_in">list</span>,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>-&gt;next == head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检测是否为空"><a href="#检测是否为空" class="headerlink" title="检测是否为空"></a>检测是否为空</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_empty - tests whether a list is empty</span></span><br><span class="line"><span class="comment"> * @head: the list to test.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">list_empty</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> READ_ONCE(head-&gt;next) == head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_empty_careful - tests whether a list is empty and not being modified</span></span><br><span class="line"><span class="comment"> * @head: the list to test</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * tests whether a list is empty _and_ checks that no other CPU might be</span></span><br><span class="line"><span class="comment"> * in the process of modifying either member (next or prev)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> using list_empty_careful() without synchronization</span></span><br><span class="line"><span class="comment"> * can only be safe if the only activity that can happen</span></span><br><span class="line"><span class="comment"> * to the list entry is list_del_init(). Eg. it cannot be used</span></span><br><span class="line"><span class="comment"> * if another CPU could re-list_add() it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">list_empty_careful</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span> =</span> smp_load_acquire(&amp;head-&gt;next);</span><br><span class="line">	<span class="keyword">return</span> (next == head) &amp;&amp; (next == head-&gt;prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检测是否只有一个节点"><a href="#检测是否只有一个节点" class="headerlink" title="检测是否只有一个节点"></a>检测是否只有一个节点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_is_singular - tests whether a list has just one entry.</span></span><br><span class="line"><span class="comment"> * @head: the list to test.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">list_is_singular</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> list_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !list_empty(head) &amp;&amp; (head-&gt;next == head-&gt;prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>and so on.</p>
]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历kernel进程链表</title>
    <url>/posts/93e3e2a6.html</url>
    <content><![CDATA[<p>linux内核中使用<code>task_struct</code>结构来描述一个PCB（<code>linux/kernel/sched.c</code>）。多个进程则常常使用双链表等来进行组织。比如可运行状态的进程组成可运行队列，等待状态的进程组成等待队列等。</p>
<p><code>list.h</code>的遍历宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * container_of - cast a member of a structure out to the containing structure</span></span><br><span class="line"><span class="comment"> * @ptr:	the pointer to the member.</span></span><br><span class="line"><span class="comment"> * @type:	the type of the container struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the member within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;				\</span></span><br><span class="line"><span class="meta">	void *__mptr = (void *)(ptr);					\</span></span><br><span class="line"><span class="meta">	static_assert(__same_type(*(ptr), ((type *)0)-&gt;member) ||	\</span></span><br><span class="line"><span class="meta">		      __same_type(*(ptr), void),			\</span></span><br><span class="line"><span class="meta">		      <span class="string">&quot;pointer type mismatch in container_of()&quot;</span>);	\</span></span><br><span class="line"><span class="meta">	((type *)(__mptr - offsetof(type, member))); &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_entry - get the struct for this entry</span></span><br><span class="line"><span class="comment"> * @ptr:	the &amp;struct list_head pointer.</span></span><br><span class="line"><span class="comment"> * @type:	the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">	container_of(ptr, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_first_entry - get the first element from a list</span></span><br><span class="line"><span class="comment"> * @ptr:	the list head to take the element from.</span></span><br><span class="line"><span class="comment"> * @type:	the type of the struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note, that list is expected to be not empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_first_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">	list_entry((ptr)-&gt;next, type, member)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * list_for_each_entry	-	iterate over list of given type</span></span><br><span class="line"><span class="comment"> * @pos:	the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:	the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the list_head within the struct.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_for_each_entry(pos, head, member)				\</span></span><br><span class="line"><span class="meta">	for (pos = list_first_entry(head, typeof(*pos), member);	\</span></span><br><span class="line"><span class="meta">	     !list_entry_is_head(pos, head, member);			\</span></span><br><span class="line"><span class="meta">	     pos = list_next_entry(pos, member))</span></span><br></pre></td></tr></table></figure>

<p><code>list_head</code>没有数据，所以它经常被嵌套在其他的结构体中。pos指向包含<code>list_struct</code>结构的结构体，head为<code>list_head</code>类型的指针，我们可以使用链表中任意一个结点的指针；member即为list_head类型的变量名。</p>
<p>获取列表里的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br></pre></td></tr></table></figure>

<p>使用了三个参数：</p>
<ul>
<li>ptr - 指向链表头的指针；</li>
<li>type - 结构体类型;</li>
<li>member - 在结构体内类型为 <code>list_head</code> 的变量的名字；</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br></pre></td></tr></table></figure>

<p>调用了宏<code>container_of</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;                      \</span></span><br><span class="line"><span class="meta">    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \</span></span><br><span class="line"><span class="meta">    (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span></span><br></pre></td></tr></table></figure>

<p>编译器会执行花括号内的全部语句，然后返回最后的表达式的值。</p>
<p><code>typeof</code>返回给定变量的类型。<code>container_of</code> 中的 0巧妙的计算了从结构体特定变量的偏移，这里的0刚好就是位宽里的零偏移。</p>
<p>下一个宏 <code>offsetof</code> 会计算从结构体的某个变量的相对于结构体起始地址的偏移。它的实现和上面类似：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br></pre></td></tr></table></figure>

<p>只需要知道结构体里面类型为 <code>list_head</code> 的变量的名字和结构体容器的类型，它可以通过结构体的变量 <code>list_head</code> 获得结构体的起始地址。在宏定义的第一行，声明了一个指向结构体成员变量 <code>ptr</code> 的指针 <code>__mptr</code> ，并且把 <code>ptr</code> 的地址赋给它。现在 <code>ptr</code> 和 <code>__mptr</code> 指向了同一个地址。从技术上讲我们并不需要这一行，但是它可以方便的进行类型检查。第一行保证了特定的结构体（参数 <code>type</code>）包含成员变量 <code>member</code>。第二行代码会用宏 <code>offsetof</code> 计算成员变量相对于结构体起始地址的偏移，然后从结构体的地址减去这个偏移，最后就得到了结构体的起始地址。</p>
<p><code>pos</code>为指向<code>task_struct</code>类型的指针，我们通过遍历宏即得到每个进程对应的<code>task_struct</code>类型的指针。我们将<code>current_head</code>赋予遍历宏中的第二个参数，current是一个宏，即为系统内正在运行的进程；由于<code>list_struct</code>结构在<code>task_struct</code>结构中的变量明为<code>tasks</code>，因此我们将<code>tasks</code>传递给遍历宏的第三个参数。</p>
<p>遍历进程链表实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/printk.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">traverse_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pos</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">current_head</span>;</span></span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  printk(<span class="string">&quot;traverse module is working...\n&quot;</span>);</span><br><span class="line">  current_head = &amp;(current-&gt;tasks);</span><br><span class="line">  list_for_each_entry(pos, current_head, tasks)</span><br><span class="line">  &#123;</span><br><span class="line">    count ++;</span><br><span class="line">    printk(<span class="string">&quot;[process %d]: %s\&#x27;s pid is %d\n&quot;</span>, count, pos-&gt;comm, pos-&gt;pid);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">traverse_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;traverse process exit!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(traverse_init);</span><br><span class="line">module_exit(traverse_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编写Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">obj-m := traverse_process.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">KERNEL_VERSION := <span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line">KDIR := /lib/modules/`uname -r`/build</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o *.ko *.mod.c *.symvers *.c~ *~</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>加载模块到内核：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo insmod traverse_process.ko</span><br></pre></td></tr></table></figure>

<p><code>dmesg</code>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[38167.768467] traverse module is working...</span><br><span class="line">[38167.768468] [process 1]: swapper/0&#x27;s pid is 0</span><br><span class="line">[38167.768469] [process 2]: systemd&#x27;s pid is 1</span><br><span class="line">[38167.768470] [process 3]: kthreadd&#x27;s pid is 2</span><br><span class="line">[38167.768470] [process 4]: rcu_gp&#x27;s pid is 3</span><br><span class="line">[38167.768471] [process 5]: rcu_par_gp&#x27;s pid is 4</span><br><span class="line">[38167.768472] [process 6]: kworker/0:0H&#x27;s pid is 6</span><br><span class="line">[38167.768472] [process 7]: mm_percpu_wq&#x27;s pid is 8</span><br><span class="line">[38167.768473] [process 8]: rcu_tasks_kthre&#x27;s pid is 10</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>卸载内核模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rmmod traverse_process</span><br></pre></td></tr></table></figure>

<p><code>dmesg</code>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[38214.937567] traverse process exit!</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel中的哈希表</title>
    <url>/posts/466f0e1b.html</url>
    <content><![CDATA[<h1 id="哈表表的定义"><a href="#哈表表的定义" class="headerlink" title="哈表表的定义"></a>哈表表的定义</h1><p>哈希表，是根据键值（key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中的一个位置来访问记录，加快了查找速度。这个映射函数就叫做散列函数，存放记录的数组称作散列列表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 哈希头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 哈希节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span>, **<span class="title">pprev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表包含两个数据结构，一个是哈希链表节点<code>hlist_node</code>，另一个是哈希表头<code>hlist_head</code>。可以看到哈希节点<code>hlist_node</code>和内核普通双向链表的节点唯一的区别就在于，前向节点<code>pprev</code>是个两级指针。同时并没有使用<code>hlist_node</code>作为哈希表头，而是重新定义了<code>hlist_head</code>结构体，这是因为哈希链表并不需要双向循环，为了节省空间使用一个指针first指向该哈希表的第一个节点就可以了。整个哈希表结构如下图所示，其中<code>ppre</code>是个二级指针，它指向前一个节点的第一个指针变量，例如<code>node1</code>的<code>ppre</code>指向<code>mylist</code>的<code>first</code>指针，<code>node2</code>的<code>ppre</code>指向<code>node1</code>的next指针。</p>
<p>之所以使用<code>ppre</code>二级指针是为了避免在首节点之后插入删除节点和在其他位置插入删除节点实现逻辑的不同，读者可以将<code>ppre</code>改成一级指针指向前一个节点，就可以发现实现逻辑的不同。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e297753dac.png" alt="img"></p>
<p><img src="https://img.ansore.de/2022/05/01/626e29750ffeb.png" alt="image-20220308232120796"></p>
<h1 id="哈希表的初始化"><a href="#哈希表的初始化" class="headerlink" title="哈希表的初始化"></a>哈希表的初始化</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Double linked lists with a single pointer list head.</span></span><br><span class="line"><span class="comment"> * Mostly useful for hash tables where the two pointer list head is</span></span><br><span class="line"><span class="comment"> * too wasteful.</span></span><br><span class="line"><span class="comment"> * You lose the ability to access the tail in O(1).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HLIST_HEAD_INIT &#123; .first = NULL &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HLIST_HEAD(name) struct hlist_head name = &#123;  .first = NULL &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)</span></span><br></pre></td></tr></table></figure>

<p>这三个初始化宏都是建立一个hlist_head结构体，并把first成员设置为NULL。</p>
<p>初始化hlist_node结构体，把两个成员变量赋值为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline void INIT_HLIST_NODE(struct hlist_node *h)</span><br><span class="line">&#123;</span><br><span class="line">	h-&gt;next = NULL;</span><br><span class="line">	h-&gt;pprev = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈希表操作"><a href="#哈希表操作" class="headerlink" title="哈希表操作"></a>哈希表操作</h1><h2 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_add_head - add a new entry at the beginning of the hlist</span></span><br><span class="line"><span class="comment"> * @n: new entry to be added</span></span><br><span class="line"><span class="comment"> * @h: hlist head to add it after</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Insert a new entry after the specified head.</span></span><br><span class="line"><span class="comment"> * This is good for implementing stacks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hlist_add_head</span><span class="params">(<span class="keyword">struct</span> hlist_node *n, <span class="keyword">struct</span> hlist_head *h)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">first</span> =</span> h-&gt;first;</span><br><span class="line">	WRITE_ONCE(n-&gt;next, first);</span><br><span class="line">	<span class="keyword">if</span> (first)</span><br><span class="line">		WRITE_ONCE(first-&gt;pprev, &amp;n-&gt;next);</span><br><span class="line">	WRITE_ONCE(h-&gt;first, n);</span><br><span class="line">	WRITE_ONCE(n-&gt;pprev, &amp;h-&gt;first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_add_before - add a new entry before the one specified</span></span><br><span class="line"><span class="comment"> * @n: new entry to be added</span></span><br><span class="line"><span class="comment"> * @next: hlist node to add it before, which must be non-NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hlist_add_before</span><span class="params">(<span class="keyword">struct</span> hlist_node *n,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> hlist_node *next)</span></span><br><span class="line">&#123;</span><br><span class="line">	WRITE_ONCE(n-&gt;pprev, next-&gt;pprev);</span><br><span class="line">	WRITE_ONCE(n-&gt;next, next);</span><br><span class="line">	WRITE_ONCE(next-&gt;pprev, &amp;n-&gt;next);</span><br><span class="line">	WRITE_ONCE(*(n-&gt;pprev), n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_add_behind - add a new entry after the one specified</span></span><br><span class="line"><span class="comment"> * @n: new entry to be added</span></span><br><span class="line"><span class="comment"> * @prev: hlist node to add it after, which must be non-NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hlist_add_behind</span><span class="params">(<span class="keyword">struct</span> hlist_node *n,</span></span><br><span class="line"><span class="params">				    <span class="keyword">struct</span> hlist_node *prev)</span></span><br><span class="line">&#123;</span><br><span class="line">	WRITE_ONCE(n-&gt;next, prev-&gt;next);</span><br><span class="line">	WRITE_ONCE(prev-&gt;next, n);</span><br><span class="line">	WRITE_ONCE(n-&gt;pprev, &amp;prev-&gt;next);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n-&gt;next)</span><br><span class="line">		WRITE_ONCE(n-&gt;next-&gt;pprev, &amp;n-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_add_fake - create a fake hlist consisting of a single headless node</span></span><br><span class="line"><span class="comment"> * @n: Node to make a fake list out of</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This makes @n appear to be its own predecessor on a headless hlist.</span></span><br><span class="line"><span class="comment"> * The point of this is to allow things like hlist_del() to work correctly</span></span><br><span class="line"><span class="comment"> * in cases where there is no list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hlist_add_fake</span><span class="params">(<span class="keyword">struct</span> hlist_node *n)</span></span><br><span class="line">&#123;</span><br><span class="line">	n-&gt;pprev = &amp;n-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hlist_add_head</code>是把一个哈希链表的节点插入到哈希链表的头节点的后边，也就是头插法。传入了哈希表头h和待插入的节点n，首先得到<code>hlist_head</code>的<code>first</code>成员，就是后边的节点的指针，这个节点可能是<code>NULL</code>，然后新插入的节点的next指向first后边的节点，如果<code>first</code>不为空，也就是后边有节点存在，<code>head</code>的后边的节点的<code>pprev</code>成员就指向新插入的节点的next成员的地址，<code>head</code>的<code>first</code>就指向新插入的节点，新插入节点的<code>pprev</code>成员指向<code>head</code>的<code>first</code>成员的地址。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e25f966b70.png" alt="img"></p>
<p><code>hlist_add_before</code>作用是把一个节点插入到一个哈希链表的节点的前边，首先把将要插入的节点的<code>pprev</code>成员变量指向<code>next</code>的前边的节点，要插入的节点的<code>next</code>指向下一个节点，然后<code>next</code>节点的<code>pprev</code>就要指向已经插入的节点的<code>next</code>节点的地址，已经插入的节点的<code>pprev</code>指向的前一个节点的值就要变成已经插入节点的地址。</p>
<h2 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __WRITE_ONCE(x, val)						\</span></span><br><span class="line"><span class="meta">do &#123;									\</span></span><br><span class="line"><span class="meta">	*(volatile typeof(x) *)&amp;(x) = (val);				\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_ONCE(x, val)						\</span></span><br><span class="line"><span class="meta">do &#123;									\</span></span><br><span class="line"><span class="meta">	compiletime_assert_rwonce_type(x);				\</span></span><br><span class="line"><span class="meta">	__WRITE_ONCE(x, val);						\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __hlist_del(<span class="keyword">struct</span> hlist_node *n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">next</span> =</span> n-&gt;next;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> **<span class="title">pprev</span> =</span> n-&gt;pprev;</span><br><span class="line"></span><br><span class="line">	WRITE_ONCE(*pprev, next);  <span class="comment">// *pprev=next</span></span><br><span class="line">	<span class="keyword">if</span> (next)</span><br><span class="line">		WRITE_ONCE(next-&gt;pprev, pprev);  <span class="comment">// next-&gt;pprev=pprev</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_del - Delete the specified hlist_node from its list</span></span><br><span class="line"><span class="comment"> * @n: Node to delete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function leaves the node in hashed state.  Use</span></span><br><span class="line"><span class="comment"> * hlist_del_init() or similar instead to unhash @n.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hlist_del</span><span class="params">(<span class="keyword">struct</span> hlist_node *n)</span></span><br><span class="line">&#123;</span><br><span class="line">	__hlist_del(n);</span><br><span class="line">	n-&gt;next = LIST_POISON1;</span><br><span class="line">	n-&gt;pprev = LIST_POISON2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_del_init - Delete the specified hlist_node from its list and initialize</span></span><br><span class="line"><span class="comment"> * @n: Node to delete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function leaves the node in unhashed state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hlist_del_init</span><span class="params">(<span class="keyword">struct</span> hlist_node *n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!hlist_unhashed(n)) &#123;</span><br><span class="line">		__hlist_del(n);</span><br><span class="line">		INIT_HLIST_NODE(n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>__hlist_del</code>将删除节点的前驱的<code>next</code>指针指向后继(<code>*pprev=next</code>)，如果将要删除的<code>next</code>指针不为空，则将后继的<code>pprev</code>指针指向前驱的<code>next</code>指针</p>
<p><img src="https://img.ansore.de/2022/05/01/626e26617eb37.png" alt="Screenshot_20220308_232224"></p>
<h2 id="判断节点是否经过哈希"><a href="#判断节点是否经过哈希" class="headerlink" title="判断节点是否经过哈希"></a>判断节点是否经过哈希</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_unhashed - Has node been removed from list and reinitialized?</span></span><br><span class="line"><span class="comment"> * @h: Node to be checked</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Not that not all removal functions will leave a node in unhashed</span></span><br><span class="line"><span class="comment"> * state.  For example, hlist_nulls_del_init_rcu() does leave the</span></span><br><span class="line"><span class="comment"> * node in unhashed state, but hlist_nulls_del() does not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">hlist_unhashed</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hlist_node *h)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !h-&gt;pprev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断一个<code>hlist_node</code>节点是否经过hash，如果没有经过hash，那么<code>pprev</code>指针为空，返回<code>true</code>，反之亦然。</p>
<h2 id="判断哈希表是否为空"><a href="#判断哈希表是否为空" class="headerlink" title="判断哈希表是否为空"></a>判断哈希表是否为空</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_empty - Is the specified hlist_head structure an empty hlist?</span></span><br><span class="line"><span class="comment"> * @h: Structure to check.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">hlist_empty</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hlist_head *h)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !READ_ONCE(h-&gt;first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断头结点是否为空，如果为空，那么对应的hash表也为空。</p>
<h2 id="遍历哈希表"><a href="#遍历哈希表" class="headerlink" title="遍历哈希表"></a>遍历哈希表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> hlist_for_each(pos, head) \</span></span><br><span class="line"><span class="meta">	for (pos = (head)-&gt;first; pos ; pos = pos-&gt;next)</span></span><br></pre></td></tr></table></figure>

<p>这个宏是对哈希链表进行遍历的宏，<code>pos</code>代表一个<code>hlist_node</code>结构体指针，<code>head</code>代表<code>hlist_head</code>结构体，就是哈希链表的头。得到<code>pos</code>后，在宏展开后就可以在循环体中取到结构体具体的数值。</p>
<h2 id="获取哈希表中的数据实体"><a href="#获取哈希表中的数据实体" class="headerlink" title="获取哈希表中的数据实体"></a>获取哈希表中的数据实体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * container_of - cast a member of a structure out to the containing structure</span></span><br><span class="line"><span class="comment"> * @ptr:	the pointer to the member.</span></span><br><span class="line"><span class="comment"> * @type:	the type of the container struct this is embedded in.</span></span><br><span class="line"><span class="comment"> * @member:	the name of the member within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;				\</span></span><br><span class="line"><span class="meta">	void *__mptr = (void *)(ptr);					\</span></span><br><span class="line"><span class="meta">	static_assert(__same_type(*(ptr), ((type *)0)-&gt;member) ||	\</span></span><br><span class="line"><span class="meta">		      __same_type(*(ptr), void),			\</span></span><br><span class="line"><span class="meta">		      <span class="string">&quot;pointer type mismatch in container_of()&quot;</span>);	\</span></span><br><span class="line"><span class="meta">	((type *)(__mptr - offsetof(type, member))); &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hlist_entry(ptr, type, member) container_of(ptr,type,member)</span></span><br></pre></td></tr></table></figure>

<p><code>member</code>为在该结构体中的成员名称</p>
]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之保护模式</title>
    <url>/posts/15f5ac65.html</url>
    <content><![CDATA[<ul>
<li>实模式（Real Mode)：又名 Real Address Mode，在此模式下地址访问的是真实地内存地址所在位置。在此模式下，可以使用20位（1MB）的地址空间，软件可以不受限制的操作所有地址的空间和IO设备。</li>
<li>保护模式（Protected Mode)：又名 Protected Virtual Address Mode，采用虚拟内存、页等机制对内存进行了保护，比起实模式更为安全可靠，同时也增加了灵活性和扩展性。</li>
</ul>
<blockquote>
<p><strong>现在的64位处理器，拥有三种基本模式（保护模式、实模式、系统管理模式）和一种扩展模式（IA-32e模式（又分兼容模式和64位模式</strong></p>
</blockquote>
<p>在8086中，实模式采取内存段来管理 0 - 0xFFFFF的这1M内存空间，但是由于只有16位寄存器，所以最大地址只能表示为0xFFFFF（64KB)，因此不得不采取将内存按段划分为64KB的方式来充分利用1M空间。也就是上所示的，采取段选择子 + 偏移量的表示法，直接输出的就是物理地址，CPU 可以直接用此地址访问内存 ，计算如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PhysicalAddress = Segment Selector * <span class="number">16</span> + Offset</span><br></pre></td></tr></table></figure>

<p>而在保护模式下,”段基址+段内偏移地址”称为线性地址,不过,此时的段基址已经不再是真正的地址了,而是一个称为选择子的东西 。 它本质是个索引,类似于数组下标,通过这个索引便能在 GDT 中找到相应的段描述符，在该描述符中记录了该段的起始、大小等信息，这样便得到了段基址。若没有开启地址分页功能,此线性地址就被 当作物理地址来用,可直接访问内存。 若开启了分页功能,此线性地址又多了 一个名字,就是虚拟地址 ( 虚拟地址、线性地址在分页机制下都是一 回事) 。 虚拟地址要经过 CPU 页部件转换成具体的物理地址,这样 CPU 才能将其送上地址总线去访问内存。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e2650470c9.png" alt="Screenshot_20210411_174013"></p>
<p>考虑到各种属性和需要设置的操作，32位保护模式下对一个内存段的描述需要8个字节，其称之为段描述符（Segment Descriptor）。段描述符分为数据段描述符、指令段描述符和系统段描述符三种，大致相同，个体差异。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e2676e7cdc.png" alt="img"></p>
<p>寄存器不足以存放N多个内存段的描述符集合，所以这些描述符的集合（称之为描述符表）被放置在内存里了。在很多描述符表中，最重要的就是所谓的全局描述符表（Global Descriptor Table，GDT），它为整个软硬件系统服务。</p>
<ul>
<li>这些描述符表放置在内存哪里？答案是没有固定的说法，可以任由程序员安排在任意合适的位置。</li>
<li>既然没有指定固定位置，CPU如何知道全局描述符表在哪？答案是Intel干脆设置了一个48位的专用的全局描述符表寄存器（GDTR）来保存全局描述符表的信息。</li>
<li>48位怎么分配呢？如图所示，0-15位表示GDT的边界位置（数值为表的长度-1，因为从0计算），16-47位这32位存放的就是GDT的基地址（恰似数组的首地址）。</li>
</ul>
<p><img src="https://img.ansore.de/2022/05/01/626e2682a412a.png" alt="img"></p>
<p>既然用16位来表示表的长度，那么2的16次方就是65536字节，除以每一个描述符的8字节，那么最多能创建8192个描述符。</p>
<p>寻址方式：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e2695f1fd2.png" alt="img"></p>
]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之中断和异常处理</title>
    <url>/posts/94c81492.html</url>
    <content><![CDATA[<p>中断和异常的作用是指示系统中的某个地方发生一些事件, 需要引起处理器(包括正在执行中的程序和任务)的注意. 当中断和异常发生时, 典型的结果是迫使处理器将控制从当前正在执行的程序或任务转移到另一个历程或任务中去. 该例程叫做中断处理程序, 或者异常处理程序. 如果是一个任务, 则发生任务切换.</p>
<p>中断包括硬件中断和软中断.</p>
<p>硬件中断是由外围硬件设备发出的中断信号引发的, 以请求处理器提供服务. 当I&#x2F;O接口发出中断请求时, 会被像8259A和I&#x2F;O APIC这样的中断控制器收集, 并发送到处理器. 硬件中断完全是随机产生的, 与处理器的执行并不同步. 当中断发生时, 处理器要先执行完当前的指令, 然后才对中断进行处理。</p>
<p>软中断是由 int n 指令引发的中断处理, n是中断号或者叫类型码.</p>
<p>中断处理程序是运行在ring0层的，这就意味着中断处理程序拥有着系统的全部权限。Intel设置了一个叫做中断描述符表（IDT, Interrupt Descriptor Table）的东西，和段描述符表一样放置在主存中，类似地，也有一个中断描述符表寄存器（IDTR）记录这个表的起始地址。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e26ac3b7ba.png" alt="img"></p>
<p>这是0号到19号中断，20～31号中断Intel保留了，32～255号中断留给了用户去定义和使用。在Linux系统下我们可以查阅当前的中断定义和映射表，方法是查看&#x2F;proc&#x2F;interrupts 文件即可</p>
]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统之段页式内存管理</title>
    <url>/posts/8c7f7ee7.html</url>
    <content><![CDATA[<h1 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h1><p>分段可以说是Intel的CPU一直保持着的一种机制，而分页只是保护模式下的一种内存管理策略。不过想开启分页机制，CPU就必须工作在保护模式，而工作在保护模式时候可以不开启分页。</p>
<p>首先是全局段描述符表：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e273208ebe.png" alt="img"></p>
<p>结构体后的<code>__attribute__((packed))</code>是GCC的扩展，用来设置该结构体不进行字节对齐。</p>
<p>段描述符表定义：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e2734eec89.png" alt="img"></p>
<p>GDTR定义：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e2736d64b9.png" alt="img"></p>
<p>段描述符表的部分以二进制位来表示的设置信息合并到了相应的字节里，这里按照位域去定义不是不可以，但是太过于臃肿了。</p>
<p>全局描述符表的定义以及设置一项描述符的函数实现：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e273ae3643.png" alt="img"></p>
<p><img src="https://img.ansore.de/2022/05/01/626e273f1aa6c.png" alt="img"></p>
<p>初始化函数：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e27418f188.png" alt="img"></p>
<p>最后有一个加载全局描述附表的函数，这个函数用汇编来实现了。代码如下：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e27480f7c4.png" alt="img"></p>
<p>CPU在保护模式下分页未开启和分页开启的不同状态时，MMU组件处理地址的流程。</p>
<p>如果没有开启分页：</p>
<blockquote>
<p>逻辑地址-&gt;段机制处理-&gt;线性地址&#x3D;物理地址</p>
</blockquote>
<p>如果开启分页：</p>
<blockquote>
<p>逻辑地址-&gt;段机制处理-&gt;线性地址-&gt;页机制处理-&gt;物理地址</p>
</blockquote>
<p>因为我们采用了平坦模式，所以给出的访问地址实际上已经是线性地址了(段基址为0)，那么剩下的问题就是所谓的页机制处理了。</p>
<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>在逻辑上把内存划分为定长的物理页，同时将一个程序执行时候的线性地址地址空间划分为逻辑页，在分页机制工作的前提下，给硬件提供一组数据结构来保存这种映射关系。也就是说，线性地址是连续的，但是其实际指向的物理地址就不见得是连续的了。</p>
<p>以32位的地址来说，分为3段来寻址，分别是地址的低12位，中间10位和高10位。高10位表示当前地址项在页目录中的偏移，最终偏移处指向对应的页表，中间10位是当前地址在该页表中的偏移，我们按照这个偏移就能查出来最终指向的物理页了，最低的12位表示当前地址在该物理页中的偏移。就这样，我们就实现了分级页表。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e274883a77.png" alt="img"></p>
]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel中的地址转换</title>
    <url>/posts/3be91ca.html</url>
    <content><![CDATA[<p>在Linux中的地址转换如下图所示，逻辑地址通过段选择子查询GDT得到段描述，然后加上偏移得到线性地址（虚拟地址），而在Linux中并没有完整的使用分段机制，它让所有的段都指向相同的地址范围，段的基地址都为0，也就是说逻辑地址和线性地址在数值上就相同了。在由分页机制将线性地址转换为物理地址</p>
<p><img src="https://img.ansore.de/2022/05/01/626e276143e9b.png" alt="Screenshot_20220313_223502"></p>
<p>在Linux系统中，为了兼容32位和64位，它需要一个统一的页面地址模型，目前常用的是4级页表模型。包括PGD页全局目录、PUD页上级目录、PMD页中级目的、PTE页表。根据情况某些页表不会被使用，每个页表项的大小会根据计算机体系结构的不同做相应的改变。例如没有启用物理地址扩展的32位系统来说，两级页表页表就够了，那么Linux会在线性地址中，会让PUD和PMD索引置为0，从根本上取消了这两个字段，但是这两个页目录在指针序列中的位置仍然被保留下来，也就是说在寻址过程中不能通过PUD和PMD直接都页表，内核会将这两个页目录表项都置为1。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e29585cc08.png" alt="Screenshot_20220313_224447"></p>
<p>由于64位系统硬件限制，实际的地址线有48条，所以线性地址实际使用也只有48位。在64位Linux中使用了4级页表结构。线性地址划分如下：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e2761c3efb.png" alt="Screenshot_20220313_224507"></p>
<p>PGD、PUD、PMD、PTE索引分别占了9位，页内偏移占了12位，总计48位，剩下高位保留。页面的大小都为4kb，每一个页表项大小为8bit，整个页面可以映射的空间是256TB。而新的Intel芯片的MMU硬件规定可以进行5级的页表映射，所以在4.15的内核中，在PGD和PUD之间又新增了一个新的页目录，叫做P4D页目录。这个页目录同32位中的情况还未使用，它的页目录项只有一个，线性地址中也没有它的索引。</p>
<p>CR3寄存器是一系列CPU控制寄存器之一，这些寄存器主要用来保存和控制系统级别操作的数据和信息。其中这个CR3寄存器用来保存当前进程的页全局目录的地址。寻页就是从页全局目录开始，内核在创建一个进程的时候就会为它分配一个页全局目录。</p>
<p>在进程描述符<code>task_struct</code>结构体中有一个指向<code>mm_struct</code>结构的<code>mm</code>指针，而<code>mm_struct</code>结构用来描述进程的虚拟地址空间，在<code>mm_struct</code>中有一个<code>PGD</code>字段就是用来保存该进程的页全局目录的（物理）地址。所以在进程切换的时候，操作系统通过访问<code>mm_struct</code>结构体<code>PGD</code>字段取得新进程的页全局目录地址填充到CR3寄存器中，就完成了页表的切换。</p>
<p>代码演示如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/export.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> cr0, cr3;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> vaddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">get_pgtable_macro</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  cr0 = read_cr0();</span><br><span class="line">  cr3 = read_cr3_pa();</span><br><span class="line"></span><br><span class="line">  printk(<span class="string">&quot;cr0 = 0x%lx, cr3 = 0x%lx\n&quot;</span>, cr0, cr3);</span><br><span class="line">  printk(<span class="string">&quot;PGDIR_SHIFT = %d\n&quot;</span>, PGDIR_SHIFT);</span><br><span class="line">  printk(<span class="string">&quot;P4D_SHIFT = %d\n&quot;</span>, P4D_SHIFT);</span><br><span class="line">  printk(<span class="string">&quot;PUD_SHIFT = %d\n&quot;</span>, PUD_SHIFT);</span><br><span class="line">  printk(<span class="string">&quot;PMD_SHIFT = %d\n&quot;</span>, PMD_SHIFT);</span><br><span class="line">  printk(<span class="string">&quot;PAGE_SHIFT = %d\n&quot;</span>, PAGE_SHIFT);</span><br><span class="line"></span><br><span class="line">  printk(<span class="string">&quot;PTRS_PER_PGD = %d\n&quot;</span>, PTRS_PER_PGD);</span><br><span class="line">  printk(<span class="string">&quot;PTRS_PER_P4D = %d\n&quot;</span>, PTRS_PER_P4D);</span><br><span class="line">  printk(<span class="string">&quot;PTRS_PER_PUD = %d\n&quot;</span>, PTRS_PER_PUD);</span><br><span class="line">  printk(<span class="string">&quot;PTRS_PER_PMD = %d\n&quot;</span>, PTRS_PER_PMD);</span><br><span class="line">  printk(<span class="string">&quot;PTRS_PER_PTE = %d\n&quot;</span>, PTRS_PER_PTE);</span><br><span class="line">  printk(<span class="string">&quot;PAGE_MASK = 0x%lx\n&quot;</span>, PAGE_MASK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">vaddr2paddr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pgd_t</span> *pgd;</span><br><span class="line">  <span class="type">p4d_t</span> *p4d;</span><br><span class="line">  <span class="type">pud_t</span> *pud;</span><br><span class="line">  <span class="type">pmd_t</span> *pmd;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> paddr = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> page_addr = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> page_offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pgd = pgd_offset(current-&gt;mm, vaddr);</span><br><span class="line">  printk(<span class="string">&quot;pgd_val = 0x%lx, pgd_index = %lu\n&quot;</span>, pgd_val(*pgd), pgd_index(vaddr));</span><br><span class="line">  <span class="keyword">if</span> (pgd_none(*pgd)) &#123;</span><br><span class="line">    printk(<span class="string">&quot;not mapped in pgd\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p4d = p4d_offset(pgd, vaddr);</span><br><span class="line">  printk(<span class="string">&quot;p4d_val = 0x%lx, p4d_index = %lu\n&quot;</span>, p4d_val(*p4d), p4d_index(vaddr));</span><br><span class="line">  <span class="keyword">if</span> (p4d_none(*p4d)) &#123;</span><br><span class="line">    printk(<span class="string">&quot;not mapped in p4d\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pud = pud_offset(p4d, vaddr);</span><br><span class="line">  printk(<span class="string">&quot;pud_val = 0x%lx, pud_index = %lu\n&quot;</span>, pud_val(*pud), pud_index(vaddr));</span><br><span class="line">  <span class="keyword">if</span> (pud_none(*pud)) &#123;</span><br><span class="line">    printk(<span class="string">&quot;not mapped in pud\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pmd = pmd_offset(pud, vaddr);</span><br><span class="line">  printk(<span class="string">&quot;pmd_val = 0x%lx, pmd_index = %lu\n&quot;</span>, pmd_val(*pmd), pmd_index(vaddr));</span><br><span class="line">  <span class="keyword">if</span> (pmd_none(*pmd)) &#123;</span><br><span class="line">    printk(<span class="string">&quot;not mapped in pmd\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pte = pte_offset_kernel(pmd, vaddr);</span><br><span class="line">  printk(<span class="string">&quot;pte_val = 0x%lx, pte_index = %lu\n&quot;</span>, pte_val(*pte), pte_index(vaddr));</span><br><span class="line">  <span class="keyword">if</span> (pte_none(*pte)) &#123;</span><br><span class="line">    printk(<span class="string">&quot;not mapped in pte\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  page_addr = pte_val(*pte) &amp; PAGE_MASK;</span><br><span class="line">  page_offset = vaddr &amp; ~PAGE_MASK;</span><br><span class="line">  paddr = page_addr | page_offset;</span><br><span class="line">  printk(<span class="string">&quot;page_addr = 0x%lx, page_offset = 0x%lx\n&quot;</span>, page_addr, page_offset);</span><br><span class="line">  printk(<span class="string">&quot;vaddr = 0x%lx, paddr = 0x%lx\n&quot;</span>, vaddr, paddr);</span><br><span class="line">  <span class="keyword">return</span> paddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">v2p_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> vaddr = <span class="number">0</span>;</span><br><span class="line">  printk(<span class="string">&quot;vaddr to paddr module is running..\n&quot;</span>);</span><br><span class="line">  get_pgtable_macro();</span><br><span class="line">  printk(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  vaddr = __get_free_page(GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (vaddr == <span class="number">0</span>) &#123;</span><br><span class="line">    printk(<span class="string">&quot;__get_free_page failed..\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sprintf</span>((<span class="type">char</span> *) vaddr, <span class="string">&quot;Hello world from kernel&quot;</span>);</span><br><span class="line">  printk(<span class="string">&quot;get_age_addr = 0x%lx\n&quot;</span>, vaddr);</span><br><span class="line">  vaddr2paddr(vaddr);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">v2p_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;vaddr to paddr module is exiting..\n&quot;</span>);</span><br><span class="line">  free_page(vaddr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(v2p_init);</span><br><span class="line">module_exit(v2p_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>Makefile文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ifneq ($(KERNELRELEASE),)</span><br><span class="line">obj-m := v2p.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PWD := $(shell pwd)</span><br><span class="line">KERNEL_VERSION := $(shell uname -r)</span><br><span class="line">KDIR := /lib/modules/`uname -r`/build</span><br><span class="line">all:</span><br><span class="line">	make -C $(KDIR) M=$(PWD)</span><br><span class="line">clean:</span><br><span class="line">	rm -rf *.o *.ko *.mod.c *.symvers *.c~ *~</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>编译后加载进内核：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">sudo insmod v2p.ko</span></span><br></pre></td></tr></table></figure>

<p>移出内核：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">sudo rmmod v2p</span></span><br></pre></td></tr></table></figure>

<p>查看内核输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">sudo dmesg</span></span><br></pre></td></tr></table></figure>

<p>最后输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 9026.990307] vaddr to paddr module is running..</span><br><span class="line">[ 9026.990311] cr0 = 0x80050033, cr3 = 0x1b60a0000</span><br><span class="line">[ 9026.990312] PGDIR_SHIFT = 39</span><br><span class="line">[ 9026.990313] P4D_SHIFT = 39</span><br><span class="line">[ 9026.990313] PUD_SHIFT = 30</span><br><span class="line">[ 9026.990314] PMD_SHIFT = 21</span><br><span class="line">[ 9026.990314] PAGE_SHIFT = 12</span><br><span class="line">[ 9026.990315] PTRS_PER_PGD = 512</span><br><span class="line">[ 9026.990315] PTRS_PER_P4D = 1</span><br><span class="line">[ 9026.990315] PTRS_PER_PUD = 512</span><br><span class="line">[ 9026.990316] PTRS_PER_PMD = 512</span><br><span class="line">[ 9026.990317] PTRS_PER_PTE = 512</span><br><span class="line">[ 9026.990317] PAGE_MASK = 0xfffffffffffff000</span><br><span class="line"></span><br><span class="line">[ 9026.990318] get_age_addr = 0xffff9f95d83cd000</span><br><span class="line">[ 9026.990319] pgd_val = 0x71001067, pgd_index = 319</span><br><span class="line">[ 9026.990320] p4d_val = 0x71001067, p4d_index = 0</span><br><span class="line">[ 9026.990321] pud_val = 0x1daf88063, pud_index = 87</span><br><span class="line">[ 9026.990322] pmd_val = 0x1d82f5063, pmd_index = 193</span><br><span class="line">[ 9026.990323] pte_val = 0x80000001d83cd163, pte_index = 461</span><br><span class="line">[ 9026.990323] page_addr = 0x80000001d83cd000, page_offset = 0x0</span><br><span class="line">[ 9026.990324] vaddr = 0xffff9f95d83cd000, paddr = 0x80000001d83cd000</span><br><span class="line">[ 9032.670145] vaddr to paddr module is exiting..</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel中的红黑树</title>
    <url>/posts/3bfc9898.html</url>
    <content><![CDATA[<p>红黑树是一种平衡二叉树。</p>
<p>基于5.16内核。</p>
<p>头文件定义：<code>include/linux/rbtree.h</code>、<code>include/linux/rbtree_types.h</code></p>
<h1 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  __rb_parent_color;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_right</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_left</span>;</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">long</span>))));</span><br><span class="line"><span class="comment">/* The alignment might seem pointless, but allegedly CRIS needs it */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中<code>rb_node</code>是节点类型，<code>rb_root</code>表示根节点。</p>
<p><code>rb_node</code>中<code>__rb_parent_color</code>同时定义了父节点和颜色值。由于该该结构体需要大小为<code>sizeof(long)</code>对齐，不管是在32位还是64位上，其地址的最后两个bit永远是0，因此就可以用最后两个bit表示该节点的颜色。例如，指针的地址永远为100、1000、1100、101100等。</p>
<p>所以对父指针和颜色操作如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __rb_parent(pc)    ((struct rb_node *)(pc &amp; ~3))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __rb_color(pc)     ((pc) &amp; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __rb_is_black(pc)  __rb_color(pc)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __rb_is_red(pc)    (!__rb_color(pc))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rb_color(rb)       __rb_color((rb)-&gt;__rb_parent_color)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rb_is_red(rb)      __rb_is_red((rb)-&gt;__rb_parent_color)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rb_is_black(rb)    __rb_is_black((rb)-&gt;__rb_parent_color)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_set_parent</span><span class="params">(<span class="keyword">struct</span> rb_node *rb, <span class="keyword">struct</span> rb_node *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	rb-&gt;__rb_parent_color = rb_color(rb) | (<span class="type">unsigned</span> <span class="type">long</span>)p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">rb_set_parent_color</span><span class="params">(<span class="keyword">struct</span> rb_node *rb,</span></span><br><span class="line"><span class="params">				       <span class="keyword">struct</span> rb_node *p, <span class="type">int</span> color)</span></span><br><span class="line">&#123;</span><br><span class="line">	rb-&gt;__rb_parent_color = (<span class="type">unsigned</span> <span class="type">long</span>)p | color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取节点信息的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化根节点指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_ROOT (struct rb_root) &#123; NULL, &#125;</span></span><br><span class="line"><span class="comment">// container_of 根据偏移获取type结构体</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	rb_entry(ptr, type, member) container_of(ptr, type, member)</span></span><br><span class="line"><span class="comment">// 判断根节点是否为空（树是否为空）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_EMPTY_ROOT(root)  (READ_ONCE((root)-&gt;rb_node) == NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#x27;empty&#x27; nodes are nodes that are known not to be inserted in an rbtree */</span></span><br><span class="line"><span class="comment">// 判断节点是否为空</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_EMPTY_NODE(node)  \</span></span><br><span class="line"><span class="meta">	((node)-&gt;__rb_parent_color == (unsigned long)(node))</span></span><br><span class="line"><span class="comment">// 设置节点为空</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_CLEAR_NODE(node)  \</span></span><br><span class="line"><span class="meta">	((node)-&gt;__rb_parent_color = (unsigned long)(node))</span></span><br></pre></td></tr></table></figure>

<h1 id="红黑树操作"><a href="#红黑树操作" class="headerlink" title="红黑树操作"></a>红黑树操作</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><ol>
<li>将红黑树节点作为一棵二叉查找树，将节点插入</li>
<li>将插入的节点着色为红色</li>
<li>通过一系列旋转或着色等操作，使之重新成为一棵红黑树</li>
</ol>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line">__rb_insert(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root,</span><br><span class="line">	    <span class="type">void</span> (*augment_rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> rb_red_parent(node), *gparent, *tmp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Loop invariant: node is red.</span></span><br><span class="line"><span class="comment">		 * 如果没有父节点，染黑即可</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!parent)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The inserted node is root. Either this is the</span></span><br><span class="line"><span class="comment">			 * first node, or we recursed at Case 1 below and</span></span><br><span class="line"><span class="comment">			 * are no longer violating 4).</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			rb_set_parent_color(node, <span class="literal">NULL</span>, RB_BLACK);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If there is a black parent, we are done.</span></span><br><span class="line"><span class="comment">		 * Otherwise, take some corrective action as,</span></span><br><span class="line"><span class="comment">		 * per 4), we don&#x27;t want a red root or two</span></span><br><span class="line"><span class="comment">		 * consecutive red nodes.</span></span><br><span class="line"><span class="comment">		 * 如果当前节点是黑色，退出</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span>(rb_is_black(parent))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 祖父节点</span></span><br><span class="line">		gparent = rb_red_parent(parent);</span><br><span class="line"></span><br><span class="line">		tmp = gparent-&gt;rb_right;</span><br><span class="line">        <span class="comment">// 如果父节点在左边</span></span><br><span class="line">		<span class="keyword">if</span> (parent != tmp) &#123;	<span class="comment">/* parent == gparent-&gt;rb_left */</span></span><br><span class="line">			<span class="keyword">if</span> (tmp &amp;&amp; rb_is_red(tmp)) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 如果叔叔节点是红色，则将父亲、叔叔节点染成黑色，祖父节点染成红色，将祖父节点设置为当前节点</span></span><br><span class="line"><span class="comment">				 * Case 1 - node&#x27;s uncle is red (color flips).</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 *       G            g</span></span><br><span class="line"><span class="comment">				 *      / \          / \</span></span><br><span class="line"><span class="comment">				 *     p   u  --&gt;   P   U</span></span><br><span class="line"><span class="comment">				 *    /            /</span></span><br><span class="line"><span class="comment">				 *   n            n</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 * However, since g&#x27;s parent might be red, and</span></span><br><span class="line"><span class="comment">				 * 4) does not allow this, we need to recurse</span></span><br><span class="line"><span class="comment">				 * at g.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				rb_set_parent_color(tmp, gparent, RB_BLACK);</span><br><span class="line">				rb_set_parent_color(parent, gparent, RB_BLACK);</span><br><span class="line">				node = gparent;</span><br><span class="line">				parent = rb_parent(node);</span><br><span class="line">				rb_set_parent_color(node, parent, RB_RED);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			tmp = parent-&gt;rb_right;</span><br><span class="line">			<span class="keyword">if</span> (node == tmp) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 如果叔叔节点是黑色，且在右边，将父节点作为支点进行左旋</span></span><br><span class="line"><span class="comment">				 * Case 2 - node&#x27;s uncle is black and node is</span></span><br><span class="line"><span class="comment">				 * the parent&#x27;s right child (left rotate at parent).</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 *      G             G</span></span><br><span class="line"><span class="comment">				 *     / \           / \</span></span><br><span class="line"><span class="comment">				 *    p   U  --&gt;    n   U</span></span><br><span class="line"><span class="comment">				 *     \           /</span></span><br><span class="line"><span class="comment">				 *      n         p</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 * This still leaves us in violation of 4), the</span></span><br><span class="line"><span class="comment">				 * continuation into Case 3 will fix that.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				tmp = node-&gt;rb_left;</span><br><span class="line">				WRITE_ONCE(parent-&gt;rb_right, tmp);</span><br><span class="line">				WRITE_ONCE(node-&gt;rb_left, parent);</span><br><span class="line">				<span class="keyword">if</span> (tmp)</span><br><span class="line">					rb_set_parent_color(tmp, parent,</span><br><span class="line">							    RB_BLACK);</span><br><span class="line">				rb_set_parent_color(parent, node, RB_RED);</span><br><span class="line">				augment_rotate(parent, node);</span><br><span class="line">				parent = node;</span><br><span class="line">				tmp = node-&gt;rb_right;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 叔叔节点是黑色，且在左边，将父节点设置成为黑色，祖父节点设置为红色，以祖父节点为支点右旋</span></span><br><span class="line"><span class="comment">			 * Case 3 - node&#x27;s uncle is black and node is</span></span><br><span class="line"><span class="comment">			 * the parent&#x27;s left child (right rotate at gparent).</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 *        G           P</span></span><br><span class="line"><span class="comment">			 *       / \         / \</span></span><br><span class="line"><span class="comment">			 *      p   U  --&gt;  n   g</span></span><br><span class="line"><span class="comment">			 *     /                 \</span></span><br><span class="line"><span class="comment">			 *    n                   U</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			WRITE_ONCE(gparent-&gt;rb_left, tmp); <span class="comment">/* == parent-&gt;rb_right */</span></span><br><span class="line">			WRITE_ONCE(parent-&gt;rb_right, gparent);</span><br><span class="line">			<span class="keyword">if</span> (tmp)</span><br><span class="line">				rb_set_parent_color(tmp, gparent, RB_BLACK);</span><br><span class="line">			__rb_rotate_set_parents(gparent, parent, root, RB_RED);</span><br><span class="line">			augment_rotate(gparent, parent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tmp = gparent-&gt;rb_left;</span><br><span class="line">			<span class="keyword">if</span> (tmp &amp;&amp; rb_is_red(tmp)) &#123;</span><br><span class="line">				<span class="comment">/* Case 1 - color flips */</span></span><br><span class="line">				rb_set_parent_color(tmp, gparent, RB_BLACK);</span><br><span class="line">				rb_set_parent_color(parent, gparent, RB_BLACK);</span><br><span class="line">				node = gparent;</span><br><span class="line">				parent = rb_parent(node);</span><br><span class="line">				rb_set_parent_color(node, parent, RB_RED);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			tmp = parent-&gt;rb_left;</span><br><span class="line">			<span class="keyword">if</span> (node == tmp) &#123;</span><br><span class="line">				<span class="comment">/* Case 2 - right rotate at parent */</span></span><br><span class="line">				tmp = node-&gt;rb_right;</span><br><span class="line">				WRITE_ONCE(parent-&gt;rb_left, tmp);</span><br><span class="line">				WRITE_ONCE(node-&gt;rb_right, parent);</span><br><span class="line">				<span class="keyword">if</span> (tmp)</span><br><span class="line">					rb_set_parent_color(tmp, parent,</span><br><span class="line">							    RB_BLACK);</span><br><span class="line">				rb_set_parent_color(parent, node, RB_RED);</span><br><span class="line">				augment_rotate(parent, node);</span><br><span class="line">				parent = node;</span><br><span class="line">				tmp = node-&gt;rb_left;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Case 3 - left rotate at gparent */</span></span><br><span class="line">			WRITE_ONCE(gparent-&gt;rb_right, tmp); <span class="comment">/* == parent-&gt;rb_left */</span></span><br><span class="line">			WRITE_ONCE(parent-&gt;rb_left, gparent);</span><br><span class="line">			<span class="keyword">if</span> (tmp)</span><br><span class="line">				rb_set_parent_color(tmp, gparent, RB_BLACK);</span><br><span class="line">			__rb_rotate_set_parents(gparent, parent, root, RB_RED);</span><br><span class="line">			augment_rotate(gparent, parent);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dummy_rotate</span><span class="params">(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rb_insert_color</span><span class="params">(<span class="keyword">struct</span> rb_node *node, <span class="keyword">struct</span> rb_root *root)</span></span><br><span class="line">&#123;</span><br><span class="line">	__rb_insert(node, root, dummy_rotate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>叔叔节点是红色</li>
</ol>
<p>则将父亲、叔叔节点染成黑色，祖父节点染成红色，将祖父节点设置为当前节点，之后对当前节点进行操作</p>
<ol start="2">
<li>叔叔节点是黑色，且在左边</li>
</ol>
<p>将父节点设置成为黑色，祖父节点设置为红色，以祖父节点为支点右旋</p>
<ol start="3">
<li>叔叔节点是黑色，且在左边</li>
</ol>
<p>将父节点设置成为黑色，祖父节点设置为红色，以祖父节点为支点右旋</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ol>
<li><strong>将红黑树当作一颗二叉查找树，将节点删除。</strong></li>
</ol>
<ul>
<li><p>被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。</p>
</li>
<li><p>被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</p>
</li>
<li><p>被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。</p>
</li>
</ul>
<ol start="2">
<li><strong>通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</strong></li>
</ol>
<p>删除代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Inline version for rb_erase() use - we want to be able to inline</span></span><br><span class="line"><span class="comment"> * and eliminate the dummy_rotate callback there</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line">____rb_erase_color(<span class="keyword">struct</span> rb_node *parent, <span class="keyword">struct</span> rb_root *root,</span><br><span class="line">	<span class="type">void</span> (*augment_rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">node</span> =</span> <span class="literal">NULL</span>, *sibling, *tmp1, *tmp2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Loop invariants:</span></span><br><span class="line"><span class="comment">		 * - node is black (or NULL on first iteration)</span></span><br><span class="line"><span class="comment">		 * - node is not the root (parent is not NULL)</span></span><br><span class="line"><span class="comment">		 * - All leaf paths going through parent and node have a</span></span><br><span class="line"><span class="comment">		 *   black node count that is 1 lower than other leaf paths.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		sibling = parent-&gt;rb_right;</span><br><span class="line">		<span class="keyword">if</span> (node != sibling) &#123;	<span class="comment">/* node == parent-&gt;rb_left */</span></span><br><span class="line">			<span class="keyword">if</span> (rb_is_red(sibling)) &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Case 1 - left rotate at parent</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 *     P               S</span></span><br><span class="line"><span class="comment">				 *    / \             / \</span></span><br><span class="line"><span class="comment">				 *   N   s    --&gt;    p   Sr</span></span><br><span class="line"><span class="comment">				 *      / \         / \</span></span><br><span class="line"><span class="comment">				 *     Sl  Sr      N   Sl</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				tmp1 = sibling-&gt;rb_left;</span><br><span class="line">				WRITE_ONCE(parent-&gt;rb_right, tmp1);</span><br><span class="line">				WRITE_ONCE(sibling-&gt;rb_left, parent);</span><br><span class="line">				rb_set_parent_color(tmp1, parent, RB_BLACK);</span><br><span class="line">				__rb_rotate_set_parents(parent, sibling, root,</span><br><span class="line">							RB_RED);</span><br><span class="line">				augment_rotate(parent, sibling);</span><br><span class="line">				sibling = tmp1;</span><br><span class="line">			&#125;</span><br><span class="line">			tmp1 = sibling-&gt;rb_right;</span><br><span class="line">			<span class="keyword">if</span> (!tmp1 || rb_is_black(tmp1)) &#123;</span><br><span class="line">				tmp2 = sibling-&gt;rb_left;</span><br><span class="line">				<span class="keyword">if</span> (!tmp2 || rb_is_black(tmp2)) &#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * Case 2 - sibling color flip</span></span><br><span class="line"><span class="comment">					 * (p could be either color here)</span></span><br><span class="line"><span class="comment">					 *</span></span><br><span class="line"><span class="comment">					 *    (p)           (p)</span></span><br><span class="line"><span class="comment">					 *    / \           / \</span></span><br><span class="line"><span class="comment">					 *   N   S    --&gt;  N   s</span></span><br><span class="line"><span class="comment">					 *      / \           / \</span></span><br><span class="line"><span class="comment">					 *     Sl  Sr        Sl  Sr</span></span><br><span class="line"><span class="comment">					 *</span></span><br><span class="line"><span class="comment">					 * This leaves us violating 5) which</span></span><br><span class="line"><span class="comment">					 * can be fixed by flipping p to black</span></span><br><span class="line"><span class="comment">					 * if it was red, or by recursing at p.</span></span><br><span class="line"><span class="comment">					 * p is red when coming from Case 1.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">					rb_set_parent_color(sibling, parent,</span><br><span class="line">							    RB_RED);</span><br><span class="line">					<span class="keyword">if</span> (rb_is_red(parent))</span><br><span class="line">						rb_set_black(parent);</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						node = parent;</span><br><span class="line">						parent = rb_parent(node);</span><br><span class="line">						<span class="keyword">if</span> (parent)</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * Case 3 - right rotate at sibling</span></span><br><span class="line"><span class="comment">				 * (p could be either color here)</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 *   (p)           (p)</span></span><br><span class="line"><span class="comment">				 *   / \           / \</span></span><br><span class="line"><span class="comment">				 *  N   S    --&gt;  N   sl</span></span><br><span class="line"><span class="comment">				 *     / \             \</span></span><br><span class="line"><span class="comment">				 *    sl  Sr            S</span></span><br><span class="line"><span class="comment">				 *                       \</span></span><br><span class="line"><span class="comment">				 *                        Sr</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 * Note: p might be red, and then both</span></span><br><span class="line"><span class="comment">				 * p and sl are red after rotation(which</span></span><br><span class="line"><span class="comment">				 * breaks property 4). This is fixed in</span></span><br><span class="line"><span class="comment">				 * Case 4 (in __rb_rotate_set_parents()</span></span><br><span class="line"><span class="comment">				 *         which set sl the color of p</span></span><br><span class="line"><span class="comment">				 *         and set p RB_BLACK)</span></span><br><span class="line"><span class="comment">				 *</span></span><br><span class="line"><span class="comment">				 *   (p)            (sl)</span></span><br><span class="line"><span class="comment">				 *   / \            /  \</span></span><br><span class="line"><span class="comment">				 *  N   sl   --&gt;   P    S</span></span><br><span class="line"><span class="comment">				 *       \        /      \</span></span><br><span class="line"><span class="comment">				 *        S      N        Sr</span></span><br><span class="line"><span class="comment">				 *         \</span></span><br><span class="line"><span class="comment">				 *          Sr</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				tmp1 = tmp2-&gt;rb_right;</span><br><span class="line">				WRITE_ONCE(sibling-&gt;rb_left, tmp1);</span><br><span class="line">				WRITE_ONCE(tmp2-&gt;rb_right, sibling);</span><br><span class="line">				WRITE_ONCE(parent-&gt;rb_right, tmp2);</span><br><span class="line">				<span class="keyword">if</span> (tmp1)</span><br><span class="line">					rb_set_parent_color(tmp1, sibling,</span><br><span class="line">							    RB_BLACK);</span><br><span class="line">				augment_rotate(sibling, tmp2);</span><br><span class="line">				tmp1 = sibling;</span><br><span class="line">				sibling = tmp2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Case 4 - left rotate at parent + color flips</span></span><br><span class="line"><span class="comment">			 * (p and sl could be either color here.</span></span><br><span class="line"><span class="comment">			 *  After rotation, p becomes black, s acquires</span></span><br><span class="line"><span class="comment">			 *  p&#x27;s color, and sl keeps its color)</span></span><br><span class="line"><span class="comment">			 *</span></span><br><span class="line"><span class="comment">			 *      (p)             (s)</span></span><br><span class="line"><span class="comment">			 *      / \             / \</span></span><br><span class="line"><span class="comment">			 *     N   S     --&gt;   P   Sr</span></span><br><span class="line"><span class="comment">			 *        / \         / \</span></span><br><span class="line"><span class="comment">			 *      (sl) sr      N  (sl)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			tmp2 = sibling-&gt;rb_left;</span><br><span class="line">			WRITE_ONCE(parent-&gt;rb_right, tmp2);</span><br><span class="line">			WRITE_ONCE(sibling-&gt;rb_left, parent);</span><br><span class="line">			rb_set_parent_color(tmp1, sibling, RB_BLACK);</span><br><span class="line">			<span class="keyword">if</span> (tmp2)</span><br><span class="line">				rb_set_parent(tmp2, parent);</span><br><span class="line">			__rb_rotate_set_parents(parent, sibling, root,</span><br><span class="line">						RB_BLACK);</span><br><span class="line">			augment_rotate(parent, sibling);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sibling = parent-&gt;rb_left;</span><br><span class="line">			<span class="keyword">if</span> (rb_is_red(sibling)) &#123;</span><br><span class="line">				<span class="comment">/* Case 1 - right rotate at parent */</span></span><br><span class="line">				tmp1 = sibling-&gt;rb_right;</span><br><span class="line">				WRITE_ONCE(parent-&gt;rb_left, tmp1);</span><br><span class="line">				WRITE_ONCE(sibling-&gt;rb_right, parent);</span><br><span class="line">				rb_set_parent_color(tmp1, parent, RB_BLACK);</span><br><span class="line">				__rb_rotate_set_parents(parent, sibling, root,</span><br><span class="line">							RB_RED);</span><br><span class="line">				augment_rotate(parent, sibling);</span><br><span class="line">				sibling = tmp1;</span><br><span class="line">			&#125;</span><br><span class="line">			tmp1 = sibling-&gt;rb_left;</span><br><span class="line">			<span class="keyword">if</span> (!tmp1 || rb_is_black(tmp1)) &#123;</span><br><span class="line">				tmp2 = sibling-&gt;rb_right;</span><br><span class="line">				<span class="keyword">if</span> (!tmp2 || rb_is_black(tmp2)) &#123;</span><br><span class="line">					<span class="comment">/* Case 2 - sibling color flip */</span></span><br><span class="line">					rb_set_parent_color(sibling, parent,</span><br><span class="line">							    RB_RED);</span><br><span class="line">					<span class="keyword">if</span> (rb_is_red(parent))</span><br><span class="line">						rb_set_black(parent);</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						node = parent;</span><br><span class="line">						parent = rb_parent(node);</span><br><span class="line">						<span class="keyword">if</span> (parent)</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/* Case 3 - left rotate at sibling */</span></span><br><span class="line">				tmp1 = tmp2-&gt;rb_left;</span><br><span class="line">				WRITE_ONCE(sibling-&gt;rb_right, tmp1);</span><br><span class="line">				WRITE_ONCE(tmp2-&gt;rb_left, sibling);</span><br><span class="line">				WRITE_ONCE(parent-&gt;rb_left, tmp2);</span><br><span class="line">				<span class="keyword">if</span> (tmp1)</span><br><span class="line">					rb_set_parent_color(tmp1, sibling,</span><br><span class="line">							    RB_BLACK);</span><br><span class="line">				augment_rotate(sibling, tmp2);</span><br><span class="line">				tmp1 = sibling;</span><br><span class="line">				sibling = tmp2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* Case 4 - right rotate at parent + color flips */</span></span><br><span class="line">			tmp2 = sibling-&gt;rb_right;</span><br><span class="line">			WRITE_ONCE(parent-&gt;rb_left, tmp2);</span><br><span class="line">			WRITE_ONCE(sibling-&gt;rb_right, parent);</span><br><span class="line">			rb_set_parent_color(tmp1, sibling, RB_BLACK);</span><br><span class="line">			<span class="keyword">if</span> (tmp2)</span><br><span class="line">				rb_set_parent(tmp2, parent);</span><br><span class="line">			__rb_rotate_set_parents(parent, sibling, root,</span><br><span class="line">						RB_BLACK);</span><br><span class="line">			augment_rotate(parent, sibling);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-inline version for rb_erase_augmented() use */</span></span><br><span class="line"><span class="type">void</span> __rb_erase_color(<span class="keyword">struct</span> rb_node *parent, <span class="keyword">struct</span> rb_root *root,</span><br><span class="line">	<span class="type">void</span> (*augment_rotate)(<span class="keyword">struct</span> rb_node *old, <span class="keyword">struct</span> rb_node *new))</span><br><span class="line">&#123;</span><br><span class="line">	____rb_erase_color(parent, root, augment_rotate);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__rb_erase_color);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel进程描述符task_struct结构</title>
    <url>/posts/7173398c.html</url>
    <content><![CDATA[<h1 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h1><p><code>task_struct</code>结构体定义在<code>include/linux/sched.h</code></p>
<h2 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span>			__state;</span><br><span class="line"><span class="type">int</span>				exit_state;</span><br><span class="line"><span class="type">int</span>				exit_code;</span><br><span class="line"><span class="type">int</span>				exit_signal;</span><br></pre></td></tr></table></figure>

<p><code>__state</code>成员可能的取值如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Task state bitmask. NOTE! These bits are also</span></span><br><span class="line"><span class="comment"> * encoded in fs/proc/array.c: get_task_state().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We have two separate sets of flags: task-&gt;state</span></span><br><span class="line"><span class="comment"> * is about runnability, while task-&gt;exit_state are</span></span><br><span class="line"><span class="comment"> * about the task exiting. Confusing, but this way</span></span><br><span class="line"><span class="comment"> * modifying one set can&#x27;t modify the other one by</span></span><br><span class="line"><span class="comment"> * mistake.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING			0x0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE		0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE		0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_STOPPED			0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_TRACED			0x0008</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;exit_state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_DEAD			0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_ZOMBIE			0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_TRACE			(EXIT_ZOMBIE | EXIT_DEAD)</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;state again: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_PARKED			0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_DEAD			0x0080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKEKILL			0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKING			0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NOLOAD			0x0400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NEW			0x0800</span></span><br><span class="line"><span class="comment">/* RT specific auxilliary flag to mark RT lock waiters */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RTLOCK_WAIT		0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STATE_MAX			0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of set_current_state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_KILLABLE			(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STOPPED			(TASK_WAKEKILL | __TASK_STOPPED)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_TRACED			(TASK_WAKEKILL | __TASK_TRACED)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_IDLE			(TASK_UNINTERRUPTIBLE | TASK_NOLOAD)</span></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of wake_up(): */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NORMAL			(TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"><span class="comment">/* get_task_state(): */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_REPORT			(TASK_RUNNING | TASK_INTERRUPTIBLE | \</span></span><br><span class="line"><span class="meta">					 TASK_UNINTERRUPTIBLE | __TASK_STOPPED | \</span></span><br><span class="line"><span class="meta">					 __TASK_TRACED | EXIT_DEAD | EXIT_ZOMBIE | \</span></span><br><span class="line"><span class="meta">					 TASK_PARKED)</span></span><br></pre></td></tr></table></figure>

<p><code>__state</code>可以取值5个互斥状态：</p>
<ul>
<li><code>TASK_RUNNING</code>：标志进程要么正在执行，要么正准备执行（已经就绪），正在等待CPU时间片。</li>
<li><code>TASK_INTERRUPTIBLE</code>：进程因为等待一些条件而被挂起（阻塞）而所处的状态。</li>
<li><code>TASK_UNINTERRUPTIBLE</code>：与<code>TASK_INTERRUPTIBLE</code>类似，但是不能通过接受一个信号或者一个外部中断来唤醒。只有等待的资源可用时，才能被唤醒。</li>
<li><code>__TASK_STOPPED</code>：停止执行，当进程接收到<code>SIGSTOP</code>、<code>SIGTIN</code>、<code>SIGTTIN</code>或<code>SIGOUT</code>信号之后就会进入该状态。</li>
<li><code>__TASK_TRACED</code>：表示进程被debug等进程监视，进程执行被调试所停止，当一个进程被另外的进程所监视，每一个信号都会让进程进入该状态。</li>
</ul>
<p><code>exit_state</code>在进程终止的时候可以达到这两种状态：</p>
<ul>
<li><code>EXIT_ZOMBIE</code>：进程的执行被终止，但是父进程还没有使用<code>wait()</code>等系统调用来获取它的终止信息，此进程成为僵尸进程。</li>
<li><code>EXIT_DEAD</code>：进程的最终状态。</li>
</ul>
<p><strong>将进程置为睡眠状态</strong></p>
<p>普通方法是将进程状态设置为<code>TASK_INTERRUPTIBLE</code> 或 <code>TASK_UNINTERRUPTIBLE</code>，并调用调度程序的<code>schedule()</code> 函数，这样会将进程中CPU运行队列中移除：</p>
<ul>
<li>如果进程出于可中断模式的睡眠状态（通过将其状态设置为<code>TASK_INTERRUPTIBLE</code>），那么可以通过显式唤醒呼叫或需要处理的信号来唤醒它。</li>
<li>如果进程出于非可中断模式的睡眠状态（通过将其状态设置为<code>TASK_UNINTERRUPTIBLE</code>），那么只能通过显式的呼叫唤醒。除非万不得已，不然不建议将进程置为不可中断模式（比如在设备IO期间，处理信号非常困难时）。</li>
</ul>
<p>新的睡眠方法：</p>
<ul>
<li><code>TASK_KILLABLE</code>：当进程处于这种可以终止的新睡眠状态中，它的运行原理类似于 <code>TASK_UNINTERRUPTIBLE</code>，只不过可以响应致命信号。</li>
</ul>
<p>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKEKILL			0x0100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of set_current_state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_KILLABLE			(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STOPPED			(TASK_WAKEKILL | __TASK_STOPPED)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_TRACED			(TASK_WAKEKILL | __TASK_TRACED)</span></span><br></pre></td></tr></table></figure>

<p>换句话说，<code>TASK_UNINTERRUPTIBLE + TASK_WAKEKILL = TASK_KILLABLE</code>。</p>
<p>而<code>TASK_WAKEKILL</code> 用于在接收到致命信号时唤醒进程</p>
<p>新的睡眠状态允许 <code>TASK_UNINTERRUPTIBLE</code> 响应致命信号</p>
<p><img src="https://img.ansore.de/2022/05/01/626e2787b349a.gif" alt="进程状态转换图"></p>
<h2 id="任务ID"><a href="#任务ID" class="headerlink" title="任务ID"></a>任务ID</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span>				pid;</span><br><span class="line"><span class="type">pid_t</span>				tgid;</span><br></pre></td></tr></table></figure>

<p>Unix系统通过pid来标识进程，linux把不同的pid与系统中每个进程或轻量级线程关联，而unix程序员希望同一组线程具有共同的pid，遵照这个标准linux引入线程组的概念。一个线程组所有线程与领头线程具有相同的pid，存入tgid字段，getpid()返回当前进程的tgid值而不是pid的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PID_MAX_DEFAULT (CONFIG_BASE_SMALL ? 0x1000 : 0x8000)</span></span><br></pre></td></tr></table></figure>

<p>在<code>CONFIG_BASE_SMALL</code>配置为0的情况下，PID的取值范围是0到32767，即系统中的进程数最大为32768个。</p>
<h2 id="任务标记"><a href="#任务标记" class="headerlink" title="任务标记"></a>任务标记</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Per task flags (PF_*), defined further below: */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>			flags;</span><br></pre></td></tr></table></figure>

<p>反应进程状态信息，但不是运行状态，用于内核标识进程当前状态。</p>
<p><code>flags</code>可能取值如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Per process flags</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_VCPU			0x00000001	<span class="comment">/* I&#x27;m a virtual CPU */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_IDLE			0x00000002	<span class="comment">/* I am an IDLE thread */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_EXITING		0x00000004	<span class="comment">/* Getting shut down */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_POSTCOREDUMP		0x00000008	<span class="comment">/* Coredumps should ignore this task */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_IO_WORKER		0x00000010	<span class="comment">/* Task is an IO worker */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_WQ_WORKER		0x00000020	<span class="comment">/* I&#x27;m a workqueue worker */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_FORKNOEXEC		0x00000040	<span class="comment">/* Forked but didn&#x27;t exec */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MCE_PROCESS		0x00000080      <span class="comment">/* Process policy on mce errors */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_SUPERPRIV		0x00000100	<span class="comment">/* Used super-user privileges */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_DUMPCORE		0x00000200	<span class="comment">/* Dumped core */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_SIGNALED		0x00000400	<span class="comment">/* Killed by a signal */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MEMALLOC		0x00000800	<span class="comment">/* Allocating memory */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_NPROC_EXCEEDED	0x00001000	<span class="comment">/* set_user() noticed that RLIMIT_NPROC was exceeded */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_USED_MATH		0x00002000	<span class="comment">/* If unset the fpu must be initialized before use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_NOFREEZE		0x00008000	<span class="comment">/* This thread should not be frozen */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_FROZEN		0x00010000	<span class="comment">/* Frozen for system suspend */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_KSWAPD		0x00020000	<span class="comment">/* I am kswapd */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MEMALLOC_NOFS	0x00040000	<span class="comment">/* All allocation requests will inherit GFP_NOFS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MEMALLOC_NOIO	0x00080000	<span class="comment">/* All allocation requests will inherit GFP_NOIO */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_LOCAL_THROTTLE	0x00100000	<span class="comment">/* Throttle writes only against the bdi I write to,</span></span></span><br><span class="line"><span class="comment"><span class="meta">						 * I am cleaning dirty pages from some other bdi. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_KTHREAD		0x00200000	<span class="comment">/* I am a kernel thread */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_RANDOMIZE		0x00400000	<span class="comment">/* Randomize virtual address space */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_SWAPWRITE		0x00800000	<span class="comment">/* Allowed to write to swap */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_NO_SETAFFINITY	0x04000000	<span class="comment">/* Userland is not allowed to meddle with cpus_mask */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MCE_EARLY		0x08000000      <span class="comment">/* Early kill for mce process policy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MEMALLOC_PIN		0x10000000	<span class="comment">/* Allocation context constrained to zones which allow long term pinning. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_FREEZER_SKIP		0x40000000	<span class="comment">/* Freezer should not count it as freezable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_SUSPEND_TASK		0x80000000      <span class="comment">/* This thread called freeze_processes() and should not be frozen */</span></span></span><br></pre></td></tr></table></figure>

<p>常用状态：</p>
<ul>
<li><code>PF_FORKNOEXEC</code>：进程刚被创建，但还没有执行</li>
<li><code>PF_SUPERPRIV</code>：进程拥有超级用户特权</li>
<li><code>PF_SIGNALED</code>：进程被信号杀出</li>
<li><code>PF_EXITING</code>：进程开始关闭</li>
</ul>
<h2 id="任务亲属关系"><a href="#任务亲属关系" class="headerlink" title="任务亲属关系"></a>任务亲属关系</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Pointers to the (original) parent process, youngest child, younger sibling,</span></span><br><span class="line"><span class="comment">* older sibling, respectively.  (p-&gt;father can be replaced with</span></span><br><span class="line"><span class="comment">* p-&gt;real_parent-&gt;pid)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Real parent process: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>	*<span class="title">real_parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Recipient of SIGCHLD, wait4() reports: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>	*<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Children/sibling form the list of natural children:</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">children</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">sibling</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">group_leader</span>;</span></span><br></pre></td></tr></table></figure>

<p>在Linux系统中，所有进程之间都有着直接或间接地联系，每个进程都有其父进程，也可能有零个或多个子进程。拥有同一父进程的所有进程具有兄弟关系。</p>
<ul>
<li><code>real_parent</code>：指向其父进程，如果创建它的父进程不再存在，则指向PID为1的init进程</li>
<li><code>parent</code>：指向其父进程，当它终止时，必须向它的父进程发送信号。它的值通常与real_parent相同</li>
<li><code>children</code>：表示链表的头部，链表中的所有元素都是它的子进程</li>
<li><code>sibling</code>：用于把当前进程插入到兄弟链表中</li>
<li><code>group_leader</code>：指向其所在进程组的领头进程</li>
</ul>
<h2 id="ptrace系统调用"><a href="#ptrace系统调用" class="headerlink" title="ptrace系统调用"></a>ptrace系统调用</h2><p><code>ptrace</code>主要用于实现断点调试。一个被跟踪的进程运行中，直到发生一个信号。则进程被中止，并且通知其父进程。在进程中止的状态下，进程的内存空间可以被读写。父进程还可以使子进程继续执行，并选择是否是否忽略引起中止的信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span>			ptrace;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* &#x27;ptraced&#x27; is the list of tasks this task is using ptrace() on.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This includes both natural children and PTRACE_ATTACH targets.</span></span><br><span class="line"><span class="comment">* &#x27;ptrace_entry&#x27; is this task&#x27;s link on the p-&gt;parent-&gt;ptraced list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">ptraced</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">ptrace_entry</span>;</span></span><br><span class="line"><span class="comment">/* Ptrace state: */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>			ptrace_message;</span><br><span class="line"><span class="type">kernel_siginfo_t</span>		*last_siginfo;</span><br></pre></td></tr></table></figure>

<p>成员<code>ptrace</code>被设置为0时表示不需要被跟踪，可能取值如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Ptrace flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The owner ship rules for task-&gt;ptrace which holds the ptrace</span></span><br><span class="line"><span class="comment"> * flags is simple.  When a task is running it owns it&#x27;s task-&gt;ptrace</span></span><br><span class="line"><span class="comment"> * flags.  When the a task is stopped the ptracer owns task-&gt;ptrace.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SEIZED	0x00010000	<span class="comment">/* SEIZE used, enable new behavior */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_PTRACED	0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_DTRACE	0x00000002	<span class="comment">/* delayed trace (used on m68k, i386) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_OPT_FLAG_SHIFT	3</span></span><br><span class="line"><span class="comment">/* PT_TRACE_* event enable flags */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_EVENT_FLAG(event)	(1 &lt;&lt; (PT_OPT_FLAG_SHIFT + (event)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TRACESYSGOOD		PT_EVENT_FLAG(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TRACE_FORK		PT_EVENT_FLAG(PTRACE_EVENT_FORK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TRACE_VFORK		PT_EVENT_FLAG(PTRACE_EVENT_VFORK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TRACE_CLONE		PT_EVENT_FLAG(PTRACE_EVENT_CLONE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TRACE_EXEC		PT_EVENT_FLAG(PTRACE_EVENT_EXEC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TRACE_VFORK_DONE	PT_EVENT_FLAG(PTRACE_EVENT_VFORK_DONE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TRACE_EXIT		PT_EVENT_FLAG(PTRACE_EVENT_EXIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_TRACE_SECCOMP	PT_EVENT_FLAG(PTRACE_EVENT_SECCOMP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_EXITKILL		(PTRACE_O_EXITKILL &lt;&lt; PT_OPT_FLAG_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SUSPEND_SECCOMP	(PTRACE_O_SUSPEND_SECCOMP &lt;&lt; PT_OPT_FLAG_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* single stepping state bits (used on ARM and PA-RISC) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SINGLESTEP_BIT	31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_SINGLESTEP		(1&lt;&lt;PT_SINGLESTEP_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_BLOCKSTEP_BIT	30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_BLOCKSTEP		(1&lt;&lt;PT_BLOCKSTEP_BIT)</span></span><br></pre></td></tr></table></figure>

<h2 id="Performance-Event"><a href="#Performance-Event" class="headerlink" title="Performance Event"></a>Performance Event</h2><p>Performance Event是一款随 Linux 内核代码一同发布和维护的性能诊断工具。这些成员用于帮助PerformanceEvent分析进程的性能问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PERF_EVENTS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">perf_event_context</span>	*<span class="title">perf_event_ctxp</span>[<span class="title">perf_nr_task_contexts</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>			<span class="title">perf_event_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">perf_event_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>				prio;</span><br><span class="line"><span class="type">int</span>				static_prio;</span><br><span class="line"><span class="type">int</span>				normal_prio;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>			rt_priority;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>prio</code>：动态优先级</li>
<li><code>static_prio</code>：静态优先级，可以通过nice系统的调用来修改</li>
<li><code>rt_priority</code>：实时优先级</li>
<li><code>normal_prio</code>：取决于静态优先级和调度策略</li>
</ul>
<p>实时优先级的取值范围是<code>0-MAX_RT_PRIO-1</code>(0-99)，普通进程的静态优先级范围是从<code>MAX_RT_PRIO</code>到<code>MAX_PRIO-1</code>（100-192）。值越大静态优先级越低。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Priority of a process goes from 0..MAX_PRIO-1, valid RT</span></span><br><span class="line"><span class="comment"> * priority is 0..MAX_RT_PRIO-1, and SCHED_NORMAL/SCHED_BATCH</span></span><br><span class="line"><span class="comment"> * tasks are in the range MAX_RT_PRIO..MAX_PRIO-1. Priority</span></span><br><span class="line"><span class="comment"> * values are inverted: lower p-&gt;prio value means higher priority.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_RT_PRIO		100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PRIO		(MAX_RT_PRIO + NICE_WIDTH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_PRIO		(MAX_RT_PRIO + NICE_WIDTH / 2)</span></span><br></pre></td></tr></table></figure>

<h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span>			policy;</span><br><span class="line"><span class="type">int</span>				nr_cpus_allowed;</span><br><span class="line"><span class="type">const</span> <span class="type">cpumask_t</span>			*cpus_ptr;</span><br><span class="line"><span class="type">cpumask_t</span>			*user_cpus_ptr;</span><br><span class="line"><span class="type">cpumask_t</span>			cpus_mask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>		<span class="title">se</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span>		<span class="title">rt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span>		<span class="title">dl</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span>	*<span class="title">sched_class</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>nr_cpus_allowed</code>：允许使用的CPU数量</li>
<li><code>policy</code>：调度策略</li>
<li><code>sched_class</code>：调度类</li>
<li><code>se</code>：普通进程的调用实体，每个进程都有其中之一的实体</li>
<li><code>rt</code>：实时进程的调用实体，每个进程都有其中之一的实体</li>
</ul>
<p>policy表示进程调度策略，目前只有以下五种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Scheduling policies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_NORMAL		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_FIFO		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_RR		2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_BATCH		3</span></span><br><span class="line"><span class="comment">/* SCHED_ISO: reserved but not implemented yet */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_IDLE		5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCHED_DEADLINE		6</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>SCHED_NORMAL</code>：用于普通进程，通过CFS调度器实现。<code>SCHED_BATCH</code>用于非交互的处理器消耗性进程。<code>SCHED_BATCH</code>是在系统负载很低时使用。</li>
<li><code>SCHED_BATCH</code>：CFS调度器。<code>SCHED_NORMAL</code>普通进程策略的分化版本。采用分时策略，根据动态优先级（可用<code>nice()</code>设置），分配CPU运算资源。这类进程比上述两类优先级低，在有实时进程存在时，实时进程优先调度。但针对吞吐量优化。</li>
<li><code>SCHED_IDLE</code>：CFS调度器。优先级最低，在系统空闲时才跑这类进程。</li>
<li><code>SCHED_FIFO</code>：RT调度器。先入先出调度算法（实时调度策略），相同优先级的任务先到先服务，高优先级的任务可以抢占低优先级的任务。</li>
<li><code>SCHED_RR</code>：RT调度器。轮流调度算法（实时调度），相同优先级的任务先到先服务，高优先级的任务可以抢占低优先级任务。</li>
<li><code>SCHED_DEADLINE</code>：新支持的实时进程调度策略，针对突发型计算，且对延迟和完成时间高敏感度的任务。基于Earliest Deadline First (EDF) 调度算法。</li>
</ul>
<h3 id="调度类"><a href="#调度类" class="headerlink" title="调度类"></a>调度类</h3><p>sched_class结构体表示调度类，目前内核中有实现以下四种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">stop_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">dl_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">rt_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">fair_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">idle_sched_class</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>idle_sched_class</code>：每个cup的第一个pid&#x3D;0线程：swapper，是一个静态线程。调度类属于：idel_sched_class，所以在ps里面是看不到的。一般运行在开机过程和cpu异常的时候做dump</li>
<li><code>stop_sched_class</code>：优先级最高的线程，会中断所有其他线程，且不会被其他任务打断。作用：1.发生在<code>cpu_stop_cpu_callback</code> 进行cpu之间任务<code>migration</code>；2.<code>HOTPLUG_CPU</code>的情况下关闭任务。</li>
<li><code>rt_sched_class</code>：RT，作用：实时线程</li>
<li><code>fair_sched_class</code>：CFS（公平），作用：一般常规线程</li>
</ul>
<p>目前系統中,Scheduling Class的优先级顺序为StopTask &gt; RealTime &gt; Fair &gt; IdleTask</p>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>		*<span class="title">mm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>		*<span class="title">active_mm</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SPLIT_RSS_COUNTING</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_rss_stat</span>		<span class="title">rss_stat</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT_BRK</span></span><br><span class="line">	<span class="type">unsigned</span>			brk_randomized:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>mm</code>：进程所拥有的用户空间内存描述符，内核线程无的mm为NULL</li>
<li><code>active_mm</code>：active_mm指向进程运行时所使用的内存描述符，相对于普通进程而言，用户mm指针变量相同。但是内核线程kernel thread没有进程地址空间，所以mm域为NULL。但是内核空间必须知道用户空间包含什么，因此active_mm被初始化为每一个运行进程的active_mm值。</li>
<li><code>rss_stat</code>：用来记录缓冲信息</li>
<li><code>brk_randomized</code>：用来确定对随机堆内存的探测</li>
</ul>
<p>如果当前内核线程被调度之前运行的也是另外一个内核线程时候，那么其mm和avtive_mm都是NULL</p>
<h2 id="判断标志"><a href="#判断标志" class="headerlink" title="判断标志"></a>判断标志</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>				exit_state;</span><br><span class="line"><span class="type">int</span>				exit_code;</span><br><span class="line"><span class="type">int</span>				exit_signal;</span><br><span class="line"><span class="comment">/* The signal sent when the parent dies: */</span></span><br><span class="line"><span class="type">int</span>				pdeath_signal;</span><br><span class="line"><span class="comment">/* JOBCTL_*, siglock protected: */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>			jobctl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used for emulating ABI behavior of previous Linux versions: */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>			personality;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scheduler bits, serialized by scheduler locks: */</span></span><br><span class="line"><span class="type">unsigned</span>			sched_reset_on_fork:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span>			sched_contributes_to_load:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span>			sched_migrated:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PSI</span></span><br><span class="line">	<span class="type">unsigned</span>			sched_psi_wake_requeue:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Force alignment to the next boundary: */</span></span><br><span class="line"><span class="type">unsigned</span>			:<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unserialized, strictly &#x27;current&#x27; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This field must not be in the scheduler word above due to wakelist</span></span><br><span class="line"><span class="comment"> * queueing no longer being serialized by p-&gt;on_cpu. However:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * p-&gt;XXX = X;			ttwu()</span></span><br><span class="line"><span class="comment"> * schedule()			  if (p-&gt;on_rq &amp;&amp; ..) // false</span></span><br><span class="line"><span class="comment"> *   smp_mb__after_spinlock();	  if (smp_load_acquire(&amp;p-&gt;on_cpu) &amp;&amp; //true</span></span><br><span class="line"><span class="comment"> *   deactivate_task()		      ttwu_queue_wakelist())</span></span><br><span class="line"><span class="comment"> *     p-&gt;on_rq = 0;			p-&gt;sched_remote_wakeup = Y;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * guarantees all stores of &#x27;current&#x27; are visible before</span></span><br><span class="line"><span class="comment"> * -&gt;sched_remote_wakeup gets used, so it can be in this word.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span>			sched_remote_wakeup:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bit to tell LSMs we&#x27;re in execve(): */</span></span><br><span class="line"><span class="type">unsigned</span>			in_execve:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span>			in_iowait:<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>exit_code</code>：用于设置进程的终止代号，这个值要么是<code>_exit()</code>或<code>exit_group()</code>系统调用参数（正常终止），要么是由内核提供的一个错误代号（异常终止）。</li>
<li><code>exit_signal</code>：被置为-1时表示是某个线程组中的一员。只有当线程组的最后一个成员终止时，才会产生一个信号，以通知线程组的领头进程的父进程。</li>
<li><code>pdeath_signal</code>：用于判断父进程终止时发送信号。</li>
<li><code>personality</code>：用于处理不同的ABI</li>
<li><code>in_execve</code>：用于通知LSM是否被do_execve()函数所调用。</li>
<li><code>in_iowait</code>：用于判断是否进行iowait计数</li>
<li><code>sched_reset_on_fork</code>：用于判断是否恢复默认的优先级或调度策略</li>
</ul>
<h2 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u64				utime;</span><br><span class="line">u64				stime;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_HAS_SCALED_CPUTIME</span></span><br><span class="line">	u64				utimescaled;</span><br><span class="line">	u64				stimescaled;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">u64				gtime;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prev_cputime</span>		<span class="title">prev_cputime</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_VIRT_CPU_ACCOUNTING_GEN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vtime</span>			<span class="title">vtime</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Context switch counts: */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>			nvcsw;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>			nivcsw;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Monotonic time in nsecs: */</span></span><br><span class="line">u64				start_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Boot based time in nsecs: */</span></span><br><span class="line">u64				start_boottime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MM fault and swap info: this can arguably be seen as either mm-specific or thread-specific: */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>			min_flt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>			maj_flt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * executable name, excluding path.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment"> * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment"> * - lock it with task_lock()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span>				comm[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span>		*<span class="title">nameidata</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span>			<span class="title">sysvsem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span>			<span class="title">sysvshm</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DETECT_HUNG_TASK</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			last_switch_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			last_switch_time;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>utime/stime</code>：用于记录进程在用户态&#x2F;内核态下所经过的节拍数（定时器）</li>
<li><code>utimescaled/stimescaled</code>：用于记录进程在用户态&#x2F;内核态的运行时间，但它们以处理器的频率为刻度</li>
<li><code>gtime</code>：以节拍计数的虚拟机运行时间（guest time）</li>
<li><code>nvcsw/nivcsw</code>：是自愿（voluntary）&#x2F;非自愿（involuntary）上下文切换计数</li>
<li><code>last_switch_count</code>：nvcsw和nivcsw的总和</li>
<li><code>start_time/start_boottime</code>：进程创建时间，<code>start_boottime</code>还包含了进程睡眠时间，常用于<code>/proc/pid/stat</code></li>
<li><code>utime/stime</code>：</li>
</ul>
<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Signal handlers: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span>		*<span class="title">signal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> __<span class="title">rcu</span>		*<span class="title">sighand</span>;</span></span><br><span class="line"><span class="type">sigset_t</span>			blocked;</span><br><span class="line"><span class="type">sigset_t</span>			real_blocked;</span><br><span class="line"><span class="comment">/* Restored if set_restore_sigmask() was used: */</span></span><br><span class="line"><span class="type">sigset_t</span>			saved_sigmask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span>		<span class="title">pending</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>			sas_ss_sp;</span><br><span class="line"><span class="type">size_t</span>				sas_ss_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>			sas_ss_flags;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>signal</code>：指向进程的信号描述符</li>
<li><code>sighand</code>：指向进程的信号处理程序描述符</li>
<li><code>blocked</code>：表示被阻塞信号的掩码，<code>real_blocked</code>表示临时掩码</li>
<li><code>pending</code>：存放私有挂起信号的数据结构</li>
<li><code>sas_ss_sp</code>：是信号处理程序备用堆栈的地址，<code>sas_ss_size</code>表示堆栈的大小</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>用于保护资源分配或释放的自旋锁</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Protection against (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed, mempolicy: */</span></span><br><span class="line"><span class="type">spinlock_t</span>			alloc_lock;</span><br><span class="line"><span class="comment">/* Protection of the PI data structures: */</span></span><br><span class="line"><span class="type">raw_spinlock_t</span>			pi_lock;</span><br></pre></td></tr></table></figure>

<p><strong>进程描述符使用计数，被置为2时，表示进程描述符正在被使用而且其相应的进程处于活动状态</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">refcount_t</span>			usage;</span><br></pre></td></tr></table></figure>

<p><strong>用于表示获取大内核锁的次数，如果进程未获得过锁，则置为-1</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_LOCK_DEPTH			48UL</span></span><br><span class="line">	u64				curr_chain_key;</span><br><span class="line">	<span class="type">int</span>				lockdep_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			lockdep_recursion;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">held_lock</span>		<span class="title">held_locks</span>[<span class="title">MAX_LOCK_DEPTH</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>在SMP上帮助实现无加锁进程的切换(unlocked context switches)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">int</span>				on_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">call_single_node</span>	<span class="title">wake_entry</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			wakee_flips;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			wakee_flip_decay_ts;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">last_wakee</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * recent_used_cpu is initially set as the last CPU used by a task</span></span><br><span class="line"><span class="comment">	 * that wakes affine another task. Waker/wakee relationships can</span></span><br><span class="line"><span class="comment">	 * push tasks around a CPU where each wakeup moves to the next one.</span></span><br><span class="line"><span class="comment">	 * Tracking a recently used CPU allows a quick search for a recently</span></span><br><span class="line"><span class="comment">	 * used CPU that may be idle.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span>				recent_used_cpu;</span><br><span class="line">	<span class="type">int</span>				wake_cpu;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>prempt_notifier结构体链表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_NOTIFIERS</span></span><br><span class="line">	<span class="comment">/* List of struct preempt_notifier: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>		<span class="title">preempt_notifiers</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>blktrace是一个针对Linux内核中块设备I&#x2F;O层的跟踪工具</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_IO_TRACE</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			btrace_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>RCU同步原语</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT_RCU</span></span><br><span class="line">	<span class="type">int</span>				rcu_read_lock_nesting;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">rcu_special</span>		<span class="title">rcu_read_unlock_special</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">rcu_node_entry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_node</span>			*<span class="title">rcu_blocked_node</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_PREEMPT_RCU */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TASKS_RCU</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			rcu_tasks_nvcsw;</span><br><span class="line">	u8				rcu_tasks_holdout;</span><br><span class="line">	u8				rcu_tasks_idx;</span><br><span class="line">	<span class="type">int</span>				rcu_tasks_idle_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">rcu_tasks_holdout_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_TASKS_RCU */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TASKS_TRACE_RCU</span></span><br><span class="line">	<span class="type">int</span>				trc_reader_nesting;</span><br><span class="line">	<span class="type">int</span>				trc_ipi_to_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">rcu_special</span>		<span class="title">trc_reader_special</span>;</span></span><br><span class="line">	<span class="type">bool</span>				trc_reader_checked;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">trc_holdout_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_TASKS_TRACE_RCU */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>用于调度器统计进程的运行信息</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span>		<span class="title">sched_info</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>用于构建进程链表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">tasks</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>to limit pushing to one attempt</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">plist_node</span>		<span class="title">pushable_tasks</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>			<span class="title">pushable_dl_tasks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>防止内核堆栈溢出</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_STACKPROTECTOR</span></span><br><span class="line">	<span class="comment">/* Canary value for the -fstack-protector GCC feature: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			stack_canary;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>PID散列表和链表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* PID/PID hash table linkage. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span>			*<span class="title">thread_pid</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>		<span class="title">pid_links</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">thread_group</span>;</span> <span class="comment">// 线程组中所有进程的链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">thread_node</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>do_fork函数</strong></p>
<p>在执行do_fork时，如果给定特别的标志，则vfork_done会指向一个特殊的地址。</p>
<p>如果copy_process函数的clone_flags参数的值被置为CLONE_CHILD_SETTID或CLONE_CHILD_CLEARID，则会吧child_tidptr参数的值分别复制到set_child_tid和clear_child_tid成员。这些标志说明必须改变子进程用户态地址空间的child_tidptr所指向的变量的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span>		*<span class="title">vfork_done</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CLONE_CHILD_SETTID: */</span></span><br><span class="line"><span class="type">int</span> __user			*set_child_tid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CLONE_CHILD_CLEARTID: */</span></span><br><span class="line"><span class="type">int</span> __user			*clear_child_tid;</span><br></pre></td></tr></table></figure>

<p><strong>缺页统计</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* MM fault and swap info: this can arguably be seen as either mm-specific or thread-specific: */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>			min_flt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>			maj_flt;</span><br></pre></td></tr></table></figure>

<p><strong>进程权能</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>		*<span class="title">cred</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>相应的程序名</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * executable name, excluding path.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment"> * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment"> * - lock it with task_lock()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span>				comm[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span>		*<span class="title">nameidata</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>文件</strong></p>
<p>fs表示进程与文件系统的联系，包括当前目录和根目录</p>
<p>files表示进程当前打开的文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Filesystem information: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span>		*<span class="title">fs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open file information: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>		*<span class="title">files</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>进程通信</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSVIPC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span>			<span class="title">sysvsem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sysv_shm</span>			<span class="title">sysvshm</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>处理器特有数据</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CPU-specific state of this task: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span>		<span class="title">thread</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>命名空间</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Namespaces: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span>			*<span class="title">nsproxy</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>进程审计</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AUDIT</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AUDITSYSCALL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">audit_context</span>		*<span class="title">audit_context</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>				loginuid;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			sessionid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>secure computing</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp</span>			<span class="title">seccomp</span>;</span></span><br></pre></td></tr></table></figure>

<p>**用于copy_process函数使用CLONE_PARENT 标记时 **</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Thread group tracking: */</span></span><br><span class="line">u64				parent_exec_id;</span><br><span class="line">u64				self_exec_id;</span><br></pre></td></tr></table></figure>

<p><strong>中断</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqtrace_events</span>		<span class="title">irqtrace</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			hardirq_threaded;</span><br><span class="line">	u64				hardirq_chain_key;</span><br><span class="line">	<span class="type">int</span>				softirqs_enabled;</span><br><span class="line">	<span class="type">int</span>				softirq_context;</span><br><span class="line">	<span class="type">int</span>				irq_config;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACE_IRQFLAGS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqtrace_events</span>		<span class="title">kcsan_save_irqtrace</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>task_rq_lock函数所使用的锁</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Protection of the PI data structures: */</span></span><br><span class="line"><span class="type">raw_spinlock_t</span>			pi_lock;</span><br></pre></td></tr></table></figure>

<p>**基于PI协议的等待互斥锁，其中PI指的是priority inheritance（优先级继承） **</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RT_MUTEXES</span></span><br><span class="line">	<span class="comment">/* PI waiters blocked on a rt_mutex held by this task: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>		<span class="title">pi_waiters</span>;</span></span><br><span class="line">	<span class="comment">/* Updated under owner&#x27;s pi_lock and rq lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">pi_top_task</span>;</span></span><br><span class="line">	<span class="comment">/* Deadlock detection and priority inheritance handling: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex_waiter</span>		*<span class="title">pi_blocked_on</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>死锁检测</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">	<span class="comment">/* Mutex deadlock detection: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span>		*<span class="title">blocked_on</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>lockdep</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MAX_LOCK_DEPTH			48UL</span></span><br><span class="line">	u64				curr_chain_key;</span><br><span class="line">	<span class="type">int</span>				lockdep_depth;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			lockdep_recursion;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">held_lock</span>		<span class="title">held_locks</span>[<span class="title">MAX_LOCK_DEPTH</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>JFS文件系统</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Journalling filesystem info: */</span></span><br><span class="line"><span class="type">void</span>				*journal_info;</span><br></pre></td></tr></table></figure>

<p><strong>块设备链表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Stacked block device info: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_list</span>			*<span class="title">bio_list</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>内存回收</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* VM state: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reclaim_state</span>		*<span class="title">reclaim_state</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>存放块设备I&#x2F;O数据流量信息</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span>		*<span class="title">backing_dev_info</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>I&#x2F;O调度器所使用的信息</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_context</span>		*<span class="title">io_context</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>记录进程的I&#x2F;O计数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_io_accounting</span>	<span class="title">ioac</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TASK_XACCT</span></span><br><span class="line">	<span class="comment">/* Accumulated RSS usage: */</span></span><br><span class="line">	u64				acct_rss_mem1;</span><br><span class="line">	<span class="comment">/* Accumulated virtual memory usage: */</span></span><br><span class="line">	u64				acct_vm_mem1;</span><br><span class="line">	<span class="comment">/* stime + utime since last update: */</span></span><br><span class="line">	u64				acct_timexpd;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>CPUSET功能</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CPUSETS</span></span><br><span class="line">	<span class="comment">/* Protected by -&gt;alloc_lock: */</span></span><br><span class="line">	<span class="type">nodemask_t</span>			mems_allowed;</span><br><span class="line">	<span class="comment">/* Sequence number to catch updates: */</span></span><br><span class="line">	<span class="type">seqcount_spinlock_t</span>		mems_allowed_seq;</span><br><span class="line">	<span class="type">int</span>				cpuset_mem_spread_rotor;</span><br><span class="line">	<span class="type">int</span>				cpuset_slab_spread_rotor;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Control Groups</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">	<span class="comment">/* Control Group info protected by css_set_lock: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">css_set</span> __<span class="title">rcu</span>		*<span class="title">cgroups</span>;</span></span><br><span class="line">	<span class="comment">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">cg_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>futex同步机制</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FUTEX</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">robust_list_head</span> __<span class="title">user</span>	*<span class="title">robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">compat_robust_list_head</span> __<span class="title">user</span> *<span class="title">compat_robust_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">pi_state_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">futex_pi_state</span>		*<span class="title">pi_state_cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>			<span class="title">futex_exit_mutex</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			futex_state;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>非一致内存访问(NUMA  Non-Uniform Memory Access)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/* Protected by alloc_lock: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span>		*<span class="title">mempolicy</span>;</span></span><br><span class="line">	<span class="type">short</span>				il_prev;</span><br><span class="line">	<span class="type">short</span>				pref_node_fork;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>RCU链表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	<span class="type">refcount_t</span>		rcu_users;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>管道</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Cache last used pipe for splice(): */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>		*<span class="title">splice_pipe</span>;</span></span><br></pre></td></tr></table></figure>

<p><strong>延迟计数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TASK_DELAY_ACCT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_delay_info</span>		*<span class="title">delays</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>fault injection</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAULT_INJECTION</span></span><br><span class="line">	<span class="type">int</span>				make_it_fail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			fail_nth;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Infrastructure for displayinglatency</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LATENCYTOP</span></span><br><span class="line">	<span class="type">int</span>				latency_record_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">latency_record</span>		<span class="title">latency_record</span>[<span class="title">LT_SAVECOUNT</span>];</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>tim slack values 常用于poll和select函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Time slack values; these are used to round up poll() and</span></span><br><span class="line"><span class="comment"> * select() etc timeout values. These are in nanoseconds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u64				timer_slack_ns;</span><br><span class="line">u64				default_timer_slack_ns;</span><br></pre></td></tr></table></figure>

<p><strong>ftrace跟踪器</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FUNCTION_GRAPH_TRACER</span></span><br><span class="line">	<span class="comment">/* Index of current stored address in ret_stack: */</span></span><br><span class="line">	<span class="type">int</span>				curr_ret_stack;</span><br><span class="line">	<span class="type">int</span>				curr_ret_depth;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Stack of return addresses for return function tracing: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ftrace_ret_stack</span>		*<span class="title">ret_stack</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Timestamp for last schedule: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>		ftrace_timestamp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of functions that haven&#x27;t been traced</span></span><br><span class="line"><span class="comment">	 * because of depth overrun:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_t</span>			trace_overrun;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Pause tracing: */</span></span><br><span class="line">	<span class="type">atomic_t</span>			tracing_graph_pause;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRACING</span></span><br><span class="line">	<span class="comment">/* State flags for use by tracers: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			trace;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Bitmask and counter of trace recursion: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			trace_recursion;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_TRACING */</span></span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel中的命名空间</title>
    <url>/posts/99e7a00f.html</url>
    <content><![CDATA[<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>Linux Namespace是Kernel的一个功能，它可以隔离一系列的系统资源，如PID、User Id、Network等等。</p>
<h1 id="命名空间描述"><a href="#命名空间描述" class="headerlink" title="命名空间描述"></a>命名空间描述</h1><p>一个进程可以属于多个namespace，在<code>task_struct</code>结构体中有一个指向namespace结构体的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Namespaces: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span>			*<span class="title">nsproxy</span>;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nsproxy</code>在文件<code>include/linux/nsproxy.h</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A structure to contain pointers to all per-process</span></span><br><span class="line"><span class="comment"> * namespaces - fs (mount), uts, network, sysvipc, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The pid namespace is an exception -- it&#x27;s accessed using</span></span><br><span class="line"><span class="comment"> * task_active_pid_ns.  The pid namespace here is the</span></span><br><span class="line"><span class="comment"> * namespace that children will use.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;count&#x27; is the number of tasks holding a reference.</span></span><br><span class="line"><span class="comment"> * The count for each namespace, then, will be the number</span></span><br><span class="line"><span class="comment"> * of nsproxies pointing to it, not the number of tasks.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The nsproxy is shared by tasks which share all namespaces.</span></span><br><span class="line"><span class="comment"> * As soon as a single namespace is cloned or unshared, the</span></span><br><span class="line"><span class="comment"> * nsproxy is copied.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns_for_children</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> 	     *<span class="title">net_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">time_namespace</span> *<span class="title">time_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">time_namespace</span> *<span class="title">time_ns_for_children</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cgroup_namespace</span> *<span class="title">cgroup_ns</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>多个进程可以使用同一个namespace，所以nsproxy可以共享使用，count字段是该结构的引用计数。</p>
<p>系统中有一个默认的nsproxy，该结构在task初始化的时候也会被初始化，定义在<code>init/init_task.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the first task table, touch at your own risk!. Base=0,</span></span><br><span class="line"><span class="comment"> * limit=0x1fffff (=2MB)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">init_task</span> =</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    .nsproxy	= &amp;init_nsproxy,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>init_nsproxy</code>的定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> <span class="title">init_nsproxy</span> =</span> &#123;</span><br><span class="line">	.count			= ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">	.uts_ns			= &amp;init_uts_ns,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_POSIX_MQUEUE) || defined(CONFIG_SYSVIPC)</span></span><br><span class="line">	.ipc_ns			= &amp;init_ipc_ns,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	.mnt_ns			= <span class="literal">NULL</span>,</span><br><span class="line">	.pid_ns_for_children	= &amp;init_pid_ns,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET</span></span><br><span class="line">	.net_ns			= &amp;init_net,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUPS</span></span><br><span class="line">	.cgroup_ns		= &amp;init_cgroup_ns,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TIME_NS</span></span><br><span class="line">	.time_ns		= &amp;init_time_ns,</span><br><span class="line">	.time_ns_for_children	= &amp;init_time_ns,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对<code>.mnt_ns</code>没有初始化，其余的namespace都进行了系统默认的初始化。</p>
<h1 id="命名空间创建"><a href="#命名空间创建" class="headerlink" title="命名空间创建"></a>命名空间创建</h1><p>新的namespace可以使用以下两种方法创建：</p>
<ol>
<li>在用fork或clone系统调用创建新进程时，有特定的选项可以控制是否与父进程共享命名空间，或者建立新的命名空间。</li>
<li>unshare系统调用将进程的某些部分从父进程分离，其中页包括namespace。</li>
</ol>
<p>在fork或clone系统调用创建新进程时，有特定的选项可以控制是否与父进程共享命名空间。选项如下：</p>
<ul>
<li>CLONE_NEWPID 空间内独立分配PID，命名空间内的PID可以与命名空间外的PID冲突。</li>
<li>CLONE_NEWIPC 进程间通信的命名空间。</li>
<li>CLONE_NEWNET 网络命名空间，用于隔离网络资源。后台进程可以运行在不同的命名空间内，还可以虚拟一块网卡。</li>
<li>CLONE_NEWNS 挂载命名空间，进程运行时可以将挂载点与系统分离，可以达到chroot的功能，而在安全方面，比chroot更高。</li>
<li>CLONE_NEWUTS UTS命名空间，主要目的是独立出主机名和网络信息服务（NIS）</li>
<li>CLONE_NEWUSER 用户命名空间，同进程ID一样，用户ID和组ID在命名空间内外是不一样的，并且在不同的命名空间可以出现不同的ID。</li>
</ul>
]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel中进程的管理和调度</title>
    <url>/posts/99e7a00f.html</url>
    <content><![CDATA[<h1 id="进程ID的类型"><a href="#进程ID的类型" class="headerlink" title="进程ID的类型"></a>进程ID的类型</h1><p>内核中的进程ID类型用<code>pid_type</code>来描述，定义在<code>include/linux/pid.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pid_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	PIDTYPE_PID,</span><br><span class="line">	PIDTYPE_TGID,</span><br><span class="line">	PIDTYPE_PGID,</span><br><span class="line">	PIDTYPE_SID,</span><br><span class="line">	PIDTYPE_MAX,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * What is struct pid?</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A struct pid is the kernel&#x27;s internal notion of a process identifier.</span></span><br><span class="line"><span class="comment"> * It refers to individual tasks, process groups, and sessions.  While</span></span><br><span class="line"><span class="comment"> * there are processes attached to it the struct pid lives in a hash</span></span><br><span class="line"><span class="comment"> * table, so it and then the processes that it refers to can be found</span></span><br><span class="line"><span class="comment"> * quickly from the numeric pid value.  The attached processes may be</span></span><br><span class="line"><span class="comment"> * quickly accessed by following pointers from struct pid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Storing pid_t values in the kernel and referring to them later has a</span></span><br><span class="line"><span class="comment"> * problem.  The process originally with that pid may have exited and the</span></span><br><span class="line"><span class="comment"> * pid allocator wrapped, and another process could have come along</span></span><br><span class="line"><span class="comment"> * and been assigned that pid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Referring to user space processes by holding a reference to struct</span></span><br><span class="line"><span class="comment"> * task_struct has a problem.  When the user space process exits</span></span><br><span class="line"><span class="comment"> * the now useless task_struct is still kept.  A task_struct plus a</span></span><br><span class="line"><span class="comment"> * stack consumes around 10K of low kernel memory.  More precisely</span></span><br><span class="line"><span class="comment"> * this is THREAD_SIZE + sizeof(struct task_struct).  By comparison</span></span><br><span class="line"><span class="comment"> * a struct pid is about 64 bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Holding a reference to struct pid solves both of these problems.</span></span><br><span class="line"><span class="comment"> * It is small so holding a reference does not consume a lot of</span></span><br><span class="line"><span class="comment"> * resources, and since a new struct pid is allocated when the numeric pid</span></span><br><span class="line"><span class="comment"> * value is reused (when pids wrap around) we don&#x27;t mistakenly refer to new</span></span><br><span class="line"><span class="comment"> * processes.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>pid内核中唯一区分每个进程的标识，在使用fork或clone系统调用时产生一个新的进程时，均会由内核分配一个新的唯一PID值。</p>
<blockquote>
<p>用户空间通过getpid()获取的进程号并不是这个PID值</p>
</blockquote>
<p>TGID线程组（轻量级进程）的标识。如果以CLONE_THREAD标志来调用clone建立一个进程，就是该进程的一个线程，它们属于一个线程组。线程组的ID，就是TGID。线程组的主线程TGID与PID相同。</p>
<p>PGID，独立的进程可以组成进程组（setpgrp系统调用），进程组可以简化组内进程发送信号的操作。如管道连接的进程处在同一个进程组内，进程组的ID就叫PGID。</p>
<p>SID，几个进程可以合并成一个会话组（setsid调用），可用于终端程序设计。会话组中所有进程都有相同的SID，保存在task_struct的session成员中。</p>
<blockquote>
<p>task_ struct-&gt;signal-&gt;__session表示全局SID，</p>
<p>而全局PGID则保存在task_struct-&gt;signal-&gt;__pgrp。</p>
<p>辅助函数set_task_session和set_task_pgrp可用于修改这些值。</p>
</blockquote>
<h1 id="PID命名空间"><a href="#PID命名空间" class="headerlink" title="PID命名空间"></a>PID命名空间</h1><p>pid_namespace定义在<code>include/linux/pid_namespace.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">idr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pid_allocated;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">child_reaper</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">pid_cachep</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> level;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BSD_PROCESS_ACCT</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fs_pin</span> *<span class="title">bacct</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line">	<span class="type">int</span> reboot;	<span class="comment">/* group exit code if this pidns was rebooted */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span> <span class="title">ns</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>child_reaper</code>：指向的是当前命名空间的init进程，每个命名空间都有一个作用相当于全局init进程的进程</li>
<li><code>level</code>：代表当前命名空间的等级，初始命名空间的level为0，它的子命名空间level为1，依次递增，而且子命名空间对父命名空间是可见的。从给定的level设置，内核即可推断进程会关联到多少个ID。</li>
<li><code>parent</code>：指向父命名空间的指针</li>
</ul>
<h1 id="PID结构"><a href="#PID结构" class="headerlink" title="PID结构"></a>PID结构</h1><h2 id="pid与upid"><a href="#pid与upid" class="headerlink" title="pid与upid"></a>pid与upid</h2><p>pid是内核对pid的内部表示。upid表示特定的命名空间中可见的信息。</p>
<p>upid定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> nr;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nr</code>：ID具体的值</li>
<li><code>ns</code>：执行命名空间的指针</li>
</ul>
<blockquote>
<p>所有的upid都会保存在一个散列表中</p>
</blockquote>
<p>pid定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">refcount_t</span> count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> level;</span><br><span class="line">	<span class="type">spinlock_t</span> lock;</span><br><span class="line">	<span class="comment">/* lists of tasks that use this pid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">inodes</span>;</span></span><br><span class="line">	<span class="comment">/* wait queue for pidfd notifications */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> wait_pidfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>[1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>count</code>：指使用该PID的task的数目；</li>
<li><code>level</code>：可以看到该PID的命名空间的数目，也就是包含该进程的命名空间的深度。</li>
<li><code>tasks[PIDTYPE_MAX]</code>：每个数组项都是一个散列表头，分别对应三种类型：<code>PIDTYPE_PID</code>, <code>PIDTYPE_PGID</code>, <code>PIDTYPE_SID</code>（<code>PIDTYPE_MAX</code>表示PID类型的数目）。所有共享同一给定的ID的task实例，都通过该散列表连接起来。</li>
<li><code>numbers[1]</code>：一个upid的实例数组，每个数组项代表一个命名空间，用来表示一个PID可以属于不同的命名空间，该元素放在末尾，可以向数组添加附加的项。</li>
</ul>
]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Atomic原子变量详解</title>
    <url>/posts/c6fa5c21.html</url>
    <content><![CDATA[<h1 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h1><p>适用于针对int变量进行同步的场景 </p>
<h1 id="Atomic使用"><a href="#Atomic使用" class="headerlink" title="Atomic使用"></a>Atomic使用</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">atomic_t</span> ac = ATOMIC_INIT(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将原子变量-1，如果结果为0，返回true，否则返回false</span></span><br><span class="line"><span class="comment">// 原子操作</span></span><br><span class="line">atomic_dec_and_test(&amp;ac);</span><br><span class="line"><span class="comment">// 原子变量+1</span></span><br><span class="line"><span class="comment">// 原子操作</span></span><br><span class="line"><span class="type">atomic_inc</span>(&amp;ac)</span><br></pre></td></tr></table></figure>

<h1 id="Atomic实现"><a href="#Atomic实现" class="headerlink" title="Atomic实现"></a>Atomic实现</h1><h2 id="atomic-t定义"><a href="#atomic-t定义" class="headerlink" title="atomic_t定义"></a>atomic_t定义</h2><p>定义在<code>include/linux/types.h</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> counter;</span><br><span class="line">&#125; <span class="type">atomic_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>不同体系下实现不同，x86实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Atomic operations that C can&#x27;t guarantee us.  Useful for</span></span><br><span class="line"><span class="comment"> * resource counting etc..</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ATOMIC_INIT(i)	&#123; (i) &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="嵌入式汇编代码语法"><a href="#嵌入式汇编代码语法" class="headerlink" title="嵌入式汇编代码语法"></a>嵌入式汇编代码语法</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;汇编语言&quot;</span></span><br><span class="line">   :输出寄存器</span><br><span class="line">   :输入寄存器</span><br><span class="line">   :会被修改的寄存器)</span><br></pre></td></tr></table></figure>

<p>汇编代码：x86或者arm的汇编代码指令</p>
<p>输出寄存器：表示汇编代码执行完成后，哪些寄存器用于存放输出数据。这些寄存器会分别对应一个C语言表达式或者一个内存地址</p>
<p>输入寄存器：表示开始执行汇编代码时，这里指定的一些寄存器用于存放输入值，也分别对应一个C变量或常数值</p>
<p>会被修改的寄存器：也叫clober list，描述了汇编代码对寄存器的修改情况</p>
<ol>
<li>asm是关键字，必选项</li>
<li>volatile 是可选的，加了，GCC 就不会优化这句。</li>
<li>汇编指令间必须被双引号括起来;</li>
<li>汇编指令间必须使用”;”、”&#x2F;n”或”&#x2F;n&#x2F;t”分开分开;</li>
<li>()内的是可选的，如asm volatile(“”)是可以的，只是无意义</li>
<li>仅省动其中一项，分号需要加上: 如这个省了输入和输出的，asm volatile (“sync” : : :”memory”)</li>
<li>Clobber&#x2F;Modify表示特定的关键字，让汇编做相应的动作</li>
</ol>
<p>输入和输出及最后的前缀说明:</p>
<ul>
<li><p>“&#x3D;”: 表示只写,常用于输出参数。</p>
</li>
<li><p>“+”: 表示可读可写</p>
</li>
<li><p>“m”、”v”和”o”:内存操作单元，V:寻址方式不是偏移量类型;  o:寻址方式是偏移量类型</p>
</li>
<li><p>“r”: 寄存器单元</p>
</li>
<li><p>“i”和”h” ：常数</p>
</li>
<li><p>“E”和”F”：浮点数</p>
</li>
<li><p>“a”: 输入变量放入eax</p>
</li>
<li><p>“p”: 合法的内存指针</p>
</li>
<li><p>“memory”: 表示通知有内存变动</p>
</li>
<li><p>“&amp;”: 该输出操作数不能使用和输入操作数相同的寄存器</p>
</li>
<li><p>“X”: 表示任何类型</p>
</li>
<li><p>“*: 表示如果选用寄存器，则其后的字母被忽略</p>
</li>
<li><p>#部分行注释，从该字符到其后的逗号之间所有字母被忽略</p>
</li>
</ul>
<p>占位符引用C语言变量，操作数占位符最多10 个，名称如下：%0，%1，…，%9。指令中使用占位符表示的操作数，总被视为long型（4个字节）,在%和序号之间插入一个字母，”b”代表低字节，”h”代表高字节。0% 表示第一个参数, 1%这种数字表示第二个参数，依次类推</p>
<h2 id="atomic-inc实现"><a href="#atomic-inc实现" class="headerlink" title="atomic_inc实现"></a>atomic_inc实现</h2><p><code>include/linux/atomic/atomic-instrumented.h</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">atomic_inc</span><span class="params">(<span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">	instrument_atomic_read_write(v, <span class="keyword">sizeof</span>(*v));</span><br><span class="line">    <span class="comment">// 不同体系下实现不同</span></span><br><span class="line">	arch_atomic_inc(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用汇编实现，x86实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * arch_atomic_inc - increment atomic variable</span></span><br><span class="line"><span class="comment"> * @v: pointer of type atomic_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Atomically increments @v by 1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_atomic_inc</span><span class="params">(<span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;incl %0&quot;</span></span></span><br><span class="line"><span class="params">		     : <span class="string">&quot;+m&quot;</span> (v-&gt;counter) :: <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_atomic_inc arch_atomic_inc</span></span><br></pre></td></tr></table></figure>

<h2 id="atomic-dec实现"><a href="#atomic-dec实现" class="headerlink" title="atomic_dec实现"></a>atomic_dec实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">atomic_dec</span><span class="params">(<span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">	instrument_atomic_read_write(v, <span class="keyword">sizeof</span>(*v));</span><br><span class="line">	arch_atomic_dec(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>x86实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * arch_atomic_dec - decrement atomic variable</span></span><br><span class="line"><span class="comment"> * @v: pointer of type atomic_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Atomically decrements @v by 1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">arch_atomic_dec</span><span class="params">(<span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(LOCK_PREFIX <span class="string">&quot;decl %0&quot;</span></span></span><br><span class="line"><span class="params">		     : <span class="string">&quot;+m&quot;</span> (v-&gt;counter) :: <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_atomic_dec arch_atomic_dec</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>semaphore信号量详解</title>
    <url>/posts/75d3819a.html</url>
    <content><![CDATA[<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量是一个计数器，用来保护一个或多个共享资源的访问。如果信号量计数器大于0，则允许进程访问，信号量-1，如果信号量等于0，信号量会将线程置入休眠直到信号量大于0。</p>
<p>信号量能够保证对临界区的访问是原子的。</p>
<p>信号量用于进程之间的同步，进程在信号量保护的临界区代码里是可以睡眠的，这是和自旋锁最大的区别。</p>
<h1 id="信号量基本使用"><a href="#信号量基本使用" class="headerlink" title="信号量基本使用"></a>信号量基本使用</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sema</span>;</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">sema_init(&amp;sema, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 进入临界区 信号量-1</span></span><br><span class="line">down(sema);</span><br><span class="line"><span class="comment">// 退出临界区 信号量+1</span></span><br><span class="line">up(sema);</span><br></pre></td></tr></table></figure>

<h1 id="信号量Kernel实现"><a href="#信号量Kernel实现" class="headerlink" title="信号量Kernel实现"></a>信号量Kernel实现</h1><h2 id="信号量结构体定义"><a href="#信号量结构体定义" class="headerlink" title="信号量结构体定义"></a>信号量结构体定义</h2><p>结构体定义在<code>include/linux/semaphore.h</code>中</p>
<p>信号量结构体定义了自旋锁，信号量数以及等待队列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Please don&#x27;t access any members of this structure directly */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">	<span class="type">raw_spinlock_t</span>		lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		count;</span><br><span class="line">    <span class="comment">// 等待队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h2><p>初始化函数传入信号量数，直接初始化结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化双向链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义初始化信号量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SEMAPHORE_INITIALIZER(name, n)				\</span></span><br><span class="line"><span class="meta">&#123;									\</span></span><br><span class="line"><span class="meta">	.lock		= __RAW_SPIN_LOCK_UNLOCKED((name).lock),	\</span></span><br><span class="line"><span class="meta">	.count		= n,						\</span></span><br><span class="line"><span class="meta">	.wait_list	= LIST_HEAD_INIT((name).wait_list),		\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">sema_init</span><span class="params">(<span class="keyword">struct</span> semaphore *sem, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span></span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">	*sem = (<span class="keyword">struct</span> semaphore) __SEMAPHORE_INITIALIZER(*sem, val);</span><br><span class="line">	lockdep_init_map(&amp;sem-&gt;lock.dep_map, <span class="string">&quot;semaphore-&gt;lock&quot;</span>, &amp;__key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DOWN"><a href="#DOWN" class="headerlink" title="DOWN"></a>DOWN</h2><p>down获取锁，如果获取到锁，则进入临界区；如果获取不到，则等待。</p>
<p>定义在<code>kernel/locking/semaphore.c</code>中。</p>
<p>首先涉及信号量数的变化都用自旋锁保护起来，如果信号量大于0，则信号量减1。如果信号量等于0，则将进程加入等待队列，并且检查进程是否有中断、超时等。由于自旋锁开销比较大，所以在加入等待队列后，释放自旋锁，让出CPU调度，之后再加上自旋锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> &#123;</span></span><br><span class="line">    <span class="comment">// 进程的侵入式链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="comment">// 进程结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">	<span class="type">bool</span> up;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Because this function is inlined, the &#x27;state&#x27; parameter will be</span></span><br><span class="line"><span class="comment"> * constant, and thus optimised away by the compiler.  Likewise the</span></span><br><span class="line"><span class="comment"> * &#x27;timeout&#x27; parameter for the cases without timeouts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __sched __down_common(<span class="keyword">struct</span> semaphore *sem, <span class="type">long</span> state,</span><br><span class="line">								<span class="type">long</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把当前进程加入到等待队列队尾</span></span><br><span class="line">	list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;sem-&gt;wait_list);</span><br><span class="line">	waiter.task = current;</span><br><span class="line">	waiter.up = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 查看当前进程是否有信号中断</span></span><br><span class="line">		<span class="keyword">if</span> (signal_pending_state(state, current))</span><br><span class="line">			<span class="keyword">goto</span> interrupted;</span><br><span class="line">        <span class="comment">// 是否超时,timeout值较大</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(timeout &lt;= <span class="number">0</span>))</span><br><span class="line">			<span class="keyword">goto</span> timed_out;</span><br><span class="line">        <span class="comment">// 设置进程的状态：TASK_UNINTERRUPTIBLE</span></span><br><span class="line">		__set_current_state(state);</span><br><span class="line">        <span class="comment">// 释放自旋锁</span></span><br><span class="line">		raw_spin_unlock_irq(&amp;sem-&gt;lock);</span><br><span class="line">        <span class="comment">// 由于自旋锁开销较大，所以此部分不用自旋锁保护，调用schedule_timeout进程让出CPU调度</span></span><br><span class="line">		timeout = schedule_timeout(timeout);</span><br><span class="line">        <span class="comment">// 加自旋锁</span></span><br><span class="line">		raw_spin_lock_irq(&amp;sem-&gt;lock);</span><br><span class="line">		<span class="keyword">if</span> (waiter.up)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> timed_out:</span><br><span class="line">	list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> -ETIME;</span><br><span class="line"></span><br><span class="line"> interrupted:</span><br><span class="line">	list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> -EINTR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LONG_MAX	((long)(~0UL &gt;&gt; 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MAX_SCHEDULE_TIMEOUT		LONG_MAX</span></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __down(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TASK_UNINTERRUPTIBLE 表示进程进入睡眠，并且不可中断</span></span><br><span class="line">    <span class="comment">// MAX_SCHEDULE_TIMEOUT long类型的最大值</span></span><br><span class="line">	__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * down - acquire the semaphore</span></span><br><span class="line"><span class="comment"> * @sem: the semaphore to be acquired</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Acquires the semaphore.  If no more tasks are allowed to acquire the</span></span><br><span class="line"><span class="comment"> * semaphore, calling this function will put the task to sleep until the</span></span><br><span class="line"><span class="comment"> * semaphore is released.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use of this function is deprecated, please use down_interruptible() or</span></span><br><span class="line"><span class="comment"> * down_killable() instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">down</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	might_sleep();</span><br><span class="line">    <span class="comment">// 自旋锁</span></span><br><span class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))</span><br><span class="line">        <span class="comment">// 如果count&gt;0，则-1</span></span><br><span class="line">		sem-&gt;count--;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果count==0，则执行__down()</span></span><br><span class="line">		__down(sem);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(down);</span><br></pre></td></tr></table></figure>

<h2 id="UP"><a href="#UP" class="headerlink" title="UP"></a>UP</h2><p>如果等待队列为空，则信号量+1，否则将等待队列中的进程up置为true，唤醒进程，唤醒后重新获取信号量执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * wake_up_process - Wake up a specific process</span></span><br><span class="line"><span class="comment"> * @p: The process to be woken up.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Attempt to wake up the nominated process and move it to the set of runnable</span></span><br><span class="line"><span class="comment"> * processes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 1 if the process was woken up, 0 if it was already running.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function executes a full memory barrier before accessing the task state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">wake_up_process</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> try_to_wake_up(p, TASK_NORMAL, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(wake_up_process);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __sched __up(<span class="keyword">struct</span> semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 拿到等待队列的进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> *<span class="title">waiter</span> =</span> list_first_entry(&amp;sem-&gt;wait_list,</span><br><span class="line">						<span class="keyword">struct</span> semaphore_waiter, <span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">// 从等待队列中删除该进程</span></span><br><span class="line">	list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">// 修改进程状态</span></span><br><span class="line">	waiter-&gt;up = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 唤醒进程</span></span><br><span class="line">	wake_up_process(waiter-&gt;task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * up - release the semaphore</span></span><br><span class="line"><span class="comment"> * @sem: the semaphore to release</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Release the semaphore.  Unlike mutexes, up() may be called from any</span></span><br><span class="line"><span class="comment"> * context and even by tasks which have never called down().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">up</span><span class="params">(<span class="keyword">struct</span> semaphore *sem)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">    <span class="comment">// 查看等待队列是否为空</span></span><br><span class="line">	<span class="keyword">if</span> (likely(list_empty(&amp;sem-&gt;wait_list)))</span><br><span class="line">        <span class="comment">// 如果等待队列中无待执行进程，信号量释放+1</span></span><br><span class="line">		sem-&gt;count++;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">		__up(sem);</span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(up);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>spinlock自旋锁详解</title>
    <url>/posts/e0450648.html</url>
    <content><![CDATA[<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>spinlock是一种死等的锁机制，一次只能有一个执行单元获取锁并进入临界区，其他执行单元不断循环死等。spinlock可以在中断上下文执行。由于不睡眠，因此spinlock可以在中断上下文中使用。 </p>
<h1 id="spinlock函数"><a href="#spinlock函数" class="headerlink" title="spinlock函数"></a>spinlock函数</h1><p>void spin_lock(spinlock_t *lock)。进程和进程之间同步</p>
<p>void spin_lock_bh(spinlock_t *lock)。涉及到和本地软中断之间的同步</p>
<p>void spin_lock_irq(spinlock_t *lock)。涉及到和本地硬中断之间的同步</p>
<p>void spin_lock_irqsave(spinlock_t *lock)。涉及到和本地硬中断之间的同步并保存本地中断状态</p>
<p>int spin_trylock(spinlock_t *lock)。尝试获取锁，如果成功返回非零，否则返回零</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">spin_lock_init(&amp;lock);</span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">spin_lock(&amp;lock);</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">spin_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>



<h1 id="spinlock实现"><a href="#spinlock实现" class="headerlink" title="spinlock实现"></a>spinlock实现</h1><h2 id="spinlock定义"><a href="#spinlock定义" class="headerlink" title="spinlock定义"></a>spinlock定义</h2><p><code>include/linux/spinlock_types.h</code>:</p>
<p>由于spinlock不允许睡眠，所以spinlock不可被抢占。</p>
<p>但是如果定义<code>CONFIG_PREEMPT_RT</code>实时，则spinlock不可被抢占；否则可以被抢占。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_PREEMPT_RT</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex_base</span> &#123;</span></span><br><span class="line">	<span class="type">raw_spinlock_t</span>		wait_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>   <span class="title">waiters</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex_base</span>	<span class="title">lock</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* !CONFIG_PREEMPT_RT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex_base</span>	<span class="title">lock</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_PREEMPT_RT */</span></span></span><br></pre></td></tr></table></figure>

<p><code>raw_spinlock</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> &#125; <span class="type">arch_spinlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> &#123;</span></span><br><span class="line">	<span class="type">arch_spinlock_t</span> raw_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> magic, owner_cpu;</span><br><span class="line">	<span class="type">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">raw_spinlock_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>arch_spinlock_t</code>根据体系不同，实现也不同。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="非RT"><a href="#非RT" class="headerlink" title="非RT"></a>非RT</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED &#123; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___SPIN_LOCK_INITIALIZER(lockname)	\</span></span><br><span class="line"><span class="meta">	&#123;					\</span></span><br><span class="line"><span class="meta">	.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,	\</span></span><br><span class="line"><span class="meta">	SPIN_DEBUG_INIT(lockname)		\</span></span><br><span class="line"><span class="meta">	SPIN_DEP_MAP_INIT(lockname) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SPIN_LOCK_INITIALIZER(lockname) \</span></span><br><span class="line"><span class="meta">	&#123; &#123; .rlock = ___SPIN_LOCK_INITIALIZER(lockname) &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SPIN_LOCK_UNLOCKED(lockname) \</span></span><br><span class="line"><span class="meta">	(spinlock_t) __SPIN_LOCK_INITIALIZER(lockname)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> spin_lock_init(_lock)			\</span></span><br><span class="line"><span class="meta">do &#123;						\</span></span><br><span class="line"><span class="meta">	spinlock_check(_lock);			\</span></span><br><span class="line"><span class="meta">	*(_lock) = __SPIN_LOCK_UNLOCKED(_lock);	\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<h3 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED &#123; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RAW_SPIN_LOCK_INITIALIZER(lockname)	\</span></span><br><span class="line"><span class="meta">&#123;						\</span></span><br><span class="line"><span class="meta">	.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,	\</span></span><br><span class="line"><span class="meta">	SPIN_DEBUG_INIT(lockname)		\</span></span><br><span class="line"><span class="meta">	RAW_SPIN_DEP_MAP_INIT(lockname) &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __RAW_SPIN_LOCK_UNLOCKED(lockname)	\</span></span><br><span class="line"><span class="meta">	(raw_spinlock_t) __RAW_SPIN_LOCK_INITIALIZER(lockname)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> raw_spin_lock_init(lock)				\</span></span><br><span class="line"><span class="meta">	do &#123; *(lock) = __RAW_SPIN_LOCK_UNLOCKED(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_ROOT_CACHED (struct rb_root_cached) &#123; &#123;NULL, &#125;, NULL &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __rt_mutex_base_init(<span class="keyword">struct</span> rt_mutex_base *lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化raw自旋锁</span></span><br><span class="line">	raw_spin_lock_init(&amp;lock-&gt;wait_lock);</span><br><span class="line">    <span class="comment">// 初始化红黑树</span></span><br><span class="line">	lock-&gt;waiters = RB_ROOT_CACHED;</span><br><span class="line">    <span class="comment">// 当前执行的进程</span></span><br><span class="line">	lock-&gt;owner = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rt_mutex_base_init</span><span class="params">(<span class="keyword">struct</span> rt_mutex_base *rtb)</span></span><br><span class="line">&#123;</span><br><span class="line">	__rt_mutex_base_init(rtb);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rt_mutex_base_init);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __rt_spin_lock_init(<span class="type">spinlock_t</span> *lock, <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">				<span class="keyword">struct</span> lock_class_key *key, <span class="type">bool</span> percpu)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> spin_lock_init(slock)					\</span></span><br><span class="line"><span class="meta">do &#123;								\</span></span><br><span class="line"><span class="meta">	static struct lock_class_key __key;			\</span></span><br><span class="line"><span class="meta">								\</span></span><br><span class="line"><span class="meta">	rt_mutex_base_init(&amp;(slock)-&gt;lock);			\</span></span><br><span class="line"><span class="meta">	__rt_spin_lock_init(slock, #slock, &amp;__key, false);	\</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure>

<h2 id="spin-lock-实现"><a href="#spin-lock-实现" class="headerlink" title="spin_lock()实现"></a>spin_lock()实现</h2><h3 id="非RT-1"><a href="#非RT-1" class="headerlink" title="非RT"></a>非RT</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> raw_spin_lock(lock)	_raw_spin_lock(lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	raw_spin_lock(&amp;lock-&gt;rlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="UP-单核实现"><a href="#UP-单核实现" class="headerlink" title="UP 单核实现"></a>UP 单核实现</h4><p>单核实现较为简单，就只是关闭了抢占。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __acquire(x)	(void)0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ___LOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; __acquire(lock); (void)(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> preempt_disable()			barrier()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LOCK(lock) \</span></span><br><span class="line"><span class="meta">  do &#123; preempt_disable(); ___LOCK(lock); &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock(lock)			__LOCK(lock)</span></span><br></pre></td></tr></table></figure>

<h4 id="SMP多核实现"><a href="#SMP多核实现" class="headerlink" title="SMP多核实现"></a>SMP多核实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lock_acquire_exclusive(l, s, t, n, i)		lock_acquire(l, s, t, 0, 1, n, i)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> spin_acquire(l, s, t, i)		lock_acquire_exclusive(l, s, t, NULL, i)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_CONTENDED(_lock, try, lock) \</span></span><br><span class="line"><span class="meta">	lock(_lock)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __raw_spin_lock(<span class="type">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 关闭抢占</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">    <span class="comment">// do_raw_spin_lock(lock)</span></span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _raw_spin_lock(lock) __raw_spin_lock(lock)</span></span><br></pre></td></tr></table></figure>

<p><code>do_raw_spin_lock</code>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * queued_spin_lock - acquire a queued spinlock</span></span><br><span class="line"><span class="comment"> * @lock: Pointer to queued spinlock structure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">queued_spin_lock</span><span class="params">(<span class="keyword">struct</span> qspinlock *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行带有获取语义的原子比较交换操作，如果锁的值是0，那么把锁的locked字段设置为1。</span></span><br><span class="line">	<span class="keyword">if</span> (likely(atomic_try_cmpxchg_acquire(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL)))</span><br><span class="line">        <span class="comment">// 如果锁的旧值是0，说明申请锁的时候锁处于空闲状态，那么成功地获得锁。</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果锁的旧值不是0，说明锁不是处于空闲状态，那么执行申请自旋锁的慢速路径。</span></span><br><span class="line">	queued_spin_lock_slowpath(lock, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x86使用asm-generic</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arch_spin_lock(l)		queued_spin_lock(l)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">do_raw_spin_lock</span><span class="params">(<span class="type">raw_spinlock_t</span> *lock)</span> __<span class="title function_">acquires</span><span class="params">(lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	__acquire(lock);</span><br><span class="line">	arch_spin_lock(&amp;lock-&gt;raw_lock);</span><br><span class="line">	mmiowb_spin_lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>queued_spin_lock_slowpath</code> 自旋锁慢路径实现(<code>kernel/locking/qspinlock.c</code>)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * queued_spin_lock_slowpath - acquire the queued spinlock</span></span><br><span class="line"><span class="comment"> * @lock: Pointer to queued spinlock structure</span></span><br><span class="line"><span class="comment"> * @val: Current value of the queued spinlock 32-bit word</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (queue tail, pending bit, lock value)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *              fast     :    slow                                  :    unlock</span></span><br><span class="line"><span class="comment"> *                       :                                          :</span></span><br><span class="line"><span class="comment"> * uncontended  (0,0,0) -:--&gt; (0,0,1) ------------------------------:--&gt; (*,*,0)</span></span><br><span class="line"><span class="comment"> *                       :       | ^--------.------.             /  :</span></span><br><span class="line"><span class="comment"> *                       :       v           \      \            |  :</span></span><br><span class="line"><span class="comment"> * pending               :    (0,1,1) +--&gt; (0,1,0)   \           |  :</span></span><br><span class="line"><span class="comment"> *                       :       | ^--&#x27;              |           |  :</span></span><br><span class="line"><span class="comment"> *                       :       v                   |           |  :</span></span><br><span class="line"><span class="comment"> * uncontended           :    (n,x,y) +--&gt; (n,0,0) --&#x27;           |  :</span></span><br><span class="line"><span class="comment"> *   queue               :       | ^--&#x27;                          |  :</span></span><br><span class="line"><span class="comment"> *                       :       v                               |  :</span></span><br><span class="line"><span class="comment"> * contended             :    (*,x,y) +--&gt; (*,0,0) ---&gt; (*,0,1) -&#x27;  :</span></span><br><span class="line"><span class="comment"> *   queue               :         ^--&#x27;                             :</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">queued_spin_lock_slowpath</span><span class="params">(<span class="keyword">struct</span> qspinlock *lock, u32 val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mcs_spinlock</span> *<span class="title">prev</span>, *<span class="title">next</span>, *<span class="title">node</span>;</span></span><br><span class="line">	u32 old, tail;</span><br><span class="line">	<span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">	BUILD_BUG_ON(CONFIG_NR_CPUS &gt;= (<span class="number">1U</span> &lt;&lt; _Q_TAIL_CPU_BITS));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pv_enabled())</span><br><span class="line">		<span class="keyword">goto</span> pv_queue;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (virt_spin_lock(lock))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Wait for in-progress pending-&gt;locked hand-overs with a bounded</span></span><br><span class="line"><span class="comment">	 * number of spins so that we guarantee forward progress.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0,1,0 -&gt; 0,0,1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果锁的状态是pending，即&#123;tail=0，pending=1，locked=0&#125;，那么等待锁的状态变成locked，即&#123;tail=0，pending=0，locked=1&#125;。</span></span><br><span class="line">	<span class="keyword">if</span> (val == _Q_PENDING_VAL) &#123;</span><br><span class="line">		<span class="type">int</span> cnt = _Q_PENDING_LOOPS;</span><br><span class="line">		val = atomic_cond_read_relaxed(&amp;lock-&gt;val,</span><br><span class="line">					       (VAL != _Q_PENDING_VAL) || !cnt--);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we observe any contention; queue.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果锁的tail字段不是0或者pending位是1，说明已经有处理器在等待自旋锁，那么跳转到标号queue，本处理器加入等待队列。</span></span><br><span class="line">	<span class="keyword">if</span> (val &amp; ~_Q_LOCKED_MASK)</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * trylock || pending</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0,0,* -&gt; 0,1,* -&gt; 0,0,1 pending, trylock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	val = queued_fetch_set_pending_acquire(lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we observe contention, there is a concurrent locker.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Undo and queue; our setting of PENDING might have made the</span></span><br><span class="line"><span class="comment">	 * n,0,0 -&gt; 0,0,0 transition fail and it will now be waiting</span></span><br><span class="line"><span class="comment">	 * on @next to become !NULL.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(val &amp; ~_Q_LOCKED_MASK)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Undo PENDING if we set it. */</span></span><br><span class="line">		<span class="keyword">if</span> (!(val &amp; _Q_PENDING_MASK))</span><br><span class="line">			clear_pending(lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">queue</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We&#x27;re pending, wait for the owner to go away.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0,1,1 -&gt; 0,1,0</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * this wait loop must be a load-acquire such that we match the</span></span><br><span class="line"><span class="comment">	 * store-release that clears the locked bit and create lock</span></span><br><span class="line"><span class="comment">	 * sequentiality; this is because not all</span></span><br><span class="line"><span class="comment">	 * clear_pending_set_locked() implementations imply full</span></span><br><span class="line"><span class="comment">	 * barriers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (val &amp; _Q_LOCKED_MASK)</span><br><span class="line">		atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_MASK));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * take ownership and clear the pending bit.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 0,1,0 -&gt; 0,0,1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	clear_pending_set_locked(lock);</span><br><span class="line">	lockevent_inc(lock_pending);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * End of pending bit optimistic spinning and beginning of MCS</span></span><br><span class="line"><span class="comment">	 * queuing.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="built_in">queue</span>:</span><br><span class="line">	lockevent_inc(lock_slowpath);</span><br><span class="line">pv_queue:</span><br><span class="line">	node = this_cpu_ptr(&amp;qnodes[<span class="number">0</span>].mcs);</span><br><span class="line">	idx = node-&gt;count++;</span><br><span class="line">	tail = encode_tail(smp_processor_id(), idx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 4 nodes are allocated based on the assumption that there will</span></span><br><span class="line"><span class="comment">	 * not be nested NMIs taking spinlocks. That may not be true in</span></span><br><span class="line"><span class="comment">	 * some architectures even though the chance of needing more than</span></span><br><span class="line"><span class="comment">	 * 4 nodes will still be extremely unlikely. When that happens,</span></span><br><span class="line"><span class="comment">	 * we fall back to spinning on the lock directly without using</span></span><br><span class="line"><span class="comment">	 * any MCS node. This is not the most elegant solution, but is</span></span><br><span class="line"><span class="comment">	 * simple enough.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(idx &gt;= MAX_NODES)) &#123;</span><br><span class="line">		lockevent_inc(lock_no_node);</span><br><span class="line">		<span class="keyword">while</span> (!queued_spin_trylock(lock))</span><br><span class="line">			cpu_relax();</span><br><span class="line">		<span class="keyword">goto</span> release;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node = grab_mcs_node(node, idx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Keep counts of non-zero index values:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	lockevent_cond_inc(lock_use_node2 + idx - <span class="number">1</span>, idx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure that we increment the head node-&gt;count before initialising</span></span><br><span class="line"><span class="comment">	 * the actual node. If the compiler is kind enough to reorder these</span></span><br><span class="line"><span class="comment">	 * stores, then an IRQ could overwrite our assignments.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	barrier();</span><br><span class="line"></span><br><span class="line">	node-&gt;locked = <span class="number">0</span>;</span><br><span class="line">	node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	pv_init_node(node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We touched a (possibly) cold cacheline in the per-cpu queue node;</span></span><br><span class="line"><span class="comment">	 * attempt the trylock once more in the hope someone let go while we</span></span><br><span class="line"><span class="comment">	 * weren&#x27;t watching.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (queued_spin_trylock(lock))</span><br><span class="line">		<span class="keyword">goto</span> release;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure that the initialisation of @node is complete before we</span></span><br><span class="line"><span class="comment">	 * publish the updated tail via xchg_tail() and potentially link</span></span><br><span class="line"><span class="comment">	 * @node into the waitqueue via WRITE_ONCE(prev-&gt;next, node) below.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_wmb();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Publish the updated tail.</span></span><br><span class="line"><span class="comment">	 * We have already touched the queueing cacheline; don&#x27;t bother with</span></span><br><span class="line"><span class="comment">	 * pending stuff.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * p,*,* -&gt; n,*,*</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	old = xchg_tail(lock, tail);</span><br><span class="line">	next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * if there was a previous node; link it and wait until reaching the</span></span><br><span class="line"><span class="comment">	 * head of the waitqueue.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (old &amp; _Q_TAIL_MASK) &#123;</span><br><span class="line">		prev = decode_tail(old);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Link @node into the waitqueue. */</span></span><br><span class="line">		WRITE_ONCE(prev-&gt;next, node);</span><br><span class="line"></span><br><span class="line">		pv_wait_node(node, prev);</span><br><span class="line">		arch_mcs_spin_lock_contended(&amp;node-&gt;locked);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * While waiting for the MCS lock, the next pointer may have</span></span><br><span class="line"><span class="comment">		 * been set by another lock waiter. We optimistically load</span></span><br><span class="line"><span class="comment">		 * the next pointer &amp; prefetch the cacheline for writing</span></span><br><span class="line"><span class="comment">		 * to reduce latency in the upcoming MCS unlock operation.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		next = READ_ONCE(node-&gt;next);</span><br><span class="line">		<span class="keyword">if</span> (next)</span><br><span class="line">			prefetchw(next);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * we&#x27;re at the head of the waitqueue, wait for the owner &amp; pending to</span></span><br><span class="line"><span class="comment">	 * go away.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * *,x,y -&gt; *,0,0</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * this wait loop must use a load-acquire such that we match the</span></span><br><span class="line"><span class="comment">	 * store-release that clears the locked bit and create lock</span></span><br><span class="line"><span class="comment">	 * sequentiality; this is because the set_locked() function below</span></span><br><span class="line"><span class="comment">	 * does not imply a full barrier.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The PV pv_wait_head_or_lock function, if active, will acquire</span></span><br><span class="line"><span class="comment">	 * the lock and return a non-zero value. So we have to skip the</span></span><br><span class="line"><span class="comment">	 * atomic_cond_read_acquire() call. As the next PV queue head hasn&#x27;t</span></span><br><span class="line"><span class="comment">	 * been designated yet, there is no way for the locked value to become</span></span><br><span class="line"><span class="comment">	 * _Q_SLOW_VAL. So both the set_locked() and the</span></span><br><span class="line"><span class="comment">	 * atomic_cmpxchg_relaxed() calls will be safe.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If PV isn&#x27;t active, 0 will be returned instead.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((val = pv_wait_head_or_lock(lock, node)))</span><br><span class="line">		<span class="keyword">goto</span> locked;</span><br><span class="line"></span><br><span class="line">	val = atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_PENDING_MASK));</span><br><span class="line"></span><br><span class="line">locked:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * claim the lock:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * n,0,0 -&gt; 0,0,1 : lock, uncontended</span></span><br><span class="line"><span class="comment">	 * *,*,0 -&gt; *,*,1 : lock, contended</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If the queue head is the only one in the queue (lock value == tail)</span></span><br><span class="line"><span class="comment">	 * and nobody is pending, clear the tail code and grab the lock.</span></span><br><span class="line"><span class="comment">	 * Otherwise, we only need to grab the lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In the PV case we might already have _Q_LOCKED_VAL set, because</span></span><br><span class="line"><span class="comment">	 * of lock stealing; therefore we must also allow:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * n,0,1 -&gt; 0,0,1</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Note: at this point: (val &amp; _Q_PENDING_MASK) == 0, because of the</span></span><br><span class="line"><span class="comment">	 *       above wait condition, therefore any concurrent setting of</span></span><br><span class="line"><span class="comment">	 *       PENDING will make the uncontended transition fail.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((val &amp; _Q_TAIL_MASK) == tail) &#123;</span><br><span class="line">		<span class="keyword">if</span> (atomic_try_cmpxchg_relaxed(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL))</span><br><span class="line">			<span class="keyword">goto</span> release; <span class="comment">/* No contention */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Either somebody is queued behind us or _Q_PENDING_VAL got set</span></span><br><span class="line"><span class="comment">	 * which will then detect the remaining tail and queue behind us</span></span><br><span class="line"><span class="comment">	 * ensuring we&#x27;ll see a @next.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_locked(lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * contended path; wait for next if not observed yet, release.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!next)</span><br><span class="line">		next = smp_cond_load_relaxed(&amp;node-&gt;next, (VAL));</span><br><span class="line"></span><br><span class="line">	arch_mcs_spin_unlock_contended(&amp;next-&gt;locked);</span><br><span class="line">	pv_kick_node(lock, next);</span><br><span class="line"></span><br><span class="line">release:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * release the node</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__this_cpu_dec(qnodes[<span class="number">0</span>].mcs.count);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(queued_spin_lock_slowpath);</span><br></pre></td></tr></table></figure>

<h3 id="RT-1"><a href="#RT-1" class="headerlink" title="RT"></a>RT</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> __rt_spin_lock(<span class="type">spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	rtlock_might_resched();</span><br><span class="line">	rtlock_lock(&amp;lock-&gt;lock);</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	migrate_disable();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __sched <span class="title function_">rt_spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	__rt_spin_lock(lock);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(rt_spin_lock);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">spin_lock</span><span class="params">(<span class="type">spinlock_t</span> *lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	rt_spin_lock(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RW-read-x2F-write-spinlock"><a href="#RW-read-x2F-write-spinlock" class="headerlink" title="RW (read&#x2F;write) spinlock"></a>RW (read&#x2F;write) spinlock</h1><ol>
<li>如果临界区没有任何thread，则任何read thread或write thread都可以进入</li>
<li>如果临界区有一个read thread，则新来的read thread可以任意进入，凡事write thread不可以进入</li>
<li>如果临界区有一个write thread，则任何read thread和write thread都不可以进入</li>
<li>如果临界区有一个或者多个read thread，write thread不可以进入临界区，但是该write thread也无法阻止后续的read thread进入，它要一直等待临界区的read thread执行完毕，才可以进入。</li>
</ol>
<p>rw spinlock 赋予 read 更高的优先级</p>
<h1 id="seqlock-顺序锁"><a href="#seqlock-顺序锁" class="headerlink" title="seqlock 顺序锁"></a>seqlock 顺序锁</h1><ol>
<li>如果临界区没有任何thread，则任何read thread或write thread都可以进入</li>
<li>如果临界区有一个read thread，则read thread可以任意进入</li>
<li>如果临界区有一个write thread，则任何read thread和write thread都不可以进入</li>
<li>如果临界区只有read thread，write thread可以立刻执行，不会等待</li>
</ol>
<p>seqlock 赋予 write 更高的优先级</p>
<h1 id="spinlock的不足"><a href="#spinlock的不足" class="headerlink" title="spinlock的不足"></a>spinlock的不足</h1><p>rw spinlock、seqlock和spinlock，它们都是基于一个memory中的共享变量（对该变量的访问是原子的）</p>
<p>当CPU一级缓存中的锁失效，就会往二级、三级、内存中去读取lock值，会造成性能浪费。</p>
<h1 id="RCU"><a href="#RCU" class="headerlink" title="RCU"></a>RCU</h1><p>Read Copy Update，克服了以上锁的缺点，具有很好的扩展性，但是这种锁机制的使用范围比较窄，它只适用于读多写少的情况，如网络路由表的查询更新、设备状态表的维护、数据结构的延迟释放以及多径I&#x2F;O设备的维护等</p>
]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>buddy和slab算法</title>
    <url>/posts/9bde40d5.html</url>
    <content><![CDATA[<h1 id="buddy"><a href="#buddy" class="headerlink" title="buddy"></a>buddy</h1><p>内核使用struct page结构体描述每个物理页，也叫页框。</p>
<p>内核在很多情况下，需要申请连续的页框，而且数量不定，比如4个、5个、9个等。</p>
<p>Linux把所有空闲的页框分组为11个块链表，每个链表上的页框是固定的。在第i条链表中每个页框都包含2的i次方个连续页。</p>
<p>系统每个页框块的第一个页框的物理地址是该块大小的整数倍。例如大小为16个页框的块，其起始地址是10*2^12的倍数</p>
<h2 id="页框操作"><a href="#页框操作" class="headerlink" title="页框操作"></a>页框操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配2^order个连续的物理页，并返回一个指针，指向第一个页的page结构体</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *<span class="title function_">alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br><span class="line"><span class="comment">// 返回page页面所映射的虚拟地址</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">page_address</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span>;</span><br></pre></td></tr></table></figure>

<p>Buddy提供了以page为单位的内存分配接口，这对内核来说颗粒度还太大了，所以需要一种新的机制，将page拆分为更小的单位来管理。</p>
<h1 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h1><h2 id="slab实现了内存的分配和管理"><a href="#slab实现了内存的分配和管理" class="headerlink" title="slab实现了内存的分配和管理"></a>slab实现了内存的分配和管理</h2><p>slab层把不同的对象划分为高速缓存组(cache)，其中每个高速缓存都存放不同类型的对象。每个对象对应一个高速缓存(cache)。例如一个高速缓存存放task_struct结构体，而另外一个高速缓存存放struct inode结构体。slab由一个或者多个物理页组成，每个高速缓存由多个slab组成。</p>
<p>slab分配器的基本思想是，先利用页面分配器分配出单个或者一组连续的物理页面，然后在此基础上将整块页面分割成多个相等的小内存单元，以满足小内存空间分配的需要。当然，为了有效的管理这些小的内存单元并保证极高的内存使用速度和效率。</p>
<p>在内核中，经常会使用一些链表，链表中会申请许多相同结构的结构体，比如文件对象，进程对象等等，如果申请比较频繁，那么为它们建立一个内存池，内存池中都是相同结构的结构体，当想申请这种结构体时，直接从这种内存池中取一个结构体出来，是有用且速度极快的。一个物理页就可以作用这种内存池的载体，进而进行充分利用，减少了内部碎片的产生。</p>
<p>所以，Slab 相当于内存池思想，且是为了解决内碎片而产生的，slab的核心思想是以对象的观点管理内存。</p>
<p>所谓的对象就是存放一组数据结构的内存区，为便于理解可把对象看作内核中的数据结构（例如：task_struct,file_struct 等）。</p>
<p>相同类型的对象归为一类，每当要申请这样一个对象时，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免内部碎片。</p>
<p>slab为这样的对象创建一个cache，即缓存。每个cache所占的内存区又被划分多个slab，每个 slab是由一个或多个连续的页框组成。每个页框中包含若干个对象，既有已经分配的对象，也包含空闲的对象。</p>
<p>尽管英文中使用了Cache这个词，但实际上指的是内存中的区域，而不是指硬件高速缓存</p>
<p><img src="https://img.ansore.de/2022/06/06/03498bdf04627edc92657e10e76abbcf.png" alt="slab"></p>
<p>最高层是 cache_chain,这是一个 slab 缓存的链接列表。可以用来查找最适合所需要的分配大小的缓存（遍历列表）<br>cache_chain 的每个元素都是一个 kmem_cache 结构的引用（称为一个 cache）。它定义了一个要管理的给定大小的对象池。</p>
<p>kmem_cache： 内存池</p>
<p>slab：内存池从系统申请内存的基本单位</p>
<p>object：内存池提供的内存的单位</p>
<p>每个缓存(kmem_cache)都包含了一个 slabs 列表，这是一段连续的内存块（通常都是页面）<br>其中每个kmem_cache有三条链表</p>
<p>slabs_full：所有对象已分配</p>
<p>slabs_partial：部分对象已分配</p>
<p>slabs_free：对象未分配</p>
<p>查看slab高速缓存分配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /proc/slabinfo</span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span><br><span class="line">nf_conntrack         975    975    320   25    2 : tunables    0    0    0 : slabdata     39     39      0</span><br><span class="line">ext4_fc_dentry_update      0      0     96   42    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">ext4_inode_cache     189    189   1200   27    8 : tunables    0    0    0 : slabdata      7      7      0</span><br><span class="line">ext4_allocation_context      0      0    144   28    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">ext4_io_end            0      0     64   64    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">ext4_extent_status    612    612     40  102    1 : tunables    0    0    0 : slabdata      6      6      0</span><br><span class="line">jbd2_journal_handle    219    219     56   73    1 : tunables    0    0    0 : slabdata      3      3      0</span><br><span class="line">jbd2_journal_head    102    102    120   34    1 : tunables    0    0    0 : slabdata      3      3      0</span><br><span class="line">jbd2_revoke_table_s    512    512     16  256    1 : tunables    0    0    0 : slabdata      2      2      0</span><br><span class="line">jbd2_revoke_record_s      0      0     32  128    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">kvm_async_pf           0      0    136   30    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">kvm_vcpu               1      1  10944    1    4 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">kvm_mmu_page_header      0      0    184   22    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">x86_emulator          12     12   2688   12    8 : tunables    0    0    0 : slabdata      1      1      0最高层是 cache_chain,这是一个 slab 缓存的链接列表。可以用来查找最适合所需要的分配大小的缓存（遍历列表）</span><br><span class="line">cache_chain 的每个元素都是一个 kmem_cache 结构的引用（称为一个 cache）。它定义了一个要管理的给定大小的对象池。</span><br></pre></td></tr></table></figure>

<h2 id="slab机制要解决的问题"><a href="#slab机制要解决的问题" class="headerlink" title="slab机制要解决的问题"></a>slab机制要解决的问题</h2><ol>
<li>减少伙伴算法在分配小块连续内存时所产生的碎片</li>
<li>将频繁使用的对象缓存起来，减少分配、初始化和释放对象的时间开销</li>
<li>通过着色技术调整对象以更好的使用硬件高速缓存</li>
</ol>
<h2 id="slab操作函数"><a href="#slab操作函数" class="headerlink" title="slab操作函数"></a>slab操作函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建高速缓存 name:高速缓存名 size:大小 align:对齐大小 </span></span><br><span class="line"><span class="keyword">struct</span> kmem_cache *<span class="title function_">kmem_cache_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> align,</span></span><br><span class="line"><span class="params">		<span class="type">slab_flags_t</span> flags, <span class="type">void</span> (*ctor)(<span class="type">void</span> *))</span>;</span><br><span class="line"><span class="comment">// 从高速缓存中申请内存 s:高速缓存结构体 gfpflags:内存不同申请场景</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmem_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags)</span>;</span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_destroy</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个指向内存块的指针，其内存块大小至少为size，反分配的内存在物理上是连续的</span></span><br><span class="line"><span class="type">static</span> __always_inline __alloc_size(<span class="number">1</span>) <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br><span class="line"><span class="comment">// 内存空间值为0</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __alloc_size(<span class="number">1</span>) <span class="type">void</span> *<span class="title function_">kzalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// vmalloc返回一个执行内存块的指针，其内存大小至少为size，所分配的内存在物理上无需连续</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="comment">// 内存空间值为0</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">vzalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th></th>
<th>vmalloc&#x2F;vfree</th>
<th>虚拟连续,物理不定</th>
<th>vmalloc区限制大小</th>
<th>页VMALLOC区</th>
<th>可能睡眠，不能从中断上下文中调用。VMALLOC区域vmalloc_start~vmalloc_end之间，vmalloc比kmalloc慢，适用于分配大内存</th>
</tr>
</thead>
<tbody><tr>
<td>slab</td>
<td>kmalloc&#x2F;kcalloc&#x2F;krealloc&#x2F;kfree</td>
<td>物理连续</td>
<td>64B-4MB(随slab而变)</td>
<td>2^order字节Normal区域</td>
<td>大小有限，不如vmalloc&#x2F;malloc大。最大&#x2F;最小值由KMALLOC_MIN_SIZE&#x2F;KMALLOC_SHIFT_MAX，对应64B、4MB。从&#x2F;proc&#x2F;slabinfo中的kmalloc-xxx中分配，建立在kmem_cache_create基础之上</td>
</tr>
<tr>
<td>slab</td>
<td>kmem_cache_create</td>
<td>物理连续</td>
<td>64B-4MB</td>
<td>字节大小，需对齐，Normal区域</td>
<td>便于固定大小数据的频繁分配和释放，分配时从缓存池中获取地址，释放时也不一定真正释放内存。通过slab进行管理</td>
</tr>
<tr>
<td>buddy</td>
<td>__get_free_page&#x2F;__get_free_pages</td>
<td>物理连续</td>
<td>4MB(1024页)</td>
<td>页，Normal区域</td>
<td>__get_free_pages基于alloc_pages，但是限定不能使用HIGHMEM</td>
</tr>
<tr>
<td>buddy</td>
<td>alloc_page&#x2F;alloc_pages&#x2F;free_pages</td>
<td>物理连续</td>
<td>4MB</td>
<td>页,Normal区域&#x2F;Vmalloc都可</td>
<td>CONFIG_FORCE_MAX_ZONEORDER定义了最大页面数2^11，一次能分配到的最大页面数为1024</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF文件详解</title>
    <url>/posts/cb38f45.html</url>
    <content><![CDATA[<p>在Linux系统中，一个ELF文件主要用来表示3种类型的文件：</p>
<ol>
<li>可执行文件。操作系统的加载器从硬盘上读取，载入内存中执行；</li>
<li>目标文件（*.o）。链接器读取，用来生成一个可执行文件或者共享库文件；</li>
<li>共享文件（*.so）。在动态链接的时候，由<code>ld-linux.so</code>来读取；</li>
</ol>
<p>每个ELF文件可以拆成四部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------</span><br><span class="line">ELF Header</span><br><span class="line">---------------------</span><br><span class="line">Program Header Table</span><br><span class="line">---------------------</span><br><span class="line">Sections</span><br><span class="line">---------------------</span><br><span class="line">Section Header Table</span><br><span class="line">---------------------</span><br></pre></td></tr></table></figure>

<ul>
<li><p>链接器只关心<code>ELF header</code>、<code>Sections</code>以及<code>Section Header Table</code>这三部分；</p>
</li>
<li><p>加载器只关心 <code>ELF header</code>、<code>Program header table</code> 和 <code>Segment</code> 这三部分；中间部分的Sections，叫做<code>Segments</code>，本质上是一样的。</p>
</li>
</ul>
<p>一个<code>Segment</code>可能包含一个或者多个<code>Sections</code></p>
<h1 id="ELF的描述"><a href="#ELF的描述" class="headerlink" title="ELF的描述"></a>ELF的描述</h1><p>定义头文件在<code>include/uapi/linux/elf.h</code>下。</p>
<p>描述ELF Header的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT	16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_hdr</span>&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	e_ident[EI_NIDENT];</span><br><span class="line">  Elf32_Half	e_type;</span><br><span class="line">  Elf32_Half	e_machine;</span><br><span class="line">  Elf32_Word	e_version;</span><br><span class="line">  Elf32_Addr	e_entry;  <span class="comment">/* Entry point */</span></span><br><span class="line">  Elf32_Off	e_phoff;</span><br><span class="line">  Elf32_Off	e_shoff;</span><br><span class="line">  Elf32_Word	e_flags;</span><br><span class="line">  Elf32_Half	e_ehsize;</span><br><span class="line">  Elf32_Half	e_phentsize;</span><br><span class="line">  Elf32_Half	e_phnum;</span><br><span class="line">  Elf32_Half	e_shentsize;</span><br><span class="line">  Elf32_Half	e_shnum;</span><br><span class="line">  Elf32_Half	e_shstrndx;</span><br><span class="line">&#125; Elf32_Ehdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_hdr</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>	e_ident[EI_NIDENT];	<span class="comment">/* ELF &quot;magic number&quot; */</span></span><br><span class="line">  Elf64_Half e_type;</span><br><span class="line">  Elf64_Half e_machine;</span><br><span class="line">  Elf64_Word e_version;</span><br><span class="line">  Elf64_Addr e_entry;		<span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off e_phoff;		<span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off e_shoff;		<span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word e_flags;</span><br><span class="line">  Elf64_Half e_ehsize;</span><br><span class="line">  Elf64_Half e_phentsize;</span><br><span class="line">  Elf64_Half e_phnum;</span><br><span class="line">  Elf64_Half e_shentsize;</span><br><span class="line">  Elf64_Half e_shnum;</span><br><span class="line">  Elf64_Half e_shstrndx;</span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>

<p>描述Program Header Table的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_phdr</span>&#123;</span></span><br><span class="line">  Elf32_Word	p_type;</span><br><span class="line">  Elf32_Off	p_offset;</span><br><span class="line">  Elf32_Addr	p_vaddr;</span><br><span class="line">  Elf32_Addr	p_paddr;</span><br><span class="line">  Elf32_Word	p_filesz;</span><br><span class="line">  Elf32_Word	p_memsz;</span><br><span class="line">  Elf32_Word	p_flags;</span><br><span class="line">  Elf32_Word	p_align;</span><br><span class="line">&#125; Elf32_Phdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_phdr</span> &#123;</span></span><br><span class="line">  Elf64_Word p_type;</span><br><span class="line">  Elf64_Word p_flags;</span><br><span class="line">  Elf64_Off p_offset;		<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf64_Addr p_vaddr;		<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf64_Addr p_paddr;		<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf64_Xword p_filesz;		<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf64_Xword p_memsz;		<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf64_Xword p_align;		<span class="comment">/* Segment alignment, file &amp; memory */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>

<p>描述Section Header Table的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_shdr</span> &#123;</span></span><br><span class="line">  Elf32_Word	sh_name;</span><br><span class="line">  Elf32_Word	sh_type;</span><br><span class="line">  Elf32_Word	sh_flags;</span><br><span class="line">  Elf32_Addr	sh_addr;</span><br><span class="line">  Elf32_Off	sh_offset;</span><br><span class="line">  Elf32_Word	sh_size;</span><br><span class="line">  Elf32_Word	sh_link;</span><br><span class="line">  Elf32_Word	sh_info;</span><br><span class="line">  Elf32_Word	sh_addralign;</span><br><span class="line">  Elf32_Word	sh_entsize;</span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_shdr</span> &#123;</span></span><br><span class="line">  Elf64_Word sh_name;		<span class="comment">/* Section name, index in string tbl */</span></span><br><span class="line">  Elf64_Word sh_type;		<span class="comment">/* Type of section */</span></span><br><span class="line">  Elf64_Xword sh_flags;		<span class="comment">/* Miscellaneous section attributes */</span></span><br><span class="line">  Elf64_Addr sh_addr;		<span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off sh_offset;		<span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword sh_size;		<span class="comment">/* Size of section in bytes */</span></span><br><span class="line">  Elf64_Word sh_link;		<span class="comment">/* Index of another section */</span></span><br><span class="line">  Elf64_Word sh_info;		<span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword sh_addralign;	<span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword sh_entsize;	<span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>

<h1 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a>ELF Header</h1><p>ELF文件头部内容，决定了这个完整的ELF文件的所有信息：</p>
<ol>
<li>标志这是个ELF文件</li>
<li>版本、文件类型、机器类型等一些基本信息</li>
<li>Program Header Table的开始地址，在整个文件的什么地方</li>
<li>Section Header Table的开始地址，在整个文件的什么地方</li>
</ol>
<p>一个ELF文件中，存在多个Sections，这些Sections的具体信息，实在Program Header Table或者Section Header Table中进行描述的。如Section Header Table：</p>
<p>假如一个ELF文件中一共存在4个Section：.text、.rodata、.data、.bss，那么在 section header table中。将会有4个Entry来分别描述这4个Section的具体信息（严格来说不止4个Entry，还会有其他的辅助Sections）</p>
<h2 id="具体代码示例"><a href="#具体代码示例" class="headerlink" title="具体代码示例"></a>具体代码示例</h2><p><code>mymath.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">my_add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">   <span class="type">int</span> k = my_add(i, j);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;k = %d \n&quot;</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc mymath.c --shared -fPIC -o libmymath.so</span><br><span class="line">-fPIC参数声明链接库的代码段是可以共享的</span><br><span class="line">-shared参数声明编译为共享库。</span><br><span class="line"></span><br><span class="line">gcc main.c -o main -L. -lmymath</span><br><span class="line">-L参数指定到哪个附加路径下面去寻找共享库，现在我们指定在当前目录下面寻找；</span><br><span class="line">-l参数指定链接的共享库名</span><br><span class="line">-I参数是指明头文件路径</span><br></pre></td></tr></table></figure>

<p>编译出可执行文件<code>main</code>。使用<code>readelf -h main</code>来看一下<code>ELF header</code>的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&#x27;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Position-Independent Executable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x1050</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          18208 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         13</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         37</span><br><span class="line">  Section header string table index: 36</span><br></pre></td></tr></table></figure>

<p>这个显示的就是ELF Header描述的所有内容。这个内容与结构体的成员变量是一一对应的。</p>
<p>这个头信息中有显示：<code>Size of this header: 64 (bytes)</code>，也就是说ELF Header部分的内容，一共是52字节。</p>
<p>使用<code>od -Ax -t x1 -N 64 main</code>指令来读取main中的字节码</p>
<blockquote>
<p>-Ax ，显示地址的时候，用十六进制来表示。如果使用 -Ad，意思就是用十进制来显示地址;</p>
<p>-t x1，显示字节码内容的时候，使用十六进制(x)，每次显示一个字节(1);</p>
<p>-N 64，只需要读取 64 个字节;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000000 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">000010 03 00 3e 00 01 00 00 00 50 10 00 00 00 00 00 00</span><br><span class="line">000020 40 00 00 00 00 00 00 00 20 47 00 00 00 00 00 00</span><br><span class="line">000030 00 00 00 00 40 00 38 00 0d 00 40 00 25 00 24 00</span><br><span class="line">000040</span><br></pre></td></tr></table></figure>

<p>在结构体中的第一个成员是 <code>unsigned char e_ident[EI_NIDENT];</code>，<code>EI_NIDENT</code> 的长度是 <code>16</code>，代表了 <code>EL header </code>中的开始 <code>16</code> 个字节，具体含义如下：</p>
<p><strong>0～16字节</strong>：</p>
<p><img src="https://img.ansore.de/2022/06/26/ea0d7614b4aeff35a6966c7d15734103.png" alt="Image"></p>
<p>官方文档如下：</p>
<p><img src="https://img.ansore.de/2022/06/26/967ba6440192b17e30d6efabad06ca6a.png" alt="Image"></p>
<p><strong>16～31字节</strong>：</p>
<ul>
<li><code>03 00</code>：<code>e_type</code>表示ELF的文件类型，<code>0x0003</code>表示 DYN (Position-Independent Executable file)。</li>
</ul>
<p>可取的类型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* These constants define the different elf file types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_NONE   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_REL    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_EXEC   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_DYN    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_CORE   4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_LOPROC 0xff00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ET_HIPROC 0xffff</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>3e 00</code>：<code>e_machine</code>表示目标体系结构类型。<code>0x003e</code>表示<code>EM_X86_64</code></li>
</ul>
<p>可取体系类型r如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* These constants define the various ELF target machines */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_NONE		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_M32		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_SPARC	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_386		3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_68K		4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_88K		5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_486		6	<span class="comment">/* Perhaps disused */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_860		7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_MIPS		8	<span class="comment">/* MIPS R3000 (officially, big-endian only) */</span></span></span><br><span class="line">				<span class="comment">/* Next two are historical and binaries and</span></span><br><span class="line"><span class="comment">				   modules of these types will be rejected by</span></span><br><span class="line"><span class="comment">				   Linux.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_MIPS_RS3_LE	10	<span class="comment">/* MIPS R3000 little-endian */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_MIPS_RS4_BE	10	<span class="comment">/* MIPS R4000 big-endian */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_PARISC	15	<span class="comment">/* HPPA */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_SPARC32PLUS	18	<span class="comment">/* Sun&#x27;s &quot;v8plus&quot; */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_PPC		20	<span class="comment">/* PowerPC */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_PPC64	21	 <span class="comment">/* PowerPC64 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_SPU		23	<span class="comment">/* Cell BE SPU */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_ARM		40	<span class="comment">/* ARM 32 bit */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_SH		42	<span class="comment">/* SuperH */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_SPARCV9	43	<span class="comment">/* SPARC v9 64-bit */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_H8_300	46	<span class="comment">/* Renesas H8/300 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_IA_64	50	<span class="comment">/* HP/Intel IA-64 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_X86_64	62	<span class="comment">/* AMD x86-64 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_S390		22	<span class="comment">/* IBM S/390 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_CRIS		76	<span class="comment">/* Axis Communications 32-bit embedded processor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_M32R		88	<span class="comment">/* Renesas M32R */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_MN10300	89	<span class="comment">/* Panasonic/MEI MN10300, AM33 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_OPENRISC     92     <span class="comment">/* OpenRISC 32-bit embedded processor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_ARCOMPACT	93	<span class="comment">/* ARCompact processor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_XTENSA	94	<span class="comment">/* Tensilica Xtensa Architecture */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_BLACKFIN     106     <span class="comment">/* ADI Blackfin Processor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_UNICORE	110	<span class="comment">/* UniCore-32 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_ALTERA_NIOS2	113	<span class="comment">/* Altera Nios II soft-core processor */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_TI_C6000	140	<span class="comment">/* TI C6X DSPs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_HEXAGON	164	<span class="comment">/* QUALCOMM Hexagon */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_NDS32	167	<span class="comment">/* Andes Technology compact code size</span></span></span><br><span class="line"><span class="comment"><span class="meta">				   embedded RISC processor family */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_AARCH64	183	<span class="comment">/* ARM 64 bit */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_TILEPRO	188	<span class="comment">/* Tilera TILEPro */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_MICROBLAZE	189	<span class="comment">/* Xilinx MicroBlaze */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_TILEGX	191	<span class="comment">/* Tilera TILE-Gx */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_ARCV2	195	<span class="comment">/* ARCv2 Cores */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_RISCV	243	<span class="comment">/* RISC-V */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_BPF		247	<span class="comment">/* Linux BPF - in-kernel virtual machine */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_CSKY		252	<span class="comment">/* C-SKY */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_FRV		0x5441	<span class="comment">/* Fujitsu FR-V */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is an interim value that we will use until the committee comes</span></span><br><span class="line"><span class="comment"> * up with a final number.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_ALPHA	0x9026</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bogus old m32r magic number, used by old tools. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_CYGNUS_M32R	0x9041</span></span><br><span class="line"><span class="comment">/* This is the old interim value for S/390 architecture */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_S390_OLD	0xA390</span></span><br><span class="line"><span class="comment">/* Also Panasonic/MEI MN10300, AM33 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EM_CYGNUS_MN10300 0xbeef</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>01 00 00 00</code>：<code>e_version</code>文件版本。0：无效版本；1：当前版本。</p>
</li>
<li><p><code>50 10 00 00 00 00 00 00</code>：8字节的<code>e_entry</code>是程序的入口地址，<code>readelf</code>的<code>Entry point address:0x1050</code>也指明了程序入口地址。</p>
</li>
</ul>
<p><strong>32~48字节</strong>：</p>
<ul>
<li><code>40 00 00 00 00 00 00 00</code>：<code>e_phoff</code>，<code>Program head table</code>在ELF文件中的偏移量。<code>0x40</code>就是说从第64字节开始。就是从程序头表开始位置。</li>
<li><code>20 47 00 00 00 00 00 00</code>：<code>e_shoff</code>，<code>Section Header Table</code>在ELF文件中的偏移量。<code>0x4720</code>表示从18208字节开始，就是节头表的开始位置。</li>
</ul>
<p><strong>48~64字节</strong>：</p>
<ul>
<li><p><code>00 00 00 00</code>：<code>e_flags</code>，保存与文件相关，处理器相关标志</p>
</li>
<li><p><code>40 00</code>：<code>e_ehsize</code>，ELF Header数据的长度，64字节。</p>
</li>
<li><p><code>38 00</code>：<code>e_phentsize</code>，<code>Program head table</code>中每个表项<code>entry</code>的长度，<code>0x38</code>为56字节</p>
</li>
<li><p><code>0d 00</code>：<code>e_phnum</code>，<code>Program head table</code>中有多少个表项<code>entry</code>，<code>0x0d</code>表示一共有13个表项</p>
</li>
<li><p><code>40 00</code>：<code>e_shentsize</code>，<code>Section header table</code>中每个表项<code>entry</code>的长度，<code>0x40</code>为64字节</p>
</li>
<li><p><code>25 00</code>：<code>e_shnum</code>，<code>Section header table</code>中有多少个表项<code>entry</code>，<code>0x25</code>表示一共有37个表项</p>
</li>
<li><p><code>24 00</code>：<code>e_shstrndx</code>，字符串表<code>entry</code>在节区表中的索引，<code>0x24</code>表示第36个<code>entry</code>描述的字符串表这个<code>section</code></p>
</li>
</ul>
<h1 id="字符串表表项-Entry"><a href="#字符串表表项-Entry" class="headerlink" title="字符串表表项 Entry"></a>字符串表表项 Entry</h1><p>在一个 <code>ELF</code> 文件中，存在很多字符串，例如：变量名、Section名称、链接器加入的符号等等，这些字符串的长度都是不固定的，因此用一个固定的结构来表示这些字符串，肯定是不现实的。于是就把这些字符串集中起来，统一放在一起，作为一个独立的 <code>Section</code> 来进行管理。</p>
<p>在文件中的其他地方呢，如果想表示一个字符串，就在这个地方写一个数字索引：表示这个字符串位于字符串统一存储地方的某个偏移位置，经过这样的按图索骥，就可以找到这个具体的字符串了。</p>
<p>如下面这个空间中存储了所有的字符串：</p>
<p><img src="https://img.ansore.de/2022/06/26/c7156780b70ea13f06355b23b5710609.png" alt="Image"></p>
<p>在程序的其他地方，如果想引用字符串 “hello,world!”，那么就只需要在那个地方标明数字 <code>13</code> 就可以了，表示：这个字符串从偏移 13 个字节处开始。</p>
<p>使用指令<code>readelf -S main</code>查看ELF文件中所有的<code>Section</code>信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are 37 section headers, starting at offset 0x4720:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .interp           PROGBITS         0000000000000318  00000318</span><br><span class="line">       000000000000001c  0000000000000000   A       0     0     1</span><br><span class="line">  [ 2] .note.gnu.pr[...] NOTE             0000000000000338  00000338</span><br><span class="line">       0000000000000040  0000000000000000   A       0     0     8</span><br><span class="line">  [ 3] .note.gnu.bu[...] NOTE             0000000000000378  00000378</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [ 4] .note.ABI-tag     NOTE             000000000000039c  0000039c</span><br><span class="line">       0000000000000020  0000000000000000   A       0     0     4</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH         00000000000003c0  000003c0</span><br><span class="line">       000000000000001c  0000000000000000   A       6     0     8</span><br><span class="line">  [ 6] .dynsym           DYNSYM           00000000000003e0  000003e0</span><br><span class="line">       00000000000000c0  0000000000000018   A       7     1     8</span><br><span class="line">  [ 7] .dynstr           STRTAB           00000000000004a0  000004a0</span><br><span class="line">       00000000000000a3  0000000000000000   A       0     0     1</span><br><span class="line">  [ 8] .gnu.version      VERSYM           0000000000000544  00000544</span><br><span class="line">       0000000000000010  0000000000000002   A       6     0     2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED          0000000000000558  00000558</span><br><span class="line">       0000000000000030  0000000000000000   A       7     1     8</span><br><span class="line">  [10] .rela.dyn         RELA             0000000000000588  00000588</span><br><span class="line">       00000000000000c0  0000000000000018   A       6     0     8</span><br><span class="line">  [11] .rela.plt         RELA             0000000000000648  00000648</span><br><span class="line">       0000000000000030  0000000000000018  AI       6    23     8</span><br><span class="line">  [12] .init             PROGBITS         0000000000001000  00001000</span><br><span class="line">       000000000000001b  0000000000000000  AX       0     0     4</span><br><span class="line">  [13] .plt              PROGBITS         0000000000001020  00001020</span><br><span class="line">       0000000000000030  0000000000000010  AX       0     0     16</span><br><span class="line">  [14] .text             PROGBITS         0000000000001050  00001050</span><br><span class="line">       0000000000000141  0000000000000000  AX       0     0     16</span><br><span class="line">  [15] .fini             PROGBITS         0000000000001194  00001194</span><br><span class="line">       000000000000000d  0000000000000000  AX       0     0     4</span><br><span class="line">  [16] .rodata           PROGBITS         0000000000002000  00002000</span><br><span class="line">       000000000000000d  0000000000000000   A       0     0     4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS         0000000000002010  00002010</span><br><span class="line">       0000000000000024  0000000000000000   A       0     0     4</span><br><span class="line">  [18] .eh_frame         PROGBITS         0000000000002038  00002038</span><br><span class="line">       000000000000007c  0000000000000000   A       0     0     8</span><br><span class="line">  [19] .init_array       INIT_ARRAY       0000000000003dd8  00002dd8</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [20] .fini_array       FINI_ARRAY       0000000000003de0  00002de0</span><br><span class="line">       0000000000000008  0000000000000008  WA       0     0     8</span><br><span class="line">  [21] .dynamic          DYNAMIC          0000000000003de8  00002de8</span><br><span class="line">       00000000000001f0  0000000000000010  WA       7     0     8</span><br><span class="line">  [22] .got              PROGBITS         0000000000003fd8  00002fd8</span><br><span class="line">       0000000000000028  0000000000000008  WA       0     0     8</span><br><span class="line">  [23] .got.plt          PROGBITS         0000000000004000  00003000</span><br><span class="line">       0000000000000028  0000000000000008  WA       0     0     8</span><br><span class="line">  [24] .data             PROGBITS         0000000000004028  00003028</span><br><span class="line">       0000000000000010  0000000000000000  WA       0     0     8</span><br><span class="line">  [25] .bss              NOBITS           0000000000004038  00003038</span><br><span class="line">       0000000000000008  0000000000000000  WA       0     0     1</span><br><span class="line">  [26] .comment          PROGBITS         0000000000000000  00003038</span><br><span class="line">       0000000000000012  0000000000000001  MS       0     0     1</span><br><span class="line">  [27] .debug_aranges    PROGBITS         0000000000000000  00003050</span><br><span class="line">       00000000000000f0  0000000000000000           0     0     16</span><br><span class="line">  [28] .debug_info       PROGBITS         0000000000000000  00003140</span><br><span class="line">       0000000000000585  0000000000000000           0     0     1</span><br><span class="line">  [29] .debug_abbrev     PROGBITS         0000000000000000  000036c5</span><br><span class="line">       0000000000000198  0000000000000000           0     0     1</span><br><span class="line">  [30] .debug_line       PROGBITS         0000000000000000  0000385d</span><br><span class="line">       00000000000001da  0000000000000000           0     0     1</span><br><span class="line">  [31] .debug_str        PROGBITS         0000000000000000  00003a37</span><br><span class="line">       0000000000000471  0000000000000001  MS       0     0     1</span><br><span class="line">  [32] .debug_line_str   PROGBITS         0000000000000000  00003ea8</span><br><span class="line">       000000000000013e  0000000000000001  MS       0     0     1</span><br><span class="line">  [33] .debug_rnglists   PROGBITS         0000000000000000  00003fe6</span><br><span class="line">       0000000000000042  0000000000000000           0     0     1</span><br><span class="line">  [34] .symtab           SYMTAB           0000000000000000  00004028</span><br><span class="line">       0000000000000390  0000000000000018          35    19     8</span><br><span class="line">  [35] .strtab           STRTAB           0000000000000000  000043b8</span><br><span class="line">       00000000000001ed  0000000000000000           0     0     1</span><br><span class="line">  [36] .shstrtab         STRTAB           0000000000000000  000045a5</span><br><span class="line">       0000000000000176  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execut0000000000000176  0000000000000000           0     0     1e), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>

<p>第36个Section描述的就是字符串表Section：<code>[36] .shstrtab STRTAB 0000000000000000 000045a5 0000000000000176 0000000000000000 0 0 1</code> </p>
<p>可以看出这个Section在ELF文件中的偏移地址是<code>000045a5</code>，长度是<code>0000000000000176</code>个字节</p>
<h1 id="读取字符串表Section的内容"><a href="#读取字符串表Section的内容" class="headerlink" title="读取字符串表Section的内容"></a>读取字符串表Section的内容</h1><p>要想打印字符串表 <code>Section</code> 的内容，就必须知道这个 <code>Section</code> 在 <code>ELF</code> 文件中的偏移地址。</p>
<p>要想知道偏移地址，只能从 <code>Section head table</code> 中第 <code>36</code> 个表项描述信息中获取。</p>
<p>要想知道第 <code>28</code> 个表项的地址，就必须知道 <code>Section head table</code> 在 <code>ELF</code> 文件中的开始地址，以及每一个表项的大小</p>
<p>readelf中<code>Start of section headers: 18208 (bytes into file)</code>可知<code>Section head table</code> 的开始地址位于 <code>ELF</code> 文件的第 <code>18208</code> 个字节处。每个表项的长度是64字节。第28个表项的开始地址是：<code>18208+36*64=20512</code>，也就是说用来描述字符串表这个 <code>Section</code> 的表项，位于 <code>ELF</code> 文件的 <code>20512</code> 字节的位置。</p>
<p>执行指令：<code>od -Ad -t x1 -j 20512 -N 64 main</code>。</p>
<p>其中的 <code>-j 20512</code> 选项，表示跳过前面的 <code>20512</code> 个字节，也就是我们从 <code>main</code> 这个 <code>ELF</code> 文件的 <code>20512</code> 字节处开始读取，一共读 <code>64</code> 个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0020512 11 00 00 00 03 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0020528 00 00 00 00 00 00 00 00 a5 45 00 00 00 00 00 00</span><br><span class="line">0020544 76 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0020560 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0020576</span><br></pre></td></tr></table></figure>

<p>这64字节的内容，就对应了<code>Elf64_Shdr</code>结构体中的每个成员变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_shdr</span> &#123;</span></span><br><span class="line">  Elf64_Word sh_name;		<span class="comment">/* 11 00 00 00  */</span></span><br><span class="line">  Elf64_Word sh_type;		<span class="comment">/* 03 00 00 00 */</span></span><br><span class="line">  Elf64_Xword sh_flags;		<span class="comment">/* 00 00 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Addr sh_addr;		<span class="comment">/* 00 00 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Off sh_offset;		<span class="comment">/* a5 45 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Xword sh_size;		<span class="comment">/* 76 01 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Word sh_link;		<span class="comment">/* 00 00 00 00 */</span></span><br><span class="line">  Elf64_Word sh_info;		<span class="comment">/* 00 00 00 00 */</span></span><br><span class="line">  Elf64_Xword sh_addralign;	<span class="comment">/* 01 00 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Xword sh_entsize;	<span class="comment">/* 00 00 00 00 00 00 00 00 */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sh_name</code>: <code>Section</code>的名称;</li>
<li><code>sh_type</code>：表示这个 Section 的类型，3 表示这是一个 <code>string table</code>;</li>
<li><code>sh_offset</code>: 表示这个 Section，在 ELF 文件中的偏移量。<code>0x000045a5</code> &#x3D; 17829，意思是字符串表这个 <code>Section</code> 的内容，从 ELF 文件的 17829 个字节处开始;</li>
<li><code>sh_size</code>：表示这个 <code>Section</code> 的长度。<code>0x00000176</code> &#x3D; 374 个字节，意思是字符串表这个 <code>Section</code> 的内容，一共有 374 个字节。</li>
</ul>
<p>与使用<code>readelf -S main</code>读取出来完全一致。</p>
<p>执行<code>od -Ad -t c -j 17829 -N 374 main</code>即可看到存储的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0017829  \0   .   s   y   m   t   a   b  \0   .   s   t   r   t   a   b</span><br><span class="line">0017845  \0   .   s   h   s   t   r   t   a   b  \0   .   i   n   t   e</span><br><span class="line">0017861   r   p  \0   .   n   o   t   e   .   g   n   u   .   p   r   o</span><br><span class="line">0017877   p   e   r   t   y  \0   .   n   o   t   e   .   g   n   u   .</span><br><span class="line">0017893   b   u   i   l   d   -   i   d  \0   .   n   o   t   e   .   A</span><br><span class="line">0017909   B   I   -   t   a   g  \0   .   g   n   u   .   h   a   s   h</span><br><span class="line">0017925  \0   .   d   y   n   s   y   m  \0   .   d   y   n   s   t   r</span><br><span class="line">0017941  \0   .   g   n   u   .   v   e   r   s   i   o   n  \0   .   g</span><br><span class="line">0017957   n   u   .   v   e   r   s   i   o   n   _   r  \0   .   r   e</span><br><span class="line">0017973   l   a   .   d   y   n  \0   .   r   e   l   a   .   p   l   t</span><br><span class="line">0017989  \0   .   i   n   i   t  \0   .   t   e   x   t  \0   .   f   i</span><br><span class="line">0018005   n   i  \0   .   r   o   d   a   t   a  \0   .   e   h   _   f</span><br><span class="line">0018021   r   a   m   e   _   h   d   r  \0   .   e   h   _   f   r   a</span><br><span class="line">0018037   m   e  \0   .   i   n   i   t   _   a   r   r   a   y  \0   .</span><br><span class="line">0018053   f   i   n   i   _   a   r   r   a   y  \0   .   d   y   n   a</span><br><span class="line">0018069   m   i   c  \0   .   g   o   t  \0   .   g   o   t   .   p   l</span><br><span class="line">0018085   t  \0   .   d   a   t   a  \0   .   b   s   s  \0   .   c   o</span><br><span class="line">0018101   m   m   e   n   t  \0   .   d   e   b   u   g   _   a   r   a</span><br><span class="line">0018117   n   g   e   s  \0   .   d   e   b   u   g   _   i   n   f   o</span><br><span class="line">0018133  \0   .   d   e   b   u   g   _   a   b   b   r   e   v  \0   .</span><br><span class="line">0018149   d   e   b   u   g   _   l   i   n   e  \0   .   d   e   b   u</span><br><span class="line">0018165   g   _   s   t   r  \0   .   d   e   b   u   g   _   l   i   n</span><br><span class="line">0018181   e   _   s   t   r  \0   .   d   e   b   u   g   _   r   n   g</span><br><span class="line">0018197   l   i   s   t   s  \0</span><br><span class="line">0018203</span><br></pre></td></tr></table></figure>

<p><code>sh_name</code>字段是以字符存储，直接存储在这里，索引是<code>0x0011</code>，第17个字节存储的字符为<code>.shstrta</code></p>
<h1 id="读取代码段的内容"><a href="#读取代码段的内容" class="headerlink" title="读取代码段的内容"></a>读取代码段的内容</h1><p>从<code>readelf -S main</code>的输出中可以看到代码段是位于第14个表项中，加载的虚拟地址是<code>0x0000000000001050</code>，它位于 <code>ELF</code> 文件中的偏移量是 <code>0x00001050</code>，长度是 <code>0x0000000000000141</code> 个字节。</p>
<p>计算这个表项 <code>Entry</code> 的地址：<code>18208+14*64=19104</code></p>
<p>读取这个表项 <code>Entry</code>，读取指令是 <code>od -Ad -t x1 -j 19104 -N 64 main</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0019104 a7 00 00 00 01 00 00 00 06 00 00 00 00 00 00 00</span><br><span class="line">0019120 50 10 00 00 00 00 00 00 50 10 00 00 00 00 00 00</span><br><span class="line">0019136 41 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0019152 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0019168</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_shdr</span> &#123;</span></span><br><span class="line">  Elf64_Word sh_name;		<span class="comment">/* a7 00 00 00  */</span></span><br><span class="line">  Elf64_Word sh_type;		<span class="comment">/* 01 00 00 00 */</span></span><br><span class="line">  Elf64_Xword sh_flags;		<span class="comment">/* 00 00 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Addr sh_addr;		<span class="comment">/* 50 10 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Off sh_offset;		<span class="comment">/* 50 10 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Xword sh_size;		<span class="comment">/* 41 01 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Word sh_link;		<span class="comment">/* 00 00 00 00 */</span></span><br><span class="line">  Elf64_Word sh_info;		<span class="comment">/* 00 00 00 00 */</span></span><br><span class="line">  Elf64_Xword sh_addralign;	<span class="comment">/* 01 00 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Xword sh_entsize;	<span class="comment">/* 00 00 00 00 00 00 00 00 */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>sh_name</code>: 表示代码段的名称在字符串表 <code>Section</code> 中的偏移位置。<code>0xa7</code> &#x3D; 167 字节，也就是在字符串表 <code>Section</code> 的第 167 字节处，存储的就是代码段的名字。回过头去找一下，看一下是不是字符串 “.text”;</p>
</li>
<li><p><code>sh_type</code>：表示这个 <code>Section</code> 的类型，1(<code>SHT_PROGBITS</code>) 表示这是代码;</p>
</li>
<li><p><code>sh_addr</code>：表示这个 <code>Section</code> 加载的虚拟地址是 <code>0x1050</code>，这个值与 <code>ELF header</code> 中的 <code>e_entry</code> 字段的值是相同的;</p>
</li>
<li><p><code>sh_offset</code>: 表示这个 <code>Section</code>，在 ELF 文件中的偏移量。<code>0x1050</code> &#x3D; 4176，意思是这个 <code>Section</code> 的内容，从 ELF 文件的 4176 个字节处开始;</p>
</li>
<li><p><code>sh_size</code>：表示这个 <code>Section</code> 的长度。<code>0x0141</code> &#x3D; 321 个字节，意思是代码段一共有 321 个字节。</p>
</li>
</ul>
<p>与指令 <code>readelf -S main</code> 读取出来的完全一样！</p>
<h1 id="Program-Header"><a href="#Program-Header" class="headerlink" title="Program Header"></a>Program Header</h1><p>执行<code>readelf -l main</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Elf file type is DYN (Position-Independent Executable file)</span><br><span class="line">Entry point 0x1050</span><br><span class="line">There are 13 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040</span><br><span class="line">                 0x00000000000002d8 0x00000000000002d8  R      0x8</span><br><span class="line">  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318</span><br><span class="line">                 0x000000000000001c 0x000000000000001c  R      0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000678 0x0000000000000678  R      0x1000</span><br><span class="line">  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000</span><br><span class="line">                 0x00000000000001a1 0x00000000000001a1  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000</span><br><span class="line">                 0x00000000000000b4 0x00000000000000b4  R      0x1000</span><br><span class="line">  LOAD           0x0000000000002dd8 0x0000000000003dd8 0x0000000000003dd8</span><br><span class="line">                 0x0000000000000260 0x0000000000000268  RW     0x1000</span><br><span class="line">  DYNAMIC        0x0000000000002de8 0x0000000000003de8 0x0000000000003de8</span><br><span class="line">                 0x00000000000001f0 0x00000000000001f0  RW     0x8</span><br><span class="line">  NOTE           0x0000000000000338 0x0000000000000338 0x0000000000000338</span><br><span class="line">                 0x0000000000000040 0x0000000000000040  R      0x8</span><br><span class="line">  NOTE           0x0000000000000378 0x0000000000000378 0x0000000000000378</span><br><span class="line">                 0x0000000000000044 0x0000000000000044  R      0x4</span><br><span class="line">  GNU_PROPERTY   0x0000000000000338 0x0000000000000338 0x0000000000000338</span><br><span class="line">                 0x0000000000000040 0x0000000000000040  R      0x8</span><br><span class="line">  GNU_EH_FRAME   0x0000000000002010 0x0000000000002010 0x0000000000002010</span><br><span class="line">                 0x0000000000000024 0x0000000000000024  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x0000000000002dd8 0x0000000000003dd8 0x0000000000003dd8</span><br><span class="line">                 0x0000000000000228 0x0000000000000228  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br><span class="line">   01     .interp </span><br><span class="line">   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt </span><br><span class="line">   03     .init .plt .text .fini </span><br><span class="line">   04     .rodata .eh_frame_hdr .eh_frame </span><br><span class="line">   05     .init_array .fini_array .dynamic .got .got.plt .data .bss </span><br><span class="line">   06     .dynamic </span><br><span class="line">   07     .note.gnu.property </span><br><span class="line">   08     .note.gnu.build-id .note.ABI-tag </span><br><span class="line">   09     .note.gnu.property </span><br><span class="line">   10     .eh_frame_hdr </span><br><span class="line">   11     </span><br><span class="line">   12     .init_array .fini_array .dynamic .got</span><br></pre></td></tr></table></figure>

<p>显示信息：</p>
<ol>
<li>这是一个DYN (Position-Independent Executable file)文件</li>
<li>入口地址是<code>0x1050</code></li>
<li>一共有13个<code>program headers</code>，是从ELF文件的第64个偏移地址开始的。</li>
</ol>
<p><code>Section</code> 与 <code>Segment</code> 本质上是一样的，可以理解为：一个 Secgment 由一个或多个 Sections 组成。还可以看到有两个<code>LOAD</code>类型的段</p>
<p>读取二进制字节码：</p>
<p>计算段表项的地址信息，从<code>ELF header</code>中得知的信息如下：</p>
<ol>
<li><code>e_phoff</code>：<code>Program header table</code> 位于 ELF 文件偏移 64 个字节的地方。</li>
<li><code>e_phentsize</code>：每一个表项的长度是 56 个字节;</li>
<li><code>e_phnum</code>：一共有 13 个表项 <code>Entry</code>;</li>
</ol>
<p>通过计算，得到可读、可执行的 <code>LOAD</code> 段，位于偏移量 <code>176</code> 字节处（<code>56*2+64</code>）。</p>
<p>执行读取指令：<code>od -Ad -t x1 -j 176 -N 56 main</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000176 01 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0000192 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0000208 78 06 00 00 00 00 00 00 78 06 00 00 00 00 00 00</span><br><span class="line">0000224 00 10 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>对应的关联：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf64_phdr</span> &#123;</span></span><br><span class="line">  Elf64_Word p_type;		<span class="comment">/* 01 00 00 00 */</span></span><br><span class="line">  Elf64_Word p_flags;		<span class="comment">/* 04 00 00 00 */</span></span><br><span class="line">  Elf64_Off p_offset;		<span class="comment">/* 00 00 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Addr p_vaddr;		<span class="comment">/* 00 00 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Addr p_paddr;		<span class="comment">/* 00 00 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Xword p_filesz;		<span class="comment">/* 78 06 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Xword p_memsz;		<span class="comment">/* 78 06 00 00 00 00 00 00 */</span></span><br><span class="line">  Elf64_Xword p_align;		<span class="comment">/* 00 10 00 00 00 00 00 00 */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>p_type</code>: 段的类型，1: 表示这个段需要加载到内存中;</li>
<li><code>p_offset</code>: 段在 ELF 文件中的偏移地址，这里值为 0，表示这个段从 ELF 文件的头部开始;</li>
<li><code>p_vaddr</code>：段加载到内存中的虚拟地址 <code>0x00</code>;</li>
<li><code>p_paddr</code>：段加载的物理地址，与虚拟地址相同;</li>
<li><code>p_filesz</code>: 这个段在 ELF 文件中，占据的字节数，<code>0x0678</code> &#x3D; 1656 个字节;</li>
<li><code>p_memsz</code>：这个段加载到内存中，需要占据的字节数，<code>0x0678</code>&#x3D; 1656 个字节。不过有些段是不需要加载到内存中的;</li>
</ul>
<p>从 <code>ELF</code> 文件的第 <code>1</code> 到 第 <code>1656</code> 个字节，都是属于这个 <code>LOAD</code> 段的内容。</p>
<p>在被执行时，这个段需要被加载到内存中虚拟地址为 <code>0x00</code> 这个地方。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><code>ELF header</code> 描述了文件的总体信息，以及两个 <code>table</code> 的相关信息(偏移地址，表项个数，表项长度);</li>
<li>每一个 <code>table</code> 中，包括很多个表项 <code>Entry</code>，每一个表项都描述了一个 <code>Section/Segment</code> 的具体信息。</li>
</ol>
]]></content>
      <categories>
        <category>Kernel</category>
      </categories>
      <tags>
        <tag>Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.S081 XV6实验环境搭建</title>
    <url>/posts/525fdb32.html</url>
    <content><![CDATA[<h1 id="Docker-搭建ubuntu环境"><a href="#Docker-搭建ubuntu环境" class="headerlink" title="Docker 搭建ubuntu环境"></a>Docker 搭建ubuntu环境</h1><p>获取ubuntu镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>

<p>启动一个容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itw /root --name ubuntu ubuntu bash</span><br></pre></td></tr></table></figure>

<p>连接ubuntu系统交互环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start -i ubuntu</span><br></pre></td></tr></table></figure>

<p>进入系统后更新以及安装vim：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install vim</span><br></pre></td></tr></table></figure>

<p>更换国内源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/source.list</span><br></pre></td></tr></table></figure>

<p>将内容替换为（由于没有https，所以用http），注意安装ubuntu版本和源版本是否匹配，如果不匹配就无法自动安装软件相关的依赖。这里docker直接拉取<code>ubuntu:latest</code>，所以直接用最后一个版本的源即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-backports main restricted universe multiverse</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ impish-security main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>替换之后更新：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure>

<h2 id="安装实验必需的软件"><a href="#安装实验必需的软件" class="headerlink" title="安装实验必需的软件"></a>安装实验必需的软件</h2><p>直接安装即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></table></figure>

<p>下载xv6的实验源码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021</span><br></pre></td></tr></table></figure>

<p>速度较慢，可以我传到gitee上的库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@gitee.com:Ansore/xv6-labs-2021.git</span><br></pre></td></tr></table></figure>

<p>进入目录，切换分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> xv6-labs-2021</span><br><span class="line">git checkout util</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make qemu</span><br></pre></td></tr></table></figure>

<p><code>ctrl + p</code>可以查看当前进程</p>
<p><code>ctrl + a  x</code>可以退出sh</p>
<h2 id="代码同步"><a href="#代码同步" class="headerlink" title="代码同步"></a>代码同步</h2><ol>
<li>可以采用docker映射目录</li>
<li>使用git同步</li>
</ol>
<p>不多赘述</p>
<h1 id="lab1-sleep实验"><a href="#lab1-sleep实验" class="headerlink" title="lab1 sleep实验"></a>lab1 sleep实验</h1><p>官方实验描述：</p>
<blockquote>
<p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p>
</blockquote>
<blockquote>
<p>Some hints:</p>
<ul>
<li>Before you start coding, read Chapter 1 of the <a href="https://pdos.csail.mit.edu/6.S081/2021/xv6/book-riscv-rev2.pdf">xv6 book</a>.</li>
<li>Look at some of the other programs in <code>user/</code> (e.g., <code>user/echo.c</code>, <code>user/grep.c</code>, and <code>user/rm.c</code>) to see how you can obtain the command-line arguments passed to a program.</li>
<li>If the user forgets to pass an argument, sleep should print an error message.</li>
<li>The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see user&#x2F;ulib.c).</li>
<li>Use the system call <code>sleep</code>.</li>
<li>See <code>kernel/sysproc.c</code> for the xv6 kernel code that implements the <code>sleep</code> system call (look for <code>sys_sleep</code>), <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program, and <code>user/usys.S</code> for the assembler code that jumps from user code into the kernel for <code>sleep</code>.</li>
<li>Make sure <code>main</code> calls <code>exit()</code> in order to exit your program.</li>
<li>Add your <code>sleep</code> program to <code>UPROGS</code> in Makefile; once you’ve done that, <code>make qemu</code> will compile your program and you’ll be able to run it from the xv6 shell.</li>
<li>Look at Kernighan and Ritchie’s book <em>The C programming language (second edition)</em> (K&amp;R) to learn about C.</li>
</ul>
</blockquote>
<p>目标：调用系统函数（定义在<code>user/user.h</code>中，实现在<code>kernel/sysproc.c</code>中），实现休眠功能</p>
<p>较为简单，直接调用系统函数即可</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: sleep seconds\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外还需要修改Makefile，URPOGS添加编译：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$U/_sleep\</span><br></pre></td></tr></table></figure>

<p>在xv6的shell中执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ <span class="built_in">sleep</span> 10</span><br><span class="line">(nothing happens <span class="keyword">for</span> a little <span class="keyword">while</span>)</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>执行以下脚本测试是否通过：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./grade-lab-util <span class="built_in">sleep</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>XV6</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.S081 XV6 lab1 util</title>
    <url>/posts/d01b0b88.html</url>
    <content><![CDATA[<h1 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h1><blockquote>
<p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<pid>: received ping”, where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<pid>: received pong”, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p>
</blockquote>
<blockquote>
<ul>
<li>Use <code>pipe</code> to create a pipe.</li>
<li>Use <code>fork</code> to create a child.</li>
<li>Use <code>read</code> to read from the pipe, and <code>write</code> to write to the pipe.</li>
<li>Use <code>getpid</code> to find the process ID of the calling process.</li>
<li>Add the program to <code>UPROGS</code> in Makefile.</li>
<li>User programs on xv6 have a limited set of library functions available to them. You can see the list in <code>user/user.h</code>; the source (other than for system calls) is in <code>user/ulib.c</code>, <code>user/printf.c</code>, and <code>user/umalloc.c</code>.</li>
</ul>
</blockquote>
<p>pipe(管道)用于两个进程间的通信，一个进程写，另一个进程读。<code>pip()</code>用于创建管道，传入一个数组。然后就两个进程可以通过fd进行通信。<code>fork()</code>函数用于创建子进程，从这个函数以下所有的程序都由父进程和fork出来的子进程共同执行。可根据 返回的pid区分父子进程，如果返回的pid&gt;0，则该进程是父进程，如果pid&#x3D;0，则为fork出来的子进程。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[BUFFER_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(fd[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, BUFFER_SIZE);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        read(fd[<span class="number">0</span>], buf, BUFFER_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, pid, buf);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        read(fd[<span class="number">0</span>], buf, BUFFER_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, pid, buf);</span><br><span class="line">        write(fd[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, BUFFER_SIZE);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h1><blockquote>
<p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p>
<p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p>
</blockquote>
<blockquote>
<ul>
<li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li>
<li>Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited.</li>
<li>Hint: <code>read</code> returns zero when the write-side of a pipe is closed.</li>
<li>It’s simplest to directly write 32-bit (4-byte) <code>int</code>s to the pipes, rather than using formatted ASCII I&#x2F;O.</li>
<li>You should create the processes in the pipeline only as they are needed.</li>
<li>Add the program to <code>UPROGS</code> in Makefile.</li>
</ul>
</blockquote>
<p>题目大致意思是用pipe和fork函数求2-35之间所有的素数。</p>
<p>求素数方法，第一个进程打印第一个素数，然后删除这个素数以及这个素数的倍数，然后将剩下的数交给下一个进程处理，以此类推。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e29962235d.gif" alt="img"></p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">primes</span><span class="params">(<span class="type">int</span> read_pipe, <span class="type">int</span> wirte_pipe)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *nums;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    read(read_pipe, &amp;length, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    nums = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * length);</span><br><span class="line">    read(read_pipe, nums, length * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> prime = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] % prime != <span class="number">0</span>) &#123;</span><br><span class="line">            nums[index++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if have no nums, exit</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(wirte_pipe, &amp;index, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        write(wirte_pipe, nums, index * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="built_in">free</span>(nums);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        primes(read_pipe, wirte_pipe);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// init data</span></span><br><span class="line">    <span class="type">int</span> data_length = <span class="number">34</span>;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">34</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">34</span>; i ++) &#123;</span><br><span class="line">        nums[i] = i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create process</span></span><br><span class="line">    <span class="type">int</span> pid =fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// write nums size</span></span><br><span class="line">        write(fd[<span class="number">1</span>], &amp;data_length, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="comment">// write num</span></span><br><span class="line">        write(fd[<span class="number">1</span>], nums, data_length * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        primes(fd[<span class="number">0</span>], fd[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><blockquote>
<p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p>
</blockquote>
<blockquote>
<ul>
<li>Look at user&#x2F;ls.c to see how to read directories.</li>
<li>Use recursion to allow find to descend into sub-directories.</li>
<li>Don’t recurse into “.” and “..”.</li>
<li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li>
<li>You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</li>
<li>Note that &#x3D;&#x3D; does not compare strings like in Python. Use strcmp() instead.</li>
<li>Add the program to <code>UPROGS</code> in Makefile.</li>
</ul>
</blockquote>
<p>实现一个unix的find程序，查找匹配的文件。</p>
<p><code>fmtname</code>函数区最后一级文件名。如<code>a/b/c.txt</code>，则返回值就为<code>cc.txt</code></p>
<p>大体思路为：读取当前路径下的所有文件，如果为文件，则比对文件名；如果为文件夹，则拼接目录，然后继续遍历文件夹。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27;\0&#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only find file</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *find_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;, *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(find_name, fmtname(path)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + DIRSIZ + <span class="number">2</span> &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;path too long!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">            p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">            <span class="keyword">if</span> (*p != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (de.inum == <span class="number">0</span> || de.name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                memmove(p, de.name, DIRSIZ);</span><br><span class="line">                p[DIRSIZ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                find(buf, find_name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;command error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><blockquote>
<p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p>
</blockquote>
<blockquote>
<ul>
<li>Use <code>fork</code> and <code>exec</code> to invoke the command on each line of input. Use <code>wait</code> in the parent to wait for the child to complete the command.</li>
<li>To read individual lines of input, read a character at a time until a newline (‘\n’) appears.</li>
<li>kernel&#x2F;param.h declares MAXARG, which may be useful if you need to declare an argv array.</li>
<li>Add the program to <code>UPROGS</code> in Makefile.</li>
<li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li>
</ul>
</blockquote>
<p>通过标准输入流读取管道输入，然后将读取的输入作为xargs后面命令的参数。</p>
<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello too | xargs <span class="built_in">echo</span> <span class="built_in">bye</span></span><br><span class="line"><span class="built_in">bye</span> hello too</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p><strong>如何读取管道符的输入（标准输入流）</strong></p>
<p>根据实验指导书<strong>1.2 I&#x2F;O and File descriptors</strong>：</p>
<blockquote>
<p>Internally, the xv6 kernel uses the file descriptor as an index into a per-process table, so that every process has a private space of file descriptors starting at zero. By convention, a process reads from file descriptor 0 (standard input), writes output to file descriptor 1 (standard output), and writes error messages to file descriptor 2 (standard error). As we will see, the shell exploits the convention to implement I&#x2F;O redirection and pipelines. The shell ensures that it always has three file descriptors open (user&#x2F;sh.c:151), which are by default file descriptors for the console.</p>
</blockquote>
<p>可知，读取标准输入流，只需读取fd&#x3D;0的描述符即可；如果我们要标准化输出，则向fd&#x3D;1的描述符写入即可。</p>
<p><strong>exec函数</strong><br>exec函数共有两个参数，第一个传入执行的命令，第二个传入参数。</p>
<p>大体思路：将xargs的所有参数保存，读取标准输入流，将读取的输入加入到保存的参数中，最后调用exec执行第一个参数，传入所有参数即可。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ+<span class="number">1</span>];</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">    ;</span><br><span class="line">  p++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="built_in">memset</span>(buf+<span class="built_in">strlen</span>(p), <span class="string">&#x27;\0&#x27;</span>, DIRSIZ-<span class="built_in">strlen</span>(p));</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only find file</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *find_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;, *p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(find_name, fmtname(path)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + DIRSIZ + <span class="number">2</span> &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;path too long!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">            p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">            <span class="keyword">if</span> (*p != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (de.inum == <span class="number">0</span> || de.name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                memmove(p, de.name, DIRSIZ);</span><br><span class="line">                p[DIRSIZ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                find(buf, find_name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;command error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>XV6</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.S081 XV6 lab2 syscall</title>
    <url>/posts/295fae46.html</url>
    <content><![CDATA[<h1 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h1><blockquote>
<p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <code>trace</code> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>, where <code>SYS_fork</code> is a syscall number from <code>kernel/syscall.h</code>. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p>
</blockquote>
<blockquote>
<ul>
<li>Add <code>$U/_trace</code> to UPROGS in Makefile</li>
<li>Run make qemu and you will see that the compiler cannot compile <code>user/trace.c</code>, because the user-space stubs for the system call don’t exist yet: add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. Once you fix the compilation issues, run trace 32 grep hello README; it will fail because you haven’t implemented the system call in the kernel yet.</li>
<li>Add a <code>sys_trace()</code> function in <code>kernel/sysproc.c</code> that implements the new system call by remembering its argument in a new variable in the <code>proc</code> structure (see <code>kernel/proc.h</code>). The functions to retrieve system call arguments from user space are in <code>kernel/syscall.c</code>, and you can see examples of their use in <code>kernel/sysproc.c</code>.</li>
<li>Modify <code>fork()</code> (see <code>kernel/proc.c</code>) to copy the trace mask from the parent to the child process.</li>
<li>Modify the <code>syscall()</code> function in <code>kernel/syscall.c</code> to print the trace output. You will need to add an array of syscall names to index into.</li>
</ul>
</blockquote>
<p>我们需要实现一个trace的调用，当用户态调用trace()函数时，传入mask，确定需要trace的系统调用（如fork，read等）。</p>
<p>大体思路时在进程描述中添加mask字段，用于判断该进程是否需要进程trace，然后在执行系统调用时，根据该mask打印调用信息。</p>
<p><strong>实现</strong></p>
<ol>
<li>在用户态的头文件声明调用（<code>user/user.h</code>），这样编译 <code>user/trace.c</code>才不会报错。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sys strace</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>user/usys.pl</code>添加调用入口</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>kernel/syscall.h</code>中添加<code>SYS_trace</code>调用号</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在进程描述的结构体中添加<code>trace_mask</code>字段代表该进程的trace状态，该文件位于<code>kernel/proc.h</code>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    ....</span><br><span class="line">  <span class="comment">// for trace</span></span><br><span class="line">  <span class="type">int</span> trace_mask;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在<code>kernel/sysproc.c</code>中添加<code>sys_trace</code>函数。（该文件主要用于实现系统调用）</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="comment">// 读取传入的mask</span></span><br><span class="line">    <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;mask) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 获取当前进程，将mask赋值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    p-&gt;trace_mask = mask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在<code>kernel/syscall.c</code>中注册trace系统调用函数。并且在系统调用中根据mask判断打印的信息。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">  ....</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *syscall_names[] = &#123;<span class="string">&quot;fork&quot;</span>, <span class="string">&quot;exit&quot;</span>, <span class="string">&quot;wait&quot;</span>, <span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;read&quot;</span>, <span class="string">&quot;kill&quot;</span>, <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;fstat&quot;</span>, <span class="string">&quot;chdir&quot;</span>, <span class="string">&quot;dup&quot;</span>, <span class="string">&quot;getpid&quot;</span>, <span class="string">&quot;sbrk&quot;</span>, <span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;uptime&quot;</span>, <span class="string">&quot;open&quot;</span>, <span class="string">&quot;write&quot;</span>, <span class="string">&quot;mknod&quot;</span>, <span class="string">&quot;unlink&quot;</span>, <span class="string">&quot;link&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;close&quot;</span>, <span class="string">&quot;trace&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="comment">// 根据mask判断是否需要打印</span></span><br><span class="line">    <span class="keyword">if</span> ((p-&gt;trace_mask &gt;&gt; num) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num<span class="number">-1</span>], p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h1><blockquote>
<p>In this assignment you will add a system call, <code>sysinfo</code>, that collects information about the running system. The system call takes one argument: a pointer to a <code>struct sysinfo</code> (see <code>kernel/sysinfo.h</code>). The kernel should fill out the fields of this struct: the <code>freemem</code> field should be set to the number of bytes of free memory, and the <code>nproc</code> field should be set to the number of processes whose <code>state</code> is not <code>UNUSED</code>. We provide a test program <code>sysinfotest</code>; you pass this assignment if it prints “sysinfotest: OK”.</p>
</blockquote>
<blockquote>
<ul>
<li><p>Add <code>$U/_sysinfotest</code> to UPROGS in Makefile</p>
</li>
<li><p>Run make qemu; <code>user/sysinfotest.c</code> will fail to compile. Add the system call sysinfo, following the same steps as in the previous assignment. To declare the prototype for sysinfo() <code>in user/user.h</code> you need predeclare the existence of <code>struct sysinfo</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sysinfo; </span><br><span class="line">int sysinfo(struct sysinfo *);</span><br></pre></td></tr></table></figure>

<p>Once you fix the compilation issues, run <strong>sysinfotest</strong>; it will fail because you haven’t implemented the system call in the kernel yet.</p>
</li>
<li><p>sysinfo needs to copy a <code>struct sysinfo</code> back to user space; see <code>sys_fstat()</code> (<code>kernel/sysfile.c</code>) and <code>filestat()</code> (<code>kernel/file.c</code>) for examples of how to do that using <code>copyout()</code>.</p>
</li>
<li><p>To collect the amount of free memory, add a function to <code>kernel/kalloc.c</code></p>
</li>
<li><p>To collect the number of processes, add a function to <code>kernel/proc.c</code></p>
</li>
</ul>
</blockquote>
<p>获取系统信息，将查询的信息从内核态拷贝到用户态。</p>
<p>添加系统调用与上面类似，获取系统信息实现：</p>
<ol>
<li><code>sys_sysinfo</code>函数实现（<code>kernel/sysproc.c</code>），<code>copyout</code>函数实现了从内核态拷贝到用户态，<code>p-&gt;pagetable</code>为该进程用户态的页表，<code>addr</code>为写入的地址：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">    uint64 addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取进程不为 UNUSED 状态的数量</span></span><br><span class="line">    info.nproc = get_nproc();</span><br><span class="line">    <span class="comment">// 获取空闲的内存数</span></span><br><span class="line">    info.freemem = get_freemem();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内核态拷贝到用户态</span></span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span>*)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>遍历所有进程，统计状态不为UNUSED的进程数量。注意操作进程时，获取和释放锁。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">get_nproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    uint64 cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">        acquire(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>遍历空闲页表，统计空闲页表数量，然后乘页大小即可</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64 <span class="title function_">get_freemem</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  uint64 cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span> (r) &#123;</span><br><span class="line">      r = r-&gt;next;</span><br><span class="line">      cnt ++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cnt * PGSIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>XV6</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.S081 XV6 lab3 page tables</title>
    <url>/posts/800f9d20.html</url>
    <content><![CDATA[<h1 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h1><blockquote>
<p>When each process is created, map one read-only page at USYSCALL (a VA defined in <code>memlayout.h</code>). At the start of this page, store a <code>struct usyscall</code> (also defined in <code>memlayout.h</code>), and initialize it to store the PID of the current process. For this lab, <code>ugetpid()</code> has been provided on the userspace side and will automatically use the USYSCALL mapping. You will receive full credit for this part of the lab if the <code>ugetpid</code> test case passes when running <code>pgtbltest</code>.</p>
</blockquote>
<blockquote>
<p>Some hints:</p>
<ul>
<li>You can perform the mapping in <code>proc_pagetable()</code> in <code>kernel/proc.c</code>.</li>
<li>Choose permission bits that allow userspace to only read the page.</li>
<li>You may find that <code>mappages()</code> is a useful utility.</li>
<li>Don’t forget to allocate and initialize the page in <code>allocproc()</code>.</li>
<li>Make sure to free the page in <code>freeproc()</code>.</li>
</ul>
</blockquote>
<p>加速系统调用，在内核和用户之间建立一个共享的只读页，这样内核往这个页写入数据的时候，用户程序就可以不经过复杂的系统调用，直接读取。</p>
<p>实验要求我们映射一个只读页<code>USYSCALL</code>，用户程序可以直接调用它。用户态调用<code>ugetpid()</code>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ugetpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">u</span> =</span> (<span class="keyword">struct</span> usyscall *)USYSCALL;</span><br><span class="line">  <span class="keyword">return</span> u-&gt;pid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>读取时直接从<code>USYSCALL</code>这个地址里读取数据。<code>TRAMPOLINE</code>意为蹦床，用来进行trap to the kernel操作的。下面的<code>TRAPFRAME</code>保存了一些进程的参数。<code>USYSCALL</code>是紧挨着<code>trapframe</code>下端的一页。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - (p)*2*PGSIZE - 3*PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>内存分布如下所示：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e29afe20ba.png" alt="Screenshot_20220411_224716"></p>
<p><code>proc_pagetable</code>里面设置映射：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map the trampoline code (for system call return)</span></span><br><span class="line"><span class="comment">// at the highest user virtual address.</span></span><br><span class="line"><span class="comment">// only the supervisor uses it, on the way</span></span><br><span class="line"><span class="comment">// to/from user space, so not PTE_U.</span></span><br><span class="line"><span class="keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,</span><br><span class="line">            (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span></span><br><span class="line"><span class="keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,</span><br><span class="line">            (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xv6先给<code>TRAPFRAME</code>分配一块内存，再白<code>TRAPFRAME</code>映射到这块内存上。<code>allocproc()</code>中，首先会搜索进程表，搜索到UNUSED进程就为其分配内存，然后给进程表p赋值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;pid = allocpid();</span><br><span class="line">p-&gt;state = USED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a trapframe page.</span></span><br><span class="line"><span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体思路如下：</p>
<ol>
<li>进程表中添加usyscall的成员变量</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">usyscall</span>;</span>   <span class="comment">// usyscall</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>为usyscall分配一页内存，并把进程的pid保存到页表中。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// allocate a usyscall page</span></span><br><span class="line"><span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">  freeproc(p);</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;usyscall-&gt;pid = p-&gt;pid;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加映射。如果映射失败，需要释放<code>TRAMPOLINE</code>和<code>TRAPFRAME</code>的映射</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map the usyscall just below TRAMPOLINE, for trampoline.S.</span></span><br><span class="line"><span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">            (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>freeproc</code>的时候需释放<code>usyscall</code>页</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">  kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>proc_freepagetable</code>取消映射页表的时候，添加USYSCALL的映射关系</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h1><blockquote>
<p>Define a function called <code>vmprint()</code>. It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process’s page table. You receive full credit for this part of the lab if you pass the <code>pte printout</code> test of <code>make grade</code>.</p>
</blockquote>
<blockquote>
<p>Now when you start xv6 it should print output like this, describing the page table of the first process at the point when it has just finished <code>exec()</code>ing <code>init</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">page table 0x0000000087f6e000</span><br><span class="line"> ..0: pte 0x0000000021fda801 pa 0x0000000087f6a000</span><br><span class="line"> .. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000</span><br><span class="line"> .. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000</span><br><span class="line"> .. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000</span><br><span class="line"> .. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000</span><br><span class="line"> ..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000</span><br><span class="line"> .. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000</span><br><span class="line"> .. .. ..509: pte 0x0000000021fdd813 pa 0x0000000087f76000</span><br><span class="line"> .. .. ..510: pte 0x0000000021fddc07 pa 0x0000000087f77000</span><br><span class="line"> .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>The first line displays the argument to <code>vmprint</code>. After that there is a line for each PTE, including PTEs that refer to page-table pages deeper in the tree. Each PTE line is indented by a number of <code>&quot; ..&quot;</code> that indicates its depth in the tree. Each PTE line shows the PTE index in its page-table page, the pte bits, and the physical address extracted from the PTE. Don’t print PTEs that are not valid. In the above example, the top-level page-table page has mappings for entries 0 and 255. The next level down for entry 0 has only index 0 mapped, and the bottom-level for that index 0 has entries 0, 1, and 2 mapped.</p>
<p>Your code might emit different physical addresses than those shown above. The number of entries and the virtual addresses should be the same.</p>
</blockquote>
<blockquote>
<ul>
<li>You can put <code>vmprint()</code> in <code>kernel/vm.c</code>.</li>
<li>Use the macros at the end of the file kernel&#x2F;riscv.h.</li>
<li>The function <code>freewalk</code> may be inspirational.</li>
<li>Define the prototype for <code>vmprint</code> in kernel&#x2F;defs.h so that you can call it from exec.c.</li>
<li>Use <code>%p</code> in your printf calls to print out full 64-bit hex PTEs and addresses as shown in the example.</li>
</ul>
</blockquote>
<p>xv6使用的是三级页表，如果页表项的PTE_V这一位是1，则该页表项是有效的，可以根据次页表项内的地址访问下一集页表。采用DFS遍历即可。</p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> depth)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (depth &gt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">      <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (depth == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.. ..&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (depth == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;.. .. ..&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">      vmprint((<span class="type">pagetable_t</span>)child, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h1><blockquote>
<p>Your job is to implement <code>pgaccess()</code>, a system call that reports which pages have been accessed. The system call takes three arguments. First, it takes the starting virtual address of the first user page to check. Second, it takes the number of pages to check. Finally, it takes a user address to a buffer to store the results into a bitmask (a datastructure that uses one bit per page and where the first page corresponds to the least significant bit). You will receive full credit for this part of the lab if the <code>pgaccess</code> test case passes when running <code>pgtbltest</code>.</p>
</blockquote>
<blockquote>
<p>Some hints:</p>
<ul>
<li>Start by implementing <code>sys_pgaccess()</code> in <code>kernel/sysproc.c</code>.</li>
<li>You’ll need to parse arguments using <code>argaddr()</code> and <code>argint()</code>.</li>
<li>For the output bitmask, it’s easier to store a temporary buffer in the kernel and copy it to the user (via <code>copyout()</code>) after filling it with the right bits.</li>
<li>It’s okay to set an upper limit on the number of pages that can be scanned.</li>
<li><code>walk()</code> in <code>kernel/vm.c</code> is very useful for finding the right PTEs.</li>
<li>You’ll need to define <code>PTE_A</code>, the access bit, in <code>kernel/riscv.h</code>. Consult the RISC-V manual to determine its value.</li>
<li>Be sure to clear <code>PTE_A</code> after checking if it is set. Otherwise, it won’t be possible to determine if the page was accessed since the last time <code>pgaccess()</code> was called (i.e., the bit will be set forever).</li>
<li><code>vmprint()</code> may come in handy to debug page tables.</li>
</ul>
</blockquote>
<p>实验要求：从一个用户页表地址开始，搜索所有被访问过的页并返回一个bitmap来显示这些页是否被访问过。第一个参数传入页表的地址，第二个参数传入需要查询的页表数，第三个是返回的结果变量的用户空间地址。</p>
<p>参考：<code>walk(pagetable_t pagetable, uint64 va, int alloc)</code>函数传入页表和虚拟地址，返回PTE在页表中的地址，如果alloc不等于 0，则创建任何需要的页。</p>
<p>在<code>sysproc.c</code>中完善<code>sys_pgaccess()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  uint64 va; <span class="comment">// check page begin addr</span></span><br><span class="line">  <span class="type">int</span> num; <span class="comment">// check page num</span></span><br><span class="line">  uint64 ua; <span class="comment">// return user addr</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;va) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (argint(<span class="number">1</span>, &amp;num) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">2</span>, &amp;ua) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (num &gt; <span class="number">64</span> || num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  uint64 bitmask = <span class="number">0x0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i ++) &#123;</span><br><span class="line">    bitmask = bitmask | (vm_pgaccess(p-&gt;pagetable, va + i*PGSIZE) &lt;&lt; i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (copyout(p-&gt;pagetable, ua, (<span class="type">char</span>*) &amp;bitmask, <span class="keyword">sizeof</span>(bitmask)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在<code>vm.c</code>中添加函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint</span><br><span class="line"><span class="title function_">vm_pgaccess</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pte == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ((*pte) &amp; PTE_A) &#123;</span><br><span class="line">    *pte ^= PTE_A;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>XV6</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件系统之AUFS</title>
    <url>/posts/cdaf4fa3.html</url>
    <content><![CDATA[<p>AUFS(advanced multi-layered unification filesystem, 高级多层统一文件系统)，用于为Linux文件系统实现联合挂载。AUFS没有合入Linux主线，但是ubuntu中有该文件系统</p>
<h1 id="检查系统是否支持AUFS"><a href="#检查系统是否支持AUFS" class="headerlink" title="检查系统是否支持AUFS"></a>检查系统是否支持AUFS</h1><p>使用一下命令查看是否支持AUFS：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep aufs /proc/filesystems </span><br><span class="line">nodev   aufs</span><br><span class="line"><span class="comment"># 如果命令没有输出，表示内核不支持AUFS</span></span><br></pre></td></tr></table></figure>

<h1 id="创建AUFS"><a href="#创建AUFS" class="headerlink" title="创建AUFS"></a>创建AUFS</h1><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p>创建实验目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> aufs</span><br></pre></td></tr></table></figure>

<p>然后在 aufs 中创建名称为 mnt 的目录作为文件系统的挂载点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> aufs/mnt</span><br></pre></td></tr></table></figure>

<p>接下来在 aufs 目录下创建 container-layer 文件夹(模拟容器的读写层)，并且在文件夹中创建文件 container-layer.txt，文件的内容初始化为 “I am container layer”：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> aufs/container-layer</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I am container layer&quot;</span> &gt; aufs/container-layer/container-layer.txt</span><br></pre></td></tr></table></figure>

<p>最后在 aufs 目录下创建三个文件夹 image-layer1、image-layer2、image-layer3(用它们来模拟容器的镜像层)。在这三个文件夹中分别创建文件，并初始化为对应的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> aufs/&#123;image-layer1,image-layer2,image-layer3&#125;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I am image layer 1&quot;</span> &gt; aufs/image-layer1/image-layer1.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I am image layer 2&quot;</span> &gt; aufs/image-layer2/image-layer2.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I am image layer 3&quot;</span> &gt; aufs/image-layer3/image-layer3.txt</span><br></pre></td></tr></table></figure>

<h2 id="创建AUFS文件系统"><a href="#创建AUFS文件系统" class="headerlink" title="创建AUFS文件系统"></a>创建AUFS文件系统</h2><p>mount 是一个非常强大的命令，我们可以用它来创建 AUFS 文件系统。下面的命令把 container-layer、image-layer1、image-layer2、image-layer3 以 AUFS 的方式挂载到刚才创建的 mnt 目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> aufs</span><br><span class="line">sudo mount -t aufs -o <span class="built_in">dirs</span>=./container-layer:./image-layer1:./image-layer2:./image-layer3 none ./mnt</span><br></pre></td></tr></table></figure>

<p>挂载完成之后mnt目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mnt</span><br><span class="line">├── container-layer.txt</span><br><span class="line">├── image-layer1.txt</span><br><span class="line">├── image-layer2.txt</span><br><span class="line">└── image-layer3.txt</span><br></pre></td></tr></table></figure>

<p>默认行为是：dirs指定左边的第一个目录是read-write权限，后续目录都是read-only权限。查看挂载的4个文件夹的权限信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/fs/aufs/si_4458ac905a87e3a2/*</span><br><span class="line">/home/ansore/aufs/container-layer=rw</span><br><span class="line">/home/ansore/aufs/image-layer1=ro</span><br><span class="line">/home/ansore/aufs/image-layer2=ro</span><br><span class="line">/home/ansore/aufs/image-layer3=ro</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td></tr></table></figure>

<p>其中<code>si_4458ac905a87e3a2</code>目录是系统为mnt这个挂载点创建的。</p>
<h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><p>向<code>mnt/image-layer1.txt</code>中文件末尾添加一行文字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\nwrite to mnt&#x27;s image-layer1.txt&quot;</span> &gt;&gt; ./mnt/image-layer1.txt</span><br></pre></td></tr></table></figure>

<p>查看 <code>mnt/image-layer1.txt</code> 的内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> mnt/image-layer1.txt </span><br><span class="line"></span><br><span class="line">I am image layer 1</span><br><span class="line"></span><br><span class="line">write to mnt<span class="string">&#x27;s image-layer1.txt</span></span><br></pre></td></tr></table></figure>

<p>此时<code>image-layer1/image-layer1.txt</code>的内容并没有变化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cat image-layer1/image-layer1.txt </span><br><span class="line">I am image layer <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>此时去<code>container-layer</code>目录中发现多了<code>image-layer1.txt</code>文件，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> container-layer/image-layer1.txt </span><br><span class="line">I am image layer 1</span><br><span class="line"></span><br><span class="line">write to mnt<span class="string">&#x27;s image-layer1.txt</span></span><br></pre></td></tr></table></figure>

<p>当尝试向 mnt&#x2F;image-layer1.txt 中写入文件时，系统首先在 mnt 目录下查找名为 image-layer1.txt 的文件，将其拷贝到 read-write 层的 container-layer 目录中，接着对 container-layer 目录中的 image-layer1.txt 的文件进行写操作。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>AUFS</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>网络虚拟化技术</title>
    <url>/posts/fe406906.html</url>
    <content><![CDATA[<h1 id="网络虚拟设备"><a href="#网络虚拟设备" class="headerlink" title="网络虚拟设备"></a>网络虚拟设备</h1><h2 id="Linux-Veth"><a href="#Linux-Veth" class="headerlink" title="Linux Veth"></a>Linux Veth</h2><p>Veth是成对出现的虚拟网络设备，发送到Veth一端的虚拟设备请求会从另一端的虚拟设备中发出。在容器虚拟化中，经常会使用Veth连接不同的网络namespace</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建两个网络namespace</span></span><br><span class="line">ip netns add ns1</span><br><span class="line">ip netns add ns2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一对Veth</span></span><br><span class="line">ip <span class="built_in">link</span> add veth0 <span class="built_in">type</span> veth peer name veth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别将两个Veth移到两个namespace中</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> veth0 netns ns1</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> veth1 netns ns2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去ns1的namespace中查看网络设备</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ip <span class="built_in">link</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">4: veth0@if3: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 7a:d3:b3:5e:97:50 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br></pre></td></tr></table></figure>

<p>n1和n2的namespace中，除了loopback的设备以外就只看到了一个网络设备。当请求发出到这个虚拟网络设备时，都会从另一个网络的namespace中出来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置每个veth的网络地址和namespace路由</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ifconfig veth0 172.18.0.2/24 up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 ifconfig veth1 172.18.0.3/24 up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 route add default dev veth0</span><br><span class="line">ip netns <span class="built_in">exec</span> ns2 route add default dev veth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过veth一端出去的包，另一端直接收到</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ping -c 1 172.18.0.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">PING 172.18.0.3 (172.18.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.051 ms</span><br><span class="line"></span><br><span class="line">--- 172.18.0.3 ping statistics ---</span><br><span class="line">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.051/0.051/0.051/0.000 ms</span><br></pre></td></tr></table></figure>

<h2 id="Linux-Bridge"><a href="#Linux-Bridge" class="headerlink" title="Linux Bridge"></a>Linux Bridge</h2><p>Bridge虚拟设备是用来桥接网络设备，相当于交换机，可以连接不同的网络设备，让请求到达Bridge时，可以通过报文中的mac地址进行广播或转发。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建veth设备并将一端移动到namespace</span></span><br><span class="line">ip netns add ns1</span><br><span class="line">ip <span class="built_in">link</span> add veth0 <span class="built_in">type</span> veth peer name veth1</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> veth1 netns ns1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网桥</span></span><br><span class="line">brctl addbr br0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载网络设备</span></span><br><span class="line">brctl addif br0 enp1s0</span><br><span class="line">brctl addif br0 veth0</span><br></pre></td></tr></table></figure>

<h1 id="Linux路由表"><a href="#Linux路由表" class="headerlink" title="Linux路由表"></a>Linux路由表</h1><p>路由表是Linux内核的一个模块，通过定义路由表决定在某个网络namespacee中包的流向，从而定义请求会到哪个网络设备上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动虚拟网络设备，并设置它在net namespace中的ip地址</span></span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> veth0 up</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> br0 up</span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ifconfig veth1 172.18.0.2/24 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别设置ns1网络空间的路由和宿主机上的路由</span></span><br><span class="line"><span class="comment"># default代表0.0.0.0/0，即在net namespace中所有流量都经过veth1的网络设备流程</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 route add default dev veth1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在宿主机上将172.18.0.0/24的网段请求路由到br0网络</span></span><br><span class="line">route add -net 172.18.0.0/24 dev br0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看宿主机IP地址</span></span><br><span class="line">ifconfig enp1s0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从namespace中访问宿主机的地址</span></span><br><span class="line">ip netns <span class="built_in">exec</span> ns1 ping -c 1 192.168.122.220</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">PING 192.168.122.220 (192.168.122.220) 56(84) bytes <span class="keyword">if</span> data.</span><br><span class="line">64 bytes from 192.168.122.220: icmp_seq=1 ttl=64 time=0.031 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.122.220 ping statistics ---</span><br><span class="line">1 packets trasmitted, 1 receivedm 0% packet look, time 0ms</span><br><span class="line">rtt min/avg/max/mdev = 0.031/0.031/0.000 ms</span><br></pre></td></tr></table></figure>

<h1 id="Linux-iptables"><a href="#Linux-iptables" class="headerlink" title="Linux iptables"></a>Linux iptables</h1><p>iptables 是对linux内核的netfilter模块进行操作和展示的工具，用来管理包的流动和转发。</p>
<p>iptables定义了一套链式的处理结构，在网络包传输的各个阶段可以使用不同的策略对包进行加工、转发或丢弃。</p>
<p>在容器虚拟化中经常用到MASQUERADE和DNAT两种策略，用于容器和宿主机外部的通信。</p>
<h2 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h2><p>MASQUERADE策略可以将请求包中的源地址转换成一个网络设备的地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开ip转发</span></span><br><span class="line">sysctl -w net.ipv4.conf.all.forwarding=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对namespace中发出的包添加网络地址转换</span></span><br><span class="line">iptables -t nat -A POSTROUTING -s 172.18.0.0/24 -o enp1s0 -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p>在namespace中请求宿主机外部地址时，将namespace中的源地址转换为宿主机的地址作为源地址。</p>
<h2 id="DNAT"><a href="#DNAT" class="headerlink" title="DNAT"></a>DNAT</h2><p>DNAT策略也是做网络地址转换的，不过它更换的是目标地址，经常用于将内部网络地址端口映射到外部去。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将宿主机上的80端口请求发送到namespace的ip上</span></span><br><span class="line">iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.18.0.2:80</span><br></pre></td></tr></table></figure>

<p>这样就可以将80端口收到的包转发到172.18.0.2:80，从而实现外部应用调用。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>AUFS</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构-简单动态字符串（SDS）</title>
    <url>/posts/46daf9d5.html</url>
    <content><![CDATA[<h1 id="简单动态字符串（SDS）"><a href="#简单动态字符串（SDS）" class="headerlink" title="简单动态字符串（SDS）"></a>简单动态字符串（SDS）</h1><p>简单动态字符串（simple dynamic string,SDS）作为Redis默认字符串表示。C字符串只会作为字符串常量（String literal）用在一些无需对字符串值进行修改的地方，如日志打印</p>
<p>包含字符串的键值对在底层都是由SDS实现的</p>
<p>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis&gt; SET msg <span class="string">&quot;hello world&quot;</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<ul>
<li>键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串<code>msg</code>的SDS</li>
<li>键值对的值是一个字符串对象，对象的底层实现是一个保存着字符串<code>hello world</code>的SDS</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis&gt; RPUSH fruits <span class="string">&quot;apple&quot;</span> <span class="string">&quot;banana&quot;</span> <span class="string">&quot;cherry&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<ul>
<li>键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串<code>fruits</code>的SDS</li>
<li>键值对的值是一个列表对象，列表对象包含了三个字符串对象，这三个字符串对象分别由三个SDS实现，第一个SDS保存<code>apple</code>….</li>
</ul>
<p>除了用来保存数据库中的字符串以外，SDS还被用作缓冲区（buffer）：AOF模块的中的AOF缓冲区，以及客户端状态中的输入缓冲区，都是由SDS实现</p>
<h1 id="SDS的定义"><a href="#SDS的定义" class="headerlink" title="SDS的定义"></a>SDS的定义</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://img.ansore.de/2022/06/19/d03a878cb23ff387159bf549438f2676.png" alt="Screenshot_20211219_200621.png"></p>
<ul>
<li>free属性的值为0，表示这个SDS没有分配任何使用空间</li>
<li>len属性的值为5，表示这个SDS保存了一个五字节长的字符串</li>
<li>buf属性是一个char类型的数组，数组的前5个字节分别保存了R、e、d、i、s五个字符，而最后一个字节则保存了空字符’\0’</li>
</ul>
<p>SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符分配额外的1字节空间，以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的，所以这个空字符对于SDS的使用者来说是完全透明的。</p>
<h1 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h1><p>C语言使用长度为N+1的字符数组来表示长度为N的字符串，并且字符数组的最后一个元素总是空字符’\0’</p>
<h2 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h2><p>因为C字符串并不记录自身长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的复杂度为O(N)。</p>
<p>SSD在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度为O(1)。</p>
<h2 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h2><p>除了获取字符串长度的复杂度高之外，C字符串不记录自身长度带来的另一个问题容易造成缓冲区溢出（buffer overflow）。</p>
<p>如&lt;string.h&gt;&#x2F;strcat函数可以将src字符串中的内容拼接到dest字符串末尾：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure>

<p>因为字符串不记录自身长度，所以strcat假定用户在执行这个函数时，已经为dest分配了组够多的内存，可以容纳src字符串中的所有内容，而一旦这个假定不成立，就会产生缓冲区溢出；</p>
<p>与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。</p>
<h2 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h2><p>C字符串并不记录自身长度，所以对于一个包含了N个字符的C字符来说，这个C字符串的底层实现总是一个N+1个字符长度的数组（额外的一个字符空间用于保存空字符）。因为C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作。</p>
<ul>
<li>如果程序执行的是增长字符串的操作，比如拼接操作，那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小—如果没有这步就会产生缓冲区溢出</li>
<li>如果程序执行的是缩短字符串的操作，比如截断操作，那么在执行这个操作后，程序需要通过程序重分配来释放字符串不再使用那部分空间—如果忘了这一步则会产生内存泄露</li>
</ul>
<p>因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以是一个比较耗时的操作。为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符串数量加1，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。</p>
<p>通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p>
<h3 id="1-空间预分配"><a href="#1-空间预分配" class="headerlink" title="1.空间预分配"></a>1.空间预分配</h3><p>空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所需要的空间，还会为SDS分配额外的未使用空间。其中，额外分配的未使用空间数量由以下公式决定：</p>
<ul>
<li>如果对SDS进行修改之后，SDS的长度降小于1M，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性值将和free属性的值相同。如果进行修改后，SDS的len将变成13字节，那么程序也会分配13字节未使用空间，SDS的buf数组的实际长度将变成13+13+1&#x3D;27字节（额外的1字节用于保存空字符）</li>
<li>如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。如果进行修改之后，SDS的len将变成30MB，那么程序分配1MB的未使用空间，SDS的buf数组的实际长度为30MB+1MB+1byte</li>
</ul>
<p>通过空间预分配策略，Redis可以减少连续执行字符串增长追做所需的内存重分配次数。</p>
<p>在扩展SDS空间之前。SDS API会先检查未使用空间是否足够，如果足够的话，API就会直接使用未使用空间，而无需执行内存重分配。通过这种分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。</p>
<h3 id="2-惰性空间释放"><a href="#2-惰性空间释放" class="headerlink" title="2.惰性空间释放"></a>2.惰性空间释放</h3><p>惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回缩短后出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。</p>
<p>通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来有可能的增长操作提供了优化。 </p>
<h2 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h2><p>C字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使用C字符串智能保存文本数据，而不能保存图像、音频、视频这样的二进制数据。</p>
<p>SDS所有的API都是二进制安全的，所有的SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤等。不仅可以保存文本数据，还可以保存任意格式二进制数据。</p>
<h2 id="兼容部分C字符串函数"><a href="#兼容部分C字符串函数" class="headerlink" title="兼容部分C字符串函数"></a>兼容部分C字符串函数</h2><p>通过遵循C字符串以空字符结尾的惯例，SDS可以在有需要时重用&lt;string.h&gt;函数库，从而避免了不必要的代码重复。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SDS</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构-链表</title>
    <url>/posts/d7011d8a.html</url>
    <content><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h1 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h1><p>每个链表节点使用一个adlist.h&#x2F;listNode结构来表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>多个listNode可以通过prev和next指针组成双端链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>list结构为链表提供了表头指针head、表尾部指针tail、以及链表长度计数器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数。</p>
<ul>
<li>dup函数用于复制链表节点所保存的值</li>
<li>free函数用于释放链表节点所保存的值</li>
<li>match函数则用于对比链表节点所保存的值和另一个输入值是否相等</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Functions implemented as macros */</span></span><br><span class="line"><span class="comment">// 返回给定链表所包含的节点数量</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listLength(l) ((l)-&gt;len)</span></span><br><span class="line"><span class="comment">// 返回给定链表的表头节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listFirst(l) ((l)-&gt;head)</span></span><br><span class="line"><span class="comment">// 返回给定链表的表尾节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listLast(l) ((l)-&gt;tail)</span></span><br><span class="line"><span class="comment">// 返回给定节点的前置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listPrevNode(n) ((n)-&gt;prev)</span></span><br><span class="line"><span class="comment">// 返回给定节点的后置节点</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listNextNode(n) ((n)-&gt;next)</span></span><br><span class="line"><span class="comment">// 返回给定节点的值</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listNodeValue(n) ((n)-&gt;value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表 l 的值复制函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span></span><br><span class="line"><span class="comment">// 将链表 l 的值释放函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span></span><br><span class="line"><span class="comment">// 将链表的对比函数设置为 m</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定链表的值复制函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGetDupMethod(l) ((l)-&gt;dup)</span></span><br><span class="line"><span class="comment">// 返回给定链表的值释放函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGetFree(l) ((l)-&gt;free)</span></span><br><span class="line"><span class="comment">// 返回给定链表的值对比函数</span></span><br><span class="line"><span class="comment">// T = O(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> listGetMatchMethod(l) ((l)-&gt;match)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构-字典</title>
    <url>/posts/876f5933.html</url>
    <content><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典，又称符号表(symbol table)、关联数组(associative array)或映射(map)，是一种用于保存键值对(key-value pair)的抽象数据结构。</p>
<h1 id="字典实现"><a href="#字典实现" class="headerlink" title="字典实现"></a>字典实现</h1><p>Redis的字典使用哈西表作为底层实现，一个哈希表里面可以由多个哈西表节点，而每个哈希表节点就保存了字典中的一个键值对</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>Redis字典所使用的哈希表由dict.h&#x2F;dictht结构定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>table属性是一个数组，数组中的每一个元素都是一个指向dict.h&#x2F;dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size属性记录了哈希表的大小，也是table数组的大小，而used属性记录了哈希表目前已有节点（键值对）的数量。sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上。</p>
<p><img src="https://img.ansore.de/2022/06/19/caf019735cef64c54639bc1e716846ad.png" alt="Screenshot_20211221_220354.png"></p>
<p>图中为一个空的哈希表，没有包含任何键值对</p>
<h2 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h2><p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>key属性保存着键值对中的键，而v保存键值对中的值，其中键值对的值可以是一个指针，或者一个uint64_t整数，又或者是个int64_t整数。</p>
<p>next属性是指向是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突(collision)问题</p>
<h2 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h2><p>Redis中的字典由dict.h&#x2F;dict结构表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>type属性和privdate属性是针对不同类型的键值对，为创建多态字典而设置的：</p>
<ul>
<li>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特性类型键值对的函数，redis会为用途不同的字典设置不同类型特性函数</li>
<li>而privdata属性则保存了需要传给那些类型特定函数的可选参数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典类型特定函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<p>ht属性是一个包含两个项的数组，数组中每个项都是一个dictht哈续表，一般情况下，字典只使用h[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。</p>
<p>除了ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了reash目前的进度，如果目前没有在进行rehash，那么它的值是-1。</p>
<h1 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h1><p>Redis计算hash值和索引值的方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算给定键的哈希值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用哈希表的sizemask属性和哈希值计算出索引值</span></span><br><span class="line"><span class="comment">// 根据情况不同,ht[x]可以是h[0]或h[1]</span></span><br><span class="line">index = hash &amp; dict-&gt;h[t].sizemask</span><br></pre></td></tr></table></figure>

<p>如，讲一个键值对k0和v0添加到字典里面，则会先使用<code>hash = dict→type→hashFunction(k0)</code>计算键k0的哈希值。假设计算出来的哈希值为8，则会继续使用 <code>index = hash &amp; dict-&gt;h[0].sizemask = 8 &amp; 3 = 0</code> 计算出键k0的索引值0，这表示包含键值对k0和v0的节点应该被放置到哈希表数组的索引0位置上</p>
<p><img src="https://img.ansore.de/2022/06/19/70547c647866ef37a40ba7eed6a5d624.png" alt="Screenshot_20211224_225905.png"></p>
<h1 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h1><p>Redis的哈希表使用链地址法(separate chaining)来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表可以组成一个单向链表，被分配到同一个索引上的多个节点 可以用这个单向链表连接起来，这样就解决的键冲突问题</p>
<h1 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h1><p>为了让哈希表的负载因子(load factor)维持在一个合理的范围内，当哈希表保存的键值对数量过多或过少时，程序需要对哈希表的大小进行相应的扩展或者收缩</p>
<p>Rehash步骤如下：</p>
<ol>
<li>为字典ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以ht[0]当前包含的键值对数量（h[0].used属性的值）。如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2^n；如果是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2^n</li>
<li>讲保存在ht[0]中的所有键值对rehash到ht[1]上面；rehash指的是重新计算哈希和索引值，然后讲键值对放置到h[1]哈希表的指定位置上</li>
<li>当h[0]包含的所有键值对都迁移到ht[1]上之后，释放h[0]，将ht[1]设置成h[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备</li>
</ol>
<h2 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h2><p>以下条件任意一个被满足时，程序自动开始对哈希表执行扩展操作：</p>
<ol>
<li>服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于1</li>
<li>服务器目前正在 执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5</li>
</ol>
<p>其中哈希表的负载因子可以通过</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure>

<p>另一方面，当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作</p>
<h1 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h1><p>渐进式rehash的步骤：</p>
<ol>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li>
<li>在字典中维持一个索引计数变量rehashidx，并将它的值设置为0，表示rehash工作正式开始</li>
<li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增1</li>
<li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值都会rehash到ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成</li>
</ol>
<h2 id="渐进式rehash执行期间的哈希表操作"><a href="#渐进式rehash执行期间的哈希表操作" class="headerlink" title="渐进式rehash执行期间的哈希表操作"></a>渐进式rehash执行期间的哈希表操作</h2><p>因为渐进式rehash过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在这期间字典删除、查找。更新等操作，会在两个哈希表执行</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构-整数集合</title>
    <url>/posts/d4303656.html</url>
    <content><![CDATA[<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>当一个集合只包含整数值元素，并且这个集合的元素数量不多的时候，Redis就会使用整数集合张作伟集合键的底层实现</p>
<h1 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>整数集合的每个元素都是contents数组的一个数组项。各个项在数组中按值的大小从小到大有序排列，并且不重复</p>
<p>length记录长度</p>
<p>虽然contents类型为int8_t，但实际上contents的真正类型有encoding属性来决定：</p>
<ul>
<li>encoding为INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组</li>
<li>encoding为INTSET_ENC_INT32，那么contents就是一个int32_t类型的数组</li>
<li>encoding为INTSET_ENC_INT64，那么contents就是一个int64_t类型的数组</li>
</ul>
<h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><p>添加一个新元素时：</p>
<ol>
<li>根据新元素类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li>
<li>将底层数据现有的所有元素都转换成与新元素相同类型，并将转换后的元素放到正确的位置上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变</li>
<li>将新元素添加到底层数组里</li>
</ol>
<h1 id="升级好处"><a href="#升级好处" class="headerlink" title="升级好处"></a>升级好处</h1><ul>
<li>提升灵活性</li>
<li>节约内存</li>
</ul>
<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>整数集合不支持降级，一旦进行升级，编码会一直保持</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构-压缩列表</title>
    <url>/posts/f9496345.html</url>
    <content><![CDATA[<h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>当一个列表键只包含少量列表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p>
<p>另外，当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Reids就会使用压缩列表来做哈希键的底层实现。</p>
<h1 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h1><p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊的编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个戒掉，每个节点可以保存一个字节数组或者一个整数值。</p>
<p><img src="https://img.ansore.de/2022/06/19/c7c9dd68f12dd91ff6e6657fe4c78369.png" alt="Screenshot_20220105_213114.png"></p>
<p>压缩列表的各个组成部分</p>
<p><img src="https://img.ansore.de/2022/06/19/f184a2a8ca8be00658845620fc1379b7.png" alt="Screenshot_20220105_213142.png"></p>
<h1 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h1><p>每个压缩列表节点都由previous_entry_length、encoding、content三个部分组成</p>
<p><img src="https://img.ansore.de/2022/06/19/f147125371ab47a2f696a947c30e9b32.png" alt="Screenshot_20220105_213409.png"></p>
<h2 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h2><p>节点的previous_entry_length属性以字节位单位，记录了压缩列表中前一个节点的长度。previous_entry_length属性的长度可以是字节或者5字节。</p>
<ul>
<li>如果前一个节点的长度小于254字节，那么previous_entry_length属性的长度位1字节：前一个节点的长度就保存在这一个字节里面。</li>
<li>如果前一个节点的而长度大于等于254节点，那么previous_entry_length属性的长度为5字节：其中属性的第一字节会被设置位0xFE（十进制254），而之后的4个字节则用于保存前一个节点的长度</li>
</ul>
<h2 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h2><p>节点的encoding属性记录了节点的content属性所保存数据的类型以及长度。</p>
<ul>
<li>1字节、2字节或者5字节，值的最高位为00、01或者11的是字节数组编码：这种编码表示节点的encoding属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录</li>
<li>一字节长，值的最高位以11开头的是整数编码：这种编码表示节点的content属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录</li>
</ul>
<h1 id="content"><a href="#content" class="headerlink" title="content"></a>content</h1><p>节点的content属性负责保存节点的值，节点的值可以是一个字节数组或整数，值的类型和长度由节点的encoding属性决定</p>
<h1 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h1>]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构-跳跃表</title>
    <url>/posts/c06b6f41.html</url>
    <content><![CDATA[<h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>如果一个有序集合包含的元素数量比较多，又或者有序集合中的元素成员是比较长的自复制，Redis会使用跳跃表来做有序集合的底层实现。</p>
<h1 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h1><p><img src="https://img.ansore.de/2022/06/19/6f55511e4bfe9660af0a375aed84a30d.png" alt="Screenshot_20211225_221756.png"></p>
<p>左边是zskiplist结构：</p>
<ul>
<li>header：指向跳跃表的头结点</li>
<li>tail: 指向跳跃表的尾节点</li>
<li>level: 记录目前跳跃表内，层数最大的那个节点层数（表头节点不计算在内）</li>
<li>length: 记录跳跃表的长度，跳跃表目前包含的节点数量（表头节点不计算在内）</li>
</ul>
<p>右边为四个zskiplistNode结构：</p>
<ul>
<li>层(level)：节点中用L1、L2、L3等字样标记节点的各层，L1表示第一层，L2表示第二层，以此类推。每个层有带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向的节点和当前节点的距离。</li>
<li>后退(backward)指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值(score)：各个节点中的1.0、2.0和3.0是节点保存的分值。在跳跃表中，节点按各自所保存的分值从大到小排序</li>
<li>成员对象(obj): 各个节点中的o1、o2、o3节点所保存的成员对象</li>
</ul>
<h2 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h2><p>redis&#x2F;zskiplistNode结构定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<h3 id="层"><a href="#层" class="headerlink" title="层"></a>层</h3><p>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层数越多，访问其他节点的速度越快</p>
<p>每次创建一个新的跳跃表节点的时候，程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的”高度“</p>
<h3 id="前进指针"><a href="#前进指针" class="headerlink" title="前进指针"></a>前进指针</h3><p>每个层都有一个指向表尾方向的前进指针，用于从表头向表尾方向访问节点。（虚线）</p>
<p><img src="https://img.ansore.de/2022/06/19/c1611c56bfb87c426edb6e240b4feaff.png" alt="Screenshot_20211225_225826.png"></p>
<ul>
<li>迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中的第二个节点。</li>
<li>在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点</li>
<li>在第三个节点时，程序沿着第二层的前进指针移动到表中的第四个节点</li>
<li>当程序再次沿着第四个节点的前进指针移动时，它碰到了一个NULL，程序知道这时已经到达跳跃表表尾，于是结束了这次遍历</li>
</ul>
<h3 id="跨度"><a href="#跨度" class="headerlink" title="跨度"></a>跨度</h3><p>层的跨度用于记录两个节点之间的距离</p>
<ul>
<li>两个节点之间跨度越大，它们距离就越远</li>
<li>指向NULL的所有前进指针的跨度都为0，因为它们没有连向任何节点</li>
</ul>
<p>跨度实际上时用来计算排位的：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来得到的结果就是目标节点在跳跃表中的排位。</p>
<h3 id="后退指针"><a href="#后退指针" class="headerlink" title="后退指针"></a>后退指针</h3><p>节点的后退指针用表表尾向表头方向访问节点</p>
<h3 id="分值和成员"><a href="#分值和成员" class="headerlink" title="分值和成员"></a>分值和成员</h3><p>分值属性是一个double类型的浮点数，跳跃表中的所有节点都按分值从小到大来排序</p>
<p>节点的成员对象是一个指针，它指向一个字符对象，而字符串对象则保存这一个SDS值。</p>
<p>在同一个跳跃表中，各个节点保存的成员对象必须时唯一的，但是多个节点保存的分值确可以是相同的，分值相同的节点按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面，而成员比较大的节点会排在后面</p>
<h2 id="跳跃表-1"><a href="#跳跃表-1" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>zskiplist结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>header和tail指针分别指向跳跃表的表头和表尾</p>
<p>通过使用length属性来记录节点的数量。</p>
<p>level属性则用于在O(1)复杂度内获取跳跃表中层高最大的那个节点的层数量。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>构建RPM包</title>
    <url>/posts/722c5981.html</url>
    <content><![CDATA[<h1 id="Archlinux下安装RPM包管理工具"><a href="#Archlinux下安装RPM包管理工具" class="headerlink" title="Archlinux下安装RPM包管理工具"></a>Archlinux下安装RPM包管理工具</h1><p><code>rpm-tools</code>是RPM的包管理工具，包括<code>rpm</code>、<code>rpmbuild</code>等命令，安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S rpm-tools</span><br></pre></td></tr></table></figure>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>下载示例项目：<a href="https://github.com/opensourceway/how-to-rpm">https://github.com/opensourceway/how-to-rpm</a></p>
<p>解压：<code>tar -xvf utils.tar</code></p>
<p>查看目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ tree development  </span><br><span class="line">development</span><br><span class="line">├── license</span><br><span class="line">│   ├── Copyright.and.GPL.Notice.txt</span><br><span class="line">│   └── GPL_LICENSE.txt</span><br><span class="line">├── scripts</span><br><span class="line">│   ├── create_motd</span><br><span class="line">│   ├── die</span><br><span class="line">│   ├── mymotd</span><br><span class="line">│   └── sysdata</span><br><span class="line">└── spec</span><br><span class="line">    └── utils.spec</span><br><span class="line"></span><br><span class="line">3 directories, 7 files</span><br></pre></td></tr></table></figure>

<h1 id="spec文件"><a href="#spec文件" class="headerlink" title="spec文件"></a>spec文件</h1><p>每个spec文件有许多部分，其中一部分可能会忽略，取决于rpm包的具体情况。这个特定的 spec 文件不是工作所需的最小文件的示例，但它是一个包含不需要编译的文件的中等复杂 spec 文件的很好例子。 如果需要编译，它将在 <code>%build</code> 部分中执行，该部分在此 spec 文件中省略掉了，因为它不是必需的。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是spec文件唯一没有标签的部分，它包含运行命令<code>rpm -qi [package name]</code>时看到的大部分信息。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">###############################################################################</span></span><br><span class="line"><span class="comment"># Spec file for Utils</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># Configured to be built by user student or other non-root user</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">Summary: Utility scripts for testing RPM creation</span><br><span class="line">Name: utils</span><br><span class="line">Version: 1.0.0</span><br><span class="line">Release: 1</span><br><span class="line">License: GPL</span><br><span class="line">URL: http://www.both.org</span><br><span class="line">Group: System</span><br><span class="line">Packager: David Both</span><br><span class="line">Requires: bash</span><br><span class="line">Requires: screen</span><br><span class="line">Requires: mc</span><br><span class="line">Requires: dmidecode</span><br><span class="line">BuildRoot: ~/rpmbuild/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Build with the following syntax:</span></span><br><span class="line"><span class="comment"># rpmbuild --target noarch -bb utils.spec</span></span><br></pre></td></tr></table></figure>

<p><code>rpmbuild</code> 程序会忽略注释行。我总是喜欢在本节中添加注释，其中包含创建包所需的 <code>rpmbuild</code> 命令的确切语法。</p>
<p><code>Summary</code> 标签是包的简短描述。</p>
<p><code>Name</code>、<code>Version</code> 和 <code>Release</code> 标签用于创建 rpm 文件的名称，如 <code>utils-1.00-1.rpm</code>。通过增加发行版号码和版本号，你可以创建 rpm 包去更新旧版本的。</p>
<p><code>License</code> 标签定义了发布包的许可证。我总是使用 GPL 的一个变体。指定许可证对于澄清包中包含的软件是开源的这一事实非常重要。这也是我将 <code>License</code> 和 <code>GPL</code> 语句包含在将要安装的文件中的原因。</p>
<p><code>URL</code> 通常是项目或项目所有者的网页。</p>
<p><code>Group</code> 标签很有趣，通常用于 GUI 应用程序。 <code>Group</code> 标签的值决定了应用程序菜单中的哪一组图标将包含此包中可执行文件的图标。与 <code>Icon</code> 标签（我们此处未使用）一起使用时，<code>Group</code> 标签允许在应用程序菜单结构中添加用于启动程序的图标和所需信息。</p>
<p><code>Packager</code> 标签用于指定负责维护和创建包的人员或组织。</p>
<p><code>Requires</code> 语句定义此 rpm 包的依赖项。每个都是包名。如果其中一个指定的软件包不存在，DNF 安装实用程序将尝试在 <code>/etc/yum.repos.d</code> 中定义的某个已定义的存储库中找到它，如果存在则安装它。如果 DNF 找不到一个或多个所需的包，它将抛出一个错误，指出哪些包丢失并终止。</p>
<p><code>BuildRoot</code> 行指定顶级目录，<code>rpmbuild</code> 工具将在其中找到 spec 文件，并在构建包时在其中创建临时目录。完成的包将存储在我们之前指定的 <code>noarch</code> 子目录中。</p>
<p>注释显示了构建此程序包的命令语法，包括定义了目标体系结构的 <code>–target noarch</code> 选项。因为这些是 Bash 脚本，所以它们与特定的 CPU 架构无关。如果省略此选项，则构建将选用正在执行构建的 CPU 的体系结构。</p>
<p><code>rpmbuild</code> 程序可以针对许多不同的体系结构，并且使用 <code>--target</code> 选项允许我们在不同的体系结构主机上构建特定体系结构的包，其具有与执行构建的体系结构不同的体系结构。所以我可以在 x86_64 主机上构建一个用于 i686 架构的软件包，反之亦然。</p>
<h2 id="描述部分"><a href="#描述部分" class="headerlink" title="描述部分"></a>描述部分</h2><p>spec 文件的 <code>%description</code> 部分包含 rpm 包的描述。 它可以很短，也可以包含许多信息。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">%description</span><br><span class="line">A collection of utility scripts for testing RPM creation.</span><br></pre></td></tr></table></figure>

<h2 id="准备部分"><a href="#准备部分" class="headerlink" title="准备部分"></a>准备部分</h2><p><code>%prep</code> 部分是在构建过程中执行的第一个脚本。 在安装程序包期间不会执行此脚本。</p>
<p>这个脚本只是一个 Bash shell 脚本。 它准备构建目录，根据需要创建用于构建的目录，并将相应的文件复制到各自的目录中。 这将包括作为构建的一部分的完整编译所需的源代码。</p>
<p><code>$RPM_BUILD_ROOT</code> 目录表示已安装系统的根目录。 在 <code>$RPM_BUILD_ROOT</code> 目录中创建的目录是真实文件系统中的绝对路径，例如 <code>/user/local/share/utils</code>、<code>/usr/local/bin</code> 等。</p>
<p>对于我们的包，我们没有预编译源，因为我们的所有程序都是 Bash 脚本。 因此，我们只需将这些脚本和其他文件复制到已安装系统的目录中。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">%prep</span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># Create the build tree and copy the files from the development directories    #</span></span><br><span class="line"><span class="comment"># into the build tree.                                                         #</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line">echo &quot;<span class="attr">BUILDROOT</span> = <span class="variable">$RPM_BUILD_ROOT</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">mkdir -p $RPM_BUILD_ROOT/usr/local/bin/</span></span><br><span class="line"><span class="string">mkdir -p $RPM_BUILD_ROOT/usr/local/share/utils</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cp ~/RPM/how-to-rpm/development/scripts/* $RPM_BUILD_ROOT/usr/local/bin</span></span><br><span class="line"><span class="string">cp ~/RPM/how-to-rpm/development/license/* $RPM_BUILD_ROOT/usr/local/share/utils</span></span><br><span class="line"><span class="string">cp ~/RPM/how-to-rpm/development/spec/* $RPM_BUILD_ROOT/usr/local/share/utils</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exit</span></span><br></pre></td></tr></table></figure>

<p>本节末尾的 <code>exit</code> 语句是必需的。</p>
<h2 id="文件部分"><a href="#文件部分" class="headerlink" title="文件部分"></a>文件部分</h2><p>spec 文件的 <code>%files</code> 这一部分定义了要安装的文件及其在目录树中的位置。 它还指定了要安装的每个文件的文件属性（<code>%attr</code>）以及所有者和组所有者。 文件权限和所有权是可选的，但我建议明确设置它们以消除这些属性在安装时不正确或不明确的任何可能性。 如果目录尚不存在，则会在安装期间根据需要创建目录。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">%files</span><br><span class="line">%attr(0744, root, root) /usr/local/bin/*</span><br><span class="line">%attr(0644, root, root) /usr/local/share/utils/*</span><br></pre></td></tr></table></figure>

<h2 id="安装前"><a href="#安装前" class="headerlink" title="安装前"></a>安装前</h2><p>此部分为空。 这应该放置那些需要 rpm 中的文件安装前执行的脚本。\</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">%pre</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h2 id="安装后"><a href="#安装后" class="headerlink" title="安装后"></a>安装后</h2><p>spec 文件的这一部分是另一个 Bash 脚本。 这个在文件安装后运行。 此部分几乎可以是你需要或想要的任何内容，包括创建文件、运行系统命令以及重新启动服务以在进行配置更改后重新初始化它们。 我们的 rpm 包的 <code>%post</code> 脚本执行其中一些任务。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">%post</span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment"># Set up MOTD scripts                                                          #</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line">cd /etc</span><br><span class="line"><span class="comment"># Save the old MOTD if it exists</span></span><br><span class="line">if <span class="section">[ -e motd ]</span></span><br><span class="line">then</span><br><span class="line">   cp motd motd.orig</span><br><span class="line">fi</span><br><span class="line"><span class="comment"># If not there already, Add link to create_motd to cron.daily</span></span><br><span class="line">cd /etc/cron.daily</span><br><span class="line">if <span class="section">[ ! -e create_motd ]</span></span><br><span class="line">then</span><br><span class="line">   ln -s /usr/local/bin/create_motd</span><br><span class="line">fi</span><br><span class="line"><span class="comment"># create the MOTD for the first time</span></span><br><span class="line">/usr/local/bin/mymotd &gt; /etc/motd</span><br></pre></td></tr></table></figure>

<h2 id="卸载后"><a href="#卸载后" class="headerlink" title="卸载后"></a>卸载后</h2><p>部分包含将在卸载 rpm 软件包后运行的脚本。 使用 <code>rpm</code> 或 <code>dnf</code> 删除包会删除文件部分中列出的所有文件，但它不会删除安装后部分创建的文件或链接，因此我们需要在本节中处理。</p>
<p>此脚本通常由清理任务组成，只是清除以前由 <code>rpm</code> 安装的文件，但 rpm 本身无法完成清除。 对于我们的包，它包括删除 <code>%post</code> 脚本创建的链接并恢复 motd 文件的已保存原件。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">%postun</span><br><span class="line"><span class="comment"># remove installed files and links</span></span><br><span class="line">rm /etc/cron.daily/create_motd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restore the original MOTD if it was backed up</span></span><br><span class="line">if <span class="section">[ -e /etc/motd.orig ]</span></span><br><span class="line">then</span><br><span class="line">   mv -f /etc/motd.orig /etc/motd</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>这个 Bash 脚本在 rpm 构建过程之后开始清理。 下面 <code>%clean</code> 部分中的两行删除了 <code>rpm-build</code> 命令创建的构建目录。 在许多情况下，可能还需要额外的清理。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">%clean</span><br><span class="line">rm -rf $RPM_BUILD_ROOT/usr/local/bin</span><br><span class="line">rm -rf $RPM_BUILD_ROOT/usr/local/share/utils</span><br></pre></td></tr></table></figure>

<h2 id="变更日志"><a href="#变更日志" class="headerlink" title="变更日志"></a>变更日志</h2><p>此可选的文本部分包含 rpm 及其包含的文件的变更列表。最新的变更记录在本部分顶部。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">%changelog</span><br><span class="line">* Wed Aug 29 2018 Your Name &lt;Youremail@yourdomain.com&gt;</span><br><span class="line">  - The original package includes several useful scripts. it is</span><br><span class="line">    primarily intended to be used to illustrate the process of</span><br><span class="line">    building an RPM.</span><br></pre></td></tr></table></figure>

<h1 id="构建rpm"><a href="#构建rpm" class="headerlink" title="构建rpm"></a>构建rpm</h1><p>运行以下命令以构建 rpm：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpmbuild --target noarch -bb utils.spec</span><br></pre></td></tr></table></figure>

<p>可查看对应目录所对应的包</p>
]]></content>
      <categories>
        <category>RPM</category>
      </categories>
      <tags>
        <tag>RPM</tag>
      </tags>
  </entry>
  <entry>
    <title>IP与域名的相互转换</title>
    <url>/posts/33dec441.html</url>
    <content><![CDATA[<p>在编程中，知道域名是不能直接访问主机，需要将其转换为IP地址。 但是在某些业务需求中需要将一个IP地址转换为域名。 Linux下，IP与域名的相互转换的C语言实现：</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据域名返回IP</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getIpByHostName</span><span class="params">(<span class="type">char</span> *hostname)</span>;</span><br><span class="line"><span class="comment">//根据IP返回域名</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getHontNameByIp</span><span class="params">(<span class="type">char</span> *ip)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 域名结构体</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// typedef struct hostent &#123;</span></span><br><span class="line"><span class="comment">//     char * h_name;        //正式的主机名称</span></span><br><span class="line"><span class="comment">//     char ** h_aliases;    //主机的别名</span></span><br><span class="line"><span class="comment">//     int h_addrtype;       //主机名的类型</span></span><br><span class="line"><span class="comment">//     int h_length;         //地址的长度</span></span><br><span class="line"><span class="comment">//     char ** h_addr_list;  //从域名服务器获取的主机地址</span></span><br><span class="line"><span class="comment">// &#125; hostent;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getIpByHostName</span><span class="params">(<span class="type">char</span> *hostname)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> * <span class="title">host</span>;</span>                            <span class="comment">//定义hostent指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">in</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_in</span>;</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> h_errno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((host = gethostbyname(hostname))!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;addr_in.sin_addr.s_addr,host-&gt;h_addr,<span class="number">4</span>);  <span class="comment">//复制主机地址、</span></span><br><span class="line">        in.s_addr=addr_in.sin_addr.s_addr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;host name is %s\n&quot;</span>, hostname);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP length: %d\n&quot;</span>, host-&gt;h_length);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Type: %d\n&quot;</span>, host-&gt;h_addrtype);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP : %s\n&quot;</span>, inet_ntoa(in));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;host name is :%s\n&quot;</span>,hostname);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %d\n&quot;</span>,h_errno);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, hstrerror(h_errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getHontNameByIp</span><span class="params">(<span class="type">char</span> *ip)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">in</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr_in</span>;</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> h_errno;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((host=gethostbyaddr(ip, <span class="keyword">sizeof</span>(ip), AF_INET))!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;addr_in.sin_addr.s_addr, host-&gt;h_addr, <span class="number">4</span>);</span><br><span class="line">        in.s_addr = addr_in.sin_addr.s_addr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Host Name is %s\n&quot;</span>, host-&gt;h_name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ip length %d\n&quot;</span>, host-&gt;h_length);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Type is %d\n&quot;</span>, host-&gt;h_addrtype);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Ip is %s\n&quot;</span>, inet_ntoa(in));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error %d\n&quot;</span>, h_errno);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, hstrerror(h_errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> hostname1[] = <span class="string">&quot;www.ansore.net&quot;</span>;              <span class="comment">//定义一个存在的域名</span></span><br><span class="line">  <span class="type">char</span> hostname2[] = <span class="string">&quot;www.123qwdferwerfsdfataewfar.net&quot;</span>;        <span class="comment">//定义一个不存在的域名</span></span><br><span class="line">  <span class="type">char</span> ip[] = <span class="string">&quot;139.129.35.50&quot;</span>;</span><br><span class="line"></span><br><span class="line">  getIpByHostName(hostname1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------------------------\n&quot;</span>);</span><br><span class="line">  getIpByHostName(hostname2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;--------------------------------------------------------\n&quot;</span>);</span><br><span class="line">  getHontNameByIp(ip);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C/C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown笔记</title>
    <url>/posts/b9733a42.html</url>
    <content><![CDATA[<hr>
<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<h4 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h4 id="目录（大纲）"><a href="#目录（大纲）" class="headerlink" title="目录（大纲）"></a>目录（大纲）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[toc]</span><br></pre></td></tr></table></figure>

<h4 id="强调或突出"><a href="#强调或突出" class="headerlink" title="强调或突出"></a>强调或突出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*斜体* 或　_斜体_</span><br><span class="line">**粗体**　或　__粗体__</span><br><span class="line">~~删除线~~</span><br><span class="line">---下划线---</span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul>
<li>有序列表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 有序列表</span><br><span class="line">2. 有序列表</span><br></pre></td></tr></table></figure>

<ul>
<li>无序列表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 无序列表</span><br><span class="line">* 无序列表</span><br><span class="line">+ 无序列表</span><br></pre></td></tr></table></figure>

<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[链接文字](链接地址)</span><br></pre></td></tr></table></figure>



<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片描述](图片地址)</span><br></pre></td></tr></table></figure>

<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">​```java</span><br><span class="line"></span><br><span class="line">​```</span><br></pre></td></tr></table></figure>

<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="center">1</th>
<th align="right">2</th>
<th align="center">3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">年龄</td>
<td align="center">11</td>
<td align="right">22</td>
<td align="center">33</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|姓名|1|2|3|</span><br><span class="line">|:----|:----:|----:|:----:|</span><br><span class="line">|年龄|11|22|33|</span><br><span class="line"></span><br><span class="line">// :----　左对齐</span><br><span class="line">// :----:　居中</span><br><span class="line">// ----: 右对齐</span><br></pre></td></tr></table></figure>

<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><ul>
<li>行内</li>
</ul>
<p>$ f(x) &#x3D; x $ </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ f(x) = x $</span><br></pre></td></tr></table></figure>

<ul>
<li>段落</li>
</ul>
<p>$$ f(x) &#x3D; x $$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ f(x) = x $$</span><br></pre></td></tr></table></figure>

<ul>
<li>上标</li>
</ul>
<p>$$ x^2 $$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ x^2 $$</span><br></pre></td></tr></table></figure>

<ul>
<li>下标</li>
</ul>
<p>$$ x_2 $$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ x_2 $$</span><br></pre></td></tr></table></figure>

<ul>
<li>大括号</li>
</ul>
<p>$$ \lbrace a+1 \rbrace $$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ \lbrace a+1 \rbrace $$</span><br></pre></td></tr></table></figure>

<ul>
<li>尖括号</li>
</ul>
<p>$$ \langle x \rangle $$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ \langle x \rangle $$</span><br></pre></td></tr></table></figure>

<ul>
<li>省略号</li>
</ul>
<p>$$ x_1, x_2 \dots x_n$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ x_1, x_2 \dots x_n$$</span><br></pre></td></tr></table></figure>

<ul>
<li>多行公式</li>
</ul>
<p>$$x + 1 \ x + 2 \ x + 3$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ x + 1 \\ x + 2 \\ x + 3 $$</span><br></pre></td></tr></table></figure>

<ul>
<li>分式</li>
</ul>
<p>$$ \frac {a} {b} $$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ \frac &#123;a&#125; &#123;b&#125; $$</span><br><span class="line"></span><br><span class="line">$$ a \over b $$</span><br></pre></td></tr></table></figure>

<ul>
<li>根式</li>
</ul>
<p>$$ \sqrt [3] {x} $$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ \sqrt [3] &#123;x&#125; $$</span><br></pre></td></tr></table></figure>

<ul>
<li>求和</li>
</ul>
<p>$$ \sum_i^n $$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ \sum_i^n $$</span><br></pre></td></tr></table></figure>

<ul>
<li>积分</li>
</ul>
<p>$$ \int_{1}^{\infty} $$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ \int_&#123;1&#125;^&#123;\infty&#125; $$</span><br></pre></td></tr></table></figure>

<ul>
<li>其他</li>
</ul>
<p>$$ \prod_{1}^{n} $$</p>
<p>$$ \bigcup_{1}^{n} $$</p>
<p>$$ \iint_{1}^{n} $$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$ \prod_&#123;1&#125;^&#123;n&#125; $$</span><br><span class="line"></span><br><span class="line">$$ \bigcup_&#123;1&#125;^&#123;n&#125; $$</span><br><span class="line"></span><br><span class="line">$$ \iint_&#123;1&#125;^&#123;n&#125; $$</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>NFC模拟门禁卡</title>
    <url>/posts/81ba4516.html</url>
    <content><![CDATA[<h4 id="首先必须支持NFC，而且必须root，system有读写权限"><a href="#首先必须支持NFC，而且必须root，system有读写权限" class="headerlink" title="首先必须支持NFC，而且必须root，system有读写权限"></a>首先必须支持NFC，而且必须root，system有读写权限</h4><h4 id="测试机型：小米5"><a href="#测试机型：小米5" class="headerlink" title="测试机型：小米5"></a>测试机型：小米5</h4><p>先安装类似 NFC TagInfo 软件读取出卡的ID，假设卡的ID为 1f,ef,ff,4d 修改&#x2F;etc&#x2F;下的libnfc-nxp.conf文件（可能有的手机不是在这个目录下，可全局搜索nfc），找到下面这段：</p>
<span id="more"></span>

<blockquote>
<p> NXP_CORE_CONF&#x3D;{20, 02, 27, 0E,         18, 01, 01,          21, 01, 00,          28, 01, 00,          30, 01, 04,          31, 01, 00,          32, 01, 60,         33, 00,         50, 01, 02,          54, 01, 06,          5B, 01, 00,          60, 01, 0E,          80, 01, 01,          81, 01, 01,          82, 01, 0E         }</p>
</blockquote>
<p>将第一行括号里的第三个数修改加四，也就是27修改为2B，第八行的第二个00修改为04后面接上卡的ID，以逗号结束，即修改为：</p>
<blockquote>
<p> NXP_CORE_CONF&#x3D;{20, 02, 2B, 0E,         18, 01, 01,          21, 01, 00,          28, 01, 00,          30, 01, 04,          31, 01, 00,          32, 01, 60,         33, 04, 1f,ef,ff,4d,         50, 01, 02,          54, 01, 06,          5B, 01, 00,          60, 01, 0E,          80, 01, 01,          81, 01, 01,          82, 01, 0E         }</p>
</blockquote>
<p>保存文件，重启手机 如果手机重启后NFC能正常开启，一般情况下就是成功了。可代替门禁卡。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>NFC</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令备忘</title>
    <url>/posts/3b2f1e44.html</url>
    <content><![CDATA[<h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name</span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure>

<h4 id="创建本地仓库"><a href="#创建本地仓库" class="headerlink" title="创建本地仓库"></a>创建本地仓库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h4 id="获取远程仓库"><a href="#获取远程仓库" class="headerlink" title="获取远程仓库"></a>获取远程仓库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone &lt;url&gt;</span><br></pre></td></tr></table></figure>



<h4 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加新的远程仓库</span><br><span class="line">git remote add &lt;name&gt; &lt;url&gt;</span><br><span class="line"></span><br><span class="line"># 查看所有remote</span><br><span class="line">git remote [-v]</span><br><span class="line"></span><br><span class="line"># 删除remote</span><br><span class="line">git remote rm &lt;name&gt;</span><br><span class="line"></span><br><span class="line"># 重命名 remote</span><br><span class="line">git remote rename &lt;old&gt; &lt;new&gt;</span><br></pre></td></tr></table></figure>

<h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 创建新分支</span><br><span class="line">git branch &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">git branch -d &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"># 删除remote分支</span><br><span class="line">git push --delete &lt;remote-name&gt; &lt;remote-branch&gt;</span><br><span class="line">git push &lt;remote-name&gt; :&lt;remote-branch&gt;</span><br><span class="line"></span><br><span class="line"># 切换到另一个分支</span><br><span class="line">git checkout &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"># 创建并切换到该分支</span><br><span class="line">git checkout -b &lt;branch-name&gt;</span><br><span class="line"></span><br><span class="line"># 合并某分支到当前分支</span><br><span class="line">git merge &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<h4 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加所有文件 </span><br><span class="line">git add .</span><br><span class="line">git add -A</span><br><span class="line"></span><br><span class="line"># 添加指定文件</span><br><span class="line">git add &lt;file-name&gt;</span><br><span class="line"></span><br><span class="line"># 提交，将暂存区内容提交到当前分支上</span><br><span class="line">git commit -m &quot;注释&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 撤销最近一个提交</span><br><span class="line">git revert HEAD</span><br><span class="line"></span><br><span class="line"># 取消 commit + add</span><br><span class="line">git reset --mixed</span><br><span class="line"></span><br><span class="line"># 取消 commit</span><br><span class="line">git reset --soft</span><br><span class="line"></span><br><span class="line"># 取消 commit + add + local working</span><br><span class="line">git reset --hard</span><br></pre></td></tr></table></figure>

<h4 id="提交到远程服务器"><a href="#提交到远程服务器" class="headerlink" title="提交到远程服务器"></a>提交到远程服务器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push &lt;remote-name&gt; &lt;local-branch&gt;:&lt;remote-branch&gt;</span><br></pre></td></tr></table></figure>

<h4 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<h4 id="从远程下载新的改动"><a href="#从远程下载新的改动" class="headerlink" title="从远程下载新的改动"></a>从远程下载新的改动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull</span><br><span class="line"></span><br><span class="line">git pull &lt;remote-name&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown公式常用符号对应表</title>
    <url>/posts/e2fad57a.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">字母</th>
<th align="center">代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$\alpha$</td>
<td align="center">\alpha</td>
</tr>
<tr>
<td align="center">$\beta$</td>
<td align="center">\beta</td>
</tr>
<tr>
<td align="center">$\gamma$</td>
<td align="center">\gamma</td>
</tr>
<tr>
<td align="center">$\delta$</td>
<td align="center">\delta</td>
</tr>
<tr>
<td align="center">$\Delta$</td>
<td align="center">\Delta</td>
</tr>
<tr>
<td align="center">$\epsilon$</td>
<td align="center">\epsilon</td>
</tr>
<tr>
<td align="center">$\varepsilon$</td>
<td align="center">\varepsilon</td>
</tr>
<tr>
<td align="center">$\zeta$</td>
<td align="center">\zeta</td>
</tr>
<tr>
<td align="center">$\eta$</td>
<td align="center">\eta</td>
</tr>
<tr>
<td align="center">$\theta$</td>
<td align="center">\theta</td>
</tr>
<tr>
<td align="center">$\Theta$</td>
<td align="center">\Theta</td>
</tr>
<tr>
<td align="center">$\vartheta$</td>
<td align="center">\vartheta</td>
</tr>
<tr>
<td align="center">$\iota$</td>
<td align="center">\iota</td>
</tr>
<tr>
<td align="center">$\kappa$</td>
<td align="center">\kappa</td>
</tr>
<tr>
<td align="center">$\lambda$</td>
<td align="center">\lambda</td>
</tr>
<tr>
<td align="center">$\Lambda$</td>
<td align="center">\Lambda</td>
</tr>
<tr>
<td align="center">$\mu$</td>
<td align="center">\mu</td>
</tr>
<tr>
<td align="center">$\nu$</td>
<td align="center">\nu</td>
</tr>
<tr>
<td align="center">$\xi$</td>
<td align="center">\xi</td>
</tr>
<tr>
<td align="center">$\Xi$</td>
<td align="center">\Xi</td>
</tr>
<tr>
<td align="center">$\pi$</td>
<td align="center">\pi</td>
</tr>
<tr>
<td align="center">$\Pi$</td>
<td align="center">\Pi</td>
</tr>
<tr>
<td align="center">$\varpi$</td>
<td align="center">\varpi</td>
</tr>
<tr>
<td align="center">$\rho$</td>
<td align="center">\rho</td>
</tr>
<tr>
<td align="center">$\varrho$</td>
<td align="center">\varrho</td>
</tr>
<tr>
<td align="center">$\sigma$</td>
<td align="center">\sigma</td>
</tr>
<tr>
<td align="center">$\Sigma$</td>
<td align="center">\Sigma</td>
</tr>
<tr>
<td align="center">$\varsigma$</td>
<td align="center">\varsigma</td>
</tr>
<tr>
<td align="center">$\tau$</td>
<td align="center">\tau</td>
</tr>
<tr>
<td align="center">$\upsilon$</td>
<td align="center">\upsilon</td>
</tr>
<tr>
<td align="center">$\Upsilon$</td>
<td align="center">\Upsilon</td>
</tr>
<tr>
<td align="center">$\phi$</td>
<td align="center">\phi</td>
</tr>
<tr>
<td align="center">$\Phi$</td>
<td align="center">\Phi</td>
</tr>
<tr>
<td align="center">$\varphi$</td>
<td align="center">\varphi</td>
</tr>
<tr>
<td align="center">$\chi$</td>
<td align="center">\chi</td>
</tr>
<tr>
<td align="center">$\psi$</td>
<td align="center">\psi</td>
</tr>
<tr>
<td align="center">$\Psi$</td>
<td align="center">\Psi</td>
</tr>
<tr>
<td align="center">$\Omega$</td>
<td align="center">\Omega</td>
</tr>
<tr>
<td align="center">$\omega$</td>
<td align="center">\omega</td>
</tr>
<tr>
<td align="center">$\int$</td>
<td align="center">\int</td>
</tr>
<tr>
<td align="center">$\iint$</td>
<td align="center">\iint</td>
</tr>
<tr>
<td align="center">$\oint$</td>
<td align="center">\oint</td>
</tr>
<tr>
<td align="center">$\infty$</td>
<td align="center">\infty</td>
</tr>
<tr>
<td align="center">$\nabla$</td>
<td align="center">\nabla</td>
</tr>
<tr>
<td align="center">$\because$</td>
<td align="center">\because</td>
</tr>
<tr>
<td align="center">$\therefore$</td>
<td align="center">\therefore</td>
</tr>
<tr>
<td align="center">$\forall$</td>
<td align="center">\forall</td>
</tr>
<tr>
<td align="center">$\exists$</td>
<td align="center">\exists</td>
</tr>
<tr>
<td align="center">$\leq$</td>
<td align="center">\leq</td>
</tr>
<tr>
<td align="center">$\geq$</td>
<td align="center">\geq</td>
</tr>
<tr>
<td align="center">$\neq$</td>
<td align="center">\neq</td>
</tr>
<tr>
<td align="center">$\approx$</td>
<td align="center">\approx</td>
</tr>
<tr>
<td align="center">$\times$</td>
<td align="center">\times</td>
</tr>
<tr>
<td align="center">$\pm$</td>
<td align="center">\pm</td>
</tr>
<tr>
<td align="center">$\div$</td>
<td align="center">\div</td>
</tr>
<tr>
<td align="center">$\mid$</td>
<td align="center">\mid</td>
</tr>
<tr>
<td align="center">$\cdot$</td>
<td align="center">\cdot</td>
</tr>
<tr>
<td align="center">$\not\subset$</td>
<td align="center">\not\subset</td>
</tr>
<tr>
<td align="center">$\in$</td>
<td align="center">\in</td>
</tr>
<tr>
<td align="center">$\notin$</td>
<td align="center">\notin</td>
</tr>
<tr>
<td align="center">$\subset$</td>
<td align="center">\subset</td>
</tr>
<tr>
<td align="center">$\subseteq$</td>
<td align="center">\subseteq</td>
</tr>
<tr>
<td align="center">$\uparrow$</td>
<td align="center">\uparrow</td>
</tr>
<tr>
<td align="center">$\downarrow$</td>
<td align="center">\downarrow</td>
</tr>
<tr>
<td align="center">$\rightarrow$</td>
<td align="center">\rightarrow</td>
</tr>
<tr>
<td align="center">$\leftarrow$</td>
<td align="center">\leftarrow</td>
</tr>
<tr>
<td align="center">$\Uparrow$</td>
<td align="center">\Uparrow</td>
</tr>
<tr>
<td align="center">$\Downarrow$</td>
<td align="center">\Downarrow</td>
</tr>
<tr>
<td align="center">$\Rightarrow$</td>
<td align="center">\Rightarrow</td>
</tr>
<tr>
<td align="center">$\Longleftarrow$</td>
<td align="center">\Longleftarrow</td>
</tr>
<tr>
<td align="center">$\lbrace \rbrace$</td>
<td align="center">\lbrace \rbrace</td>
</tr>
<tr>
<td align="center">$\overline{a+b+c+d}$</td>
<td align="center">\overline{a+b+c+d}</td>
</tr>
<tr>
<td align="center">$\hat{y}$</td>
<td align="center">\hat{y}</td>
</tr>
<tr>
<td align="center">$\check{y}$</td>
<td align="center">\check{y}</td>
</tr>
<tr>
<td align="center">$\breve{y}$</td>
<td align="center">\breve{y}</td>
</tr>
<tr>
<td align="center">$\bigcup$</td>
<td align="center">\bigcup</td>
</tr>
<tr>
<td align="center">$\bigcap$</td>
<td align="center">\bigcap</td>
</tr>
<tr>
<td align="center">$\bigvee$</td>
<td align="center">\bigvee</td>
</tr>
<tr>
<td align="center">$\bigwedge$</td>
<td align="center">\bigwedge</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>身份证号码验证算法</title>
    <url>/posts/84e6c10f.html</url>
    <content><![CDATA[<h3 id="一、18位身份证号码结构"><a href="#一、18位身份证号码结构" class="headerlink" title="一、18位身份证号码结构"></a>一、18位身份证号码结构</h3><p>身份证号码由前十七位本体码和最后一位校验码组成</p>
<p>排列次序一次依次是：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位校验码</p>
<h3 id="二、校验值计算"><a href="#二、校验值计算" class="headerlink" title="二、校验值计算"></a>二、校验值计算</h3><p>1.本体码加权求和</p>
<p>公式为：S &#x3D; SUM(Ai*Bi);</p>
<p>-Ai为身份证上第i个数字</p>
<p>-Bi为第i个加权因子（加权因子：7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2）</p>
<p>2.计算模</p>
<p>mode &#x3D; S % 11;</p>
<p>3.查找相应校验码</p>
<p>校验码：1 0 X 9 8 7 6 5 4 3 2 （第mode个）</p>
<h3 id="三、C语言实现"><a href="#三、C语言实现" class="headerlink" title="三、C语言实现"></a>三、C语言实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 身份证验证算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获得校验码</span></span><br><span class="line"> <span class="type">char</span> <span class="title function_">getValidateCode</span><span class="params">(<span class="type">char</span> *idcard)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//验证身份证</span></span><br><span class="line"> <span class="type">int</span> <span class="title function_">getValidateResult</span><span class="params">(<span class="type">char</span> * idcard,<span class="type">char</span> validateCode)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//存储身份证号码</span></span><br><span class="line"> <span class="type">char</span> * idcard=<span class="string">&quot;122222190904057081&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">char</span> code = getValidateCode(idcard);</span><br><span class="line"> <span class="type">int</span> result = getValidateResult(idcard,code);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;validatecode is %c\n&quot;</span>,code);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(result==<span class="number">1</span>)&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;身份证号码正确\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;身份证号码不正确\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取身份证校验码（最后一位）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">getValidateCode</span><span class="params">(<span class="type">char</span> *idcard)</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> weight[<span class="number">17</span>] = &#123;<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="type">char</span> validate[<span class="number">11</span>] = &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> i,sum=<span class="number">0</span>,mode;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">17</span>;i++)&#123;</span><br><span class="line"> sum = sum + (idcard[i] - <span class="string">&#x27;0&#x27;</span>) * weight[i];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//计算模</span></span><br><span class="line"> mode = sum%<span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> validate[mode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到验证结果 0不正确 1正确</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getValidateResult</span><span class="params">(<span class="type">char</span> * idcard,<span class="type">char</span> validateCode)</span>&#123;</span><br><span class="line"> <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(idcard[<span class="number">17</span>]==validateCode)&#123;</span><br><span class="line"> result = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>编程</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CloudFlare的SSL证书不信任问题</title>
    <url>/posts/f2bb7cec.html</url>
    <content><![CDATA[<p>我的域名由CloudFlare托管，主要看重它的解析特别快，几分钟就生效。我用的是CloudFlare签发的15年证书，一直套着CDN用，由于众所周知的原因，有时候突然会访问不了我的服务。有一天把CDN关了之后访问我的服务，浏览器就报证书不可信，查询之后才知道非CA机构颁发的证书是不被信任的，跟自己签发的没区别，除非套上CloudFlare的CDN。emm…</p>
<p>免费的如Let’s Encrypt，需要三个月更新一次证书，虽然可以写个脚本定时更新，但是据说规则也变化，也不想折腾了。另外一方面，套上CDN以后可以隐藏真实IP，减少不必要的麻烦。</p>
<p>基于这些考虑，我决定还是忍受一下时不时访问不了的问题，套上CDN，继续用15年的证书。</p>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>CloudFlare</tag>
      </tags>
  </entry>
  <entry>
    <title>关于自己搭建图床</title>
    <url>/posts/1d36fa67.html</url>
    <content><![CDATA[<h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><p>我之前使用的图床是SM.MS，一直相安无事，直到Gitee图床的外链问题，让我意识到我该做点什么了，虽然SM.MS是个老牌图床，但是自己搭建一个，数据掌握在自己手里比较安心，毕竟数据丢了后悔就来不及了</p>
<h1 id="图床选择"><a href="#图床选择" class="headerlink" title="图床选择"></a>图床选择</h1><p>图床程序：<a href="https://github.com/lsky-org/lsky-pro.git">lsky-pro</a></p>
<p>Docker镜像：<code>halcyonazure/lsky-pro-docker</code></p>
<p>Docekr镜像地址：<a href="https://github.com/HalcyonAzure/lsky-pro-docker.git">lsky-pro-docker</a></p>
<p>感谢各位开源老铁！</p>
<h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p>使用docker搭建，我的图片不是很多，使用本地存储，数据库使用sqllite，并将数据目录映射出来，自己做备份</p>
<p>另外我的VPS只开放80和443端口，其他服务通过nginx反代处理，配置域名，这样即使以后迁移服务器，也不需要更改什么。</p>
<p>运行docker容器，将服务映射到1081端口，映射数据目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name lsky-pro \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  -p 1081:80 \</span><br><span class="line">  -v /opt/application/lsky:/var/www/html \</span><br><span class="line">  halcyonazure/lsky-pro-docker:latest</span><br></pre></td></tr></table></figure>

<p>Nginx反代：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream lsky &#123;</span><br><span class="line">    server 127.0.0.1:1081;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    server_name  xxx.xx;</span><br><span class="line">    return 301 https://xxx.xx$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    listen [::]:443 ssl http2;</span><br><span class="line">    gzip on;</span><br><span class="line">    server_name  xxx.xx;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/cert/xxx.xx/cert.crt;</span><br><span class="line">    ssl_certificate_key /etc/cert/xxx.xx/private.key;</span><br><span class="line"></span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    access_log /var/log/nginx/lsky_access.log combined;</span><br><span class="line">    error_log  /var/log/nginx/lsky_error.log;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_pass http://lsky;</span><br><span class="line"></span><br><span class="line">        proxy_set_header  Host                $http_host;</span><br><span class="line">        proxy_set_header  X-Real-IP           $remote_addr;</span><br><span class="line">        proxy_set_header  X-Forwarded-Ssl     on;</span><br><span class="line">        proxy_set_header  X-Forwarded-For     $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header  X-Forwarded-Proto   $scheme;</span><br><span class="line">        proxy_set_header  X-Frame-Options     SAMEORIGIN;</span><br><span class="line"></span><br><span class="line">        client_max_body_size        100m;</span><br><span class="line">        client_body_buffer_size     128k;</span><br><span class="line"></span><br><span class="line">        proxy_buffer_size           4k;</span><br><span class="line">        proxy_buffers               4 32k;</span><br><span class="line">        proxy_busy_buffers_size     64k;</span><br><span class="line">        proxy_temp_file_write_size  64k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问对应域名，安装，完毕！</p>
<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>目前我选择两种备份策略</p>
<ol>
<li>rclone挂载OneDrive，然后使用以下脚本备份</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># backup lsky</span></span><br><span class="line">tar -czvPf /home/OneDrive/Server/Backup/lsky_backup.tar.gz /opt/application/lsky</span><br></pre></td></tr></table></figure>

<p>执行任务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 * * * sh /opt/application/backup.sh</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Duplicati备份到OneDrive和GoogleDrive</li>
</ol>
]]></content>
      <categories>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>折腾</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>晶体管构成的逻辑门</title>
    <url>/posts/7fc14d24.html</url>
    <content><![CDATA[<h1 id="晶体管构成的逻辑门"><a href="#晶体管构成的逻辑门" class="headerlink" title="晶体管构成的逻辑门"></a>晶体管构成的逻辑门</h1><p>三极管有两种，一种是PNP型。用E到B的电流控制E到C的电流，E的电压是最高的。另一种是NPN型，用B到E的电流控制C到E电流，C的电压是最高的。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e0cf1c836.png" alt="Untitled"></p>
<p>我们来看一个PNP型三极管的例子，本例的目的，是用三极管控制灯泡的亮灭。</p>
<p>我们先搭建一个包含三极管灯泡及电源的回路，这个时候可以看到回路是不通的。现在我们开始添加其他电路，一个电阻、一个电源加一个开关。我们闭合控制电路的开关，灯泡那个回路通了，灯泡就亮了，这就是三极管作为开关的应用。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e0d53c69a.png" alt="Untitled"></p>
<p>如果我们把开关替换为一个麦克风，麦克风本质上也是一个开关，不过它感知的是声音。然后把灯泡替换为一个喇叭，这就形成一个基本的放大电路。麦克风的声音会控制喇叭的通断，并且麦克风的声音会放大到喇叭里。</p>
<p>左侧的这部分电路，称为控制电路。如果我们拿一个方盒子把它盖起来，那么灯泡回路的通断，其实就取决于控制电路的通断。我们把高电压用1表示，低电压或者没电压用0表示。那么控制电路输出1，三极管输出1，灯泡回路就通，灯泡就亮起。反之控制电路输出0，三极管输出0，灯泡回路就断，灯泡就熄灭。输出跟输入是相同的，这种被称为同相器，多用于放大电路</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e0db0633b.png" alt="Untitled"></p>
<p>如果我们把之前灯泡串联的两个手动开关，替换为两个PNP型三极管，同样会形成一个新的串联电路。只闭合右边的开关，灯泡是不亮的；同时闭合两个开关，灯泡就会亮起。这两个串联的三极管，称为与门。只有当两个控制的腿输入都为1时，灯泡的回路才会导通，也就是输出才为1。与门真值表，与我们学过的逻辑“与”是一样的。</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e0ddca8c3.png" alt="Untitled"></p>
<p>同样的把之前灯泡并联的两个手动开关，替换为两个PNP型三极管，也会形成一个新的并联电路。这时候闭合任意一个开关，灯泡都会亮；两个开关都闭合，灯泡当然也是亮的；只有两个开关都断开时，灯泡才会熄灭。任意一个控制的腿输入为1，灯泡的回路就会导通，也就是输出才为1。这两个并联的三极管，称为或门，或门真值表，与我们学过的逻辑“或”是一样的。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e0e83f7b7.png" alt="Untitled"></p>
<p>下面我们来用一个NPN型三极管，右边的5V电压作为输入，接到三极管最上面的腿，同时拐个弯引出一条线作为输出。三极管中间的腿是控制，接一个带开关的5V电压，最下面一条腿接地。</p>
<p>当控制的开关闭合，三极管导通，作为输入的5V会直接流向大地，而不会从输出那条线出来；当控制的开关断开，三极管断开，作为输入的5V会直接流向输出，这就形成了一个非门电路。输入和输出刚好是反的，非门的真值表同样很简洁。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e0f2866ce.png" alt="Untitled"></p>
<p>以上就是布尔运算中与或非的实际电路实现，与或非门是最基本的门电路，我们可以用它们搭建组合其他的电路。比如我们可以把与门与一个非门串联，就会形成一个与非门。它的符号就是与门符号加了一个小圆圈，而真值表则刚好跟与门相反。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e0f83a5b1.png" alt="Untitled"></p>
<p>那如果把一个或门和一个非门串联，会形成什么呢？啊哈，一个或非门就完成了！是不是很简单？或非门的符号就是或门加一个小圆圈，真值表也跟或门刚好相反。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e10195bb3.png" alt="Untitled"></p>
<p>接下来是今天最复杂的电路，我们要实现布尔运算的“异或”，也就是要造一个异或门。我们先来画好两个输入一个输出，然后放一个与门，紧接着一个非门，再放一个或门，把非门的输出和或门的输出作为最后一个与门的输入，一个异或门就造好了。 </p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>基本运算原理</title>
    <url>/posts/6c643e9e.html</url>
    <content><![CDATA[<h1 id="基本运算原理"><a href="#基本运算原理" class="headerlink" title="基本运算原理"></a>基本运算原理</h1><p><img src="https://img.ansore.de/2022/05/15/6280e376b19f8.png" alt="Untitled"></p>
<p><img src="https://img.ansore.de/2022/05/15/6280e37b8a7eb.png" alt="Screenshot_20220103_131456.png"></p>
<p><img src="https://img.ansore.de/2022/05/15/6280e37f7189e.png" alt="Untitled"></p>
<p>我们可以用一个与门、一个或门，来搭建一个2位的加法器。异或门来计算和 ，与门计算进位。</p>
<p>这个电路称为半加器</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3824bb68.png" alt="Untitled"></p>
<p>半加器有2个输入X、Y，2个输出，分别是和以及进位。它能产生进位，但是不能处理进位。这是另一层抽象，我们可以把半加器作为一个元件来使用。我们再进一步，制造一个可以做3位加法的电路。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e388becab.png" alt="Untitled"></p>
<p>3个1位二进制数相加，最大值就是1+1+1&#x3D;11，同样可以用2位保存结果。具体电路实现，我们可以用2个半加器和1个或门来搭建。一共有3个输入X、Y、Z，我们把X、Y输入到第一个半加器，输出的和跟Z一起输入到第二个半加器。然后把两个半加器的进位输入到或门，第二个半加器输出的和就是最终的和，而或门的输出就是进位。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e38b39e2a.png" alt="Untitled"></p>
<p>两个进位是不可能同时为1的，因为任意两个输入相加，如果产生了进位，那么和一定是0。再加上一位无论是0还是1，都不会产生进位。</p>
<p>我们把3个1位数相加的所有情况都列出来，一共有8种。然后再把电路拉出来，X、Y、Z是三个输入位，XOR 1跟AND 1组成了第一个半加器，XOR 2跟AND 2组成了第二个半加器，OR 1处理两个半加器的进位，这就是全加器的所有电路。</p>
<p>XOR 1的输出是X+Y的和，作为XOR 2还有AND 2的输入。AND 1的输出是X+Y的进位，作为OR 1的输入。Z是XOR 2的第2个输入，XOR 2的输出是最终的和。同时，Z也是AND 2的输入。AND 2的输出和AND 1的输出共同作为OR 1的输入，OR 1的输出就是最终的进位。 </p>
<p>全加器可以接收3个输入，并产生和以及进位，同时它也可以处理计算中产生的进位。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e38fef4da.png" alt="Untitled"></p>
<p>它接受3个输入，并输出和与进位，它也能处理计算过程中的进位。有了半加器和全加器，我们又可以更上一层楼了。计算机中1个1位的二进制数称为1个比特（Bit），也可以叫1位，而8个比特长度的二进制数称为1个字节（Byte）。 </p>
<p>现在我们来搭建一个8位的计算单元，也就是可以接受2个单字节的数A、B作为输入，然后计算它们的和。1个字节共有8个比特，即8位，而计算机中序号是从0开始的。就是说，1个字节的第1位，序号是0。而第8位，序号是7，这个序号我们称为索引（Index）。</p>
<p>A0+B0可以用一个半加器处理，因为不需要处理来自上次计算的进位。而A1+B1需要处理A0+B0的进位以及A1、B1本身，所以需要1个全加器，来处理这3个输入。从A1、B1到A7、B7，都需要处理进位，所以必须都用全加器处理。</p>
<p>我们用1个半加器和7个全加器，就制造了一个可以处理两个字节A、B加法的计算单元。同时我们注意到，最后一个全加器的进位是没有被处理的。所以这可能会导致计算错误，我们称之为溢出。</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e395409d4.png" alt="Untitled"></p>
<p>那么，它可以做减法吗？可以，但是跟我们平常做减法不一样。计算机里的减法，也是通过加法来实现的，比如我们8-3等价于8+（-3）。那么计算机是怎么表示负数的呢？简单起见，我们以一个4位的计算机为例。 </p>
<p>4位的计算机，能处理的最大的数是1111。我们从0000开始，每次加1，在加了15次之后，我们得到了1111。那么1111+1等于多少呢？正常应该是10000，但是这是一个4位的计算机。所以最高位的1是没法存储的，所以被丢弃了。那么最后结果就是0000，这就又回到了最初的起点。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e397aa678.png" alt="Untitled"></p>
<p>就像钟表一样，指针转完一圈就开始新的一圈，我们也做一个4位二进制表盘。从0000开始顺时针旋转，一直到1111一共16个数字。但是计算机只认识0和1，它可不知道正负数。表盘的16个数字，我们以0000为分界线做个切分。拿出一部分来表示负数，比如最高位是1的部分。那么最高位就成了一个标志位，是0就是正数，是1就表示负数，0的二进制就是0000。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3999859c.png" alt="Untitled"></p>
<p>而0向右依次加1，就得到了正整数。向左依次减1，就得到了负整数。然后我们把这些数字铺下去，以0为基准，顺时针旋转1下，得到1，再转一下得到2，以此类推。以0为基准，逆时针旋转一下，得到-1，再转一下得到-2，很合理吧。而数学里是没有+0和-0之分的，所以1000不是表示-0，而是表示-8。</p>
<p>我们在这个表盘上做个减法，比如2-3，先把当前位置定到2，-3的话就是逆时针旋转3下，就来到了-1这里。这个很简单，因为我们这个表盘是个循环，所以我们还有另一种方法到达-1。就是从2的位置，继续顺时针旋转，13下之后就到了-1。 </p>
<p>因为从2出发，转一整圈还会回到2，就如同钟表一样。所以2+16其实就等效于2，所以2-3也等于2+16-3，这里结合咱们的表盘，停下来想一想。 </p>
<p>而对于-1～-7，如何计算它在表盘上的二进制数呢？我们以-1为例，+1的二进制数为0001。那么我们先把标志位切换为1，得到1001，这个叫做-1的原码。然后把1001除了标志位外的3位取反，得到1110，这个叫做-1的反码。然后再把反码加1，得到1111，这就是-1的补码。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e39d28eb6.png" alt="Untitled"></p>
<p>1～-7在表盘上对应的二进制数字，就是补码。0和正整数1～7的原码、反码、补码都是一样的。-8有点不一样，1000本来是表示-0，但是只有1个0。所以-8的原码、反码、补码都是一个码1000。其实1000也等于+7的码0111+1。 </p>
<p>4位计算机下的整数表示。范围是-8～7，共计16个数字。同时，这个理论也适用于任何多位的计算机，无论是8位、32位、64位，方法都一样</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e39e73893.png" alt="Screenshot_20220103_132312.png"></p>
<p>那我们来做个减法 7-3，首先我们获取-3的原码1011，然后取反得到-3的反码1100，在把反码+1得到-3的补码1101。7的补码是0111，0111+1101&#x3D;10100，最高位的1会被丢弃，所以最后结果是0100，也就是4。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3a08195b.png" alt="Untitled"></p>
<p>这里做一个把4位机拓展到N位机的小总结</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3a64bd1a.png" alt="Untitled"></p>
<p>那我们那个8位的计算单元，能做乘除法吗？必须的，只不过乘法是通过拆成加法来做的，比如4x5，就是4个5相加。而除法是先拆成减法，比如20&#x2F;5，就是20持续的减5，再把减法通过加法实现。</p>
<p>总而言之，这个8位计算单元，加减乘除都能做。而更先进的CPU，可以通过搭建专业的电路来做乘除法 </p>
<p>同时，计算机除了做计算之外，还需要做一些逻辑判断。比如判断计算结果是否溢出，这个我们在全加器那提到过。判断结果是否为0，可以额外搭建一个电路。判断奇偶性则可以通过判断最终结果的最低位是否为0。我们来看看判0电路怎么做，8位的计算单元输出是8位，我们用7个或门，依次计算其中任意一位是否为1，就可以得出结论了。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3a97908a.png" alt="Untitled"></p>
<p>而计算单元+逻辑单元，组合起来就得到了一个ALU。全称是逻辑运算单元，既能做逻辑判断也能做加减乘除等计算，我们用一个大V来表示。它接受2个8位也就是1字节的输入，同时输出1个8位的结果。它接受1个4位的操作码，比如1000代表加。也会输出诸如结果是否为0或者为负值等逻辑状态，这就是一个基本全功能的ALU了。</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3adbf896.png" alt="Untitled"></p>
<p>而诸如我们提到的1000代表加法，这就是计算机指令。世界上第一个封装到单芯片中的完整ALU，是英特尔的74181芯片，它使用了70个晶体管，是一个4位的ALU。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU运行指令</title>
    <url>/posts/68e12db1.html</url>
    <content><![CDATA[<h1 id="CPU运行指令"><a href="#CPU运行指令" class="headerlink" title="CPU运行指令"></a>CPU运行指令</h1><h1 id="搭建计算机"><a href="#搭建计算机" class="headerlink" title="搭建计算机"></a>搭建计算机</h1><p>数据不保存，是没有意义的。所以我们需要制造可以保存数据的电路，这个电路既可以读取，也可以写入数据。之前我们所有的电路都是一路向前的，有没有想过把输出接到输入上会怎样？ </p>
<p>我们来看一个吃自己的小电路，这是一个或门，我们把输出接回到其中一个输入上。然后再增加电源，给它来一个1，也就是高电压。你看或门的输出变成了1。然后这个1又回到了或门的第二个输入，也就是它把自己的输出又吃了回去。现在，即使我们断开第一个输入，或门的输出也还是1，这样我们就保存了一个1。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3bc1368c.png" alt="Untitled"></p>
<p>但是这个电路有个小问题，就是这个改变是永久性的，只要不断电，那么这个或门的输出就永远是1，这样的话也没啥大用。我们想要一个可以按照需求改变的电路，把这个或门电路拓展一下，我们就得到了这样的一个电路。有2个输入，1个SET，1个RESET。</p>
<p>SET可以让电路保存1，RESET可以让电路保存0。看起来好像可以工作了的样子，功能上没啥问题，就是太费线了。如果要保存8位数据，那么需要8个这样的电路。就需要16根线，来分别控制每个电路的SET和RESET。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3be80e88.png" alt="Untitled"></p>
<p>这要是存个1024个字节，那就是1024x2根线。1024个字节，我们称为1KB。而1MB&#x3D;1024x1KB，1GB&#x3D;1024x1MB，那就很难想象如何存取1MB甚至1GB的数据。那得需要多少条线啊！</p>
<p>那么，我们再改进一下，做一个这样的电路。这个电路也有2个输入，1个写入，1个使能。使能相当于一把锁，可以控制数据的写入。当这把锁是0，写入无论怎么改变，都不能保存，这就是锁上的状态；当这把锁是1，也就是锁打开了，你写入1，然后再把锁关闭，那么这个1就锁在里面了。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3c093791.png" alt="Untitled"></p>
<p>你看，我们又可以保存1个比特的信息了，这个电路比上个电路优点在哪呢？假设我们要存1个字节也就是8位的数据，那么我们可以用8个这样的电路。然后让这8个电路公用同一把锁，1根线就够了。数据写入是分开的，共有8根线。当锁打开的时候，8个位都可以写入；当锁关闭的时候，8各位都不能写入。这样一共只需要9根线，就可以组成1个8位的存储单元了。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3c34fd87.png" alt="Untitled"></p>
<p>如果你堆叠的更多，可以形成16位、32位、64位的存储单元。这样的电路多用在寄存器上，它的执行速度比较快。我们称之为SRAM，静态随机访问存储。也可以用SRAM来做内存，但是成本比较高。</p>
<p>SRAM存储1位，就要用到6个逻辑门，10个晶体管。在芯片上占的面积大，而且很贵啊！所以在实际的CPU中，寄存器的数量不会太多。百个左右，也就是KB级别的。而主流的内存都是用DRAM，动态随机访问存储。 </p>
<p>这个动态是哪里在动呢？我们先来了解一个新的元件-电容。电容的结构很简单，一般有两片金属电极，中间夹一层绝缘材料。然后两个电极上接上导线，一个电容就做成了。当我们给电极通电，电荷会在金属电极上积聚；当你把电断开后，电荷仍存在。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3c53b6fe.png" alt="Untitled"></p>
<p>这是由于同性相斥、异性相吸形成的一个静电场。我们来搭建一个简单的电路，使用一个电容，以及一个PNP三极管作为开关。可以看到当开关闭合后后，三极管导通，电容就开始充电；当开关断开后，三极管也断开，但是电容仍然带电，OUTPUT会输出一个高电压，这时OUTPUT就保存了1。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3c7724ff.png" alt="Untitled"></p>
<p>但是呢，电容里的电量，会一点点漏掉，最终会完全放电，而电压也就消失了。所以需要定期给电容充电，以让它保持电压。也即保证数据不丢失，定期充电我们称之为刷新。这就是动态的由来，8个这样的存储单元可以保存1个字节。SRAM，只要0或者1保存进去，它就会一直在那里。DRAM，如果要保持0或者1，就要一直刷新，所谓静态与动态是相对的概念。 </p>
<p>好了，我们现在有了制造寄存器和内存单元的电路，如果我们有多个存储单元，比如有4个，那么我们怎么找到它们呢？也就是我们如何处理这些存储单元定位的问题。我们搭建一个电路，有2个输入X、Y，还有A、B、C、D4个输出。X、Y分别有0、1这2种状态，那么组合一共有00、01、10、11四种状态。X、Y都为0，则C的输出为1；X&#x3D;0，Y&#x3D;1，则D的输出为1；X&#x3D;1，Y&#x3D;0，则A的输出为1；X、Y分别为1，则B的输出为1。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3c98c672.png" alt="Untitled"></p>
<p>A、B、C、D这4根线，分别接到4个1字节存储单元的ENABLE线上，是不是就可以控制4个存储单元的写入了？输入为00、01、10、11时，可以分别找到C、D、A、B。00、01、10、11对应一个特定的位置，就像一个门牌号。我们把X、Y称之为地址线，而A、B、C、D称之为地址。2根线最多寻找4个地址，这就是2根线的寻址能力。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3cb517fa.png" alt="Untitled"></p>
<p>如果拓展到3根线，则可以表示8个位置，同样可以通过设计相应的电路实现。以111为例，通过2个与门即可让输入111时，找到门牌号为111的那根线。那么3根线的寻址能力为2x2x2，也就是8个地址。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3cd88cd7.png" alt="Untitled"></p>
<p>我们来做一个4根线的选择器，它的寻址能力为2的4次方，也就是16个地址，这是我们会用到的一个内存组。它可以保存16个字节的数据，它的地址从0000，一直延伸到1111。</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3cf227eb.png" alt="Untitled"></p>
<p>我们再来制造一个寄存器组，每个寄存器单元为1个字节，所以需要一组8位宽的数据线。然后在放置8个寄存器单元，把前面制作的3线选择器放在上方，这样就可以找到每一个寄存器单元，这就形成了一个8个字节的寄存器组。每一个寄存器都可以单独定位，执行写入和读取。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3d7237b6.png" alt="Untitled"></p>
<p>现在我们有了更高级的元件，可以开始搭建CPU了。首先我们放一个ALU，这个是在上一期视频中搭建的。接受2个输入，每个输入位1字节，也就是8位。输出是1字节，也是8位，同时也输出结果是否为0，是否溢出等逻辑状态。然后再放4个通用寄存器，分别为A、B、C、D。这4个寄存器主要是用于计算过程中使用，它们都是8位的寄存器。IC和IP是两个专用寄存器，IC用来给指令计数，IP用来存储指令地址。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3d902f23.png" alt="Untitled"></p>
<p>计算机中的指令，在最底层是以电压的高低存在。高高低低的电压，进入不同的电路，产生各种结果。我们用1和0来表示电压高低，这种二进制形式的指令，称之为机器语言。它比电压的高低还是好记一些，现在我们制定几个简单的指令。</p>
<p>LOAD_A为0000，功能是把紧跟在后面的一个4位地址的内容加载到寄存器A。LOAD_B为0001，与LOAD_A类似，只不过把数据加载到寄存器B。ADD为0100，是加法指令，把指定的两个寄存器中的数字相加，然后保存到第一个寄存器。STORE_A是存储指令，把A中的数据存储到紧跟在后面的4位地址中，它的二进制编码，是1000。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3e016f62.png" alt="Untitled"></p>
<p>0001、0100是机器语言指令，会被转换为高低电压信号，然后被计算机执行。而0001、0100这种二进制数字是在是难以记忆的，所以人们给它们起了诸如LOAD_A、ADD等别名，这样对编程人员会更加友好一些。这样的别名组成的语言，就是汇编语言。</p>
<p>而计算机是如何识别汇编语言呢？比如你写了一个LOAD_B，那么LOAD_B首先会被转为2进制的形式，就是0001。计算机当然也不会理解0001，它是通过电路来理解具体的指令。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3e241fed.png" alt="Untitled"></p>
<p>我们这里做一个解码电路，它只有在输入为0001时，输出才为1。它可以判断指令是否为0001，其他的指令也是同理。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3e45ebcb.png" alt="Untitled"></p>
<p>内存部分也可以加进来了，我们的内存一共有16个字节，共需4位的门牌号来标示每个地址。解码器也放置到位，它可以接受4位的指令，解码后再输入到相应的电路。用个框框圈起来，这一部分被称为控制单元，也就是CU。当然CU还包括一些存取的电路，这里我就不画了。 </p>
<p>我们把4个寄存器连接到CU，建立CU与寄存器的连接，同时寄存器也连接到内存，这样数据就可以在寄存器与内存间传递。然后把ALU的输入和输出连接到CU，寄存器中的内容可以由CU送到ALU的输入。ALU的输出也可以送到CU，然后再保存到寄存器。最后把内存也连接到CU，CU可以从内存中读取指令，也可以把数据写入到内存等。 </p>
<p>这里要注意一下，内存到CU有两组线，地址线和数据线。CU要负责找到相应的地址，并且读取数据、指令等。然后我们再加一个框框，框起来的部分我们叫CPU。这样，我们就搭建了一台冯·诺伊曼架构的计算机。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3e745e86.png" alt="Untitled"></p>
<p>冯·诺伊曼架构是指存储程序计算机，CPU要执行的指令，以及要处理的数据，都要先进入内存，然后再进入CPU。现代CPU还会有多级缓存，主要是为了解决CPU运算速度够，而读取数据不够的问题。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3e98b4a4.png" alt="Untitled"></p>
<p>还会有分之预测的电路，也是为了提高运算速度。我们这个小小的CPU，主要是为了研究原理。那么多电路估计各位也记不住，主要是让你形成印象，知道CPU内部是怎么做计算的就可以了。</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3ef753f0.png" alt="Untitled"></p>
<h1 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令"></a>运行指令</h1><p>现在我们就用这几个指令来写个小程序，目的是为了把2个数字相加，然后再把结果存到内存中。程序对应的代码就是这4行 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3f074f6e.png" alt="Untitled"></p>
<p>计算机执行这些指令分三个步骤，把指令拿过来，看看什么意思，然后送去执行。执行完毕后再进行下一条，还是同样的步骤：取指、解码、执行。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3f2f39f2.png" alt="Untitled"></p>
<p>我们把刚才写的小程序放到计算机内存里，冯·诺伊曼架构的计算机是存储程序计算机，所以我们的指令和数据必须先放到内存。计算机里存储数据、指令包括内存地址都是二进制的，为了方便查看，我们把二进制指令转换为汇编指令。把二进制内存地址也转为十六进制。</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3f638fbe.png" alt="Untitled"></p>
<p>我们把这个小程序拆分成具体的动作，指令计数器在CPU初始化完成后，被置为0。然后控制单元到内存地址为0的位置取指令，这里存储的指令为LOAD_A 7，指令会进入IP。经过解码器解码后，进入执行阶段，这是一个加载指令。把门牌号为7的内存地址的内容，加载到寄存器A。7号地址存的是数字8，数字8就进入了寄存器A。第一条指令执行完成，然后IC加1，到下一个位置取指令。同样经过取指、解码、执行三个阶段，LOAD_B 8执行后，数字6进入了寄存器B。 </p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3fbf2f60.png" alt="Untitled"></p>
<p>然后IC继续加1，这里的指令是ADD A B。寄存器A中的数字8和寄存器B中的数字6，被送往ALU的两个输入端，经过计算后产生结果14。14会被控制单元再存回寄存器A，这时寄存器A的内容为数字14。IC再加1，得到指令STORE_A 15。STORE_A指令会把寄存器A中的内容，存到门牌号为15的内存。数字14进入15号内存地址，这个程序就执行完毕了。</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e3fe5b8c2.png" alt="Untitled"></p>
<p>这就是绝大多数的计算机执行指令的过程</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu运行第一个X86汇编程序</title>
    <url>/posts/8bc2bf34.html</url>
    <content><![CDATA[<h1 id="qemu运行第一个X86汇编程序"><a href="#qemu运行第一个X86汇编程序" class="headerlink" title="qemu运行第一个X86汇编程序"></a>qemu运行第一个X86汇编程序</h1><p>新建一个文件，命名为start.asm</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, <span class="number">0b</span>800h</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">mov byte [<span class="number">0x00</span>], <span class="string">&#x27;2&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x02</span>], <span class="string">&#x27;0&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x04</span>], <span class="string">&#x27;2&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x06</span>], <span class="string">&#x27;2&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x08</span>], <span class="string">&#x27;,&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x0a</span>], <span class="string">&#x27;H&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x0c</span>], <span class="string">&#x27;a&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x0e</span>], <span class="string">&#x27;p&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x10</span>], <span class="string">&#x27;p&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x12</span>], <span class="string">&#x27;y&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x14</span>], <span class="string">&#x27; &#x27;</span></span><br><span class="line">mov byte [<span class="number">0x16</span>], <span class="string">&#x27;n&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x18</span>], <span class="string">&#x27;e&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x1a</span>], <span class="string">&#x27;w&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x1c</span>], <span class="string">&#x27; &#x27;</span></span><br><span class="line">mov byte [<span class="number">0x1e</span>], <span class="string">&#x27;Y&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x20</span>], <span class="string">&#x27;e&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x22</span>], <span class="string">&#x27;a&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x24</span>], <span class="string">&#x27;r&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x26</span>], <span class="string">&#x27;!&#x27;</span></span><br><span class="line"></span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">times <span class="number">510</span>-($-$$) db <span class="number">0</span></span><br><span class="line">db <span class="number">0x55</span>, <span class="number">0xaa</span></span><br></pre></td></tr></table></figure>

<p>编译汇编程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nasm -f bin start.asm -o start.img</span><br></pre></td></tr></table></figure>

<p>qemu运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ qemu-system-x86_64 -fda start.bin</span><br></pre></td></tr></table></figure>

<p>会看到如下输出</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e40a569fe.png" alt="Screenshot_20220103_130235.png"></p>
<p>虚拟机运行</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e40d84541.png" alt="Untitled"></p>
<p><img src="https://img.ansore.de/2022/05/15/6280e41104f29.png" alt="Untitled"></p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4133b407.png" alt="Untitled"></p>
<p>其十六进制如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">B8 00 B8 8E D8 C6 06 00 00 32 C6 06 02 00 30 C6 06 04 00 32 C6 06 </span><br><span class="line">06 00 32 C6 06 08 00 2C C6 06 0A 00 48 C6 06 0C 00 61 C6 06 0E 00 </span><br><span class="line">70 C6 06 10 00 70 C6 06 12 00 79 C6 06 14 00 20 C6 06 16 00 6E C6 </span><br><span class="line">06 18 00 65 C6 06 1A 00 77 C6 06 1C 00 20 C6 06 1E 00 59 C6 06 20 </span><br><span class="line">00 65 C6 06 22 00 61 C6 06 24 00 72 C6 06 26 00 21 EB FE 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 55 AA</span><br></pre></td></tr></table></figure>

<p>我们可以看到结束为55AA</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MBR分区表</title>
    <url>/posts/75d55d1f.html</url>
    <content><![CDATA[<h1 id="MBR分区表"><a href="#MBR分区表" class="headerlink" title="MBR分区表"></a>MBR分区表</h1><p><img src="https://img.ansore.de/2022/05/15/6280e420dc67b.png" alt="Screenshot_20220103_135401.png"></p>
<p>64字节的分区表标志，不可被破坏</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e423ea6d2.png" alt="Screenshot_20220103_135819.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编如何操作显卡让显示器打印字符</title>
    <url>/posts/ebd0dfbd.html</url>
    <content><![CDATA[<h1 id="x86汇编如何操作显卡让显示器打印字符"><a href="#x86汇编如何操作显卡让显示器打印字符" class="headerlink" title="x86汇编如何操作显卡让显示器打印字符"></a>x86汇编如何操作显卡让显示器打印字符</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, <span class="number">0b</span>800h</span><br><span class="line">mov ds, ax</span><br></pre></td></tr></table></figure>

<p><img src="https://img.ansore.de/2022/05/15/6280e4367e5c9.png" alt="Screenshot_20220103_140129.png"></p>
<p>8086CPU是一个16位的处理器，它有8个16位通用寄存器，每个寄存器都有自己的名字，而计算机经常处理单字节的数据，一个字节是8位，如果每次都用16位寄存器处理有些浪费，所以AX、BX、CX、DX这四个寄存器可以分别拆成2个8位寄存器来使用。</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e438904c3.png" alt="Screenshot_20220103_140709.png"></p>
<p>8086一共有20根地址线，所以寻址能力是2^20，也就是1M，8086可以找到0x00000-0xFFFFF之间的所有地址。0x00000-0x9FFFF分配给内存，一共是640KB。0xCFFFF-0xFFFFF分配给BIOS。0xAFFFF-0xBFFFF分配给了包括文字模式、图像模式在内的显示部分</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e43a319c5.png" alt="Screenshot_20220103_141038.png"></p>
<p>显卡是支持文字模式和图形模式，其中文字模式还支持黑白和彩色两种。</p>
<p>图像模式包括VGA等占用0xA0000-0xAFFFF之间的64K空间，黑白模式占用0xB0000-0xB7FFF之间的32K空间。彩色文字模式占用0xB8000-0xBFFFF之间的32K空间。这些地址空间实际上以映射显卡的显存</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e43c2712b.png" alt="Screenshot_20220103_141835.png"></p>
<p>假如显存空间有4GB，而映射的地址空间可能只有256MB，那么首先把4GB开始的256MB映射到CPU的寻址空间，如果不够用，就切换到下一个256MB….</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e43d93e3c.png" alt="Screenshot_20220103_142056.png"></p>
<p>文字模式会把显示器的整个区域分割为25行，每行80个字符，也就是整个屏幕可以显示2000个字符</p>
<p>如果为了显示字符，每次都操作像素太痛苦了，所以把每个可以显示的字符的像素先定义好，然后发送给显卡一个字符的代号，显卡就知道该怎么显示了，这个代号就是ASCII码表。</p>
<p>比如我们想显示字符’A’，它的编码是0x41，不能只是单纯的把0x41发送给显卡，还需要指定一个属性字节，这个字节必须紧跟在字符’A’后面发送</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e43f30913.png" alt="Screenshot_20220103_142639.png"></p>
<p>如果我们想显示一个黑底白字的字符’A’，就要发送0x4107到显存去，而计算机默认就是显示黑底白字。但是发送的时候得空一个字节：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov ax, <span class="number">0b</span>800h</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏移地址</span></span><br><span class="line">mov byte [<span class="number">0x00</span>], <span class="string">&#x27;2&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x02</span>], <span class="string">&#x27;0&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x04</span>], <span class="string">&#x27;2&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x06</span>], <span class="string">&#x27;2&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x08</span>], <span class="string">&#x27;,&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x0a</span>], <span class="string">&#x27;H&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x0c</span>], <span class="string">&#x27;a&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x0e</span>], <span class="string">&#x27;p&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x10</span>], <span class="string">&#x27;p&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x12</span>], <span class="string">&#x27;y&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x14</span>], <span class="string">&#x27; &#x27;</span></span><br><span class="line">mov byte [<span class="number">0x16</span>], <span class="string">&#x27;n&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x18</span>], <span class="string">&#x27;e&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x1a</span>], <span class="string">&#x27;w&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x1c</span>], <span class="string">&#x27; &#x27;</span></span><br><span class="line">mov byte [<span class="number">0x1e</span>], <span class="string">&#x27;Y&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x20</span>], <span class="string">&#x27;e&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x22</span>], <span class="string">&#x27;a&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x24</span>], <span class="string">&#x27;r&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x26</span>], <span class="string">&#x27;!&#x27;</span></span><br></pre></td></tr></table></figure>

<p>CPU执行指令就是单纯的顺序执行，所以程序的指令都是放在一起的，占用一端连续的地址空间，称为代码段，数据也是一样的道理，所以也会有一个数据段</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e442045cb.png" alt="Screenshot_20220103_143551.png"></p>
<p>CS寄存器指向代码段的起始地址，DS寄存器指向数据段的起始地址，指令寄存器IP里面存储的并不是绝对的物理地址，而是相对于CS寄存器的偏移，也就是说CPU访问指令是通过段地址+偏移地址的方式来进行的，CS指定代码段基准地址，IP指定代码段的偏移地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">; 设定数据段寄存器DS， 值为<span class="number">0b</span>800h</span><br><span class="line">mov ax, <span class="number">0b</span>800h</span><br><span class="line">mov ds, ax</span><br><span class="line"></span><br><span class="line">; 通过mov指令，把数据传送到显存地址</span><br><span class="line">mov byte [<span class="number">0x00</span>], <span class="string">&#x27;2&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x02</span>], <span class="string">&#x27;0&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x04</span>], <span class="string">&#x27;2&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x06</span>], <span class="string">&#x27;2&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x08</span>], <span class="string">&#x27;,&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x0a</span>], <span class="string">&#x27;H&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x0c</span>], <span class="string">&#x27;a&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x0e</span>], <span class="string">&#x27;p&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x10</span>], <span class="string">&#x27;p&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x12</span>], <span class="string">&#x27;y&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x14</span>], <span class="string">&#x27; &#x27;</span></span><br><span class="line">mov byte [<span class="number">0x16</span>], <span class="string">&#x27;n&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x18</span>], <span class="string">&#x27;e&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x1a</span>], <span class="string">&#x27;w&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x1c</span>], <span class="string">&#x27; &#x27;</span></span><br><span class="line">mov byte [<span class="number">0x1e</span>], <span class="string">&#x27;Y&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x20</span>], <span class="string">&#x27;e&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x22</span>], <span class="string">&#x27;a&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x24</span>], <span class="string">&#x27;r&#x27;</span></span><br><span class="line">mov byte [<span class="number">0x26</span>], <span class="string">&#x27;!&#x27;</span></span><br><span class="line"></span><br><span class="line">; 标定当前位置，死循环</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">; $$表示程序的起始位置,$表示jmp所在的位置</span><br><span class="line">; $-$$就是从开头到jmp的位置一共多少个字节</span><br><span class="line">; 填充<span class="number">0</span></span><br><span class="line">times <span class="number">510</span>-($-$$) db <span class="number">0</span></span><br><span class="line">; 结束标志位</span><br><span class="line">db <span class="number">0x55</span>, <span class="number">0xaa</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解mov指令</title>
    <url>/posts/3295c3b.html</url>
    <content><![CDATA[<h1 id="深入了解mov指令"><a href="#深入了解mov指令" class="headerlink" title="深入了解mov指令"></a>深入了解mov指令</h1><h1 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h1><p>MOV应用方式</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4522ec36.png" alt="Screenshot_20220103_145038.png"></p>
<p>去掉不可达</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e450cf8ab.png" alt="Screenshot_20220103_145114.png"></p>
<p>mov在使用的时候，源操作数和目的操作数的位宽必须一直，可以都为8位、16位等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov <span class="number">0xb700</span>, <span class="number">0xb800</span></span><br><span class="line">mov [<span class="number">0x01</span>], <span class="number">0xb800</span></span><br><span class="line">mov byte [<span class="number">0x01</span>], <span class="number">0xb800</span></span><br><span class="line">mov word [<span class="number">0x01</span>], <span class="number">0xb800</span></span><br><span class="line">mov [<span class="number">0x01</span>], [<span class="number">0x02</span>]</span><br><span class="line">mov ax, [<span class="number">0x02</span>]</span><br><span class="line">mov [<span class="number">0x03</span>], ax</span><br><span class="line">mov ds, [<span class="number">0x05</span>]</span><br><span class="line">mov [<span class="number">0x04</span>], ds</span><br><span class="line">mov ax, bx</span><br><span class="line">mov cx, dl</span><br><span class="line">mov cs, ds </span><br></pre></td></tr></table></figure>

<p>编译报错如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nasm mov.asm -o mov.bin</span><br><span class="line">mov.asm:1: error: invalid combination of opcode and operands</span><br><span class="line">mov.asm:2: error: operation size not specified</span><br><span class="line">mov.asm:3: warning: byte data exceeds bounds [-w+number-overflow]</span><br><span class="line">mov.asm:5: error: invalid combination of opcode and operands</span><br><span class="line">mov.asm:11: error: invalid combination of opcode and operands</span><br><span class="line">mov.asm:12: error: invalid combination of opcode and operands</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>内存分段</title>
    <url>/posts/8098635f.html</url>
    <content><![CDATA[<h1 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h1><p>内存分段在886中主要解决一个16位寄存器寻址能不不够的问题，用两个寄存器，所以就有了段地址：偏移地址的寻址方式</p>
<p>1M&#x3D;16*64KB，16&#x3D;2^4，4根线描述</p>
<p>1M空间最小划分段数16，最大划分段数：65535，每段16字节，因为每段最小是16字节，所以每个段的起始地址，都必须是16的倍数，这就是16字节对</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e458df9aa.png" alt="Screenshot_20220103_183821.png"></p>
<p>16位模式也称为实模式，当我们进入32位模式的时候会有个保护模式，在保护模式下，程序不能更改其他程序的内存</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e45ea35bb.png" alt="Screenshot_20220103_184039.png"></p>
<p><strong>汇编地址</strong></p>
<p>在编译的过程中，Nasm会把编译的源文件当成一整个代码段，里面的每一条指令，都会有一个相对于代码段头部的偏移地址，这个偏移地址就叫做汇编地址。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>bochs调试汇编程序</title>
    <url>/posts/de410ea2.html</url>
    <content><![CDATA[<h1 id="bochs调试汇编程序"><a href="#bochs调试汇编程序" class="headerlink" title="bochs调试汇编程序"></a>bochs调试汇编程序</h1><p>Bochs是做系统开发常用的虚拟机，调试系统内核很方便。</p>
<p>Linux下调试，安装<code>bochs-sdl</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nasm -f bin -o main.img main.asm</span><br></pre></td></tr></table></figure>

<p>It is possible to avoid the creation of the .bochsrc file by using the following command line:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bochs \</span><br><span class="line">    -qf /dev/null \</span><br><span class="line">    <span class="string">&#x27;ata0-master: type=disk, path=&quot;main.img&quot;, mode=flat, cylinders=1, heads=1, spt=1&#x27;</span> \</span><br><span class="line">    <span class="string">&#x27;boot: disk&#x27;</span> \</span><br><span class="line">    <span class="string">&#x27;display_library: sdl&#x27;</span> \</span><br><span class="line">    <span class="string">&#x27;megs: 128&#x27;</span></span><br></pre></td></tr></table></figure>

<p>The <code>qf /dev/null</code> part is ugly, but it is the only way I’ve managed to automatically skip the menu screen:</p>
<ul>
<li><code>q</code> or <code>n</code> always ask for it, and I have to hit <code>6</code> for it to run afterwards</li>
<li><code>qn &lt;(echo ...)</code> also worked, but uses a Bash extension which would fail on my Makefile</li>
</ul>
<p><strong>查看寄存器</strong></p>
<p>汇编代码中，调试最常用的功能就是查看寄存器的内容。</p>
<ul>
<li><code>r</code> 查看通用寄存器</li>
<li><code>sreg</code> 查看段寄存器</li>
<li><code>creg</code> 查看控制寄存器</li>
<li><code>dreg</code> 查看调试寄存器</li>
<li><code>info cpu</code> 查看所有寄存器</li>
</ul>
<p><strong>查找和定位代码</strong></p>
<p>次常用的肯定是控制代码执行流程，代码执行到想要仔细跟踪的那个部分。</p>
<ul>
<li><code>b 内存地址</code> 设置断点。如<code>b 0x7c00</code>，在线性地址0x7c00处设置断点。</li>
<li><code>info break</code> 查看设置过的断点</li>
<li><code>c</code> 继续执行代码。一般设置断点后，想让代码恢复执行，就使用这个命令。</li>
<li><code>s</code> 单步执行。单步执行一行代码，和高级语言调试器的step into按钮类似，遇到函数调用会跳转到函数内部执行。单步执行命令也可以带参数，指定执行的次数，如 <code>s 100</code> 就是单步执行100次。</li>
<li><code>n</code> 执行下一行。它和单步执行类似，单步执行遇到循环和函数时会跳转到内部，而n命令会执行完循环和函数，类似于step over，这样在遇到大量的循环或者较长的函数时，可以用n命令来执行到下一行。n命令能跳转到下一行是因为loop或者call执行有明显的结束标记（前者通过cx寄存器，后者通ret指令），如果遇到用jmp语句写的循环这种情况，没有明显结束标记的，可以用下面的u命令反汇编代码的地址，找到循环的下一行指令的地址，然后给该地址加一个断点就能达到同样的效果。</li>
<li><code>u</code> 反汇编代码。直接使用u命令会反汇编当前执行的指令，它可以加参数， <code>u /反汇编数量 起始地址</code> ，如 <code>u /20 0x7c00</code> 就是从0x7c00处开始，反汇编20条指令，如果没有起始地址就是从当前地址开始。它还可以反汇编一个范围的代码，<code>u 起始地址 结束地址</code> ，如<code>u 0x7c00 0x7cff</code> 就是反汇编0x7c00到0x7cff的代码。</li>
</ul>
<p><strong>查看内存</strong></p>
<ul>
<li><code>x /nuf 地址</code> 查看线性地址处的内存内容。</li>
<li><code>xp /nuf 地址</code> 查看物理地址处的内存内容。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n 指定要显示的内存单元的数量</span><br><span class="line">u 显示的内存单元的大小，如下参数之一</span><br><span class="line">	b 单个字节</span><br><span class="line">	h 半个字(2 字节)</span><br><span class="line">	w 一个字(4 字节)</span><br><span class="line">f 打印的格式。如下类型之一：</span><br><span class="line">	x 按照十六进制形式打印</span><br><span class="line">	d 按照十进制形式打印</span><br><span class="line">	u 以无符号的10进制打印</span><br><span class="line">	o 按照八进制形式打印</span><br><span class="line">	t 按照二进制行是打印</span><br></pre></td></tr></table></figure>

<p>Bochs还有一个比较有用的设计就是，当你输入指令后，直接按回车键（Enter Key）会重复上一次的命令。比如上一个命令是单步执行<code>s</code>，此时直接按回车键就相当于<code>s</code>的功能。</p>
<h1 id="调试指令手册"><a href="#调试指令手册" class="headerlink" title="调试指令手册"></a><strong>调试指令手册</strong></h1><p><strong>执行控制</strong></p>
<p><a href="bochs%E8%B0%83%E8%AF%95%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%208a0a25b93d564398801c033054c0e17a/Untitled%20Database%20ccd7cc0e0289407489c18511dad37932.csv">Untitled</a></p>
<p><strong>断点操作</strong></p>
<p><a href="bochs%E8%B0%83%E8%AF%95%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%208a0a25b93d564398801c033054c0e17a/Untitled%20Database%202f1f9f2617ea4eeea781225b55b3320c.csv">Untitled</a></p>
<p>① ② ③ ④ 的命令都可以设置条件，即都可以变成条件断点。具体做法是在命令之后添加<code>if condition</code> ，如<code>vbreak 0x008:0x001 if &quot;条件表达式&quot;</code></p>
<p><strong>内存观察点</strong></p>
<p>内存观察点类似于内存的监听器，当指定地址的内存产生读取或者写入事件时，会产生中断。</p>
<p><a href="bochs%E8%B0%83%E8%AF%95%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%208a0a25b93d564398801c033054c0e17a/Untitled%20Database%20bf5ddaae7e7a46e2ae6f9d3a12e00998.csv">Untitled</a></p>
<p><strong>内存操作</strong></p>
<p><a href="bochs%E8%B0%83%E8%AF%95%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%208a0a25b93d564398801c033054c0e17a/Untitled%20Database%20bac0185a6944474bbe5a8469f31c4572.csv">Untitled</a></p>
<p><strong>查看信息</strong></p>
<p><a href="bochs%E8%B0%83%E8%AF%95%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%208a0a25b93d564398801c033054c0e17a/Untitled%20Database%2040a1c01876d645e9b4844bee67d63adc.csv">Untitled</a></p>
<p><strong>寄存器操作</strong></p>
<p><a href="bochs%E8%B0%83%E8%AF%95%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%208a0a25b93d564398801c033054c0e17a/Untitled%20Database%20d66f99bdd64c4365b377d1323400817e.csv">Untitled</a></p>
<p>只能修改通用寄存器和指令寄存器。不能够修改标志寄存器，段寄存器，浮点寄存器和SIMD寄存器。</p>
<p><strong>反汇编</strong></p>
<p><a href="bochs%E8%B0%83%E8%AF%95%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%208a0a25b93d564398801c033054c0e17a/Untitled%20Database%20505a33364f3e4011bc0ff1cb14fe6191.csv">Untitled</a></p>
<p><strong>指令跟踪</strong></p>
<p><a href="bochs%E8%B0%83%E8%AF%95%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%208a0a25b93d564398801c033054c0e17a/Untitled%20Database%2070c530162d1b42bbadd3f65cd44e3790.csv">Untitled</a></p>
<p><strong>指令编程环境</strong></p>
<p>Bochs的instrument功能，提供了运行时的各种钩子函数。它也是可选功能，在编译安装时需要开启<code>-enable-instrumentation</code>选项指定。</p>
<p>.&#x2F;configure […] –enable-instrumentation</p>
<p>.&#x2F;configure […] –enable-instrumentation&#x3D;”instrument&#x2F;stubs”</p>
<p>自定义的代码要创建一个独立的目录，例如”instrument&#x2F;myinstrument”，将”instrument&#x2F;stubs”目录拷贝进去，然后使用如下的指令设定：</p>
<p><code>1./configure [...] --enable-instrumentation=&quot;instrument/myinstrument&quot;</code></p>
<p>指令命令：</p>
<p>instrument [command] 用[command]调用BX_INSTR_DEBUG_CMD指令回调</p>
<p><strong>show指令</strong></p>
<p><a href="bochs%E8%B0%83%E8%AF%95%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%208a0a25b93d564398801c033054c0e17a/Untitled%20Database%209ccc85fc7953463da1c628a0dae9e0f8.csv">Untitled</a></p>
<p><strong>其他命令</strong></p>
<p><a href="bochs%E8%B0%83%E8%AF%95%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%208a0a25b93d564398801c033054c0e17a/Untitled%20Database%2065aa0975ebd247439aceaac62cf0dadb.csv">Untitled</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>X86汇编的加减法和循环</title>
    <url>/posts/46482b1e.html</url>
    <content><![CDATA[<h1 id="X86汇编的加减法和循环"><a href="#X86汇编的加减法和循环" class="headerlink" title="X86汇编的加减法和循环"></a>X86汇编的加减法和循环</h1><p>加法：<strong>add</strong></p>
<p>减法：<strong>sub</strong>stract</p>
<p>寄存器：<strong>reg</strong>ister (8&#x2F;16)</p>
<p>内存：<strong>mem</strong>ory (8&#x2F;16)</p>
<p>立即数：<strong>imm</strong>ediate (8&#x2F;16)</p>
<h1 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h1><p>CPU内部有一个标志寄存器（<strong>eflags</strong>），它的第0位就是CF位，用来保存进位和借位，当计算结果出现进位和借位时，CF会被置一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 不产生进位的加法</span><br><span class="line">mov ax, 0x0001</span><br><span class="line">mov bx, 0x0002</span><br><span class="line">add ax, bx</span><br><span class="line">; 产生进位的加法</span><br><span class="line">mov ax, 0xf000</span><br><span class="line">mov bx, 0x1000</span><br><span class="line">add ax, bx</span><br><span class="line">; 不产生进位的减法</span><br><span class="line">mov cx, 0x0003</span><br><span class="line">mov dx, 0x0002</span><br><span class="line">sub cx,dx</span><br><span class="line">; 产生进位的减法</span><br><span class="line">mov cx, 0x0001</span><br><span class="line">mov dx, 0x0002</span><br><span class="line">sub cx,dx</span><br><span class="line"></span><br><span class="line">xuanmai: jmp xuanmai</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55,0xaa</span><br></pre></td></tr></table></figure>

<p>第一次加法时cf小写为，所以值位0，不产生进位</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e47a1cc90.png" alt="Screenshot_20220109_215906.png"></p>
<p>第二次加法CF大写，产生进位</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e47c27679.png" alt="Screenshot_20220109_220003.png"></p>
<p>减法同理</p>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>loop循环</p>
<p>每次执行到loop时，会判断CX寄存器是否为0，不为0则跳到标号处继续执行，并自动将CX-1。直到CX为0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标号</span><br><span class="line">    ...</span><br><span class="line">    循环体             CX=0</span><br><span class="line">    ... </span><br><span class="line">loop 标号</span><br></pre></td></tr></table></figure>

<p>计算1+2+…+100</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 设定循环次数</span><br><span class="line">mov cx, 100</span><br><span class="line">; 初始化ax</span><br><span class="line">mov ax, 0x0000</span><br><span class="line">;循环部分</span><br><span class="line">sum:</span><br><span class="line">  add ax, cx</span><br><span class="line">  loop sum</span><br><span class="line"></span><br><span class="line">jmp $</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55, 0xaa</span><br></pre></td></tr></table></figure>

<h1 id="自增和自减"><a href="#自增和自减" class="headerlink" title="自增和自减"></a>自增和自减</h1><p>自增：<strong>inc</strong>ease   &#x3D; add ax, 1</p>
<p>自减：<strong>dec</strong>ease  </p>
<p>inc和dec虽然也是加减法，但是它们并不影响CF标志位</p>
<h1 id="16位寄存器处理32位加减法"><a href="#16位寄存器处理32位加减法" class="headerlink" title="16位寄存器处理32位加减法"></a>16位寄存器处理32位加减法</h1><p>解决思路时两个相加或者相减的数，都用2个寄存器来保存，然后分别把高位和高位相加减，低位和低位相加减，但是低位相加可能会产生进位，相减可能会产生借位，此时add&#x2F;sub指令就不能满足要求了，此时需要两个指令</p>
<p>adc &#x3D; add with carry &#x3D; 被加数+加数+CF</p>
<p>sbb &#x3D; sub with carry &#x3D; 被减数-减数-CF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; bx:ax = 0x0001f000</span><br><span class="line">mov bx, 0x0001</span><br><span class="line">mox ax, 0xf000</span><br><span class="line">; dx:cx = 0x00101000</span><br><span class="line">mov dx, 0x0010</span><br><span class="line">mov cx, 0x1000</span><br><span class="line">;低位相加</span><br><span class="line">add ax, cx</span><br><span class="line">;高位相加</span><br><span class="line">adc bx, dx</span><br><span class="line">jmp $</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55, 0xaa</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>X86汇编的乘除法以及栈的定义使用</title>
    <url>/posts/b125ae61.html</url>
    <content><![CDATA[<h1 id="X86汇编的乘除法以及栈的定义使用"><a href="#X86汇编的乘除法以及栈的定义使用" class="headerlink" title="X86汇编的乘除法以及栈的定义使用"></a>X86汇编的乘除法以及栈的定义使用</h1><p>寄存器向下兼容，保留了ax,bx等寄存器</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e485dfb46.png" alt="Screenshot_20220109_222051.png"></p>
<h1 id="乘除法"><a href="#乘除法" class="headerlink" title="乘除法"></a>乘除法</h1><p>乘法：mul + reg&#x2F;mem</p>
<p>除法：div + reg&#x2F;mem</p>
<p>它们只有一个操作数，所以会使用特定的寄存器，来保存另外一个参与计算的数</p>
<p>如果是8位乘8位的乘法，乘积的高8位保存在ah寄存器，低8位保存在al寄存器；如果是16位的乘法，高16位存在dx寄存器，低16位存在ax寄存器；</p>
<p>乘法的结果也会影响CF标志位</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4895fb6b.png" alt="Screenshot_20220109_222449.png"></p>
<p>div指令后面的数是除数，被除数事先保存到ax寄存器或者dx:ax寄存器</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e48c143dc.png" alt="Screenshot_20220109_222852.png"></p>
<p>mul和div指令对应的操作数都是无符号的，也就是不能处理负数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 8位乘法</span><br><span class="line">mov al, 0xf0</span><br><span class="line">mov ah, 0x02</span><br><span class="line">mul ah</span><br><span class="line">; 16位乘法</span><br><span class="line">mov ax, 0xf000</span><br><span class="line">mov bx, 0x0002</span><br><span class="line">mul bx</span><br><span class="line">; 16位除法</span><br><span class="line">mov ax, 0x0004</span><br><span class="line">mov bl, 0x02</span><br><span class="line">div bl</span><br><span class="line">; 32位除法</span><br><span class="line">mov dx, 0x0008</span><br><span class="line">mov ax, 0x0006</span><br><span class="line">mov cx, 0x0002</span><br><span class="line">div cx</span><br><span class="line">; 循环以及补0</span><br><span class="line">jmp $</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55, 0xaa</span><br></pre></td></tr></table></figure>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p> 定义代码段：CS寄存器保存代码段的基地址，IP保存相对于基地址的偏移</p>
<p>栈也是这样定义的，其基准地址是SS，偏移地址是SP</p>
<p>数据段和代码段，是从内存低处向高处行进的，地址是增长的。对于栈来说，push操作会让SP减小，pop操作会让SP增大。通常来说，我们可以把SS设置为0x0000，那么进行push操作时：</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e48d752f7.png" alt="Screenshot_20220109_224305.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 设置SS寄存器</span><br><span class="line">mov bx, 0x0000</span><br><span class="line">mov ss, bx</span><br><span class="line">; 设置sp寄存器</span><br><span class="line">mov sp, 0x0000</span><br><span class="line">; ax压入栈</span><br><span class="line">push ax</span><br><span class="line">; ax弹出栈</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">; 循环以及补0</span><br><span class="line">jmp $</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55, 0xaa</span><br></pre></td></tr></table></figure>

<p><img src="https://img.ansore.de/2022/05/15/6280e4903b446.png" alt="Screenshot_20220109_224515.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>更优雅的打印字符串</title>
    <url>/posts/77315fe6.html</url>
    <content><![CDATA[<h1 id="更优雅的打印字符串"><a href="#更优雅的打印字符串" class="headerlink" title="更优雅的打印字符串"></a>更优雅的打印字符串</h1><p>目标：给定一个以0x00结尾的字符串在内存中的起始地址，通过调用一个函数，把整个字符串输出到屏幕上。</p>
<p><strong>ds和es是段寄存器，si和di是变址寄存器</strong></p>
<p>通过段寄存器DS以及源索引寄存器SI来保存字符串的起始地址，即DS:SI，而SI指向第一个字符出现的位置，取出一个字符SI就加1。通过段寄存器ES以及目标索引寄存器DI，保存写入的目标地址，也就是显存的地址，ES的值位0xb800，DI寄存器的初始值位0x0000，写入一个字节就加1， 通过循环将DS:SI指向的字符串依次取出，并写入到ES:DI指向的目标地址，直到遇到0x00结束循环</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e49b23e11.png" alt="Screenshot_20220110_220208.png"></p>
<h1 id="EFLAGS寄存器"><a href="#EFLAGS寄存器" class="headerlink" title="EFLAGS寄存器"></a>EFLAGS寄存器</h1><p>第0位CF位，进位标志</p>
<p>第2位PF位，偶数标志位，当计算结果是偶数时，PF会被置1</p>
<p>第6位是ZF位，Zero Flag，零标志位，独立结果为0时，ZF会被置1</p>
<p>第7位是SF位，也就是符号位，比如减法结果为负值，他就会被置1</p>
<p>第11位是OF位，也是溢出位，当计算结果存在溢出时，它会被置为1</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e49cb1a33.png" alt="Screenshot_20220110_220309.png"></p>
<p>标志位的用法，要结合条件转移指令使用</p>
<h1 id="JCC-条件转移指令"><a href="#JCC-条件转移指令" class="headerlink" title="JCC-条件转移指令"></a>JCC-条件转移指令</h1><p><strong>jz</strong>    Jump if zero(ZF&#x3D;1)</p>
<p><strong>jnz</strong>  Jump if not zero(ZF&#x3D;0)</p>
<h1 id="cmp-比较指令"><a href="#cmp-比较指令" class="headerlink" title="cmp-比较指令"></a>cmp-比较指令</h1><p><strong>cmp</strong>  dest目的(reg&#x2F;mem)  source源(reg&#x2F;mem&#x2F;imm)</p>
<p>比较两个数，改变标志寄存器的值</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e49ee05cb.png" alt="Screenshot_20220110_221101.png"></p>
<h1 id="section-分段"><a href="#section-分段" class="headerlink" title="section-分段"></a>section-分段</h1><p>section  name align&#x3D;16&#x2F;32 vstart&#x3D;0</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4a03dc97.png" alt="Screenshot_20220110_221417.png"></p>
<p>align：加align与不加align的区别在于，如果定义多个section，而某些section的内容不足16字节，编译器就会给你补齐到16字节，而不加align参数就没有这个效果</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4a253265.png" alt="Screenshot_20220110_221540.png"></p>
<p><strong>vstart</strong>：这个参数的用途是设置段内的偏移地址的基准地址，如果不设置这个参数，那么在编译阶段，所有的偏移地址都是按照程序头部来算的，而默认的程序头部基准地址为0x0000，如果我们使用了标号，那么标号的偏移地址，也就是汇编地址，是跟程序加载到内存的偏移地址保持一致的。在真机运行环境，我们的程序会被加载到0x7c00位置，并且段寄存器如ES,DS,SS等都默认初始化位0x0000，但是程序的起始位置却是0x7c00，这就导致程序里的标号不对了。解决办法有两种，一种是把DS,ES,SS都初始化为0x7c00，另外一种是使用vstart参数，让vstart&#x3D;0x7c00，汇编地址在计算的时候会自动加上0x7c00。</p>
<h1 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h1><p>call 标号</p>
<p>类似函数调用，call 后面跟一个标号、寄存器或者内存地址，标号的本质也是个内存地址偏移。标号的本质也是一个内存地址偏移。我们把常用的一段代码放到标号后面，形成类似函数的代码块。需要注意的是，在代码块的最后，要加一个ret指令，就是return。代码先顺序执行，遇到call指令调用代码块，遇到ret返回调用点，汇编用寄存器来保存传入传出参数。</p>
<h1 id="and-与运算指令"><a href="#and-与运算指令" class="headerlink" title="and-与运算指令"></a>and-与运算指令</h1><p><strong>and</strong> dest目的(reg&#x2F;mem) source源(reg&#x2F;mem&#x2F;imm)</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4a58c86e.png" alt="Screenshot_20220110_223603.png"></p>
<h1 id="or-或运算指令"><a href="#or-或运算指令" class="headerlink" title="or-或运算指令"></a>or-或运算指令</h1><p><strong>or</strong> dest目的(reg&#x2F;mem) source源(reg&#x2F;mem&#x2F;imm)</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4a7caf9f.png" alt="Screenshot_20220110_223654.png"></p>
<p>or bh,0x000，通过ZF可以判断bh是否为0</p>
<h1 id="not-非运算指令"><a href="#not-非运算指令" class="headerlink" title="not-非运算指令"></a>not-非运算指令</h1><p>not reg&#x2F;mem</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4a9bae91.png" alt="Screenshot_20220110_223836.png"></p>
<h1 id="xor-异或运算指令"><a href="#xor-异或运算指令" class="headerlink" title="xor-异或运算指令"></a>xor-异或运算指令</h1><p><strong>xor</strong> dest目的(reg&#x2F;mem) source源(reg&#x2F;mem&#x2F;imm)</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4ac0a6b8.png" alt="Screenshot_20220110_223927.png"></p>
<p>影响ZF标志位，也可以通过ZF判断两个数是否相等</p>
<h1 id="打印字符串"><a href="#打印字符串" class="headerlink" title="打印字符串"></a>打印字符串</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NUL equ 0x00</span><br><span class="line">SETCHAR equ 0x07</span><br><span class="line">VIDEOMEM equ 0xb800</span><br><span class="line">STRINGLEN equ 0xffff</span><br><span class="line"></span><br><span class="line">section code align=16 vstart=0x7c00</span><br><span class="line">  mov si, SayHello</span><br><span class="line">  xor di, di</span><br><span class="line">  call PrintString</span><br><span class="line">  mov si, SayByeBye</span><br><span class="line">  call PrintString</span><br><span class="line">  jmp End</span><br><span class="line"></span><br><span class="line">PrintString:</span><br><span class="line">  .setup:</span><br><span class="line">  mov ax, VIDEOMEM</span><br><span class="line">  mov es, ax</span><br><span class="line"></span><br><span class="line">  mov bh, SETCHAR</span><br><span class="line">  mov cx, STRINGLEN</span><br><span class="line"></span><br><span class="line">  .printchar:</span><br><span class="line">  mov bl, [ds:si]</span><br><span class="line">  inc si</span><br><span class="line">  mov [es:di], bl</span><br><span class="line">  inc di</span><br><span class="line">  mov [es:di], bh</span><br><span class="line">  inc di</span><br><span class="line">  or bl, NUL</span><br><span class="line">  jz .return</span><br><span class="line">  loop .printchar</span><br><span class="line"></span><br><span class="line">  .return</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">SayHello db &#x27;Hi there,I am Ansore!&#x27;</span><br><span class="line">         db 0x00</span><br><span class="line">SayByeBye db &#x27;I think you can handle it, bye!&#x27;</span><br><span class="line">         db 0x00</span><br><span class="line"></span><br><span class="line">End: jmp End</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">db 0x55, 0xaa</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4b20b0df.png" alt="Screenshot_20220111_210706.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编读取硬盘</title>
    <url>/posts/9a4d13c.html</url>
    <content><![CDATA[<h1 id="汇编读取硬盘"><a href="#汇编读取硬盘" class="headerlink" title="汇编读取硬盘"></a>汇编读取硬盘</h1><p>目标：把指定数据从硬盘里读取出来，保存到指定内存，把这些数据输出到屏幕</p>
<p>端口本质是寄存器的代号，读写只能用in&#x2F;out指令，如显卡，硬盘都有自己的寄存器，CPU读写不同的端口，实质上是在读写不同的寄存器。</p>
<p>计算机的主硬盘分配了8个端口，0x1f0~0x1f7</p>
<h1 id="读写硬盘"><a href="#读写硬盘" class="headerlink" title="读写硬盘"></a>读写硬盘</h1><p>CHS(Cylinders Heads Sectors)，需要把磁头、柱面和扇区信息都传递下去。现在已经不用了</p>
<p>LBA(Logical Block Addressing)，逻辑块寻址。</p>
<h1 id="in-读出指令"><a href="#in-读出指令" class="headerlink" title="in-读出指令"></a>in-读出指令</h1><p>in dest目的(al&#x2F;ax) source源(dx&#x2F;imm8)</p>
<p>源可以是8位立即数或者dx寄存器，使用8位立即数只能访问0～255端口，存在局限性。而使用dx寄存器则可以访问0~65535端口</p>
<h1 id="out-写入指令"><a href="#out-写入指令" class="headerlink" title="out-写入指令"></a>out-写入指令</h1><p>out dest目的(dx&#x2F;imm8) source源(al&#x2F;ax)</p>
<h1 id="LBA28"><a href="#LBA28" class="headerlink" title="LBA28"></a>LBA28</h1><p>用28位来标记硬盘的逻辑扇区号，总共2^28个扇区，每个扇区512字节。也就是说可以寻编128GB的硬盘</p>
<ul>
<li>要读取硬盘的第一步，是告诉硬盘要读取几个扇区，这个数值要写到0x1f2端口，这个是8位端口；</li>
<li>第二步是告诉硬盘要从哪个扇区开始读，LBA28模式下，需要写入28位的逻辑扇区号，由于端口是8位的，所以要分成4份，分别写入0x1f3<del>0x1f6这四个端口。同时，0x1f6这个端口只写入了逻辑扇区号的27</del>24位，剩下的几位还要标识硬盘号以及读写模式，第4位是选择硬盘号，第6位是选择读写模式；</li>
<li>第三步是往0x1f7写入0x20，表示你要读取的硬盘；如果写入0x30，就是要写硬盘</li>
</ul>
<p><img src="https://img.ansore.de/2022/05/15/6280e4be81a30.png" alt="Screenshot_20220111_213442.png"></p>
<p>这时候需要查看硬盘的状态是否准备就绪，同样也是通过0x1f7端口来查询，读入状态字节后。我们只关心第3位和第7位，所以用and来把其他位置0，而cmp则可以判断硬盘是否有空并且已经准备好了</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4c03bf3a.png" alt="Screenshot_20220111_213740.png"></p>
<ul>
<li>第四步就是读取硬盘。需要通过0x1f0端口。这是个16位的端口，一次可以读2个字节或者1个字。我们就循环读取0x1f0，把得到的数据保存到目标内存就可以了</li>
</ul>
<p><img src="https://img.ansore.de/2022/05/15/6280e4c22c6d9.png" alt="Screenshot_20220111_213934.png"></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>data.asm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Data db &#x27;Hi, I come from hard disk drive!&#x27;</span><br><span class="line">     db 0x00</span><br></pre></td></tr></table></figure>

<p>readhdd.asm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HDDPORT equ 0x1f0</span><br><span class="line">NUL equ 0x00</span><br><span class="line">SETCHAR equ 0x07</span><br><span class="line">VIDEOMEM equ 0xb800</span><br><span class="line">STRINGLEN equ 0xffff</span><br><span class="line">section code align=16 vstart=0x7c00</span><br><span class="line"></span><br><span class="line">mov si, [READSTART]</span><br><span class="line">mov cx, [READSTART+0x02]</span><br><span class="line">mov al, [SECTORNUM]</span><br><span class="line">push ax</span><br><span class="line"></span><br><span class="line">mov ax, [DESTMEN]</span><br><span class="line">mov dx, [DESTMEN+0x02]</span><br><span class="line">mov bx, 16</span><br><span class="line">div bx</span><br><span class="line"></span><br><span class="line">mov ds, ax</span><br><span class="line">xor di, di</span><br><span class="line">pop ax</span><br><span class="line"></span><br><span class="line">call ReadHDD</span><br><span class="line">xor si, si</span><br><span class="line">call PrintString</span><br><span class="line">jmp End</span><br><span class="line"></span><br><span class="line">ReadHDD:</span><br><span class="line">  push ax</span><br><span class="line">  push bx</span><br><span class="line">  push cx</span><br><span class="line">  push dx</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT+2</span><br><span class="line">  out dx, al</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT+3</span><br><span class="line">  mov ax, si</span><br><span class="line">  out dx, al</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT+4</span><br><span class="line">  mov al, ah</span><br><span class="line">  out dx, al</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT+5</span><br><span class="line">  mov ax, cx</span><br><span class="line">  out dx, al</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT+6</span><br><span class="line">  mov al, ah</span><br><span class="line">  mov ah, 0xe0</span><br><span class="line">  or al, ah</span><br><span class="line">  out dx, al</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT+7</span><br><span class="line">  mov al, 0x20</span><br><span class="line">  out dx, al</span><br><span class="line"></span><br><span class="line">  .waits:</span><br><span class="line">  in al, dx</span><br><span class="line">  and al, 0x88</span><br><span class="line">  cmp al, 0x08</span><br><span class="line">  jnz .waits</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT</span><br><span class="line">  mov cx, 256</span><br><span class="line"></span><br><span class="line">  .readword:</span><br><span class="line">  in ax, dx</span><br><span class="line">  mov [ds:di], ax</span><br><span class="line">  add di, 2</span><br><span class="line">  or ah, 0x00</span><br><span class="line">  jnz .readword</span><br><span class="line"></span><br><span class="line">  .return:</span><br><span class="line">  pop dx</span><br><span class="line">  pop cx</span><br><span class="line">  pop bx</span><br><span class="line">  pop ax</span><br><span class="line"></span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">PrintString:</span><br><span class="line">  .setup:</span><br><span class="line">  push ax</span><br><span class="line">  push bx</span><br><span class="line">  push cx</span><br><span class="line">  push dx</span><br><span class="line">  mov ax, VIDEOMEM</span><br><span class="line">  mov es, ax</span><br><span class="line">  xor di, di</span><br><span class="line"></span><br><span class="line">  mov bh, SETCHAR</span><br><span class="line">  mov cx, STRINGLEN</span><br><span class="line"></span><br><span class="line">  .printchar:</span><br><span class="line">  mov bl, [ds:si]</span><br><span class="line">  inc si</span><br><span class="line">  mov [es:di], bl</span><br><span class="line">  inc di</span><br><span class="line">  mov [es:di], bh</span><br><span class="line">  inc di</span><br><span class="line">  or bl, NUL</span><br><span class="line">  jz .return</span><br><span class="line">  loop .printchar</span><br><span class="line">  .return:</span><br><span class="line">  mov bx, di</span><br><span class="line">  pop dx</span><br><span class="line">  pop cx</span><br><span class="line">  pop bx</span><br><span class="line">  pop ax</span><br><span class="line">  ret</span><br><span class="line">  </span><br><span class="line">READSTART dd 10</span><br><span class="line">SECTORNUM db 1</span><br><span class="line">DESTMEN   dd 0x10000</span><br><span class="line"></span><br><span class="line">End: jmp End</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">                 db 0x55, 0xaa</span><br></pre></td></tr></table></figure>

<p><img src="https://img.ansore.de/2022/05/15/6280e4c5bb500.png" alt="Screenshot_20220111_223359.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>QEMU启动hda文件系统</title>
    <url>/posts/c9a89521.html</url>
    <content><![CDATA[<h1 id="QEMU启动hda文件系统"><a href="#QEMU启动hda文件系统" class="headerlink" title="QEMU启动hda文件系统"></a>QEMU启动hda文件系统</h1><p>创建文件系统，大小为16M</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=./rootfs.img bs=1M count=16</span><br></pre></td></tr></table></figure>

<p>格式化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkfs.ext3 rootfs.ext3</span><br></pre></td></tr></table></figure>

<p>挂载文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o loop rootfs.img ./fs</span><br></pre></td></tr></table></figure>

<p>此时在&#x2F;dev下有个loop0的设备</p>
<p>写入磁盘引导和数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=./readhdd.bin of=/dev/loop0 bs=512 count=1</span><br><span class="line">dd if=./data of=/dev/loop0 seek=10 bs=512 count=1</span><br></pre></td></tr></table></figure>

<p>卸载硬盘</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">umount /dev/loop0</span><br></pre></td></tr></table></figure>

<p>qemu虚拟机启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -hda rootfs.img</span><br></pre></td></tr></table></figure>

<p>或者写入时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=./readhdd.bin of=/dev/loop0 bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure>

<p>notrunc规定在写入数据后不截断</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>运行扇区外的程序</title>
    <url>/posts/2c89a838.html</url>
    <content><![CDATA[<h1 id="运行扇区外的程序"><a href="#运行扇区外的程序" class="headerlink" title="运行扇区外的程序"></a>运行扇区外的程序</h1><p>目标：使启动扇区的BootLoader程序可以启动普通扇区内的程序</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4d57ac05.png" alt="Screenshot_20220112_222729.png"></p>
<h1 id="BootLoader启动扇区"><a href="#BootLoader启动扇区" class="headerlink" title="BootLoader启动扇区"></a>BootLoader启动扇区</h1><p><img src="https://img.ansore.de/2022/05/15/6280e4d80b3a3.png" alt="Screenshot_20220112_223010.png"></p>
<p>所以程序需要准备一份“简历”，告诉BootLoader，BootLoader才能正确读取、加载并运行程序。这段程序要放到最前面，好让BootLoader读取第一个扇区后，就能获知所有的信息</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4d9aef39.png" alt="Screenshot_20220112_223428.png"></p>
<p>而对于BootLoader，结构为：</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4db70ead.png" alt="Screenshot_20220112_223503.png"></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>Program.asm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HDDPORT equ 0x1f0</span><br><span class="line"></span><br><span class="line">section code align=16 vstart=0x7c00</span><br><span class="line">  mov si, [READSTART]</span><br><span class="line">  mov cx, [READSTART+2]</span><br><span class="line">  mov al, [SECTORNUM]</span><br><span class="line">  push ax</span><br><span class="line">  ;Setup the destnation</span><br><span class="line">	mov ax, [DESTMEN]</span><br><span class="line">	mov dx, [DESTMEN+0x02]</span><br><span class="line">  mov bx, 16</span><br><span class="line">  div bx</span><br><span class="line">  </span><br><span class="line">  mov ds, ax</span><br><span class="line">  xor di, di</span><br><span class="line">  pop ax</span><br><span class="line">  ;read the first sector</span><br><span class="line">  call ReadHDD</span><br><span class="line"></span><br><span class="line">  ResetSegment:</span><br><span class="line">  mov bx, 0x04</span><br><span class="line">  mov cl, [0x10]</span><br><span class="line"></span><br><span class="line">  .reset:</span><br><span class="line">  mov ax, [bx]</span><br><span class="line">  mov dx, [bx+2]</span><br><span class="line">  add ax, [cs:DESTMEN]</span><br><span class="line">  adc dx, [cs:DESTMEN+2]</span><br><span class="line"></span><br><span class="line">  mov si, 16</span><br><span class="line">  div si</span><br><span class="line">  mov [bx], ax</span><br><span class="line">  add bx, 4</span><br><span class="line">  loop .reset</span><br><span class="line"></span><br><span class="line">  ResetEntry:</span><br><span class="line">  mov ax, [0x13]</span><br><span class="line">  mov dx, [0x15]</span><br><span class="line">  add ax, [cs:DESTMEN]</span><br><span class="line">  adc dx, [cs:DESTMEN+2]</span><br><span class="line"></span><br><span class="line">  mov si, 16</span><br><span class="line">  div si</span><br><span class="line"></span><br><span class="line">  mov [0x13], ax</span><br><span class="line"></span><br><span class="line">  jmp far [0x11]</span><br><span class="line">ReadHDD:</span><br><span class="line">  push ax</span><br><span class="line">  push bx</span><br><span class="line">  push cx</span><br><span class="line">  push dx</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT+2</span><br><span class="line">  out dx, al</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT+3</span><br><span class="line">  mov ax, si</span><br><span class="line">  out dx, al</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT+4</span><br><span class="line">  mov al, ah</span><br><span class="line">  out dx, al</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT+5</span><br><span class="line">  mov ax, cx</span><br><span class="line">  out dx, al</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT+6</span><br><span class="line">  mov al, ah</span><br><span class="line">  mov ah, 0xe0</span><br><span class="line">  or al, ah</span><br><span class="line">  out dx, al</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT+7</span><br><span class="line">  mov al, 0x20</span><br><span class="line">  out dx, al</span><br><span class="line"></span><br><span class="line">  .waits:</span><br><span class="line">  in al, dx</span><br><span class="line">  and al, 0x88</span><br><span class="line">  cmp al, 0x08</span><br><span class="line">  jnz .waits</span><br><span class="line"></span><br><span class="line">  mov dx, HDDPORT</span><br><span class="line">  mov cx, 256</span><br><span class="line"></span><br><span class="line">  .readword:</span><br><span class="line">  in ax, dx</span><br><span class="line">  mov [ds:di], ax</span><br><span class="line">  add di, 2</span><br><span class="line">  ;or ah, 0x00</span><br><span class="line">  ;jnz .readword</span><br><span class="line">  loop .readword</span><br><span class="line">  .return:</span><br><span class="line">  pop dx</span><br><span class="line">  pop cx</span><br><span class="line">  pop bx</span><br><span class="line">  pop ax</span><br><span class="line"></span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">READSTART dd 1</span><br><span class="line">SECTORNUM db 1</span><br><span class="line">DESTMEN   dd 0x10000</span><br><span class="line"></span><br><span class="line">End: jmp End</span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">                 db 0x55, 0xaa</span><br></pre></td></tr></table></figure>

<p>BootLoader.asm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NUL equ 0x00</span><br><span class="line">SETCHAR equ 0x07</span><br><span class="line">VIDEOMEM equ 0xb800</span><br><span class="line">STRINGLEN equ 0xffff</span><br><span class="line"></span><br><span class="line">section head align=16 vstart=0</span><br><span class="line">  Size dd ProgramEnd ; 4B 0x00</span><br><span class="line">	SegmentAddr:</span><br><span class="line">  CodeSeg dd section.code.start ;4B 0x04</span><br><span class="line">	DataSeg dd section.data.start ;4B 0x08</span><br><span class="line">	StackSeg dd section.stack.start ;4B 0x0c</span><br><span class="line">	SegmentNum:</span><br><span class="line">	SegNum db (SegmentNum-SegmentAddr)/4 ;1B 0x10</span><br><span class="line">	Entry dw CodeStart ;2B 0x11</span><br><span class="line">	      dd section.code.start ;4B 0x13</span><br><span class="line"></span><br><span class="line">section code align=16 vstart=0</span><br><span class="line">CodeStart:</span><br><span class="line">  mov ax, [DataSeg]</span><br><span class="line">	mov ds, ax</span><br><span class="line">	xor si, si</span><br><span class="line">	call PrintString</span><br><span class="line">	jmp $</span><br><span class="line"></span><br><span class="line">PrintString:</span><br><span class="line">  .setup:</span><br><span class="line">  push ax</span><br><span class="line">  push bx</span><br><span class="line">  push cx</span><br><span class="line">  push dx</span><br><span class="line">  mov ax, VIDEOMEM</span><br><span class="line">  mov es, ax</span><br><span class="line">  xor di, di</span><br><span class="line"></span><br><span class="line">  mov bh, SETCHAR</span><br><span class="line">  mov cx, STRINGLEN</span><br><span class="line"></span><br><span class="line">  .printchar:</span><br><span class="line">  mov bl, [ds:si]</span><br><span class="line">  inc si</span><br><span class="line">  mov [es:di], bl</span><br><span class="line">  inc di</span><br><span class="line">  mov [es:di], bh</span><br><span class="line">  inc di</span><br><span class="line">  or bl, NUL</span><br><span class="line">  jz .return</span><br><span class="line">  loop .printchar</span><br><span class="line">  .return:</span><br><span class="line">  mov bx, di</span><br><span class="line">  pop dx</span><br><span class="line">  pop cx</span><br><span class="line">  pop bx</span><br><span class="line">  pop ax</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">section data align=16 vstart=0</span><br><span class="line">  Hello db &#x27;Hello, I come from program on sector 1, loaded by bootloader!&#x27;</span><br><span class="line"></span><br><span class="line">section stack align=16 vstart=0</span><br><span class="line">  ; resb 保留一定空间</span><br><span class="line">  resb 128</span><br><span class="line"></span><br><span class="line">section end align=16</span><br><span class="line">  ProgramEnd:</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://img.ansore.de/2022/05/15/6280e4e03d18e.png" alt="Screenshot_20220112_225338.png"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>KVM与实体机共享目录</title>
    <url>/posts/18aaf2d9.html</url>
    <content><![CDATA[<h1 id="virtiofs"><a href="#virtiofs" class="headerlink" title="virtiofs"></a>virtiofs</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filesystem</span> <span class="attr">type</span>=<span class="string">&quot;mount&quot;</span> <span class="attr">accessmode</span>=<span class="string">&quot;passthrough&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">type</span>=<span class="string">&quot;virtiofs&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">binary</span> <span class="attr">path</span>=<span class="string">&quot;/usr/lib/virtiofsd&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">dir</span>=<span class="string">&quot;/home/ansore/DATADISK/DISK3/virt_mount/project&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dir</span>=<span class="string">&quot;/home/ansore/project&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;fs0&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&quot;pci&quot;</span> <span class="attr">domain</span>=<span class="string">&quot;0x0000&quot;</span> <span class="attr">bus</span>=<span class="string">&quot;0x08&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;0x00&quot;</span> <span class="attr">function</span>=<span class="string">&quot;0x0&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filesystem</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>挂载目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t virtiofs myfs /mnt</span><br></pre></td></tr></table></figure>
<h1 id="9P"><a href="#9P" class="headerlink" title="9P"></a>9P</h1><p>编辑配置文件：<br><code>virsh edit kvm1</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">devices</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filesystem</span> <span class="attr">type</span>=<span class="string">&quot;mount&quot;</span> <span class="attr">accessmode</span>=<span class="string">&quot;passthrough&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">dir</span>=<span class="string">&quot;/home/ansore/DATADISK/DISK1/study/EFI&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span> <span class="attr">dir</span>=<span class="string">&quot;share_dir&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&quot;pci&quot;</span> <span class="attr">domain</span>=<span class="string">&quot;0x0000&quot;</span> <span class="attr">bus</span>=<span class="string">&quot;0x07&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;0x00&quot;</span> <span class="attr">function</span>=<span class="string">&quot;0x0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filesystem</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动虚拟机<code>virsh start kvm1</code><br>执行控制台连接<code>virsh console kvm1</code><br>确保9p和virtio内存驱动已经加载 <code>lsmod | grep 9p</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9pnet_virtio 17006 0 9pnet 61632 1 9pnet_virtio virtio_ring 17513 3 virtio_pci,virtio_balloon,9pnet_virtio virtio 13058 3 virtio_pci,virtio_balloon,9pnet_virtio</span><br></pre></td></tr></table></figure>
<p>挂载共享的目录到&#x2F;mnt. <strong><code>mount -t 9p -o trans=virtio tmp_shared /mnt</code></strong><br>列出挂载 <code>mount | grep tmp_shared</code></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中找到并删除重复文件的工具</title>
    <url>/posts/4cb3e1a1.html</url>
    <content><![CDATA[<ol>
<li>Rdfind</li>
<li>Fdupes</li>
<li>FSlint</li>
</ol>
<h1 id="Rdfind"><a href="#Rdfind" class="headerlink" title="Rdfind"></a>Rdfind</h1><p><strong>Rdfind</strong> 意即 <strong>r</strong>edundant <strong>d</strong>ata <strong>find</strong>（冗余数据查找），是一个通过访问目录和子目录来找出重复文件的自由开源的工具。它是基于文件内容而不是文件名来比较。Rdfind 使用<strong>排序</strong>算法来区分原始文件和重复文件。如果你有两个或者更多的相同文件，Rdfind 会很智能的找到原始文件并认定剩下的文件为重复文件。一旦找到副本文件，它会向你报告。你可以决定是删除还是使用<a href="https://link.zhihu.com/?target=https://www.ostechnix.com/explaining-soft-link-and-hard-link-in-linux-with-examples/">硬链接或者符号（软）链接</a>代替它们。</p>
<p><strong>安装 Rdfind</strong></p>
<p>Rdfind 存在于 <a href="https://link.zhihu.com/?target=https://aur.archlinux.org/packages/rdfind/">AUR</a> 中。因此，在基于 Arch 的系统中，你可以像下面一样使用任一如 <a href="https://link.zhihu.com/?target=https://www.ostechnix.com/yay-found-yet-another-reliable-aur-helper/">Yay</a> AUR 程序助手安装它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yay -S rdfind</span><br></pre></td></tr></table></figure>

<p>在 Debian、Ubuntu、Linux Mint 上：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt-get install rdfind</span><br></pre></td></tr></table></figure>

<p>在 Fedora 上：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo dnf install rdfind</span><br></pre></td></tr></table></figure>

<p>在 RHEL、CentOS 上：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install rdfind</span><br></pre></td></tr></table></figure>

<p><strong>用法</strong></p>
<p>一旦安装完成，仅带上目录路径运行 Rdfind 命令就可以扫描重复文件。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rdfind ~/Downloads</span><br></pre></td></tr></table></figure>

<p>Rdfind 命令将扫描 <code>~/Downloads</code> 目录，并将结果存储到当前工作目录下一个名为 <code>results.txt</code> 的文件中。你可以在 <code>results.txt</code> 文件中看到可能是重复文件的名字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat results.txt</span><br><span class="line"># Automatically generated</span><br><span class="line"># duptype id depth size device inode priority name</span><br><span class="line">DUPTYPE_FIRST_OCCURRENCE 1469 8 9 2050 15864884 1 /home/sk/Downloads/tor-browser_en-US/Browser/TorBrowser/Tor/PluggableTransports/fte/tests/dfas/test5.regex</span><br><span class="line">DUPTYPE_WITHIN_SAME_TREE -1469 8 9 2050 15864886 1 /home/sk/Downloads/tor-browser_en-US/Browser/TorBrowser/Tor/PluggableTransports/fte/tests/dfas/test6.regex</span><br><span class="line">[...]</span><br><span class="line">DUPTYPE_FIRST_OCCURRENCE 13 0 403635 2050 15740257 1 /home/sk/Downloads/Hyperledger(1).pdf</span><br><span class="line">DUPTYPE_WITHIN_SAME_TREE -13 0 403635 2050 15741071 1 /home/sk/Downloads/Hyperledger.pdf</span><br><span class="line"># end of file</span><br></pre></td></tr></table></figure>

<p>通过检查 <code>results.txt</code> 文件，你可以很容易的找到那些重复文件。如果愿意你可以手动的删除它们。</p>
<p>此外，你可在不修改其他事情情况下使用 <code>-dryrun</code> 选项找出所有重复文件，并在终端上输出汇总信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdfind -dryrun true ~/Downloads</span><br></pre></td></tr></table></figure>

<p>一旦找到重复文件，你可以使用硬链接或符号链接代替他们。</p>
<p>使用硬链接代替所有重复文件，运行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rdfind -makehardlinks true ~/Downloads</span><br></pre></td></tr></table></figure>

<p>使用符号链接&#x2F;软链接代替所有重复文件，运行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rdfind -makesymlinks true ~/Downloads</span><br></pre></td></tr></table></figure>

<p>目录中有一些空文件，也许你想忽略他们，你可以像下面一样使用 <code>-ignoreempty</code> 选项：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rdfind -ignoreempty true ~/Downloads</span><br></pre></td></tr></table></figure>

<p>如果你不再想要这些旧文件，删除重复文件，而不是使用硬链接或软链接代替它们。</p>
<p>删除重复文件，就运行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rdfind -deleteduplicates true ~/Downloads</span><br></pre></td></tr></table></figure>

<p>如果你不想忽略空文件，并且和所哟重复文件一起删除。运行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rdfind -deleteduplicates true -ignoreempty false ~/Downloads</span><br></pre></td></tr></table></figure>

<p>更多细节，参照帮助部分：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rdfind --help</span><br></pre></td></tr></table></figure>

<p>手册页：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">man rdfind</span><br></pre></td></tr></table></figure>

<h1 id="Fdupes"><a href="#Fdupes" class="headerlink" title="Fdupes"></a>Fdupes</h1><p><strong>Fdupes</strong> 是另一个在指定目录以及子目录中识别和移除重复文件的命令行工具。这是一个使用 C 语言编写的自由开源工具。Fdupes 通过对比文件大小、部分 MD5 签名、全部 MD5 签名，最后执行逐个字节对比校验来识别重复文件。</p>
<p>与 Rdfind 工具类似，Fdupes 附带非常少的选项来执行操作，如：</p>
<ul>
<li>在目录和子目录中递归的搜索重复文件</li>
<li>从计算中排除空文件和隐藏文件</li>
<li>显示重复文件大小</li>
<li>出现重复文件时立即删除</li>
<li>使用不同的拥有者&#x2F;组或权限位来排除重复文件</li>
<li>更多</li>
</ul>
<p><strong>安装 Fdupes</strong></p>
<p>Fdupes 存在于大多数 Linux 发行版的默认仓库中。</p>
<p>在 Arch Linux 和它的变种如 Antergos、Manjaro Linux 上，如下使用 Pacman 安装它。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fdupes</span><br></pre></td></tr></table></figure>

<p>在 Debian、Ubuntu、Linux Mint 上:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fdupes</span><br></pre></td></tr></table></figure>

<p>在 Fedora 上：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo dnf install fdupes</span><br></pre></td></tr></table></figure>

<p>在 RHEL、CentOS 上：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install fdupes</span><br></pre></td></tr></table></figure>

<p><strong>用法</strong></p>
<p>Fdupes 用法非常简单。仅运行下面的命令就可以在目录中找到重复文件，如：<code>~/Downloads</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fdupes ~/Downloads</span><br></pre></td></tr></table></figure>

<p>我系统中的样例输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/home/sk/Downloads/Hyperledger.pdf</span><br><span class="line">/home/sk/Downloads/Hyperledger(1).pdf</span><br></pre></td></tr></table></figure>

<p>你可以看到，在 <code>/home/sk/Downloads/</code> 目录下有一个重复文件。它仅显示了父级目录中的重复文件。如何显示子目录中的重复文件？像下面一样，使用 <code>-r</code> 选项。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fdupes -r ~/Downloads</span><br></pre></td></tr></table></figure>

<p>现在你将看到 <code>/home/sk/Downloads/</code> 目录以及子目录中的重复文件。</p>
<p>Fdupes 也可用来从多个目录中迅速查找重复文件。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fdupes ~/Downloads ~/Documents/ostechnix</span><br></pre></td></tr></table></figure>

<p>你甚至可以搜索多个目录，递归搜索其中一个目录，如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fdupes ~/Downloads -r ~/Documents/ostechnix</span><br></pre></td></tr></table></figure>

<p>上面的命令将搜索 <code>~/Downloads</code> 目录，<code>~/Documents/ostechnix</code> 目录和它的子目录中的重复文件。</p>
<p>有时，你可能想要知道一个目录中重复文件的大小。你可以使用 <code>-S</code> 选项，如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ fdupes -S ~/Downloads</span><br><span class="line">403635 bytes each:</span><br><span class="line">/home/sk/Downloads/Hyperledger.pdf</span><br><span class="line">/home/sk/Downloads/Hyperledger(1).pdf</span><br></pre></td></tr></table></figure>

<p>类似的，为了显示父目录和子目录中重复文件的大小，使用 <code>-Sr</code> 选项。</p>
<p>我们可以在计算时分别使用 <code>-n</code> 和 <code>-A</code> 选项排除空白文件以及排除隐藏文件。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fdupes -n ~/Downloads</span><br><span class="line">fdupes -A ~/Downloads</span><br></pre></td></tr></table></figure>

<p>在搜索指定目录的重复文件时，第一个命令将排除零长度文件，后面的命令将排除隐藏文件。</p>
<p>汇总重复文件信息，使用 <code>-m</code> 选项。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ fdupes -m ~/Downloads</span><br><span class="line">1 duplicate files (in 1 sets), occupying 403.6 kilobytes</span><br></pre></td></tr></table></figure>

<p>删除所有重复文件，使用 <code>-d</code> 选项。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fdupes -d ~/Downloads</span><br></pre></td></tr></table></figure>

<p>样例输出：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[1] /home/sk/Downloads/Hyperledger Fabric Installation.pdf</span><br><span class="line">[2] /home/sk/Downloads/Hyperledger Fabric Installation(1).pdf</span><br><span class="line"></span><br><span class="line">Set 1 of 1, preserve files [1 - 2, all]:</span><br></pre></td></tr></table></figure>

<p>这个命令将提示你保留还是删除所有其他重复文件。输入任一号码保留相应的文件，并删除剩下的文件。当使用这个选项的时候需要更加注意。如果不小心，你可能会删除原文件。</p>
<p>如果你想要每次保留每个重复文件集合的第一个文件，且无提示的删除其他文件，使用 <code>-dN</code> 选项（不推荐）。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fdupes -dN ~/Downloads</span><br></pre></td></tr></table></figure>

<p>当遇到重复文件时删除它们，使用 <code>-I</code> 标志。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fdupes -I ~/Downloads</span><br></pre></td></tr></table></figure>

<p>关于 Fdupes 的更多细节，查看帮助部分和 man 页面。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fdupes --help</span><br><span class="line">man fdupes</span><br></pre></td></tr></table></figure>

<h1 id="FSlint"><a href="#FSlint" class="headerlink" title="FSlint"></a>FSlint</h1><p><strong>FSlint</strong> 是另外一个查找重复文件的工具，有时我用它去掉 Linux 系统中不需要的重复文件并释放磁盘空间。不像另外两个工具，FSlint 有 GUI 和 CLI 两种模式。因此对于新手来说它更友好。FSlint 不仅仅找出重复文件，也找出坏符号链接、坏名字文件、临时文件、坏的用户 ID、空目录和非精简的二进制文件等等。</p>
<p><strong>安装 FSlint</strong></p>
<p>FSlint 存在于 <a href="https://link.zhihu.com/?target=https://aur.archlinux.org/packages/fslint/">AUR</a>，因此你可以使用任一 AUR 助手安装它。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">yay -S fslint</span><br></pre></td></tr></table></figure>

<p>在 Debian、Ubuntu、Linux Mint 上：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fslint</span><br></pre></td></tr></table></figure>

<p>在 Fedora 上：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo dnf install fslint</span><br></pre></td></tr></table></figure>

<p>在 RHEL，CentOS 上：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install fslint</span><br></pre></td></tr></table></figure>

<p>一旦安装完成，从菜单或者应用程序启动器启动它。</p>
<p><strong>FSlint 命令行选项</strong></p>
<p>FSlint 提供下面的 CLI 工具集在你的文件系统中查找重复文件。</p>
<ul>
<li><code>findup</code> — 查找重复文件</li>
<li><code>findnl</code> — 查找名称规范（有问题的文件名）</li>
<li><code>findu8</code> — 查找非法的 utf8 编码的文件名</li>
<li><code>findbl</code> — 查找坏链接（有问题的符号链接）</li>
<li><code>findsn</code> — 查找同名文件（可能有冲突的文件名）</li>
<li><code>finded</code> — 查找空目录</li>
<li><code>findid</code> — 查找死用户的文件</li>
<li><code>findns</code> — 查找非精简的可执行文件</li>
<li><code>findrs</code> — 查找文件名中多余的空白</li>
<li><code>findtf</code> — 查找临时文件</li>
<li><code>findul</code> — 查找可能未使用的库</li>
<li><code>zipdir</code> — 回收 ext2 目录项下浪费的空间</li>
</ul>
<p>所有这些工具位于 <code>/usr/share/fslint/fslint/fslint</code> 下面。</p>
<p>例如，在给定的目录中查找重复文件，运行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ /usr/share/fslint/fslint/findup ~/Downloads/</span><br></pre></td></tr></table></figure>

<p>类似的，找出空目录命令是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ /usr/share/fslint/fslint/finded ~/Downloads/</span><br></pre></td></tr></table></figure>

<p>获取每个工具更多细节，例如：<code>findup</code>，运行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ /usr/share/fslint/fslint/findup --help</span><br></pre></td></tr></table></figure>

<p>关于 FSlint 的更多细节，参照帮助部分和 man 页。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ /usr/share/fslint/fslint/fslint --help</span><br><span class="line">$ man fslint</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>QEMU搭建ARM32环境</title>
    <url>/posts/28e97253.html</url>
    <content><![CDATA[<p>环境基于ubuntu18.04</p>
<h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#获取内核源码</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.4.18.tar.xz</span><br><span class="line">tar -vxf linux-5.4.18.tar.xz</span><br><span class="line"></span><br><span class="line">#编译内核</span><br><span class="line">mkdir -p output</span><br><span class="line">KERNEL_OUT=$PWD/output</span><br><span class="line"></span><br><span class="line">cd linux-5.4.18</span><br><span class="line"></span><br><span class="line">export ARCH=arm</span><br><span class="line">export CROSS_COMPILE=/usr/local/arm/gcc-arm-11.2-2022.02-x86_64-arm-none-linux-gnueabihf/bin/arm-none-linux-gnueabihf-</span><br><span class="line"></span><br><span class="line">make O=$KERNEL_OUT vexpress_defconfig</span><br><span class="line">make O=$KERNEL_OUT zImage -j12</span><br><span class="line">make O=$KERNEL_OUT modules -j12</span><br><span class="line">make O=$KERNEL_OUT dtbs -j12</span><br></pre></td></tr></table></figure>
<p>等待编译完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内核镜像在：arch/arm/boot/zImage</span><br><span class="line">设备树文件在：arch/arm/boot/dts/vexpress-v2p-ca9.dtb</span><br></pre></td></tr></table></figure>
<h1 id="制作arm32的ubuntu20-04根文件系统"><a href="#制作arm32的ubuntu20-04根文件系统" class="headerlink" title="制作arm32的ubuntu20.04根文件系统"></a>制作arm32的ubuntu20.04根文件系统</h1><h2 id="安装-debootstrap-工具"><a href="#安装-debootstrap-工具" class="headerlink" title="安装 debootstrap 工具"></a>安装 debootstrap 工具</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install binfmt-support qemu qemu-user-static debootstrap</span><br></pre></td></tr></table></figure>
<h2 id="制作ubuntu20-04文件系统"><a href="#制作ubuntu20-04文件系统" class="headerlink" title="制作ubuntu20.04文件系统"></a>制作ubuntu20.04文件系统</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ubuntu20.04_rootfs</span><br><span class="line"></span><br><span class="line">sudo debootstrap --arch=armhf --foreign focal ubuntu20.04_rootfs/ https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/</span><br><span class="line">#--arch：指定要制作文件系统的处理器体系结构，比如 armhf、arm64</span><br><span class="line">#focal：指定 ubuntu 的版本。focal 是 ubuntu 20.04 系统</span><br><span class="line">#--foreign: 只执行引导的初始解包阶段，仅仅下载和解压</span><br><span class="line">#https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/: 清华大学开源 ubuntu 镜像源地址</span><br><span class="line"></span><br><span class="line"># sudo cp /usr/bin/qemu-aarch64-static ubuntu20.04_rootfs/usr/bin/</span><br><span class="line"># sudo cp /usr/bin/qemu-arm-static ubuntu20.04_rootfs/usr/bin/</span><br><span class="line">sudo chroot ubuntu20.04_rootfs/ debootstrap/debootstrap --second-stage</span><br></pre></td></tr></table></figure>
<h2 id="设置根文件系统的用户名和密码"><a href="#设置根文件系统的用户名和密码" class="headerlink" title="设置根文件系统的用户名和密码"></a>设置根文件系统的用户名和密码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入文件系统</span><br><span class="line">sudo chroot ubuntu20.04_rootfs/</span><br><span class="line"></span><br><span class="line">#修改root密码</span><br><span class="line">passwd root</span><br><span class="line"></span><br><span class="line">#添加用户</span><br><span class="line">adduser username</span><br><span class="line"></span><br><span class="line">#将username添加到/etc/sudoers中，否则无法使用sudo</span><br><span class="line">sudo chmod +w /etc/sudoers</span><br><span class="line">#修改/etc/sudoers，在root    ALL=(ALL:ALL) ALL下添加：</span><br><span class="line">username    ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line">sudo chmod -w /etc/sudoers</span><br><span class="line"></span><br><span class="line">#设置编码类型</span><br><span class="line">locale-gen zh_CN.UTF-8</span><br><span class="line"></span><br><span class="line">#安装网络工具</span><br><span class="line">apt update</span><br><span class="line">apt install net-tools</span><br><span class="line">apt install network-manager</span><br><span class="line">apt install openssh-server</span><br></pre></td></tr></table></figure>
<h2 id="制作文件系统镜像文件"><a href="#制作文件系统镜像文件" class="headerlink" title="制作文件系统镜像文件"></a>制作文件系统镜像文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=ubuntu20.04_arm.img bs=1M count=2048</span><br><span class="line">mkfs.ext4 ubuntu20.04_arm.img</span><br><span class="line"></span><br><span class="line">mkdir -p tmpfs</span><br><span class="line">mount -t ext4 ubuntu20.04_arm.img tmpfs/ -o loop</span><br><span class="line">cp -af ubuntu20.04_rootfs/* tmpfs/</span><br><span class="line">umount tmpfs</span><br><span class="line">chmod 777 ubuntu20.04_arm.img</span><br></pre></td></tr></table></figure>
<h1 id="qemu启动脚本run-sh"><a href="#qemu启动脚本run-sh" class="headerlink" title="qemu启动脚本run.sh"></a>qemu启动脚本run.sh</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#https://wiki.qemu.org/Documentation</span><br><span class="line"></span><br><span class="line">kernel_root=$PWD/system-image</span><br><span class="line">kernel_image=$kernel_root/zImage</span><br><span class="line">kernel_dtb=$kernel_root/vexpress-v2p-ca9.dtb</span><br><span class="line">rootfs_image=$PWD/ubuntu20.04_arm.img</span><br><span class="line"></span><br><span class="line">qemu-system-arm \</span><br><span class="line">	-M vexpress-a9 \</span><br><span class="line">	-m 1024M \</span><br><span class="line">	-smp 4 \</span><br><span class="line">	-nographic \</span><br><span class="line">	-kernel $kernel_image \</span><br><span class="line">	-dtb $kernel_dtb \</span><br><span class="line">	-sd $rootfs_image \</span><br><span class="line">	-append &quot;noinitrd root=/dev/mmcblk0 rw rootwait earlyprintk console=ttyAMA0&quot;	\</span><br><span class="line">	-net nic -net user,hostfwd=tcp::2222-:22	\</span><br><span class="line">	-vnc :1</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-M：指定开发板型号</span><br><span class="line">-m：指定内存大小</span><br><span class="line">-smp：指定cpu核心数</span><br><span class="line">-nographic：无图形界面启动</span><br><span class="line">-kernel：内核镜像</span><br><span class="line">-dtb：设备树镜像</span><br><span class="line">-sd：文件系统镜像</span><br><span class="line">-append：传递给内核的启动参数</span><br><span class="line">-net：指定网络类型，并将22端口映射为2222用于ssh登录</span><br><span class="line">-vnc：指定vnc的端口，端口为5900+冒号后的数字</span><br></pre></td></tr></table></figure>
<h1 id="启动登录"><a href="#启动登录" class="headerlink" title="启动登录"></a>启动登录</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入系统 </span><br><span class="line">./run.sh</span><br><span class="line">#登陆后获取网络ip </span><br><span class="line">sudo dhclient</span><br></pre></td></tr></table></figure>
<h1 id="配置ubuntu20-04自动获取ip"><a href="#配置ubuntu20-04自动获取ip" class="headerlink" title="配置ubuntu20.04自动获取ip"></a>配置ubuntu20.04自动获取ip</h1><p>第4步中，需要每次开机都执行sudo dhclient才能获取到ip，过于麻烦。ubuntu20.04网络的配置信息将不再保存在&#x2F;etc&#x2F;network&#x2F;interfaces文件中，虽然该文件依然存在，但是内容是空的。新系统已经使用netplan管理网络，可以在&#x2F;etc&#x2F;netplan&#x2F;中创建00-installer-config.yaml配置文件实现:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/netplan/00-installer-config.yaml</span><br></pre></td></tr></table></figure>
<p>添加如下内容,其中eth0为使用的网卡：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">	version: 2</span><br><span class="line">	ethernets:</span><br><span class="line">		eth0:</span><br><span class="line">			dhcp4: true</span><br><span class="line">			nameservers:</span><br><span class="line">				addresses: [114.114.114.114,223.5.5.5]</span><br></pre></td></tr></table></figure>
<p>保存后执行以下命令生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>
<h1 id="解决apt-update失败问题"><a href="#解决apt-update失败问题" class="headerlink" title="解决apt update失败问题"></a>解决apt update失败问题</h1><p>执行 apt update 命令报错:<br>Certificate verification failed: The certificate is NOT trusted. The certificate chain uses expired certificate. Could not handshake: Error in the certificate verification<br>证书验证失败：证书不受信任。证书链使用过期的证书。无法握手：证书验证错误<br>解决方法：<br>手动下载 ca-certificates deb 文件重新安装最新版。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://archive.ubuntu.com/ubuntu/pool/main/c/ca-certificates/ca-certificates_20210119~16.04.1_all.deb</span><br><span class="line"></span><br><span class="line">sudo dpkg -i ./ca-certificates_20210119~16.04.1_all.deb</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN基于Tensorflow实现cifar10数据集80准确率</title>
    <url>/posts/4c3e71da.html</url>
    <content><![CDATA[<h2 id="数据导入和预处理"><a href="#数据导入和预处理" class="headerlink" title="数据导入和预处理"></a>数据导入和预处理</h2><p>本文使用的是CIFAR10的数据集。CIFAR10包含了十个类型的图片，有60000张大小为32x32的彩色图片，其中50000张用于训练，10000张用于测试。数据集共分为5个训练块和1个测试块，每个块有10000个图像，包含以下数据：</p>
<ol>
<li>data——1个数据块中包含1个10000*3072大小的uint8s数组，数组每行存储1张32x32图像，第一个1024数组包含红色通道，下一个1024数组包含绿色通道，最后一个1024包含蓝色通道。图像存储以行顺序为主，所以数组的前32列为图像的第一行红色通道的值。</li>
<li>lables——1个数据块包含1个10000数的列表，范围为0-9，分别对应图片不同的分类，索引值i的数值表示数组data中的第i个图片的标签。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_CIFAR_batch</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 载入cifar数据集的一个batch &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        datadict = p.load(f, encoding=<span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line">        X = datadict[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">        Y = datadict[<span class="string">&#x27;labels&#x27;</span>]</span><br><span class="line">        X = X.reshape(<span class="number">10000</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>).transpose(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>).astype(<span class="string">&quot;float32&quot;</span>)</span><br><span class="line">        Y = np.array(Y)</span><br><span class="line">        <span class="keyword">return</span> X, Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># one hot 处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_one_hot</span>(<span class="params">data1</span>):</span><br><span class="line">    <span class="keyword">return</span> (np.arange(<span class="number">10</span>)==data1[:,<span class="literal">None</span>]).astype(np.integer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_CIFAR10</span>(<span class="params">ROOT</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 载入cifar全部数据 &quot;&quot;&quot;</span></span><br><span class="line">    xs = []</span><br><span class="line">    ys = []</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">        f = os.path.join(ROOT, <span class="string">&#x27;data_batch_%d&#x27;</span> % (b,))</span><br><span class="line">        X, Y = load_CIFAR_batch(f)</span><br><span class="line">        xs.append(X)</span><br><span class="line">        ys.append(Y)</span><br><span class="line">    Xtr = np.concatenate(xs)</span><br><span class="line">    Ytr = np.concatenate(ys)</span><br><span class="line">    <span class="keyword">del</span> X, Y</span><br><span class="line">    Xte, Yte = load_CIFAR_batch(os.path.join(ROOT, <span class="string">&#x27;test_batch&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># one hot 处理</span></span><br><span class="line">    Ytr = make_one_hot(Ytr)</span><br><span class="line">    Yte = make_one_hot(Yte)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Xtr, Ytr, Xte, Yte</span><br></pre></td></tr></table></figure>

<p>读取过程中，将每张图片维度转换为[32,32,3]，然后将数据类型改变为float，每批数据都是10000x32x32x3，相当于超过了3000万个浮点数，数据类型float实际与float64相同，也就是说每个数字占用8个字节，这就意味着每批数据至少占用240M内存，一次将训练集和测试集载入内存的话，至少需要1.4G内存空间，这还只是数据的准备阶段。</p>
<p>函数load_CIFAR10函数传入的值为cifar10数据的加载的相对目录，读出数据后还要对10类标签进行one-hot编码，以供后来的softmax分类处理。该函数返回值分别为训练集图像、训练集标签、测试集图像、测试集标签，他们的索引值一一对应。</p>
<h2 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h2><p>TensorFlow基于数据流图的框架，首先定义模型之前要将各个节点表示成某种抽象的计算，边表示节点之间张量的联系。也就是说Tensorflow不单独地运行单一的复杂计算，而是先用图描述一系列可交互性的计算操作，然后全部一起在Python之外运行，提高运算效率。</p>
<p>本文采用的卷积神经网络（CNN）主要用来识别以为、缩放以及其他形式扭曲不变性的二维图像，相较于一般神经网络，卷积网络的输入图像和网络的拓扑结构能很好的吻合，特征提取和模式分类可以同时进行，并且都在训练中产生。采用监督学习训练模型，每一个输入对象都有一个期望的输出值，利用一组已知类别的样本调整分类器参数，使其各层参数最终分别收敛。</p>
<p>本文创建的模型，是一个多层架构，采用类似vgg16的结构创建模型，由卷积层和非线性层（nonlinearities）交替多次后排列构成，但是没有用到vgg16庞大的全连接层结构，设计思路如下：</p>
<ol>
<li>所有卷积层均使用3X3的小卷积核</li>
<li>两层卷积搭配一层池化</li>
<li>使用vgg16前三个卷积和池化操作，以2的次幂依次递增卷积核数量(64,128,256) </li>
<li>调整精度控制，防止过拟合或者欠拟合的情况</li>
<li>模型的全连接层没有采用vgg16的三层结构，卷积层输出后直接跟10分类的softmax classifier</li>
<li>初始化权重和偏置全部采用随机，防止0梯度的情况</li>
<li>建立状态可视化，分别记录训练过程中的损失以及对训练集准确率的变化</li>
<li>定义输入和输出节点，供安卓端调用</li>
</ol>
<h3 id="定义占位符"><a href="#定义占位符" class="headerlink" title="定义占位符"></a>定义占位符</h3><p>因为Tensorflow是基于图来计算的，每执行一步程序，都是一个op，整个程序在运行之前必须定义要执行的操作，placeholder其实也是一种常量，但是是由用户在调用run方法的时候传递的。在训练过程中，由于数据量比较庞大，不可能将所有数据一次性载入内存执行运算，所以运用placeholder在运算的时候传入一小部分数据进行运算，计算完毕以后再传入另外一部分进行运算，这样一直迭代下去，减少对计算机配置的需求。</p>
<p>首先创建图的输入部分，分别为inputnode（图片）和classes（分类），在定义这Tensor Variable时，需要指定名字，以方便安卓端调用的时候能找到计算流图中的输入位置（通过形参name指定），在Tensorflow进行运算的时候使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.name_scope(<span class="string">&quot;inputs&quot;</span>):</span><br><span class="line">        x = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">3</span>], name=<span class="string">&quot;inputnode&quot;</span>)</span><br><span class="line">        y_ = tf.placeholder(tf.float32, [<span class="literal">None</span>, <span class="number">10</span>], name=<span class="string">&quot;classes&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>图片输入x为浮点数4维张量，定义它的shape为[None, 32, 32, 3]，其中None可以为任意值，第2、3维是图片的尺寸，表示输入图片的大小为32x32像素，第4维为图片的颜色通道，黑白图片为1，彩色图片为3（r、g、b三个输入通道）。输入值y_是一个2维张量，每一行的10维向量代表不同图片的分类，这里输入的是图片标签的真实分类。</p>
<h3 id="权重和偏置初始化"><a href="#权重和偏置初始化" class="headerlink" title="权重和偏置初始化"></a>权重和偏置初始化</h3><p>当训练模型时，用变量来存储和更新参数。变量包含张量（Tensor）存放在内存中，建立模型时它们需要明确被初始化，训练模型后它们可以存放到磁盘。之后训练模型和分析可以直接加载。</p>
<p>创建模型的时候，变量初始化时加入轻微噪声，打破对称性，防止0梯度问题。为了避免在建模型的时候反复进行初始化操作，直接定义两个函数用于初始化权重和偏置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">weight_variable</span>(<span class="params">shape</span>):</span><br><span class="line">    init = tf.random_normal(shape, stddev=<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(init, name=<span class="string">&quot;Weights&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bias_variable</span>(<span class="params">shape</span>):</span><br><span class="line">    init = tf.random_normal(shape)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(init, name=<span class="string">&quot;biases&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在tensorflow中创建一个变量的时候，需要将一个张量作为初始值传入构造函数Variable()。所有这些操作都需要指定张量的shape，也就是张量的维度。变量的维度通常是固定的。</p>
<h3 id="卷积、池化和dropout"><a href="#卷积、池化和dropout" class="headerlink" title="卷积、池化和dropout"></a>卷积、池化和dropout</h3><p>卷积运算可以理解成一种加权求和，通过卷积运算，可以使原信号特征增强，而且可以降低噪声，本文使用1步长、0边距的模板，保证输入和输出的向量是同样大小。</p>
<p>采用池化层的原因是，根据图像的局部相关性原理，对图像进行子采样可以减少计算量，同时也可以保证图像不变性，本文采用2x2大小的模板做最大池化。</p>
<p>Dropout在深度学习中，按照一定的概率使一部分神经元不被激活，也就是说按一定概率将它从神经网络中暂时丢弃，从而防止过度拟合。依然定义函数进行操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conv2d</span>(<span class="params">x, W</span>):</span><br><span class="line">    conv = tf.nn.conv2d(x, W, strides=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], padding=<span class="string">&#x27;SAME&#x27;</span>, name=<span class="string">&quot;Conv2D&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> conv</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max_pool_2x2</span>(<span class="params">x</span>):</span><br><span class="line">    pool = tf.nn.max_pool(x, ksize=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], strides=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], padding=<span class="string">&#x27;SAME&#x27;</span>, name=<span class="string">&quot;MaxPool2D&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> pool</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dropout</span>(<span class="params">x, keep</span>):</span><br><span class="line">    <span class="keyword">return</span> tf.nn.dropout(x, keep, name=<span class="string">&quot;dropout&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>每一层卷积之后，紧接着¬用一个非线性层，主要目的是在系统中引入非线性特征。本文中使用Relu层，具有比tanh和sigmoid函数更好的效率和速度，Relu层只要对input的所有值应用函数f(x)&#x3D;max(0,x)，也就是说这一层所有的negative activation为0，可以很大程度上减少存储空间，同时也可以加快收敛速度。添加卷积层同样抽象成一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#　添加卷积层　</span></span><br><span class="line"><span class="comment"># inputs 输入数据　</span></span><br><span class="line"><span class="comment"># weight_shape权重格式　</span></span><br><span class="line"><span class="comment"># bias_shape 偏置格式</span></span><br><span class="line"><span class="comment"># keep_prob 过拟合</span></span><br><span class="line"><span class="comment"># activation_function激励函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_conv</span>(<span class="params">inputs, weight_shape, bias_shape, keep_prob, activation_function = <span class="literal">None</span></span>):</span><br><span class="line">    Weights1 = weight_variable(weight_shape)</span><br><span class="line">    biases1 = bias_variable(bias_shape)</span><br><span class="line">    <span class="comment"># 卷积</span></span><br><span class="line">    <span class="keyword">if</span> activation_function <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        conv = conv2d(inputs, Weights1) + biases1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        conv = activation_function(conv2d(inputs, Weights1)+biases1)</span><br><span class="line">    drop = dropout(conv, keep_prob)</span><br><span class="line">    <span class="keyword">return</span> drop</span><br></pre></td></tr></table></figure>

<h3 id="定义网络结构"><a href="#定义网络结构" class="headerlink" title="定义网络结构"></a>定义网络结构</h3><p>本文采用卷积层和采样层（池化层）交替设置，即layer1的具体结构就是两层卷积层搭配一层采样层，layer2和layer3同样也是两层卷积层加上一层采样层，经过这样三层运算后图片维度变化为：</p>
<blockquote>
<p>input:32x32 -&gt; layer1:16x16 -&gt; layer2:8x8 -&gt; layer3:4x4</p>
</blockquote>
<p>网络结构代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># layer 1</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">&quot;layer1&quot;</span>):</span><br><span class="line">        drop1 = add_conv(images, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>], [<span class="number">64</span>], <span class="number">1</span>, tf.nn.relu)</span><br><span class="line">        drop1 = add_conv(drop1, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>], [<span class="number">64</span>], <span class="number">1</span>, tf.nn.relu)</span><br><span class="line">        drop1 = max_pool_2x2(drop1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># layer 2</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">&quot;layer2&quot;</span>):</span><br><span class="line">        drop2 = add_conv(drop1, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">128</span>], [<span class="number">128</span>], <span class="number">1</span>, tf.nn.relu)</span><br><span class="line">        drop2 = add_conv(drop2, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">128</span>, <span class="number">128</span>], [<span class="number">128</span>], <span class="number">1</span>, tf.nn.relu)</span><br><span class="line">        drop2 = max_pool_2x2(drop2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># layer 3</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">&quot;layer3&quot;</span>):</span><br><span class="line">        drop3 = add_conv(drop2, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">128</span>, <span class="number">256</span>], [<span class="number">256</span>], <span class="number">1</span>, tf.nn.relu)</span><br><span class="line">        drop3 = add_conv(drop3, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>, <span class="number">256</span>], [<span class="number">256</span>], <span class="number">1</span>, tf.nn.relu)</span><br><span class="line">        drop3 = max_pool_2x2(drop3)</span><br><span class="line">        </span><br><span class="line">    drop3_flat = tf.reshape(drop3, [-<span class="number">1</span>, <span class="number">4</span> * <span class="number">4</span> * <span class="number">256</span>], name=<span class="string">&quot;reshape&quot;</span>)</span><br><span class="line"></span><br><span class="line">    dropf = dropout(drop3_flat, <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># out</span></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">&quot;out&quot;</span>):</span><br><span class="line">        Wf = weight_variable([<span class="number">4</span>*<span class="number">4</span>*<span class="number">256</span>, <span class="number">10</span>])</span><br><span class="line">        bf = bias_variable([<span class="number">10</span>])</span><br><span class="line">        dense = tf.matmul(dropf, Wf) + bf</span><br></pre></td></tr></table></figure>

<p>Layer1由两个卷积接一个max_pooling完成。第一层卷积在每个3x3的patch中算出64个特征值。权重是一个[3, 3, 3, 64]的张量，前两个维度是卷积核（patch）的大小，接着是输入通道，最后一个是输出通道，输出对应同样大小的偏置向量。第二层卷积在每个3x3的patch中会得到64个特征。后接一个最大池化层，进行图片采样，进入下一个隐含层。</p>
<p>为了构建一个更深的网络结构，本文将几个类似的层堆叠起来，layer2和layer3的结构几乎一样。layer2中每个3x3的patch会得到128个特征，layer3中每个3x3的patch会得到256个特征。</p>
<p>Layer3执行完毕后，图片的大小为(4x4)x256（最后一层输出特征图大小为256），紧接着通过tensorflow的reshape将这个四维张量拉直成一个二维张量（第1维是图片的序列，第二维是所有的图片特征）。然后接一个dropout防止过拟合。<br>本文所定义的CNN结构不包含全连接层（测试过添加一层256节点的全连接层，训练80个循环以后，测试集只能达到72%左右的准确率，效果比不加还要差）。</p>
<p>最后直接跟输出层，输入图片大小为(4x4)x256，输出10个特征图，即图片的十个分类，输出层由欧式径向基函数（RBF，Euclidean Radial Basis Function）单元组成，每个类一个单元，每个单元由4x4x256个输入，输出层的作用函数为线性函数，对隐藏层神经元输出的结果进行线性加权后输出，作为整个神经网络的输出结果。</p>
<h2 id="定义训练方式"><a href="#定义训练方式" class="headerlink" title="定义训练方式"></a>定义训练方式</h2><h3 id="定义模型训练指标"><a href="#定义模型训练指标" class="headerlink" title="定义模型训练指标"></a>定义模型训练指标</h3><p>卷积网络在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力。</p>
<p>卷积网络执行的是监督训练，所以其样本集是由形如：（输入向量，理想输出向量）的向量对构成的。所有这些向量对，都是来源于已经准备好的训练数据集。</p>
<p>定义训练方法代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out = inference(x)</span><br><span class="line"></span><br><span class="line">    p = tf.nn.softmax(out, name=<span class="string">&quot;outnode&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">&quot;loss&quot;</span>):</span><br><span class="line">        cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=out, labels=y_))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">&quot;train&quot;</span>):</span><br><span class="line">        train_step = tf.train.AdamOptimizer(<span class="number">1e-4</span>).minimize(cross_entropy)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.name_scope(<span class="string">&quot;accuracy&quot;</span>):</span><br><span class="line">        accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(out, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>)), tf.float32))</span><br><span class="line">    tf.summary.scalar(<span class="string">&#x27;loss&#x27;</span>, cross_entropy)</span><br><span class="line">    tf.summary.scalar(<span class="string">&#x27;train_accuracy&#x27;</span>, accuracy)</span><br></pre></td></tr></table></figure>

<p>模型训练分为以下两个阶段：</p>
<p>第一阶段，前向传播阶段：</p>
<ol>
<li>样本集中取一个样本，输入网络</li>
<li>计算相应的实际输出；在此阶段，信息从输入层经过逐级的变换，传送到输出层。</li>
</ol>
<p>这个过程也是网络在完成训练后正常执行时执行的过程。</p>
<p>第二阶段，反向传播阶段（BP）：</p>
<ol>
<li>将每个元组的网络预测与真实的类标号相比较，计算差值</li>
<li>按极小化误差的方法，修改权重和偏置，使得网络预测和实际之间的均方误差减小。</li>
</ol>
<p>即由输出层，经由每个隐藏层，到第一个隐藏层（后向传播）。理论上来说，权重和偏置最终会收敛，学习过程停止。</p>
<p>要完成这两步，首先需要定义一个指标来评估这个模型的好坏，在机器学习中一般定义一个指标表示这个模型是坏的，这个指标成为成本（cost）或损失（loss），然后尽量减小这个指标。本文中使用的成本函数是“交叉熵”（cross-entropy），交叉熵产生与信息论，简单来说，交叉熵是衡量两个概率分布p和q之间的相似性，其定义如下：</p>
<p>$$ H_{y’}(y) &#x3D; -\sum_i{y’_i\log y_i} $$</p>
<p>y是预测的概率分布，y&#96;是实际的分布（即输入的ont-hot vector）。</p>
<p>程序中计算交叉熵：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=out, labels=y_))</span><br></pre></td></tr></table></figure>

<p>softmax_cross_entropy_with_logits实现过程如下：</p>
<ol>
<li>对网络输入的最后一层（out）做一个softmax（所以在网络的输出层没有加softmax）</li>
<li>用tf.log计算上层每个结果的对数，然后把y_的每个元素和tf.log(y_)对应的元素相乘</li>
<li>用tf.reduce_sum计算张量的所有元素的总和</li>
</ol>
<p>最后用tf.reduce_mean计算batch维度（第一维度）下交叉熵（cross-entropy）的平均值，并将这个值作为总损失（loss）。</p>
<p>TensorFlow拥有一张描述各个计算单元的图，也就是说TensorFlow是基于图的，并不是基于数据流的，而且它可以自动使用反向传播算法（BP，backpropagation algorithm），有效确定变量是如何影响需要最小化的那个成本值（cross-entropy），然后通过优化算法不断修改变量来降低成本值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_step = tf.train.AdamOptimizer(<span class="number">1e-4</span>).minimize(cross_entropy)</span><br></pre></td></tr></table></figure>

<p>TensorFlow中有大量内置的优化算法。本文中使用实现了Adam算法的优化器，Adam 也是基于梯度下降的方法，每次迭代参数的学习步长都有一个确定的范围，不会因为很大的梯度导致很大的学习步长，参数的值比较稳定，AdamOptimizer通过使用动量（参数的移动平均数）来改善传统梯度下降，促进参数的动态调整。然后以1e-4的学习效率最小化交叉熵。</p>
<p>这一步实际上是用来往图上添加一个新操作，其中包括计算梯度，计算每个参数的步长变化，并且计算出新的参数值。整个模型可以反复地运行train_step完成梯度下降来更新权值，不断减少损失。TensorFlow在这里做的是，它在后台给计算的那张图里面增加一系列新的操作单元用于实现反向传播算法和梯度下降算法。然后，返回一个单一的操作。也就是说，它把那些繁琐的操作都进行了封装，直接调用即可。</p>
<h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><p>训练模型之后，需要定量评估模型的性能以及准确率如何，分类算法的模型是基于数值输入预测分类值，实际目标是1和0的序列。这就需要度量预测值和真实值之间的距离。分类算法的损失函数一般不容易评估模型的好坏，所以通常情况下是看准确预测分类结果的百分比。</p>
<p>首先需要找出哪些lable是预测正确的，然后除以总数得到正确率。</p>
<p>实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">accuracy = tf.reduce_mean(tf.cast(tf.equal(tf.argmax(out, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>)), tf.float32))</span><br></pre></td></tr></table></figure>

<p>其中tf.argmax会返回一个张量某个维度中的最大值得索引，如tf.argmax(out,1)表示模型对每个输入的最大概率的分类的分类值，而tf.argmax(y_,1)表示真实分类的分类值。然后用tf.equal来判断预测是否和真实分类一致。到这一步返回的是一个布尔数组，为了计算准确率，通过tf.cast将布尔值转化为浮点数来代表对、错（如1代表对、0代表错），然后通过tf.reduce_mean取平均值。</p>
<h3 id="安卓的输出节点"><a href="#安卓的输出节点" class="headerlink" title="安卓的输出节点"></a>安卓的输出节点</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = tf.nn.softmax(out, name=<span class="string">&quot;outnode&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里使用了softmax回归（softmax regression）模型，这个模型可以用来给不同的对象分配概率，关于softmax定义如下：</p>
<p>$$ softmax(x)_i &#x3D; \frac {exp(x_i)} {\sum_j{exp(x_j)}} $$</p>
<p>Softmax把输入值当成幂指数求值，然后再正则化这些结果。这个幂运算表示，更大的evidence对应更大的假设模型里面的乘数权重值，反之，更少的evidence意味假设模型里面更小的乘数权重值。如果模型里的权值不能是0或者负数，softmax然后会正则化这些权重值，使它们的总和等于1，以此来构造一个有效的概率分布。</p>
<p>这里把softmax看成一个激励（activation）函数，把定义的线性函数输出转换成需要的格式，也就是关于图片的10个类别。所以，给定一张图片，它对于每个类别的吻合成都可以被softmax函数转换成一个概率值。</p>
<p>将这个概率值作为输出节点，并指明输出节点（通过name指定），供安卓端调用。</p>
<h3 id="状态可视化"><a href="#状态可视化" class="headerlink" title="状态可视化"></a>状态可视化</h3><p>Tensorflow发布包中提供了TensorBoard，用于展示Tensorflow任务在计算过程中的Graph、定量指标图以及附加数据。为了释放tensorboard中所使用的事件文件，所有的即时数据都要在图表构建阶段合并到一个操作（op）中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.summary.scalar(<span class="string">&#x27;loss&#x27;</span>, cross_entropy)</span><br><span class="line">   tf.summary.scalar(<span class="string">&#x27;train_accuracy&#x27;</span>, accuracy)</span><br><span class="line"></span><br><span class="line">   merged_summary_op = tf.summary.merge_all()</span><br></pre></td></tr></table></figure>

<p>创建好会话（Session）后，实例化一个tf.summary.FileWriter，用于写入包含图表和即时数据具体值的事件文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">summary_writer = tf.summary.FileWriter(<span class="string">&#x27;./tmp&#x27;</span>, graph=tf.get_default_graph())</span><br></pre></td></tr></table></figure>

<p>每次运行merged_summary_op时，都会往事件文件中写入最新的即时数据，函数的输出会传入事件文件读写器（writer）的add_summary()函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_,loss,summary = sess.run([train_step, cross_entropy, merged_summary_op],feed_dict=&#123;x:batch_x,y_:batch_y&#125;)</span><br><span class="line"></span><br><span class="line">summary_writer.add_summary(summary, n*num_batch+i)</span><br></pre></td></tr></table></figure>

<p>事件文件写入完毕后，就训练文件夹打开一个Tensorboard，查看即时数据情况。</p>
<h2 id="训练和保存模型"><a href="#训练和保存模型" class="headerlink" title="训练和保存模型"></a>训练和保存模型</h2><h3 id="环境以及配置"><a href="#环境以及配置" class="headerlink" title="环境以及配置"></a>环境以及配置</h3><p>使用计算机配置：</p>
<blockquote>
<p>处理器：Intel 酷睿i3-6100</p>
<p>GPU：NVIDIA GeForce GTX 1050Ti</p>
<p>内存：16G</p>
</blockquote>
<p>运行环境：</p>
<blockquote>
<p>操作系统：windows 10</p>
<p>Python版本：python3.6</p>
<p>TensorFlow版本：tensorflow-1.7</p>
<p>GPU驱动环境：cuda_9.0，cudnn-7.1</p>
</blockquote>
<h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p>整个训练过程主要包括训练模型、保存即时数据、保存检查点文件（checkpoint file）、评估模型几个部分。具体代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_model</span>(<span class="params">sess, saver,ckpt_path</span>):</span><br><span class="line">    latest_ckpt = tf.train.latest_checkpoint(ckpt_path)</span><br><span class="line">    <span class="built_in">print</span>(latest_ckpt)</span><br><span class="line">    <span class="keyword">if</span> latest_ckpt:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;恢复模型-&#x27;</span>, latest_ckpt)</span><br><span class="line">        saver.restore(sess, latest_ckpt)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(latest_ckpt[latest_ckpt.rindex(<span class="string">&#x27;-&#x27;</span>) + <span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;新建模型&#x27;</span>)</span><br><span class="line">        sess.run(tf.global_variables_initializer())</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cnn_train</span>(<span class="params">batch, x_train, y_train, x_test, y_test</span>):</span><br><span class="line"></span><br><span class="line">    num_batch = <span class="built_in">len</span>(x_train) // batch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># load model</span></span><br><span class="line">        sess.run(tf.initialize_all_variables())</span><br><span class="line"></span><br><span class="line">        saver = tf.train.Saver(tf.all_variables())</span><br><span class="line">        last_epoch = load_model(sess, saver, <span class="string">&#x27;save_model/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        summary_writer = tf.summary.FileWriter(<span class="string">&#x27;./tmp &#x27;</span>, graph=tf.get_default_graph())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(last_epoch + <span class="number">1</span>, <span class="number">1000</span>):</span><br><span class="line">            <span class="comment"># 每次取batch_size张图片</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_batch):</span><br><span class="line">                batch_x = x_train[i*batch : (i+<span class="number">1</span>)*batch]</span><br><span class="line">                batch_y = y_train[i*batch : (i+<span class="number">1</span>)*batch]</span><br><span class="line">                <span class="comment"># 开始训练数据，同时训练三个变量，返回三个数据</span></span><br><span class="line">                _,loss,summary = sess.run([train_step, cross_entropy, merged_summary_op],</span><br><span class="line">                                           feed_dict=&#123;x:batch_x,y_:batch_y&#125;)</span><br><span class="line">                summary_writer.add_summary(summary, n*num_batch+i)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 打印损失</span></span><br><span class="line">                <span class="keyword">if</span> (n*num_batch+i) % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="built_in">print</span>(n*num_batch+i, loss)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n*num_batch+i) % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 获取测试数据的准确率</span></span><br><span class="line">                    x_test_t = x_test[<span class="number">0</span>: <span class="number">2000</span>]</span><br><span class="line">                    y_test_t = y_test[<span class="number">0</span>: <span class="number">2000</span>]</span><br><span class="line">                    acc = sess.run(accuracy, feed_dict=&#123;x:x_test_t, y_:y_test_t&#125;)</span><br><span class="line">                    <span class="comment"># tf.summary.scalar(&#x27;test_accuracy&#x27;, acc)</span></span><br><span class="line">                    <span class="built_in">print</span>(n*num_batch+i, acc)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> acc &gt; <span class="number">0.77</span>:</span><br><span class="line">                        constant_graph = graph_util.convert_variables_to_constants(sess, sess.graph_def, [<span class="string">&quot;outnode&quot;</span>])</span><br><span class="line">                        <span class="keyword">with</span> tf.gfile.FastGFile(<span class="string">&quot;android_model/model-&quot;</span>+<span class="built_in">str</span>(acc)+<span class="string">&quot;.pb&quot;</span>, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                            f.write(constant_graph.SerializeToString())</span><br><span class="line">            saver.save(sess, <span class="string">&#x27;save_model /cifar.model&#x27;</span>, global_step=n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    cifar10_dir = <span class="string">&#x27;data/cifar-10-batches-py/&#x27;</span></span><br><span class="line">    X_train, y_train, X_test, y_test = input_data.load_CIFAR10(cifar10_dir)</span><br><span class="line">    batch_size = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">    cnn_train(batch_size, X_train, y_train, X_test, y_test)</span><br></pre></td></tr></table></figure>

<p>Tensorflow结构以C API为界限，将整个系统分为“前端”和“后端”两个子系统，前端系统提供编程模型，负责构造计算图。后端用C&#x2F;C++语言编写，运算速度比较快，因此后端提供运行时环境，负责执行计算图。前端通过Session连接后端，所以tensorflow构建的计算图必须通过session会话才能执行。</p>
<p>构造图的阶段完成后，才能启动图。启动图的第一步是创建一个Session对象, 如果无任何创建参数, 会话构造器将启动默认图。会话会管理TensorFlow程序运行时的所有资源。当所有计算完成之后需要关闭会话来帮助系统回收资源，否则就可能出现资源泄露的问题，本文中使用Python上下文管理器来使用会话，当上下文退出时，关闭和资源释放也会自动完成。</p>
<p>在训练过程中，传入的整个图像和标签数据集会被切片，以符合每个操作所设置的batch值，占位符操作将填补以符合这个值，然后使用feed_dict参数，将数据传入会话函数（session）。</p>
<p>模型的训练过程描述如下：</p>
<ol>
<li>取得训练集和验证集，将所有数据输入到训练模型函数中。</li>
<li>选定训练组，本文从样本集中分别随机地寻求128个样本作为一个训练组(batch)。</li>
<li>检测是否有检查点文件（checkpoint file），如果有，直接从文件中恢复上次保存的模型，继续训练；如果没有，新建模型，从头开始训练，并初始化所有参数。</li>
<li>取一个训练组加入到网络，并给出它的目标向量（真实值）。</li>
<li>计算损失（loss）和准确率（accuracy），输出到操作（op）中，并通过优化器来减小损失，调整各层权重和偏置。</li>
<li>每经过N个batch后，用验证集评估模型准确率，判断指标是否满足精度要求，如果满足要求，则将模型保存为安卓端可用的模型（.pb为后缀的模型，保存了整张图和每层的权重和偏置），如果不满足，则跳过不保存</li>
<li>训练集每经过一次迭代，就保存模型，向训练文件夹中写入包含了所有课训练变量的值的检查点文件（checkpoint file），以便于中断训练后，可以直接从上次训练的部分恢复继续训练，不需要再进行初始化。</li>
<li>迭代结束或者键盘中断，则结束训练。</li>
</ol>
<p>在循环的每个步骤中，程序都会抓取训练数据中的128个批处理数据点（也就是一个batch），然后用这些数据点作为参数替换之前的占位符来运行train_step。</p>
<p>如此反复多次，直到最终误差收敛。</p>
<p>本文使用随机训练（stochastic training）的方法，每次使用其中一小部分的随机数据来进行训练，更确切地说是随机梯度下降训练。在理想的情况下，所有的数据都来进行每一步的训练，这能得到更好的训练结果，但是这显然也需要很大的计算开销。所以，每一次训练的时候，使用不同的数据子集，这样既可以减少计算开销，又可以最大化地学习到数据集的总特性。</p>
<p>在一块GPU上运行了大约81000个batch，也就是210左右次迭代，大约用了一个半小时，该模型使用验证集评估，最高达到80%的精度。</p>
<h3 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h3><p>在官方api中，提供了两种不同的模型保存方法。</p>
<p>一种是使用tf.train.Saver()保存，这种方式只保存了网络中的各层参数值，并不保存模型结构。这种方式有几个缺点，首先这种模型文件是依赖tensorflow的，只能在tensorflow框架下使用，其次在恢复模型参数之前，还需要再定义一遍网络结构，然后才能恢复到网络中。</p>
<p>另外一种是基于Protocol Buffers的序列化协议，将网络中各层参数值和网络模型结构通过预定好的格式进行持久化保存，也是谷歌推荐的保存模型的方式，它可以独立运行，封闭的序列化格式，任何语言都可以解析它。另外的好处是保存为pb文件的时候，模型的变量都会变成固定的，导致模型大小会大大减小，适合手机端运行。</p>
<p>保存模型具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">constant_graph = graph_util.convert_variables_to_constants(sess, sess.graph_def, [<span class="string">&quot;outnode&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.gfile.FastGFile(<span class="string">&quot;android_model/model-&quot;</span>+<span class="built_in">str</span>(acc)+<span class="string">&quot;.pb&quot;</span>, mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(constant_graph.SerializeToString())</span><br><span class="line">        saver.save(sess, <span class="string">&#x27;save_model /cifar.model&#x27;</span>, global_step=n)</span><br></pre></td></tr></table></figure>
<p>这样就将模型保存为了.pb后缀的文件，这样的模型文件会在之后移植到安卓端的时候使用。</p>
<h3 id="训练结果分析"><a href="#训练结果分析" class="headerlink" title="训练结果分析"></a>训练结果分析</h3><p>本文中使用的模型总参量为120万左右，这还是简化后的VGG16模型，在一块1050ti的GPU上训练了一个半小时左右，经过210次左右迭代。</p>
<p>在经过20000个batch后损失的变化就相对来说比较小了，损失没有上升趋势，说明没有出现过拟合情况。而且在运行时间不长的情况下，说明参数收敛的比较快。在1小时33分钟左右，经过约80000个batch后，损失值达到4.27e-3。此时对于训练集的准确率达到了99.22%，相对来说，应该算是比较好的结果。</p>
<p>对于训练集，在经过约30000个batch以后，准确率基本维持在98%以上，在到达80000个batch以后，一直稳定在99%以上。也就是说对于当前这个数据集来说，模型继续学习下去得到的收益并不大。可以通过引入新的数据集或者调节各个图像的对比度等等，增加样本多样性，以此增加模型精度。</p>
<p>对于测试集的准确率，最高达到了80%，而官方提供模型准确率是86%。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>cnn</tag>
        <tag>tensorflow</tag>
        <tag>cifar</tag>
      </tags>
  </entry>
  <entry>
    <title>Fashion-MNIST数据集</title>
    <url>/posts/7e7e4a71.html</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Fashion-MNIST是一个替代手写数字集的图像数据集，比手写数据集更加复杂。它是由Zalando旗下的研究部门提供。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul>
<li>60000张训练图像和标签数据</li>
<li>10000张测试图像和标签数据</li>
<li>10个类别</li>
<li>每张图片28x28分辨率</li>
<li>灰度图片</li>
</ul>
<p>类别如下：</p>
<table>
<thead>
<tr>
<th align="center">标注编号</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">T-shirt&#x2F;top</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">Trouser</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">Pullover</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Dress</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Coat</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">Sandal</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">Shirt</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">Sneaker</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">Bag</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">Ankle boot</td>
</tr>
</tbody></table>
<h3 id="获取数据集"><a href="#获取数据集" class="headerlink" title="获取数据集"></a>获取数据集</h3><p>通过mxnet.gluon的data包来下载这个数据集。第一次调用会从网上获取数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> data <span class="keyword">as</span> gdata</span><br><span class="line"></span><br><span class="line">mnist_train = gdata.vision.FashionMNIST(train=<span class="literal">True</span>)</span><br><span class="line">mnist_test = gdata.vision.FashionMNIST(train=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(mnist_train))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(mnist_test))</span><br><span class="line"></span><br><span class="line">feature, label = mnist_train[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(feature.shape, label.dtype)</span><br></pre></td></tr></table></figure>

<p>mxnet默认是从国外下载数据集，所以速度特别慢，可以在启动notebook时指定nexnet的国内镜像。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MXNET_GLUON_REPO=https://apache-mxnet.s3.cn-north-1.amazonaws.com.cn/ jupyter notebook</span><br></pre></td></tr></table></figure>

<p>该数据集会下载到.mxnet&#x2F;datasets&#x2F;fashion-mnist&#x2F;目录下，一共四个文件，分别是训练图片、标签和测试图片、标签。</p>
<p>官方数据集的github地址为：<a href="https://github.com/zalandoresearch/fashion-mnist">https://github.com/zalandoresearch/fashion-mnist</a></p>
<h3 id="读取小批量数据"><a href="#读取小批量数据" class="headerlink" title="读取小批量数据"></a>读取小批量数据</h3><p>Gluon的DataLoader中一个很方便的功能是允许使用多进程来加速数据读取（暂时不支持windows系统）</p>
<p>此外，通过ToTensor类将图像数据从uint8格式转换为32位浮点格式，并除以255使得所有像素点的数值均在0到1之间。ToTensor类还将图像通道从最后一维移到最前一维。通过数据集的transform_firt函数，可以将ToTensor变得变换应用到每个数据样本（图像和标签）的第一个元素，即图像之上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> data <span class="keyword">as</span> gdata</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mnist_train = gdata.vision.FashionMNIST(train=<span class="literal">True</span>)</span><br><span class="line">mnist_test = gdata.vision.FashionMNIST(train=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(mnist_train))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(mnist_test))</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line"></span><br><span class="line">transformer = gdata.vision.transforms.ToTensor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.platform.startswith(<span class="string">&quot;win&quot;</span>):</span><br><span class="line">    <span class="comment"># 0表示不需要额外的进程加速数据读取</span></span><br><span class="line">    num_workers = <span class="number">0</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    num_workers = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">train_iter = gdata.DataLoader(mnist_train.transform_first(transformer), batch_size, shuffle=<span class="literal">True</span>, num_workers=num_workers)</span><br><span class="line">test_iter = gdata.DataLoader(mnist_test.transform_first(transformer), batch_size, shuffle=<span class="literal">True</span>, num_workers=num_workers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看读取一遍训练数据需要的时间</span></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%.2f s&quot;</span>, time.time()-start)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>mxnet</tag>
        <tag>fashion-mnist</tag>
      </tags>
  </entry>
  <entry>
    <title>softmax回归的Gluon实现</title>
    <url>/posts/c643d6ee.html</url>
    <content><![CDATA[<p>使用MXNet提供的Gluon接口可以更加方便地实现Softmax回归</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gluonbook <span class="keyword">as</span> gb</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> gluon, init, autograd</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> loss <span class="keyword">as</span> gloss, nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = gb.load_data_fashion_mnist(batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义和初始化模型</span></span><br><span class="line">net = nn.Sequential()</span><br><span class="line">net.add(nn.Dense(<span class="number">10</span>))</span><br><span class="line"><span class="comment"># 使用N(0,1)初始化模型权重参数</span></span><br><span class="line">net.initialize(init.Normal(sigma=<span class="number">0.01</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># softmax和交叉熵损失函数</span></span><br><span class="line">loss = gloss.SoftmaxCrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义优化算法</span></span><br><span class="line">trainer = gluon.Trainer(net.collect_params(), <span class="string">&#x27;sgd&#x27;</span>, &#123;<span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.1</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算分类准确率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_hat, y</span>):</span><br><span class="line">    <span class="comment"># y_hat.argmax(axis=1) 返回每行中最大元素的索引</span></span><br><span class="line">    <span class="comment"># y中对应的即是分类的索引值</span></span><br><span class="line">    <span class="comment"># == 获得非0即1的数</span></span><br><span class="line">    <span class="comment"># 求平均值 得到准确率</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat.argmax(axis=<span class="number">1</span>) == y.astype(<span class="string">&#x27;float32&#x27;</span>)).mean().asscalar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line"><span class="comment"># 对每个数据块准确率求和 算平均值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_accuracy</span>(<span class="params">data_iter, net</span>):</span><br><span class="line">    acc = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        acc += accuracy(net(X), y)</span><br><span class="line">    <span class="keyword">return</span> acc / <span class="built_in">len</span>(data_iter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">net, train_iter, test_iter, loss, num_epochs, batch_size, params=<span class="literal">None</span>, lr=<span class="literal">None</span>, trainer=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        train_l_sum = <span class="number">0</span></span><br><span class="line">        train_acc_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            <span class="keyword">with</span> autograd.record():</span><br><span class="line">                y_hat = net(X)</span><br><span class="line">                l = loss(y_hat, y)</span><br><span class="line"></span><br><span class="line">            l.backward()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> trainer <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                gb.sgd(params, lr, batch_size)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                trainer.step(batch_size)</span><br><span class="line"></span><br><span class="line">            train_l_sum += l.mean().asscalar()</span><br><span class="line">            train_acc_sum += accuracy(y_hat, y)</span><br><span class="line"></span><br><span class="line">        test_acc = evaluate_accuracy(test_iter, net)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;epoch %d, loss %.4f, train_acc %.3f, test_acc %.3f&quot;</span> % (epoch + <span class="number">1</span>, train_l_sum / <span class="built_in">len</span>(train_iter), train_acc_sum / <span class="built_in">len</span>(train_iter), test_acc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num_epochs = <span class="number">5</span></span><br><span class="line">lr = <span class="number">0.1</span></span><br><span class="line">train(net, train_iter, test_iter, loss, num_epochs, batch_size, <span class="literal">None</span>, <span class="literal">None</span>, trainer)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>mxnet</tag>
        <tag>softmax</tag>
      </tags>
  </entry>
  <entry>
    <title>Softmax回归</title>
    <url>/posts/9558f536.html</url>
    <content><![CDATA[<p>和线性回归不同，Softmax回归的输出单元从一个变成了多个，且引入了softmax运算使得输出更适合离散值的预测和训练。</p>
<h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><p>假设一个简单的图像分类问题，输入的图像为灰度、高和宽分别问两个像素。这样每个像素都可以用一个标量来表示。将图像的四个像素分别记为$x_1,x_2,x_3,x_4$，假设这些训练集中图像的真实标签为狗、猫和猪（假设四个像素可以表示出这三种动物），这些标签分别对应离散值$y_1,y_2,y_3$。</p>
<p>通常用离散的数值来表示类别，例如$y_1&#x3D;1,y_2&#x3D;2,y_3&#x3D;3$。这样，一张图像的标签就为1,2和3这三个数值中的一个，虽然可以使回归模型来建模，并叫预测值就近定点化到1,2和3这三个数值中，但是这种连续值到离散值的转化会影响到分类的质量。因此，一般使用更加适合的离散值输出的模型来解决分类问题。</p>
<h3 id="Softmax回归模型"><a href="#Softmax回归模型" class="headerlink" title="Softmax回归模型"></a>Softmax回归模型</h3><p>softmax回归跟线性回归一样将输入特征与权重做线性叠加。与回归模型的一个主要区别是，softmax回归的输出值个数等于标签里的类别数。因为一共有4个特征和3种输出动物类别，所以权重包含12个标量（带下标的$w$）、偏置包含三个标量（带下标的$b$），且对每一个输入计算$o_1,o_2,o_3$这三个输出：</p>
<p>$$o_1 &#x3D; x_1w_{11}+x_2w_{21}+x_3w_{31}+x_4w_{41}+b_1$$</p>
<p>$$o_2 &#x3D; x_1w_{12}+x_2w_{22}+x_3w_{32}+x_4w_{42}+b_2$$</p>
<p>$$o_3 &#x3D; x_1w_{13}+x_2w_{23}+x_3w_{33}+x_4w_{43}+b_3$$</p>
<p>与线性回归一样，softmax回归也是一个单层网络。每个输出都依赖于所有的输入，softmax回归的输出层也是一个全连接层。</p>
<h3 id="softmax运算"><a href="#softmax运算" class="headerlink" title="softmax运算"></a>softmax运算</h3><p>既然分类问题需要得到离散的预测输出，一个简单的办法是将输出值$o_i$当做预测类别$i$的置信度，并将值最大的输出作为对应的类别预测输出，即输出$argmax_io_i$。</p>
<p>然而，直接使用输出层的输出有两点问题。一方面，由于输出层的输出值的范围不确定，难以直观上判断这些值的意义。另一方面，由于真是标签是离散值，这些离散值与不确定范围的输出值之间的误差难以衡量。</p>
<p>softmax运算符（softmax operator）解决了这两个问题。它通过一下方式将输出值变成值为正且和为1的概率分布：</p>
<p>$$\hat{y1},\hat{y2},\hat{y2} &#x3D; softmax(o_1,o_2,o_3)$$</p>
<p>其中：</p>
<p>$$\hat{y1} &#x3D; \frac{\exp(o_1)}{\sum_{i&#x3D;1}^3\exp(o_i)}$$</p>
<p>$$\hat{y2} &#x3D; \frac{\exp(o_2)}{\sum_{i&#x3D;1}^3\exp(o_i)}$$</p>
<p>$$\hat{y3} &#x3D; \frac{\exp(o_3)}{\sum_{i&#x3D;1}^3\exp(o_i)}$$</p>
<p>容易看出$\hat{y_1}+\hat{y_2}+\hat{y_3}&#x3D;1$且$0&lt;&#x3D;\hat{y_1},\hat{y_2},\hat{y_3}&lt;&#x3D;1$，因此$\hat{y_1},\hat{y_2},\hat{y_3}$是一个合法的概率分布。此外</p>
<p>$$argmax_io_i&#x3D;argmax_i\hat{y}_i$$</p>
<p>因此softmax运算不改变预测类别输出。</p>
<h3 id="单样本分类的矢量计算表达式"><a href="#单样本分类的矢量计算表达式" class="headerlink" title="单样本分类的矢量计算表达式"></a>单样本分类的矢量计算表达式</h3><p>假设softmax回归的权重和偏置参数分别为</p>
<p>$$W &#x3D; \left[<br>\begin{matrix}<br>w_{11} &amp; w_{12} &amp; w_{13} \<br>w_{21} &amp; w_{22} &amp; w_{23} \<br>w_{31} &amp; w_{32} &amp; w_{33} \<br>w_{41} &amp; w_{42} &amp; w_{43}<br>\end{matrix}\right] $$</p>
<p>$$b &#x3D; \left[\begin{matrix} b_1 &amp; b_2 &amp; b_3 \end{matrix}\right]$$</p>
<p>设宽和高分别为2个像素的图像样本$i$的特征为</p>
<p>$$x^{(i)} &#x3D; \left[\begin{matrix} x_1^{(i)} &amp; x_2^{(i)} &amp; x_3^{(i)} &amp; x_4^{(i)} \end{matrix}\right]$$</p>
<p>输出层为</p>
<p>$$o^{(i)} &#x3D; \left[\begin{matrix} o_1^{(i)} &amp; o_2^{(i)} &amp; o_3^{(i)} \end{matrix}\right]$$</p>
<p>预测概率分布为</p>
<p>$$\hat{y}^{(i)} &#x3D; \left[\begin{matrix} \hat{y}_1^{(i)} &amp; \hat{y}_2^{(i)} &amp; \hat{y}_3^{(i)} \end{matrix}\right]$$</p>
<p>softmax对回归样本$i$分类的矢量计算表达式为</p>
<p>$$0^{(i)} &#x3D; x^{(i)}W + b$$</p>
<p>$$\hat{y}^{(i)} &#x3D; sfotmax(o^{(i)})$$</p>
<h3 id="小批量样本分类的矢量计算表达式"><a href="#小批量样本分类的矢量计算表达式" class="headerlink" title="小批量样本分类的矢量计算表达式"></a>小批量样本分类的矢量计算表达式</h3><p>给定一个小批量样本，其批量大小为$n$，输入个数（特征数）为$d$，输出个数（类别数）为$q$。设批量特征为$X \in R^{n<em>d}$。假设softmax回归的权重和偏置参数分别为$W \in R^{d</em>q}, b \in R^{1*q}$。softmax回归的矢量表达式为</p>
<p>$$O &#x3D; XW + b$$</p>
<p>$$\hat{Y} &#x3D; softmax(O)$$</p>
<p>其中加法运算使用了广播机制，$O,\hat{Y} \in R^{n*q}$且两个矩阵的第$i$行分别为样本$i$的输出$o^{i}$和概率分布$\hat{y}^{(i)}$</p>
<h3 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h3><p>“交叉熵”（cross-entropy），产生与信息论，简单来说，交叉熵是衡量两个概率分布p和q之间的相似性，其定义如下：</p>
<p>$$ H_{y’}(y) &#x3D; -\sum_i{y’_i\log y_i} $$</p>
<p>y是预测的概率分布，$y’$是实际的分布（one-hot）</p>
<p>或是</p>
<p>$$H(y^{(i)}, \hat{y}^{(i)}) &#x3D; -\sum_{j&#x3D;1}^q y_j^{(i)}\log \hat{y}_j^{(i)}$$</p>
<p>其中带下标的$y_j^{(i)}$是向量$y^{(i)}$中非0即1的元素，需要将它与样本$i$类别的离散数值，即不带下标的$y^{(i)}$区分。向量$y^{(i)}$中只有第$y^{(i)}$个元素$y^{(i)}_{y^{(i)}}$为1，其余全是0。也就是说，交叉熵只关心对正确类别的预测概率，因为只要其值足够大，就可以确保分类结果正确。当然，如果一个样本有多个标签时，就不能做这一步简化了。但即便对这种情况，交叉熵同样只关心对图像中出现的物体类别的预测。</p>
<p>交叉熵适合衡量两个概率分布的差异。</p>
<h3 id="模型预测及评价"><a href="#模型预测及评价" class="headerlink" title="模型预测及评价"></a>模型预测及评价</h3><p>在训练好softmax回归模型后，给定任意一组样本特征，可以预测出每个输出类别的概率。通常，把预测概率最大的类别作为输出类别。如果它与真实的类别一致，说明这次预测是正确的。可以使用准确率（accuracy）来评价模型的表现。它等于正确预测数量与总预测数量之比。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>mxnet</tag>
        <tag>softmax</tag>
      </tags>
  </entry>
  <entry>
    <title>softmax回归的实现</title>
    <url>/posts/532472fc.html</url>
    <content><![CDATA[<p>softmax回归的实现与线性回归的实现非常相似。同样使用小批量随机梯度下降来优化模型的损失函数。在训练模型是，迭代周期num_epochs和学习率lr都是可以调节的参数。</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gluonbook <span class="keyword">as</span> gb</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, nd</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = gb.load_data_fashion_mnist(batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入向量28x28x1 (宽28 高28 灰度)</span></span><br><span class="line">num_input = <span class="number">784</span></span><br><span class="line"><span class="comment"># 输出向量 10个分类</span></span><br><span class="line">num_output = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重初始化</span></span><br><span class="line">weight = nd.random.normal(scale=<span class="number">0.01</span>, shape=(num_input, num_output))</span><br><span class="line"><span class="comment"># 偏置初始化</span></span><br><span class="line">bias = nd.zeros(num_output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对模型参数附上梯度</span></span><br><span class="line">weight.attach_grad()</span><br><span class="line">bias.attach_grad()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义softmax运算</span></span><br><span class="line"><span class="comment"># 1.对每个元素进行指数运算</span></span><br><span class="line"><span class="comment"># 2.对exp矩阵同行元素求和</span></span><br><span class="line"><span class="comment"># 3.令矩阵各元素与该行元素之和相除</span></span><br><span class="line"><span class="comment"># 最终得到每行元素和为1，且非负</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">X</span>):</span><br><span class="line">    X_exp = X.exp()</span><br><span class="line">    partition = X_exp.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 运用广播机制</span></span><br><span class="line">    <span class="keyword">return</span> X_exp / partition</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">net</span>(<span class="params">X</span>):</span><br><span class="line">    <span class="keyword">return</span> softmax(nd.dot(X.reshape((-<span class="number">1</span>, num_input)), weight) + bias)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line"><span class="comment"># 交叉熵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy</span>(<span class="params">y_hat, y</span>):</span><br><span class="line">    <span class="keyword">return</span> - nd.pick(y_hat, y).log()</span><br><span class="line"></span><br><span class="line"><span class="comment"># nd.pick说明</span></span><br><span class="line"><span class="comment"># y_hat是对两个样本的预测的三个概率值</span></span><br><span class="line"><span class="comment"># y是真实类别 可用pick函数，这直接的到这两个标签的预测概率</span></span><br><span class="line"><span class="comment"># y_hat = nd.array([[0.1,0.2,0.7], [0.3,0.2,0.5]])</span></span><br><span class="line"><span class="comment"># y = nd.array([0,2])</span></span><br><span class="line"><span class="comment"># print(nd.pick(y_hat, y))</span></span><br><span class="line"><span class="comment"># y = nd.array([0,0])</span></span><br><span class="line"><span class="comment"># print(nd.pick(y_hat, y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算分类准确率</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_hat, y</span>):</span><br><span class="line">    <span class="comment"># y_hat.argmax(axis=1) 返回每行中最大元素的索引</span></span><br><span class="line">    <span class="comment"># y中对应的即是分类的索引值</span></span><br><span class="line">    <span class="comment"># == 获得非0即1的数</span></span><br><span class="line">    <span class="comment"># 求平均值 得到准确率</span></span><br><span class="line">    <span class="keyword">return</span> (y_hat.argmax(axis=<span class="number">1</span>) == y.astype(<span class="string">&#x27;float32&#x27;</span>)).mean().asscalar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line"><span class="comment"># 对每个数据块准确率求和 算平均值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_accuracy</span>(<span class="params">data_iter, net</span>):</span><br><span class="line">    acc = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> X, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        acc += accuracy(net(X), y)</span><br><span class="line">    <span class="keyword">return</span> acc / <span class="built_in">len</span>(data_iter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">num_epochs = <span class="number">5</span></span><br><span class="line">lr = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">net, train_iter, test_iter, loss, num_epochs, batch_size, params=<span class="literal">None</span>, lr=<span class="literal">None</span>, trainer=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        train_l_sum = <span class="number">0</span></span><br><span class="line">        train_acc_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            <span class="keyword">with</span> autograd.record():</span><br><span class="line">                y_hat = net(X)</span><br><span class="line">                l = loss(y_hat, y)</span><br><span class="line"></span><br><span class="line">            l.backward()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> trainer <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                gb.sgd(params, lr, batch_size)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                trainer.step(batch_size)</span><br><span class="line"></span><br><span class="line">            train_l_sum += l.mean().asscalar()</span><br><span class="line">            train_acc_sum += accuracy(y_hat, y)</span><br><span class="line"></span><br><span class="line">        test_acc = evaluate_accuracy(test_iter, net)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;epoch %d, loss %.4f, train_acc %.3f, test_acc %.3f&quot;</span> % (epoch + <span class="number">1</span>, train_l_sum / <span class="built_in">len</span>(train_iter), train_acc_sum / <span class="built_in">len</span>(train_iter), test_acc))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train(net, train_iter, test_iter, cross_entropy, num_epochs, batch_size, [weight, bias], lr, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>mxnet</tag>
        <tag>softmax</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树算法</title>
    <url>/posts/ef296a07.html</url>
    <content><![CDATA[<h3 id="机器学习中的分类和预测算法的评估"><a href="#机器学习中的分类和预测算法的评估" class="headerlink" title="机器学习中的分类和预测算法的评估"></a>机器学习中的分类和预测算法的评估</h3><ul>
<li>准确率</li>
<li>速度</li>
<li>健壮性</li>
<li>可规模行</li>
<li>可解释性</li>
</ul>
<h3 id="什么是决策树-x2F-判定数（decision-tree）"><a href="#什么是决策树-x2F-判定数（decision-tree）" class="headerlink" title="什么是决策树&#x2F;判定数（decision tree）"></a>什么是决策树&#x2F;判定数（decision tree）</h3><p>决策时是一个类似流程图的树结构，其中，每个内部节点表示一个属性上的测试，每个分支代表一个属性的输出，而每个树叶节点代表类或类分布。输的最顶层是根节点。</p>
<h3 id="熵（entropy）概念"><a href="#熵（entropy）概念" class="headerlink" title="熵（entropy）概念"></a>熵（entropy）概念</h3><p>1948年，香农提出了“信息熵（entropy）”的概念</p>
<p>一条信息的信息量大小和它的不确定行是有直接的关系，要搞清楚一件非常不确定的事情，或者使我们一无所知的事情，需要大量的信息，信息的度量就等于不确定性的多少。</p>
<p>$${ H(X) &#x3D; -\sum P(x)\log }$$</p>
<p>变量的不确定性越大，熵也就越大。</p>
<h3 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h3><h4 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h4><p>1970-1980, J.Ross. Quinlan  ID3算法</p>
<blockquote>
<p>未完待续</p>
</blockquote>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>图片与TFRecord的相互转化</title>
    <url>/posts/7931261f.html</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>TFRecord是一种二进制格式文件，理论上可以保存任何格式的信息，可以将任何类型数据转化为Tensorflow所支持的格式，这种方法可以让数据集和网络架构更容易相互匹配。TFRecord文件包含了tf.train.Example协议内存块（protocol buffer）。可以将数据填入Example协议内存块（protocol buffer），将协议内存块序列化为一个字符串，并且通过tf.python_io.TFRecordWriter写入到TFRecord文件。</p>
<p>Protocol Buffer（protobuf）是Google公司出口的一种独立于开发语言，独立于平台的可扩展结构化徐磊机制。与xml、json类似。是一种数据交互格式协议。</p>
<p>Example消息体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message Example &#123;</span><br><span class="line">  Features features = 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">message Features &#123;</span><br><span class="line">  // Map from feature name to feature.</span><br><span class="line">  map&lt;string, Feature&gt; feature = 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">message Feature &#123;</span><br><span class="line">  // Each feature can be exactly one kind.</span><br><span class="line">  oneof kind &#123;</span><br><span class="line">    BytesList bytes_list = 1;</span><br><span class="line">    FloatList float_list = 2;</span><br><span class="line">    Int64List int64_list = 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">message BytesList &#123;</span><br><span class="line">  repeated bytes value = 1;</span><br><span class="line">&#125;</span><br><span class="line">message FloatList &#123;</span><br><span class="line">  repeated float value = 1 [packed = true];</span><br><span class="line">&#125;</span><br><span class="line">message Int64List &#123;</span><br><span class="line">  repeated int64 value = 1 [packed = true];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个包含一系列的feature属性。灭一个feature是一个map，也就是key-value键值对的形式，key取值是String类型，而value是feature类型的消息体，他的类型有三种：</p>
<ul>
<li>BytesList</li>
<li>FloatList</li>
<li>Int64List</li>
</ul>
<p>它们都是列表形式。</p>
<h3 id="图片转TfRecord格式"><a href="#图片转TfRecord格式" class="headerlink" title="图片转TfRecord格式"></a>图片转TfRecord格式</h3><p>python代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包图片文件 to tfrecord</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 图片路径，两组标签都在该目录下</span></span><br><span class="line">filename = <span class="string">&quot;./images/train.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tfrecord文件保存路径</span></span><br><span class="line">file_path = <span class="string">r&quot;/image/tfrecord/train/&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个tfrecord存放图片个数</span></span><br><span class="line">bestnum = <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第几个图片</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第几个TFRecord文件</span></span><br><span class="line">recordfilenum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件格式：图片路径 标签</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_images_labels</span>(<span class="params">filename = filename</span>):</span><br><span class="line">    images_list = []</span><br><span class="line">    labels_list = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="comment"># rstrip：用来去除结尾字符、空白符(包括\n、\r、\t、&#x27; &#x27;，即：换行、回车、制表符、空格)</span></span><br><span class="line">            content = line.rstrip().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            name = content[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># labels = []</span></span><br><span class="line">            <span class="keyword">for</span> value <span class="keyword">in</span> content[<span class="number">1</span>:]:</span><br><span class="line">                labels_list.append(<span class="built_in">int</span>(value))</span><br><span class="line">            images_list.append(name)</span><br><span class="line">    <span class="comment"># 将训练数据随机打乱以获得更好的训练效果。</span></span><br><span class="line">    state = np.random.get_state()</span><br><span class="line">    np.random.shuffle(images_list)</span><br><span class="line">    np.random.set_state(state)</span><br><span class="line">    np.random.shuffle(labels_list)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> images_list, labels_list</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tfrecords格式文件名</span></span><br><span class="line">    ftrecordfilename = (<span class="string">&quot;train-%d.tfrecords&quot;</span> % recordfilenum)</span><br><span class="line">    writer = tf.python_io.TFRecordWriter(os.path.join(file_path, ftrecordfilename))</span><br><span class="line"></span><br><span class="line">    images_list, labels_list = load_images_labels()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, image_path <span class="keyword">in</span> <span class="built_in">enumerate</span>(images_list):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 超过2000，写入下一个tfrecord</span></span><br><span class="line">        <span class="keyword">if</span> i !=<span class="number">0</span> <span class="keyword">and</span> i % bestnum == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;(%d/%d) 已完成&quot;</span> % (i, <span class="built_in">len</span>(images_list)))</span><br><span class="line">            recordfilenum += <span class="number">1</span></span><br><span class="line">            ftrecordfilename = (<span class="string">&quot;train-%d.tfrecords&quot;</span> % recordfilenum)</span><br><span class="line">            writer = tf.python_io.TFRecordWriter(os.path.join(file_path, ftrecordfilename))</span><br><span class="line"></span><br><span class="line">        img = Image.<span class="built_in">open</span>(image_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        <span class="comment"># 将图片转化为二进制格式</span></span><br><span class="line">        img_raw = img.tobytes()</span><br><span class="line">        example = tf.train.Example(</span><br><span class="line">            features=tf.train.Features(feature=&#123;</span><br><span class="line">                <span class="string">&#x27;label&#x27;</span>: tf.train.Feature(int64_list=tf.train.Int64List(value=[labels_list[i]])),</span><br><span class="line">                <span class="string">&#x27;image_raw&#x27;</span>: tf.train.Feature(bytes_list=tf.train.BytesList(value=[img_raw])),</span><br><span class="line">            &#125;))</span><br><span class="line">        <span class="comment"># 序列化为字符串</span></span><br><span class="line">        writer.write(example.SerializeToString())</span><br><span class="line">    writer.close()</span><br></pre></td></tr></table></figure>

<h3 id="读取TFRecord格式文件"><a href="#读取TFRecord格式文件" class="headerlink" title="读取TFRecord格式文件"></a>读取TFRecord格式文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">img_size = <span class="number">224</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_and_decode_tfrecord</span>(<span class="params">filename</span>):</span><br><span class="line">    filename_deque = tf.train.string_input_producer(filename)</span><br><span class="line">    reader = tf.TFRecordReader()</span><br><span class="line">    _, serialized_example = reader.read(filename_deque)</span><br><span class="line">    features = tf.parse_single_example(serialized_example, features=&#123;</span><br><span class="line">        <span class="string">&#x27;label&#x27;</span>: tf.FixedLenFeature([], tf.int64),</span><br><span class="line">        <span class="string">&#x27;image_raw&#x27;</span>: tf.FixedLenFeature([], tf.string)&#125;)</span><br><span class="line">    label = tf.cast(features[<span class="string">&#x27;label&#x27;</span>], tf.int32)</span><br><span class="line">    img = tf.decode_raw(features[<span class="string">&#x27;image_raw&#x27;</span>], tf.uint8)</span><br><span class="line">    img = tf.reshape(img, [img_size, img_size, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 归一化处理</span></span><br><span class="line">    img = tf.image.convert_image_dtype(img, dtype=tf.float32)</span><br><span class="line">    <span class="comment"># 归一化处理 两种方式效果相同</span></span><br><span class="line">    <span class="comment"># img = tf.cast(img, tf.float32) / 255.0</span></span><br><span class="line">    <span class="comment"># One-hot处理</span></span><br><span class="line">    label = tf.one_hot(label, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line"><span class="comment"># TFrecord文件路径</span></span><br><span class="line">train_list = [<span class="string">&#x27;./images/test/train-0.tfrecords&#x27;</span>, <span class="string">&#x27;./images/test/train-1.tfrecords&#x27;</span>]</span><br><span class="line"></span><br><span class="line">img, label = read_and_decode_tfrecord(train_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小批量读取</span></span><br><span class="line">img_batch, label_batch = tf.train.batch([img, label], num_threads=<span class="number">1</span>, batch_size=<span class="number">10</span>, capacity=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(img_batch.shape)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    <span class="comment"># 创建一个协调器，管理线程</span></span><br><span class="line">    coord = tf.train.Coordinator()</span><br><span class="line">    <span class="comment"># 启动QueueRunner,此时文件名队列已经进队</span></span><br><span class="line">    threads = tf.train.start_queue_runners(sess=sess, coord=coord)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        b_image, b_label = sess.run([img_batch, label_batch])</span><br><span class="line">        <span class="comment"># b_image = Image.fromarray(b_image[0])</span></span><br><span class="line">        <span class="comment"># plt.imshow(b_image)</span></span><br><span class="line">        <span class="comment"># plt.axis(&#x27;off&#x27;)</span></span><br><span class="line">        <span class="comment"># plt.show()</span></span><br><span class="line">        <span class="comment"># print(b_image)</span></span><br><span class="line">        <span class="built_in">print</span>(b_label)</span><br><span class="line">    coord.request_stop()</span><br><span class="line">    <span class="comment"># 其他所有线程关闭之后，这一函数才能返回</span></span><br><span class="line">    coord.join(threads)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
        <tag>tfrecord</tag>
      </tags>
  </entry>
  <entry>
    <title>多层感知机</title>
    <url>/posts/c3f7cdb7.html</url>
    <content><![CDATA[<p>多层感知机（multilayer perceptron，简称 MLP），多层神经网络模型。</p>
<h3 id="隐藏层"><a href="#隐藏层" class="headerlink" title="隐藏层"></a>隐藏层</h3><p>多层感知机在单层神经网络的基础上引入了一到多个隐藏层（hidden layer）。隐藏层介于输入层和输出层之间。</p>
<p>包含单个隐藏层的多层感知机设计：</p>
<p>$$H &#x3D; XW_h + b_h$$</p>
<p>$$O &#x3D; HW_o + b_o$$</p>
<p>将隐藏层的输出直接作为输入层的输入。两个式子联立起来，得到：</p>
<p>$$O &#x3D; (XW_h + b_h)W_o + b_o &#x3D; XW_hW_0 + b_hW_o + b_o$$</p>
<p>可以看出，虽然引入了隐藏层，却依然等价与一个单层神经网络：其中输出层权重参数为$W_hW_o$，偏置参数为$b_hW_o + b_o$。即便添加再多的隐藏层，以上设计依然等价与一个单层神经网络。</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>上述问题的根源在于全连接层只是对数据做仿射变换（affine transformation），而多个仿射变换的叠加依然是一个仿射变换。解决问题的一个方法是引入一个非线性变换，例如对隐藏层变量使用按元素操作的非线性函数进行变换，然后作为下一个全连接层的输入。这个非线性函数被称为激活函数（activation function）。</p>
<h4 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h4><p>ReLU（rectified linear unit）函数提供了一个很简单的非线性变换。给定元素$x$，该函数定义为：</p>
<p>$$ReLU(x) &#x3D; max(x, 0)$$</p>
<p>ReLU函数只保留正数元素，并将负数元素清零。</p>
<p>当输入为负数时，ReLU函数的导数为0，输入为正时，ReLU的导数为1</p>
<p>绘制函数图像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, nd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xyplot</span>(<span class="params">x_vals, y_vals, name</span>):</span><br><span class="line"></span><br><span class="line">    plt.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = (<span class="number">5</span>, <span class="number">2.5</span>)</span><br><span class="line">    plt.plot(x_vals.asnumpy(), y_vals.asnumpy())</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    plt.ylabel(name + <span class="string">&#x27;(x)&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">x = nd.arange(-<span class="number">8.0</span>, <span class="number">8.0</span>, <span class="number">0.1</span>)</span><br><span class="line"><span class="comment"># print(x)</span></span><br><span class="line"></span><br><span class="line">x.attach_grad()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> autograd.record():</span><br><span class="line">    y = x.relu()</span><br><span class="line"><span class="comment"># print(y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制函数图像</span></span><br><span class="line">xyplot(x, y, <span class="string">&quot;relu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制导数</span></span><br><span class="line">y.backward()</span><br><span class="line"></span><br><span class="line">xyplot(x, x.grad, <span class="string">&quot;grad of relu&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>结果如图所示：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e28edeb57c.png" alt="relu"></p>
<p>ReLU函数的导数：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e28b306742.png" alt="grad_of_relu"></p>
<h4 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h4><p>Sigmoid函数可以将元素的值变换到0和1之间：</p>
<p>$$sigmoid(x) &#x3D; \frac{1}{1+\exp(-x)}$$</p>
<p>Sigmoid函数在早期神经网络中较为普遍，但是目前更多被简单的ReLU函数所替代。当输入接近0时，sigmoid函数接近线性变换。</p>
<p>绘制函数图像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, nd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xyplot</span>(<span class="params">x_vals, y_vals, name</span>):</span><br><span class="line"></span><br><span class="line">    plt.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = (<span class="number">5</span>, <span class="number">2.5</span>)</span><br><span class="line">    plt.plot(x_vals.asnumpy(), y_vals.asnumpy())</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    plt.ylabel(name + <span class="string">&#x27;(x)&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">x = nd.arange(-<span class="number">8.0</span>, <span class="number">8.0</span>, <span class="number">0.1</span>)</span><br><span class="line"><span class="comment"># print(x)</span></span><br><span class="line"></span><br><span class="line">x.attach_grad()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> autograd.record():</span><br><span class="line">    y = x.sigmoid()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制函数图像</span></span><br><span class="line">xyplot(x, y, <span class="string">&#x27;sigmoid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制导数图像</span></span><br><span class="line">y.backward()</span><br><span class="line">xyplot(x, x.grad, <span class="string">&#x27;grad of sigmoid&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>sigmoid函数图像：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e2906c7bca.png" alt="sigmoid"></p>
<p>sigmoid的导数：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e2911d3137.png" alt="grad_of_sigmoid"></p>
<p>当输入为0时，sigmoid函数的导数达到最大值0.25；当输入越偏离0时，sigmoid函数的导数越接近0.</p>
<h4 id="Tanh函数"><a href="#Tanh函数" class="headerlink" title="Tanh函数"></a>Tanh函数</h4><p>Tanh（双曲正切）函数可以将元素的值变换到-1和1之间：<br>$$tanh(x) &#x3D; \frac{1-\exp(-2x)}{1+\exp(-2x)}$$</p>
<p>当输入接近0时，tanh函数接近线性变换。虽然函数的形状和sigmoid函数的形状很相似，但是tanh函数在坐标系的原点上对称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, nd</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xyplot</span>(<span class="params">x_vals, y_vals, name</span>):</span><br><span class="line"></span><br><span class="line">    plt.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = (<span class="number">5</span>, <span class="number">2.5</span>)</span><br><span class="line">    plt.plot(x_vals.asnumpy(), y_vals.asnumpy())</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    plt.ylabel(name + <span class="string">&#x27;(x)&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">x = nd.arange(-<span class="number">8.0</span>, <span class="number">8.0</span>, <span class="number">0.1</span>)</span><br><span class="line"><span class="comment"># print(x)</span></span><br><span class="line"></span><br><span class="line">x.attach_grad()</span><br><span class="line"><span class="keyword">with</span> autograd.record():</span><br><span class="line">    y = x.tanh()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制函数图像</span></span><br><span class="line">xyplot(x, y, <span class="string">&#x27;tanh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制导数图像</span></span><br><span class="line">y.backward()</span><br><span class="line">xyplot(x, x.grad, <span class="string">&#x27;grad of tanh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>tanh的函数图像：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e291bbc33c.png" alt="tanh"></p>
<p>tanh的导数：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e2924bbc54.png" alt="grad_of_tanh"></p>
<p>当输入为0时，tanh函数的导数达到最大值1；当输入偏离0时，tanh函数的导数越接近0.</p>
<h3 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h3><p>多层感知机就是至少含有一个隐藏层的由全连接层组成的神经网络，且每个隐藏层的输出通过激活函数变换。多层感知机的层数和各个隐藏层中隐藏单元个数都是超参数。由于引入了非线性因素，多层感知机的计算方式为：</p>
<p>$$H&#x3D;\phi(XW_h+b_h)$$</p>
<p>$$O &#x3D; HW_o +b_o$$</p>
<p>其中$\phi$表示激活函数。在分类问题中，可以对输出Ｏsoftmax运算，并使用softmax回归中的交叉熵损失函数。在回归问题中，将输出层个数设置为1，并将输出$O$直接提供给线性回归中使用的平方损失函数。</p>
<h3 id="多层感知机的实现"><a href="#多层感知机的实现" class="headerlink" title="多层感知机的实现"></a>多层感知机的实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gluonbook <span class="keyword">as</span> gb</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> loss <span class="keyword">as</span> gloss</span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = gb.load_data_fashion_mnist(batch_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型参数</span></span><br><span class="line"><span class="comment"># 28*28</span></span><br><span class="line"><span class="comment"># 输入，输出， 隐藏单元数</span></span><br><span class="line">num_inputs, num_outputs, num_hiddens = <span class="number">784</span>, <span class="number">10</span>, <span class="number">256</span></span><br><span class="line"></span><br><span class="line">W1 = nd.random.normal(scale=<span class="number">0.01</span>, shape=(num_inputs, num_hiddens))</span><br><span class="line">b1 = nd.zeros(shape=(num_hiddens))</span><br><span class="line"></span><br><span class="line">W2 = nd.random.normal(scale=<span class="number">0.01</span>, shape=(num_hiddens, num_outputs))</span><br><span class="line">b2 = nd.zeros(shape=(num_outputs))</span><br><span class="line"></span><br><span class="line">params = [W1, b1, W2, b2]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">    param.attach_grad()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义激活函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">relu</span>(<span class="params">X</span>):</span><br><span class="line">    <span class="keyword">return</span> nd.maximum(X, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">net</span>(<span class="params">X</span>):</span><br><span class="line">    X = X.reshape((-<span class="number">1</span>, num_inputs))</span><br><span class="line">    H = relu(nd.dot(X, W1) + b1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nd.dot(H, W2) + b2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line">loss = gloss.SoftmaxCrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">num_epochs, lr = <span class="number">5</span>, <span class="number">0.5</span></span><br><span class="line"><span class="comment"># softmax回归中实现</span></span><br><span class="line">gb.train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size, params, lr)</span><br></pre></td></tr></table></figure>

<h3 id="多层感知机的Gluon实现"><a href="#多层感知机的Gluon实现" class="headerlink" title="多层感知机的Gluon实现"></a>多层感知机的Gluon实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gluonbook <span class="keyword">as</span> gb</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> gluon, init</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> loss <span class="keyword">as</span> gloss, nn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">batch_size = <span class="number">256</span></span><br><span class="line">train_iter, test_iter = gb.load_data_fashion_mnist(batch_size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line">net = nn.Sequential()</span><br><span class="line">net.add(nn.Dense(<span class="number">256</span>, activation=<span class="string">&#x27;relu&#x27;</span>), nn.Dense(<span class="number">10</span>))</span><br><span class="line">net.initialize(init.Normal(sigma=<span class="number">0.01</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss = gloss.SoftmaxCrossEntropyLoss()</span><br><span class="line">trainer = gluon.Trainer(net.collect_params(), <span class="string">&#x27;sgd&#x27;</span>, &#123;<span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.5</span>&#125;)</span><br><span class="line"></span><br><span class="line">num_epochs = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">gb.train_ch3(net, train_iter, test_iter, loss, num_epochs, batch_size, <span class="literal">None</span>, <span class="literal">None</span>, trainer)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>mxnet</tag>
        <tag>多层感知机</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习-权重衰减</title>
    <url>/posts/470e020b.html</url>
    <content><![CDATA[<p>权重衰减（weight decay）是应对过拟合方法的常用方法。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>权重衰减等价于$L_2$范数正则化（regularization）。正则化是通过模型损失函数添加惩罚项来使得训练后的模型参数值较小，是应对过拟合的常用方法。</p>
<p>$L_2$范数正则化在模型原来的损失函数基础上添加$L_2$范数称惩罚项。从而得到训练所需最小的函数。$L_2$范数惩罚项是模型权重参数每个元素的平方和与一个正的常数的乘积。以线性回归为例：</p>
<p>$$l(w_1,w_2,b) &#x3D; \frac{1}{n}\sum_{i&#x3D;1}^{n} \frac{1}{2}(x_1^{(i)}+x_2^{(i)}+b-y^{(i)})^2$$</p>
<p>其中$w_1,w_2$为权重参数，$b$是偏置参数，样本$i$的输入为$x^{(i)}, x^{(i)}$，标签为$y^{(i)}$，样本数为$n$。将权重参数用向量$w&#x3D;[w_1,w_2]$表示，带$L_2$范数惩罚项的新函数为</p>
<p>$$l(w_1,w_2,b)+\frac{k}{2n}||w||^2$$</p>
<p>其中超参数$k&gt;0$。当权重参数均为0时，惩罚项最小。当$k$较大时，惩罚项在损失函数中的比重较大，这通常会使学到的权重参数的元素接近于0。当$k$设为0时，惩罚项完全不起作用。上述式子中$L_2$范数平法$||w||^2$展开后得到$w_1^2+w_2^2$。有了$L_2$范数的惩罚项后，在小批量的随机梯度下降中，权重$w_1,w_2$的迭代方式改为：</p>
<p>$$w_1 \leftarrow (1-\frac{n\lambda}{|\beta|})w_1-\frac{\eta}{|\beta|}\sum_{i\in\beta}x_1^{(i)}(x_1^{(i)}w_1+x_2^{(i)}w_2+b-y^{(i)}$$</p>
<p>$$w_2 \leftarrow (1-\frac{n\lambda}{|\beta|})w_2-\frac{\eta}{|\beta|}\sum_{i\in\beta}x_2^{(i)}(x_1^{(i)}w_1+x_2^{(i)}w_2+b-y^{(i)}$$</p>
<p>$L_2$范数正则化让权重$w_1$和$w_2$先自乘小于1的数，再减去惩罚项中的梯度。因此，$L_2$范数正则化又称权重衰减。权重衰减通过惩罚绝对值较大的模型参数为需要学习的模型增加了限制，这可能对过拟合有效。在实际中，有事也在惩罚项中添加偏差元素的平方和。</p>
<h3 id="高维线性回归"><a href="#高维线性回归" class="headerlink" title="高维线性回归"></a>高维线性回归</h3><p>使用下列函数生成样本标签：<br>$$y &#x3D; 0.05 + \sum_{i&#x3D;1}^p 0.01x_i+\varepsilon$$</p>
<p>其中噪音项$\varepsilon$服从N(0,1)，p为维度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gluonbook <span class="keyword">as</span> gb</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, gluon, init, nd</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> data <span class="keyword">as</span> gdata, loss <span class="keyword">as</span> gloss</span><br><span class="line"></span><br><span class="line">n_train, n_test, num_inputs = <span class="number">20</span>, <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">true_w, true_b = nd.ones((num_inputs, <span class="number">1</span>)) * <span class="number">0.01</span>, <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">features = nd.random.normal(shape=(n_train + n_test, num_inputs))</span><br><span class="line">labels = nd.dot(features, true_w) + true_b</span><br><span class="line">labels += nd.random.normal(scale=<span class="number">0.01</span>, shape=labels.shape)</span><br><span class="line">train_features, test_features = features[:n_train, :], features[n_train:, :]</span><br><span class="line">train_labels, test_labels = labels[:n_train], labels[n_train:]</span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gluonbook <span class="keyword">as</span> gb</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, gluon, init, nd</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> data <span class="keyword">as</span> gdata, loss <span class="keyword">as</span> gloss</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">n_train, n_test, num_inputs = <span class="number">20</span>, <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">true_w, true_b = nd.ones((num_inputs, <span class="number">1</span>)) * <span class="number">0.01</span>, <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">features = nd.random.normal(shape=(n_train + n_test, num_inputs))</span><br><span class="line">labels = nd.dot(features, true_w) + true_b</span><br><span class="line">labels += nd.random.normal(scale=<span class="number">0.01</span>, shape=labels.shape)</span><br><span class="line">train_features, test_features = features[:n_train, :], features[n_train:, :]</span><br><span class="line">train_labels, test_labels = labels[:n_train], labels[n_train:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_params</span>():</span><br><span class="line">    w = nd.random.normal(scale=<span class="number">1</span>, shape=(num_inputs, <span class="number">1</span>))</span><br><span class="line">    b = nd.zeros(shape=(<span class="number">1</span>,))</span><br><span class="line">    w.attach_grad()</span><br><span class="line">    b.attach_grad()</span><br><span class="line">    <span class="keyword">return</span> [w,b]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义L2范数惩罚项</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">l2_penalty</span>(<span class="params">w</span>):</span><br><span class="line">    <span class="keyword">return</span> (w**<span class="number">2</span>).<span class="built_in">sum</span>() / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义训练和测试</span></span><br><span class="line">batch_size, num_epochs, lr = <span class="number">1</span>, <span class="number">100</span>, <span class="number">0.003</span></span><br><span class="line"></span><br><span class="line">net, loss = gb.linreg, gb.squared_loss</span><br><span class="line"></span><br><span class="line">train_iter = gdata.DataLoader(gdata.ArrayDataset(train_features, train_labels), batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">semilogy</span>(<span class="params">x_vals, y_vals, x_label, y_label, x2_vals=<span class="literal">None</span>, y2_vals=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">             legend=<span class="literal">None</span>, figsize=(<span class="params"><span class="number">5.5</span>, <span class="number">2.5</span></span>)</span>):</span><br><span class="line"></span><br><span class="line">    plt.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = figsize</span><br><span class="line">    plt.xlabel(x_label)</span><br><span class="line">    plt.ylabel(y_label)</span><br><span class="line">    plt.semilogy(x_vals, y_vals)</span><br><span class="line">    <span class="keyword">if</span> x2_vals <span class="keyword">and</span> y2_vals:</span><br><span class="line">        plt.semilogy(x2_vals, y2_vals, linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        plt.legend(legend)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fit_and_plot</span>(<span class="params">lambd</span>):</span><br><span class="line">    w, b = init_params()</span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X, y <span class="keyword">in</span> train_iter:</span><br><span class="line">            <span class="keyword">with</span> autograd.record():</span><br><span class="line">                <span class="comment"># 添加L2范数惩罚项</span></span><br><span class="line">                l = loss(net(X, w, b), y) + lambd * l2_penalty(w)</span><br><span class="line">            l.backward()</span><br><span class="line">            gb.sgd([w,b], lr, batch_size)</span><br><span class="line">        train_ls.append(loss(net(train_features, w, b), train_labels).mean().asscalar())</span><br><span class="line">        test_ls.append(loss(net(test_features, w, b), test_labels).mean().asscalar())</span><br><span class="line"></span><br><span class="line">    semilogy(<span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>), train_ls, <span class="string">&#x27;epochs&#x27;</span>, <span class="string">&#x27;loss&#x27;</span>,</span><br><span class="line">                    <span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>), test_ls, [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;L2 norm of w:&#x27;</span>, w.norm().asscalar())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用权重衰减</span></span><br><span class="line">fit_and_plot(lambd=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 使用权重衰减</span></span><br><span class="line"><span class="comment"># fit_and_plot(lambd=3)</span></span><br></pre></td></tr></table></figure>

<p>当未使用权重衰减（lambd&#x3D;0）时，训练集上的误差远小于测试集</p>
<p><img src="https://img.ansore.de/2022/05/01/626e281e166bd.png" alt="no_weight_decay"></p>
<blockquote>
<p>L2 norm of w: 11.61194</p>
</blockquote>
<p>使用权重衰减（lambd&#x3D;3）时，训练误差虽然提高，但是测试集上的误差下降，过拟合得到一定程度上缓解，此时权重参数更接近0。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e282dd5df4.png" alt="weight_decay"></p>
<blockquote>
<p>L2 norm of w: 0.046675965</p>
</blockquote>
<h3 id="权重衰减的Gluon实现"><a href="#权重衰减的Gluon实现" class="headerlink" title="权重衰减的Gluon实现"></a>权重衰减的Gluon实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gluonbook <span class="keyword">as</span> gb</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, gluon, init, nd</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> data <span class="keyword">as</span> gdata, loss <span class="keyword">as</span> gloss, nn</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">n_train, n_test, num_inputs = <span class="number">20</span>, <span class="number">100</span>, <span class="number">200</span></span><br><span class="line">true_w, true_b = nd.ones((num_inputs, <span class="number">1</span>)) * <span class="number">0.01</span>, <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">features = nd.random.normal(shape=(n_train + n_test, num_inputs))</span><br><span class="line">labels = nd.dot(features, true_w) + true_b</span><br><span class="line">labels += nd.random.normal(scale=<span class="number">0.01</span>, shape=labels.shape)</span><br><span class="line">train_features, test_features = features[:n_train, :], features[n_train:, :]</span><br><span class="line">train_labels, test_labels = labels[:n_train], labels[n_train:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">semilogy</span>(<span class="params">x_vals, y_vals, x_label, y_label, x2_vals=<span class="literal">None</span>, y2_vals=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">             legend=<span class="literal">None</span>, figsize=(<span class="params"><span class="number">4.5</span>, <span class="number">2.5</span></span>)</span>):</span><br><span class="line"></span><br><span class="line">    plt.rcParams[<span class="string">&#x27;figure.figsize&#x27;</span>] = figsize</span><br><span class="line">    plt.xlabel(x_label)</span><br><span class="line">    plt.ylabel(y_label)</span><br><span class="line">    plt.semilogy(x_vals, y_vals)</span><br><span class="line">    <span class="keyword">if</span> x2_vals <span class="keyword">and</span> y2_vals:</span><br><span class="line">        plt.semilogy(x2_vals, y2_vals, linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        plt.legend(legend)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义训练和测试</span></span><br><span class="line">batch_size, num_epochs, lr = <span class="number">1</span>, <span class="number">100</span>, <span class="number">0.003</span></span><br><span class="line"></span><br><span class="line">net, loss = gb.linreg, gb.squared_loss</span><br><span class="line"></span><br><span class="line">train_iter = gdata.DataLoader(gdata.ArrayDataset(train_features, train_labels), batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fit_and_plot</span>(<span class="params">wd</span>):</span><br><span class="line">    net = nn.Sequential()</span><br><span class="line">    net.add(nn.Dense(<span class="number">1</span>))</span><br><span class="line">    net.initialize(init.Normal(sigma=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对权重衰减，权重名称一般是以weight结尾</span></span><br><span class="line">    train_w = gluon.Trainer(net.collect_params(<span class="string">&#x27;.*weight&#x27;</span>), <span class="string">&#x27;sgd&#x27;</span>, &#123;<span class="string">&#x27;learning_rate&#x27;</span>: lr, <span class="string">&#x27;wd&#x27;</span>: wd&#125;)</span><br><span class="line">    train_b = gluon.Trainer(net.collect_params(<span class="string">&#x27;.*bias&#x27;</span>), <span class="string">&#x27;sgd&#x27;</span>, &#123;<span class="string">&#x27;learning_rate&#x27;</span>: lr&#125;)</span><br><span class="line"></span><br><span class="line">    train_ls, test_ls = [], []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">        <span class="keyword">for</span> X,y <span class="keyword">in</span> train_iter:</span><br><span class="line">            <span class="keyword">with</span> autograd.record():</span><br><span class="line">                l = loss(net(X), y)</span><br><span class="line">            l.backward()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 对两个Trainer分别调用step函数，从而分别更新权重和偏置</span></span><br><span class="line">            train_b.step(batch_size)</span><br><span class="line">            train_w.step(batch_size)</span><br><span class="line"></span><br><span class="line">        train_ls.append(loss(net(train_features), train_labels).mean().asscalar())</span><br><span class="line">        test_ls.append(loss(net(test_features), test_labels).mean().asscalar())</span><br><span class="line"></span><br><span class="line">    semilogy(<span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>), train_ls, <span class="string">&#x27;epochs&#x27;</span>, <span class="string">&#x27;loss&#x27;</span>,</span><br><span class="line">             <span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>), test_ls, [<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;test&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;L2 norm of w:&#x27;</span>, net[<span class="number">0</span>].weight.data().norm().asscalar())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用权重衰减</span></span><br><span class="line">fit_and_plot(wd=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 使用权重衰减</span></span><br><span class="line"><span class="comment"># fit_and_plot(wd=3)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>mxnet</tag>
        <tag>softmax</tag>
      </tags>
  </entry>
  <entry>
    <title>用tf.data读取TFRecord</title>
    <url>/posts/9658a59d.html</url>
    <content><![CDATA[<p>tf.TFRecordReader()可能会弃用，官方推荐用tf.data读取TFRecord，用起来也相对方便。实现代码如下：</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img_size = <span class="number">224</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_exmp</span>(<span class="params">serial_exmp</span>):</span><br><span class="line">    features = tf.parse_single_example(serial_exmp, features=&#123;</span><br><span class="line">        <span class="string">&#x27;label&#x27;</span>: tf.FixedLenFeature([], tf.int64),</span><br><span class="line">        <span class="string">&#x27;image_raw&#x27;</span>: tf.FixedLenFeature([], tf.string)</span><br><span class="line">    &#125;)</span><br><span class="line">    label = tf.cast(features[<span class="string">&#x27;label&#x27;</span>], tf.int32)</span><br><span class="line">    img = tf.decode_raw(features[<span class="string">&#x27;image_raw&#x27;</span>], tf.uint8)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(img.shape)</span></span><br><span class="line">    img = tf.reshape(img, [<span class="number">224</span>, <span class="number">224</span>, <span class="number">3</span>])</span><br><span class="line">    <span class="comment"># 归一化处理</span></span><br><span class="line">    img = tf.image.convert_image_dtype(img, dtype=tf.uint8)</span><br><span class="line">    <span class="comment"># img = tf.cast(img, tf.float32) / 255.0</span></span><br><span class="line">    <span class="comment"># label = tf.one_hot(label, 8)</span></span><br><span class="line">    <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># TFrecord文件路径</span></span><br><span class="line">train_list = [<span class="string">&#x27;./images/test/train-0.tfrecords&#x27;</span>]</span><br><span class="line"></span><br><span class="line">train_set = tf.data.TFRecordDataset(train_list)</span><br><span class="line">train_set = train_set.<span class="built_in">map</span>(parse_exmp).repeat().batch(<span class="number">1</span>).shuffle(buffer_size=<span class="number">50</span>)</span><br><span class="line">train_iterator = train_set.make_one_shot_iterator()</span><br><span class="line">images_batch, labels_batch = train_iterator.get_next()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        images, labels = sess.run([images_batch, labels_batch])</span><br><span class="line">        b_image = Image.fromarray(images[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">print</span>(labels[<span class="number">0</span>])</span><br><span class="line">        plt.imshow(b_image)</span><br><span class="line">        <span class="comment"># plt.axis(&#x27;off&#x27;)</span></span><br><span class="line">        plt.show()</span><br><span class="line">        <span class="comment"># print(labels)</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
        <tag>tfrecord</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/posts/40997091.html</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在统计学中，线性回归（Linear regression）是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归，大于一个自变量情况的叫做多元回归。</p>
<p>在线性回归中，数据使用线性预测来建模，并且未知的模型参数也是通过数据来估计的。这些模型被叫做线性模型。</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>以预测房价为例，假设价格指取决于房屋的两个因素：面积（平方米）和房龄（年）。</p>
<p>设房屋的面积是$x_1$，房龄是$x_2$，出售价格是$y$，建立基于输入$x_1$和$x_2$来计算输出$y$的表达式，也就是模型（model）。线性回归假设输出与各输入之间是线性关系：</p>
<p>$$\hat{y}&#x3D;x_1w_1+x_2w_2+b$$</p>
<p>其实$w_1$，$w_2$是权重（weight），b是偏置（bias），均为标量。它们是线性回归模型的参数（parameter）。模型是输出$\hat{y}$是线性回归对真实价格$y$的预测或估计。通常允许有一定误差。</p>
<h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>然后需要通过数据来寻找特定的模型参数数值，使得模型在数据上的误差尽可能小。这个过程叫做模型训练（Model training）。</p>
<h3 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h3><p>通常收集一系列真实的数据，在这个数据上面寻找模型参数来最小化模型的预测价格与真实价格的误差。在机器学习中，该数据被称为训练数据集（training data set）或者训练集（training set），一栋房子的价格被称为一个样本（sample），其真实的价格叫做标签（label），用来预测标签的两个因素叫做特征（feature），特征用来表征样本的特点。</p>
<p>价格样本数为$n$，索引为$i$的样本特征为$\sideset{}{_1^{(i)}}x$，$\sideset{}{_2^{(i)}}x$，标签为$\hat{y}$。对索引为$i$的房屋，线性回归模型的预测表达式为</p>
<p>$$\hat{y}^{(i)}&#x3D;\sideset{}{_1^{(i)}}xw_1+\sideset{}{_2^{(i)}}xw_2+b$$</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>在模型训练中,我们需要衡量价格预测值与真实值之间的误差。通常我们会选取一个非负数作为误差,且数值越小表示误差越小。一个常用的选择是平方函数。它在评估索引为 i 的样本误差的表达式为</p>
<p>$$l^{(i)}(w_1,w_2,b)&#x3D;\frac{1}{2}(\hat{y}^{(i)}-y^{(i)})^2$$</p>
<p>其中常数 1&#x2F;2 使得对平方项求导后的常数系数为 1,这样在形式上稍微简单一些。显然,误差越小表示预测价格与真实价格越相近,且当二者相等时误差为 0。给定训练数据集,这个误差只与模型参数相关,因此我们将它记为以模型参数为参数的函数。机器学习里,我们将衡量误差的函数称为损失函数(loss function)。这里使用的平方误差函数也被称为平方损失(square loss)。通常,我们用训练数据集中所有样本误差的平均来衡量模型预测的质量,即</p>
<p>$$l(w_1,w_2,b)&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^nl^{(i)}(w_1,w_2,b)$$</p>
<p>$$&#x3D;\frac{1}{n}\sum_{i&#x3D;1}^n\frac{1}{2}(\sideset{}{_1^{(i)}}xw_1+\sideset{}{_2^{(i)}}xw_2+b-y^{(i)})^2$$</p>
<p>在模型训练中，我们希望找出一组模型参数，来使得训练样本平均损失最小：</p>
<p>$$w_1’,w_2’ ,b’ &#x3D; argmin_{w_1,w_2,b}l(w_1,w_2,b)​$$</p>
<h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h3><p>当模型和损失函数形式较为简单时,上面的误差最小化问题的解可以直接用公式表达出来。这类解叫做解析解(analytical solution)。本节使用的线性回归和平方误差刚好属于这个范畴。然而,大多数深度学习模型并没有解析解,只能通过优化算法有限次迭代模型参数来尽可能降低损失函<br>数的值。这类解叫做数值解(numerical solution)。<br>在求数值解的优化算法中,小批量随机梯度下降(mini-batch stochastic gradient descent)在深度学习中被广泛使用。它的算法很简单:我们先选取一组模型参数的初始值,例如随机选取;接下来对参数进行多次迭代,使得每次迭代都可能降低损失函数的值。在每次迭代中,我们先随机均匀采样一个由固定数目训练数据样本所组成的小批量(mini-batch)B;然后求小批量中数据样本的平均损失有关模型参数的导数(梯度);最后用此结果与预先设定的一个正数的乘积作为模型参数在本次迭代的减小量。</p>
<h3 id="模型预测"><a href="#模型预测" class="headerlink" title="模型预测"></a>模型预测</h3><p>模型训练完成以后，可以得到一个对最优解的近似。然后可以用模型来估算训练数据集以外的任意一栋房屋的房价。这里估算也叫模型预测、模型推断和模型测试。</p>
<p>我们应尽可能采用矢量计算，以提升计算效率。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython <span class="keyword">import</span> display</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd, autograd</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数据集 加入一个服从N(0,0.01)的噪点</span></span><br><span class="line">num_input = <span class="number">2</span></span><br><span class="line">num_example = <span class="number">1000</span></span><br><span class="line">true_w = [<span class="number">2</span>, -<span class="number">3.4</span>]</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line"></span><br><span class="line">features = nd.random.normal(scale=<span class="number">1</span>, shape=(num_example, num_input))</span><br><span class="line">labels = true_w[<span class="number">0</span>] * features[:, <span class="number">0</span>] + true_w[<span class="number">1</span>] * features[:, <span class="number">1</span>] + true_b</span><br><span class="line">labels += nd.random.normal(scale=<span class="number">0.01</span>, shape=labels.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line"><span class="comment"># def use_svg_display():</span></span><br><span class="line"><span class="comment">#     display.set_matplotlib_formats(&#x27;svg&#x27;)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def set_figsize(figsize=(3.5, 2.5)):</span></span><br><span class="line"><span class="comment">#     use_svg_display()</span></span><br><span class="line"><span class="comment">#     # 设置图的尺寸。</span></span><br><span class="line"><span class="comment">#     plt.rcParams[&#x27;figure.figsize&#x27;] = figsize</span></span><br><span class="line"><span class="comment"># set_figsize()</span></span><br><span class="line"><span class="comment"># plt.show(plt.scatter(features[:, 1].asnumpy(), labels.asnumpy(), 1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">data_iter</span>(<span class="params">batch_size, features, labels</span>):</span><br><span class="line">    num_example = <span class="built_in">len</span>(features)</span><br><span class="line">    indices = <span class="built_in">list</span>(<span class="built_in">range</span>(num_example))</span><br><span class="line">    <span class="comment"># 样本读取随机</span></span><br><span class="line">    random.shuffle(indices)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_example, batch_size):</span><br><span class="line">        j = nd.array(indices[i: <span class="built_in">min</span>(i + batch_size, num_example)])</span><br><span class="line">        <span class="comment"># 根据索引返回元素</span></span><br><span class="line">        <span class="keyword">yield</span> features.take(j), labels.take(j)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型参数</span></span><br><span class="line">w = nd.random.normal(scale=<span class="number">0.01</span>, shape=(num_input, <span class="number">1</span>))</span><br><span class="line">b = nd.zeros(shape=(<span class="number">1</span>,))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建它们的梯度</span></span><br><span class="line">w.attach_grad()</span><br><span class="line">b.attach_grad()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linreg</span>(<span class="params">x, w, b</span>):</span><br><span class="line">    <span class="keyword">return</span> nd.dot(x, w) + b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">squared_loss</span>(<span class="params">y_hat, y</span>):</span><br><span class="line">    <span class="keyword">return</span> (y_hat - y.reshape(y_hat.shape)) ** <span class="number">2</span> / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义优化算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sgd</span>(<span class="params">params, lr, batch_size</span>):</span><br><span class="line">    <span class="keyword">for</span> param <span class="keyword">in</span> params:</span><br><span class="line">        param[:] = param - lr * param.grad / batch_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">lr = <span class="number">0.03</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line">net = linreg</span><br><span class="line">loss = squared_loss</span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for x, y in data_iter(batch_size, features, labels):</span></span><br><span class="line"><span class="comment">#     print(x, y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#迭代周期 num_epochs</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(num_epochs):</span><br><span class="line">    <span class="comment"># 一个迭代周期</span></span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> data_iter(batch_size, features, labels):</span><br><span class="line">        <span class="keyword">with</span> autograd.record():</span><br><span class="line">            <span class="comment"># l为损失</span></span><br><span class="line">            l = loss(net(x, w, b), y)</span><br><span class="line">        <span class="comment"># 小批量的损失对模型参数求梯度</span></span><br><span class="line">        l.backward()</span><br><span class="line"></span><br><span class="line">        sgd([w, b], lr, batch_size)</span><br><span class="line">    tran_l = loss(net(features, w, b), labels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;epoch %d, loss %f&quot;</span> % (epoch + <span class="number">1</span>, tran_l.mean().asnumpy()))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train_w: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(w)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;true_w: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(true_w)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;train_b: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;true_b: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(true_b)</span><br></pre></td></tr></table></figure>

<h3 id="TensorFlow实现线性模型"><a href="#TensorFlow实现线性模型" class="headerlink" title="TensorFlow实现线性模型"></a>TensorFlow实现线性模型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据集</span></span><br><span class="line">x_data = np.random.rand(<span class="number">100</span>).astype(np.float32)</span><br><span class="line">y_data = x_data * <span class="number">0.1</span> + <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重和偏置初始化</span></span><br><span class="line">Weights = tf.Variable(tf.random_uniform([<span class="number">1</span>], -<span class="number">1.0</span>, <span class="number">1.0</span>))</span><br><span class="line">biases = tf.Variable(tf.zeros([<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线性模型</span></span><br><span class="line">y = Weights * x_data + biases</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失和优化器</span></span><br><span class="line">loss = tf.reduce_mean(tf.square(y - y_data))</span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.5</span>)</span><br><span class="line">train = optimizer.minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">init = tf.initialize_all_variables()</span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">201</span>):</span><br><span class="line">    sess.run(train)</span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(step, sess.run(Weights), sess.run(biases))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>mxnet</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归的Gluon实现</title>
    <url>/posts/593cfb3c.html</url>
    <content><![CDATA[<p>使用MXNet提供的Gluon接口实现线性回归</p>
<p>mxnet的nn（neural networks）模块定义了大量的神经网络的层。loss模块定义了各种损失函数</p>
<p>MXNet的initializer模块提供了模型参数初始化的各种方法</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, nd</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> loss <span class="keyword">as</span> gloss</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> data <span class="keyword">as</span> gdata</span><br><span class="line"><span class="keyword">from</span> mxnet.gluon <span class="keyword">import</span> nn <span class="keyword">as</span> gnn</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> init</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> gluon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数据集</span></span><br><span class="line">num_input = <span class="number">2</span></span><br><span class="line">num_example = <span class="number">1000</span></span><br><span class="line">true_w = [<span class="number">2</span>, -<span class="number">3.4</span>]</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line"></span><br><span class="line">features = nd.random.normal(scale=<span class="number">1</span>, shape=(num_example, num_input))</span><br><span class="line">labels = true_w[<span class="number">0</span>] * features[:, <span class="number">0</span>] + true_w[<span class="number">1</span>] * features[:, <span class="number">1</span>] + true_b</span><br><span class="line">labels += nd.random.normal(scale=<span class="number">0.01</span>, shape=labels.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"><span class="comment"># 将训练数据的特征与标签组合</span></span><br><span class="line">dataset = gdata.ArrayDataset(features, labels)</span><br><span class="line">data_iter = gdata.DataLoader(dataset, batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印数据</span></span><br><span class="line"><span class="comment"># for x, y in data_iter:</span></span><br><span class="line"><span class="comment">#     print(x, y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line"><span class="comment"># Sequential可以看做是串联各层的容器，容器的每一层将看做是下一层的输入</span></span><br><span class="line">net = gnn.Sequential()</span><br><span class="line"><span class="comment"># 线性回归是单层神经网络，输出层的神经元和输入层各个输入完全连接，因此，线性回归输出层也叫全连接层</span></span><br><span class="line"><span class="comment"># gluon无需指定每一层的输入个数 模型会自动推断</span></span><br><span class="line"><span class="comment"># 定义输出个数为1</span></span><br><span class="line">net.add(gnn.Dense(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化模型参数</span></span><br><span class="line"><span class="comment"># 通过init.Normal参数指定每个参数元素将在初始化时随机采样于服从N(0,0.01)的数，偏置默认初始化为0</span></span><br><span class="line">net.initialize(init.Normal(sigma=<span class="number">0.01</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line"><span class="comment"># 平方损失 又称 L2范式损失</span></span><br><span class="line">loss = gloss.L2Loss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义优化算法</span></span><br><span class="line"><span class="comment"># 指定学习率是0.03的小批量随机梯度下降（sgd）为优化算法</span></span><br><span class="line">trainer = gluon.Trainer(net.collect_params(), <span class="string">&#x27;sgd&#x27;</span>, &#123;<span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.03</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># net[0].weight.attach_grad()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">num_epochs = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_epochs + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> data_iter:</span><br><span class="line">        <span class="comment"># 需要反向传导的地方record一下</span></span><br><span class="line">        <span class="keyword">with</span> autograd.record():</span><br><span class="line">            l = loss(net(x), y)</span><br><span class="line">        <span class="comment"># 计算梯度</span></span><br><span class="line">        l.backward()</span><br><span class="line">        <span class="comment"># 更新模型参数</span></span><br><span class="line">        trainer.step(batch_size)</span><br><span class="line">    l = loss(net(features), labels)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;epoch %d, loss: %f&#x27;</span> % (epoch, l.mean().asnumpy()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;true_w:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(true_w)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_w: &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">0</span>].weight.data())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;true_b:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(true_b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;train_b: &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">0</span>].bias.data())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度</span></span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">0</span>].weight.data().grad)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>mxnet</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-写一个BOOT引导程序</title>
    <url>/posts/ea957129.html</url>
    <content><![CDATA[<h1 id="写一个BOOT引导程序"><a href="#写一个BOOT引导程序" class="headerlink" title="写一个BOOT引导程序"></a>写一个BOOT引导程序</h1><p>先上代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line"></span><br><span class="line">BaseOfStack equ 0x7c00</span><br><span class="line"></span><br><span class="line">; init reg</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, BaseOfStack</span><br><span class="line"></span><br><span class="line">; clear screen</span><br><span class="line">mov ax, 0x600</span><br><span class="line">mov bx, 0x700</span><br><span class="line">mov cx, 0x0</span><br><span class="line">mov dx, 0x184f</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">; set focus</span><br><span class="line">mov ax, 0x200</span><br><span class="line">mov bx, 0x0</span><br><span class="line">mov dx, 0x0</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">; display on screen</span><br><span class="line">mov ax, 0x1301</span><br><span class="line">mov bx, 0xf</span><br><span class="line">mov dx, 0x0</span><br><span class="line">mov cx, 15</span><br><span class="line">push ax</span><br><span class="line">mov ax, ds</span><br><span class="line">mov es, ax</span><br><span class="line">pop ax</span><br><span class="line">mov bp, StartBootMessage</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">; reset floppy</span><br><span class="line">xor ah, ah</span><br><span class="line">xor dl, dl</span><br><span class="line">int 0x13</span><br><span class="line"></span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">StartBootMessage: db &quot;Start Boot Anos&quot;</span><br><span class="line"></span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line"></span><br><span class="line">; dw 0xaa55</span><br><span class="line">db 0x55, 0xaa</span><br></pre></td></tr></table></figure>

<p><code>org 0x7c00</code>用于指定程序的起始地址，如果程序未指定起始地址，那么编译器会把0x0000最为程序的起始地址。<code>BaseOfStack equ 0x7c00</code>意思是<code>BaseOfStack</code>等价与<code>0x7c00</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, BaseOfStack</span><br></pre></td></tr></table></figure>

<p>这几条指令则是将CS寄存器的段基地址设置到DS、ES、SS等寄存器中，设置栈的指针SP寄存器。</p>
<h1 id="INT-0x10中断"><a href="#INT-0x10中断" class="headerlink" title="INT 0x10中断"></a>INT 0x10中断</h1><h2 id="设置屏幕光标位置"><a href="#设置屏幕光标位置" class="headerlink" title="设置屏幕光标位置"></a>设置屏幕光标位置</h2><p>BIOS中断服务程序<code>INT 0x10</code>的主功能号<code>AH=0x02</code>可以实现光标位置的设置，具体说明如下：</p>
<p><code>INT 0x10, AH=0x02</code>功能：设置光标</p>
<ul>
<li>DH&#x3D;游标的列数</li>
<li>DL&#x3D;游标的行数</li>
<li>BH&#x3D;页码数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 0x200</span><br><span class="line">mov bx, 0x0</span><br><span class="line">mov dx, 0x0</span><br><span class="line">int 0x10</span><br></pre></td></tr></table></figure>

<p>这几行代码是将光标位置设置到屏幕左上角(0,0)</p>
<h2 id="上卷指定范围的窗口（包括清屏）"><a href="#上卷指定范围的窗口（包括清屏）" class="headerlink" title="上卷指定范围的窗口（包括清屏）"></a>上卷指定范围的窗口（包括清屏）</h2><p>BIOS中断服务程序<code>INT 0x10</code>的主功能号<code>AH=0x06</code>可以实现按指定范围滚动窗口，同时也包括清屏，具体说明如下：</p>
<p><code>INT 0x10, AH=0x06</code>功能：按指定范围滚动窗口</p>
<ul>
<li><p>AL&#x3D;滚动的列数，若为0则实现清屏功能</p>
</li>
<li><p>BH&#x3D;滚动后空出的位置放入的属性</p>
</li>
<li><p>CH&#x3D;滚动的范围的左上角坐标的列号</p>
</li>
<li><p>CL&#x3D;滚动的范围的左上角坐标的行号</p>
</li>
<li><p>DH&#x3D;滚动的范围的右上角坐标的列号</p>
</li>
<li><p>DL&#x3D;滚动的范围的右上角坐标的行号</p>
</li>
<li><p>BH&#x3D;颜色属性</p>
<ul>
<li>bit0~2：字体颜色（0：黑、1：蓝、2：绿、3：青、4：红、5：紫、6：棕、7：白）</li>
<li>bit 3：字体亮度（0：字体正常、1：字体高亮度）</li>
<li>bit 4~6：背景颜色（0：黑、1：蓝、2：绿、3：青、4：红、5：紫、6：棕、7：白）</li>
<li>bit 7：字体闪烁（0：不闪烁、1：闪烁）</li>
</ul>
</li>
</ul>
<p>如果AL&#x3D;0，则清屏，其他BX、CX、DX寄存器参数将不起作用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax, 0x600</span><br><span class="line">mov bx, 0x700</span><br><span class="line">mov cx, 0x0</span><br><span class="line">mov dx, 0x184f</span><br><span class="line">int 0x10</span><br></pre></td></tr></table></figure>

<h2 id="显示字符串"><a href="#显示字符串" class="headerlink" title="显示字符串"></a>显示字符串</h2><p>BIOS中断服务程序<code>INT 0x10</code>的主功能号<code>AH=0x13</code>可以实现字符串显示功能，具体说明如下：</p>
<p><code>INT 0x10, AH=0x13</code>功能：显示一行字符串</p>
<ul>
<li>AL&#x3D;写入模式<ul>
<li>AL&#x3D;0x00：字符串属性由BL寄存器提供，而CX寄存器提供字符串长度（以B为单位），显示后光标位置不变</li>
<li>AL&#x3D;0x01：同AL&#x3D;0x00，但光标位置会移动到字符串末尾</li>
<li>AL&#x3D;0x02：字符串属性由每个字符后面紧跟的字节提供，所以CX寄存器提供的字符串长度以Word为单位，显示后光标位置不变</li>
<li>AL&#x3D;0x03：同AL&#x3D;0x02，但是光标位置会移动到末端</li>
</ul>
</li>
<li>CX&#x3D;字符串的长度</li>
<li>DH&#x3D;游标的坐标行号</li>
<li>DL&#x3D;游标的坐标列号</li>
<li>ES:BP&#x3D;要显示字符串的内存地址</li>
<li>BH&#x3D;页码</li>
<li>BL&#x3D;字符串属性&#x2F;颜色属性<ul>
<li>bit0~2：字体颜色（0：黑、1：蓝、2：绿、3：青、4：红、5：紫、6：棕、7：白）</li>
<li>bit 3：字体亮度（0：字体正常、1：字体高亮度）</li>
<li>bit 4~6：背景颜色（0：黑、1：蓝、2：绿、3：青、4：红、5：紫、6：棕、7：白）</li>
<li>bit 7：字体闪烁（0：不闪烁、1：闪烁）</li>
</ul>
</li>
</ul>
<h1 id="INT-0x13中断"><a href="#INT-0x13中断" class="headerlink" title="INT 0x13中断"></a>INT 0x13中断</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; reset floppy</span><br><span class="line">xor ah, ah</span><br><span class="line">xor dl, dl</span><br><span class="line">int 0x13</span><br></pre></td></tr></table></figure>

<p>这段代码实现了软盘的复位功能。</p>
<p><code>INT 0x13, AH=0x00</code>功能：重置磁盘驱动器，为下一次读写软盘做准备</p>
<ul>
<li>DL&#x3D;驱动器号，0x00~0x7F：软盘，0x80~0xFF：硬盘</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-FAT12文件系统</title>
    <url>/posts/86db78d0.html</url>
    <content><![CDATA[<p>FAT12是DOS时代就开始使用的文件系统，直到现在仍然在软盘上使用，FAT12软盘的被格式化后为：有两个磁头，每个磁头80个柱面（磁道），每个柱面有18个扇区，每个扇区512个字节空间。所以标准软盘的总空间为：</p>
<p><code>2 * 80 *18 * 512=1474560B=1440K=1.44M</code></p>
<p>下面是FAT12的结构图：</p>
<p><img src="https://img.ansore.de/2022/07/04/3ef8f69d24adf08bf3cfc34cc2d02e5e.png" alt="Untitled"></p>
<h1 id="引导扇区"><a href="#引导扇区" class="headerlink" title="引导扇区"></a>引导扇区</h1><p>操作系统之所以认识<code>FAT12</code>格式的磁盘，其秘密就在于逻辑0扇区这<code>512B</code>上。如果这512字节的最后两个字节的内容分别是55和AA（<code>0xAA55</code>低字节在前，高字节在后)的话，BIOS在启动时会将这个扇区读取到<code>0:7C00h-0:7DFFh</code>处，然后跳转到<code>0:7C00h</code>处继续执行指令，操作系统即用此来达到引导系统的目的，而这个磁盘就称为引导磁盘。</p>
<p>操作系统标识FAT12文件系统是因为在逻辑0扇区(即引导扇区)处还存储着一个特定的数据结构，此结构有固定的格式，在操作系统将此磁盘格式化时自动生成，具体数据结构如下表所示：</p>
<p><img src="https://img.ansore.de/2022/07/04/606721836dcce98f57423dd74ef31769.png" alt="Screenshot_20220116_114137"></p>
<p><code>BS_jmpBoot</code>：是跳转指令，偏移0处的跳转指令必须是合法的可执行的基于x86的CPU指令，如：<code>jmp start</code>，这样可以生成3字节长的指令，（加关键字short的短跳转指令的长度是2字节），指向操作系统引导代码部分。Windows和MS-DOS生成的FAT12启动扇区中的跳转指令是短跳转，如：<code>jmp short LABEL_START</code>，然后加一个nop的空指令来保持3字节的长度。</p>
<p><code>BPB_BytsPerSec</code>：每扇区的字节数，类型是双字节长，标准分区上的每扇区字节数一般是512B， FAT12的格式下设置为512(0x200h)。</p>
<p><code>BPB_SecPerClus</code>：每簇扇区数，偏移13处，类型是字节，簇是数据存储的最小单位，在FAT12格式下一般为1，即每簇只有1个扇区(512字节)。</p>
<p><code>BPB_RsvdSecCnt</code>：Boot记录占用多少扇区，即在FAT1之前的 引导扇区，一般情况下，引导扇区占用1个扇区。</p>
<p><code>BPB_NumFATs</code>：共有多少个FAT表，默认情况下此字段的值为2，也就是有两个FAT表，FAT1和FAT2的内容相同，当FAT1表出错的时候可以使用FAT2来恢复文件分配表。</p>
<p><code>BPB_RootEntCnt</code>：根目录文件数最大值，默认为224，每个目录条目占用32B的空间，因此根目录的大小为：224*32&#x2F;512&#x3D;14，即占用14个扇区。</p>
<p><code>BPB_TotSec16</code>：扇区总数&#x3D;0xB40&#x3D;2880，这里的扇区总数包括保留扇区（含引导扇区）、FAT表、根目录区以及数据区占用的全部扇区数，如果此域值为0，则<code>BPB_TotSec32</code>必须是非0值。</p>
<p><code>BPB_Media</code>：描述存储介质类型。对于不可移动的存储介质而言，标准值是0xF8；对于可移动的存储介质，常用值为0xF0。此域的合法值为0xF0、0xF8、0xF9、0xFA、0xFB、0xFC、0xFD、0xFE、0xFF。无论往该字段写入什么值，必须向FAT[0]的低字节写入相同的值。</p>
<p><code>BPB_FATSz16</code>：每个FAT占用的扇区数&#x3D;0x9&#x3D;9，即FAT1占用1—9逻辑扇区，FAT2占用10—18逻辑扇区。</p>
<p><code>BPB_SecPerTrk</code>：每磁道扇区数&#x3D;0x12&#x3D;18，即标准FAT12文件系统中，每个磁道的扇区数就是为18。</p>
<p><code>BPB_NumHeads</code>：磁头数&#x3D;0x2&#x3D;2，该磁盘包括2个磁头，也就是面数是2。</p>
<p><code>BS_VolLab</code>：指定卷标。</p>
<p><code>BS_FileSysType</code>：指定文件系统类型。这个类型只是字符串，操作系统不使用该字段来鉴别FAT类文件系统类型。</p>
<p>结构如下所示：</p>
<p><img src="https://img.ansore.de/2022/07/04/cacbdc6b82493449237e2ea10e46b4df.png" alt="Screenshot_20220122_092852"></p>
<h1 id="FAT表"><a href="#FAT表" class="headerlink" title="FAT表"></a>FAT表</h1><p>FAT1和FAT2是两个完全相同的FAT表，每个FAT占用9个扇区。其中FAT1占用1—9扇区，FAT2占用10—18扇区。</p>
<p>FAT12文件系统以簇为单位分配数据区的存储空间（扇区），每个簇的长度为<code>BPB_BytsPerSec * BPB_SecPerClus</code>，数据区的簇号与FAT的表项是一一对应的关系。即使文件只有一个字节没FAT12文件系统也会分配一个簇的空间存储它。此种设计方法可以将磁盘存储空间按固定的存储片（页）有效管理起来，进而可以按照文件偏移，分片段访问文件内的数据，就不必将文件里的数据一次性读取出来。</p>
<p>FAT表项的位宽与FAT类型有关系，如FAT12的表项位宽为12bit，FAT32的表项位宽为32bit。当一个文件体积增大时，其所需的磁盘空间也会增加，随着时间推移，文件系统将无法确保文件中的数据存储在连续的扇区中，文件往往会被分为若干个片段，借助FAT表，将不连续的文件片段按簇号连接起来，这个连接与C语言中的单链表极为相似。</p>
<p>首先12个二进制数字表示这个簇指向的下一个簇。FAT表从零开始编号。如果2号簇储存的数字为3，那么说明2号簇指向3号簇。3号簇的12位数字储存的是5的话，那么说明3号簇指向5号簇。这就形成了一个链表，链表的空指针NULL（结尾标志），使用0xFFF表示。</p>
<p><img src="https://img.ansore.de/2022/07/04/ac2c98e7a3bfbfc1d88cb4b153f00f32.png" alt="Screenshot_20220123_163149"></p>
<p>其中FAT[0]的低8位在数值上与<code>BPB_Media</code>字段保持一致，其余位全部为1。</p>
<p>现在大部分操作系统直接跳过这两个表项的检索，使它们不再参与计算。所以<code>FAT[0]</code>和<code>FAT[1]</code>的值页不那么重要了。</p>
<h1 id="根目录区"><a href="#根目录区" class="headerlink" title="根目录区"></a>根目录区</h1><p>根目录区的开始扇区号是19，它是由若干个目录条目(Directory Entry)组成，条目最多有<code>BPB_RootEntCnt</code>个，由于根目录区的大小是依赖于<code>BPB_RootEntCnt</code>的，所以长度不固定。</p>
<p>在<code>FAT12</code>中，因为<code>BPB_RootEntCnt=0xE0=14*16+0=244</code>，即条目最多为244个，又因为每个条目占用32个字节，故<code>244*32/512=14</code>，即该根目录区占14个扇区，即19—32。</p>
<p>根目录区中的每个条目占用32字节，它的格式如下图：</p>
<p><img src="https://img.ansore.de/2022/07/04/17438e00f70a21c8f77efa4e7be01b97.png" alt="Untitled1"></p>
<p>这里主要定义了文件的名字，属性，最后写入的时间和日期，文件的开始簇数以及文件大小。</p>
<h1 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h1><p>数据区的某一个扇区如果是一个目录，那么这个目录被称为子目录。子目录分为一级、二级……子目录，他们的组织方法和根目录基本一样。</p>
<p>子目录中一定要包含两个目录项：<code>.</code>和<code>..</code></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-BOOT加载LOADER</title>
    <url>/posts/9afe7748.html</url>
    <content><![CDATA[<h1 id="FAT12文件系统数据"><a href="#FAT12文件系统数据" class="headerlink" title="FAT12文件系统数据"></a>FAT12文件系统数据</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line">; 设置栈指针的位置</span><br><span class="line">BaseOfStack equ 0x7c00</span><br><span class="line">; 加载Loader到内存里的位置（20位）</span><br><span class="line">BaseOfLoader equ 0x1000</span><br><span class="line">OffsetOfLoader equ 0x00</span><br><span class="line"></span><br><span class="line">; 根目录占用的扇区数：(BPB_RootEntCnt * 32 + BPB_BytesPerSec - 1) / BPB_BytesPerSec</span><br><span class="line">; (224 * 32 + 512 - 1) / 512 = 14</span><br><span class="line">RootDirSectors equ 14</span><br><span class="line">; 根目录的起始扇区号 = 保留扇区数(BPB_RsvdSecCnt) + FAT表扇区数(BPB_FATSz16) + FAT表份数(BPB_NumFATs) = 1 + 9 * 2 = 19</span><br><span class="line">SectorNumOfRootDirStart equ 19</span><br><span class="line">; FAT表的起始扇区号，引导扇区的扇区号是0</span><br><span class="line">SectorNumOfFAT1Start equ 1</span><br><span class="line">; 用于平衡文件（或目录）的起始簇号与数据区起始簇号的差值。</span><br><span class="line">SectorBalance equ 17</span><br><span class="line"></span><br><span class="line">; FAT12 Head</span><br><span class="line">jmp short LableStart nop</span><br><span class="line">BS_OEMName	db	&#x27;ANOSboot&#x27;</span><br><span class="line">BPB_BytesPerSec	dw	512</span><br><span class="line">BPB_SecPerClus	db	1</span><br><span class="line">BPB_RsvdSecCnt	dw	1</span><br><span class="line">BPB_NumFATs	db	2</span><br><span class="line">BPB_RootEntCnt	dw	224</span><br><span class="line">BPB_TotSec16	dw	2880</span><br><span class="line">BPB_Media	db	0xf0</span><br><span class="line">BPB_FATSz16	dw	9</span><br><span class="line">BPB_SecPerTrk	dw	18</span><br><span class="line">BPB_NumHeads	dw	2</span><br><span class="line">BPB_HiddSec	dd	0</span><br><span class="line">BPB_TotSec32	dd	0</span><br><span class="line">BS_DrvNum	db	0</span><br><span class="line">BS_Reserved1	db	0</span><br><span class="line">BS_BootSig	db	0x29</span><br><span class="line">BS_VolID	dd	0</span><br><span class="line">BS_VolLab	db	&#x27;boot loader&#x27;</span><br><span class="line">BS_FileSysType	db	&#x27;FAT12   &#x27;</span><br></pre></td></tr></table></figure>

<p><code>BaseOfLoader</code>与<code>OffsetOfLoader</code>组成了Loader的起始物理地址，即<code>BaseOfLoader:OffsetOfLoader=0x10000</code>。</p>
<p><code>RootDirSectors equ 14</code>定义了根目录占用的扇区数，这个数值是FAT12文件系统提供的信息计算得到的。即<code>(BPB_RootEntCnt * 32 + BPB_BytesPerSec - 1) / BPB_BytesPerSec = (224 * 32 + 512 - 1) / 512 = 14</code></p>
<p><code>SectorNumOfRootDirStart equ 19</code>定义了根目录的起始扇区，这个数组也是计算得到的。保留扇区数+FAT表扇区数*FAT表份数&#x3D;1+2*9&#x3D;19，扇区编号从0开始，所以根目录扇区编号为19</p>
<p><code>SectorBalance equ 17</code>用于平衡文件（目录）的起始簇号与数据区起始簇号的差值。因为数据区对应的有效簇号是2，为了正确计算出FAT表项对应的数据区起始扇区号，则FAT表项值减2，或者将数据区的起始簇号&#x2F;扇区号减2（仅在每簇一个扇区组成时可用）。暂用一种取巧的方式，将根目录起始扇区减2（19-2&#x3D;17），进而间接把数据区的起始扇区号（数据区起始扇区号&#x3D;根目录起始扇区号+根目录所占的扇区数）减2</p>
<h1 id="FAT中读取文件"><a href="#FAT中读取文件" class="headerlink" title="FAT中读取文件"></a>FAT中读取文件</h1><h2 id="读取磁盘扇区模块"><a href="#读取磁盘扇区模块" class="headerlink" title="读取磁盘扇区模块"></a>读取磁盘扇区模块</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; read one sector from floppy</span><br><span class="line">; 从第 ax 个 Sector 开始, 将 cl 个 Sector 读入 es:bx 中</span><br><span class="line">ReadOneSector:</span><br><span class="line">  push bp</span><br><span class="line">  mov bp, sp</span><br><span class="line">  sub esp, 2 ; 辟出两个字节的堆栈区域保存要读的扇区数: byte [bp-2]</span><br><span class="line">  mov byte [bp-2], cl</span><br><span class="line">  push bx</span><br><span class="line">  mov bl, [BPB_SecPerTrk]</span><br><span class="line">  div bl</span><br><span class="line">  inc ah</span><br><span class="line">  mov cl, ah</span><br><span class="line">  mov dh, al</span><br><span class="line">  shr al, 1</span><br><span class="line">  mov ch, al</span><br><span class="line">  and dh, 1</span><br><span class="line">  pop bx</span><br><span class="line">  mov dl, [BS_DrvNum]</span><br><span class="line"></span><br><span class="line">GoOnReading:</span><br><span class="line">  mov ah, 2</span><br><span class="line">  mov al, byte [bp-2]</span><br><span class="line">  int 0x13</span><br><span class="line">  jc GoOnReading</span><br><span class="line">  add esp, 2</span><br><span class="line">  pop bp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

<p>通过中断<code>int 13</code>，从驱动器中读取开始地址(<code>ax</code>号扇区)后指定数量(<code>cl</code>个)扇区数据到目标地址(<code>es:bp</code>)</p>
<p><code>ReadOneSector</code>负责实现读取。仅仅是对BIOS中断服务程序的再次封装，以简化读取磁盘扇区需要的操作，</p>
<p><code>INT13, AH=0x02</code>功能：读取磁盘扇区</p>
<ul>
<li>AL&#x3D;读取扇区数（非0）</li>
<li>CH&#x3D;磁道号（柱面号）的低8位</li>
<li>CL&#x3D;扇区号1<del>63（bit 0</del>5），磁道号（柱面号）的高2位（bit 6~7，只对硬盘有效）</li>
<li>DH&#x3D;磁头号</li>
<li>DL&#x3D;驱动器号（如果操作的是硬盘驱动器，bit 7必须被置位）</li>
<li>ES:BX&#x3D;&gt;数据缓冲区</li>
</ul>
<p>模块<code>ReadOneSector</code>仅仅是对BIOS的<code>0x13</code>号中断<code>0x02</code>号功能的封装，以简化磁盘读取扇区的的操作过程，该模块是需要参数的，参数说明如下：</p>
<ul>
<li>AX &#x3D; 待读取的磁盘起始扇区号</li>
<li>CL&#x3D; 读入的扇区数量</li>
<li>EX : BX &#x3D;&gt; 数据缓冲区起始地址</li>
</ul>
<p>模块<code>ReadOneSector</code>的参数中传入的磁盘扇区号是 <strong>LBA（Logical Block Address，逻辑块寻址）</strong> 格式的，而BIOS的<code>0x13</code>号中断<code>0x02</code>号功能只能接受 <strong>CHS（Cylinder&#x2F;Head&#x2F;Sector，柱面&#x2F;磁头&#x2F;扇区）</strong> 格式的磁盘扇区号，那么就需要将LBA格式的转换为CHS格式的，通过以下公式，便可以转换：</p>
<p>$$LAB扇区号 \div 每磁道扇区数 \begin{cases} 商Q \rightarrow \begin{cases} 柱面号&#x3D;Q&gt;&#x3D;1 \ 磁头号&#x3D;Q \end{cases}\ 余数R \rightarrow 起始扇区号 &#x3D; R + 1 \end{cases}$$</p>
<p>具体流程如下：</p>
<ol>
<li>模块<code>ReadOneSector</code>一开始，先保存栈帧寄存器（<code>bp</code>）和栈寄存器（<code>sp</code>）中的数值（<code>bp</code>存储在栈中，<code>sp</code>保存在<code>bp</code>寄存器中）</li>
<li>然后从栈中开辟两个字节的存储空间，即是<code>sp</code>向下移动两个字节（<code>sub esp, 2</code>）。然后将<code>CL</code>中的内容（1个字节，参数，读入扇区数）存入栈中，因为接下来要使用到<code>CL</code>寄存器。<strong>注：</strong> <code>CL</code>中的内容是一个字节，而栈项要对齐，所以要要用两个字节保存一个字节的内容，即使浪费了一个字节。</li>
<li>然后就是把<code>BX</code>的内容也保存到栈中，因为接下来要用到<code>BX</code>。</li>
<li>使用<code>AX</code>寄存器（待读取的磁盘起始扇区号）除以<code>BL</code>寄存器（每磁道扇区数），计算出目标磁道号（商：<code>AL</code>寄存器）和目标磁道内的起始扇区号（余数：<code>AH</code>寄存器），又因为磁道内的起始扇区号是从1开始计数的，故将此余数值加1（<code>inc ah; mov cl, ah</code>）紧接着按照以上公式计算出磁道号（即是柱面号）、磁头号。</li>
<li>恢复<code>BX</code></li>
<li>获取驱动器号<code>BS_DrvNum</code></li>
<li>设置<code>0x13</code>中断功能号<code>AH=0x02</code>，设置读入扇区数<code>mov al, byte [bp - 2]</code>（我们之前把参数<code>CL</code>读入扇区数保存在了栈中，所以现在用<code>bp</code>去索引它）。</li>
<li>然后调用<code>0x13</code>号中断。</li>
<li>判断是否读取成功（即是若CF位为0，则成功），否则（CF&#x3D;1）回到步骤<code>7</code>。</li>
</ol>
<h2 id="LOADER-BIN文件搜索"><a href="#LOADER-BIN文件搜索" class="headerlink" title="LOADER.BIN文件搜索"></a>LOADER.BIN文件搜索</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; search loader.bin</span><br><span class="line">; 保存根目录的起始扇区号(SectorNo)，赋值为SectorNumOfRootDirStart(根目录的起始扇区)</span><br><span class="line">; 19</span><br><span class="line">mov word [SectorNo], SectorNumOfRootDirStart</span><br><span class="line"></span><br><span class="line">SearchInRootDirBegin:</span><br><span class="line">  ; RootDirSizeForLoop(临时变量) == RootDirSectors (14)</span><br><span class="line">  cmp word [RootDirSizeForLoop], 0</span><br><span class="line">  jz NoLoaderBin</span><br><span class="line">  ; 查找扇区-1</span><br><span class="line">  dec word [RootDirSizeForLoop]</span><br><span class="line">  ; 设置读取扇区模块参数 EX:BX,AX,CL</span><br><span class="line">  mov ax, 0x0000</span><br><span class="line">  mov es, ax</span><br><span class="line">  mov bx, 0x8000</span><br><span class="line">  mov ax, [SectorNo]</span><br><span class="line">  mov cl, 1</span><br><span class="line">  ; 读取扇区模块</span><br><span class="line">  call ReadOneSector</span><br><span class="line">  ; 开始查找loader.bin</span><br><span class="line">  mov si, LoaderFileName ; 文件名源地址</span><br><span class="line">  mov di, 0x8000 ; 文件名目标地址</span><br><span class="line">  cld ; DF复位=0，往高地址递进</span><br><span class="line">  mov dx, 0x10</span><br><span class="line"></span><br><span class="line">SearchForLoaderBin:</span><br><span class="line">  ; 如果dx=0,说明比较完成，开始读取下一个根目录扇区</span><br><span class="line">  cmp dx, 0</span><br><span class="line">  jz GotoNextSectorInRoorDir</span><br><span class="line">  ; 否则dx-1（目录项-1）</span><br><span class="line">  dec dx</span><br><span class="line">  ; cx保存目录项文件名长度 11bits</span><br><span class="line">  mov cx, 11</span><br><span class="line"></span><br><span class="line">CmpFileName:</span><br><span class="line">  ; 判断文件名是否比较完</span><br><span class="line">  ; 如果cx=0,说明已找到</span><br><span class="line">  cmp cx, 0</span><br><span class="line">  jz FileNameFound</span><br><span class="line">  ; 没有比较完, cx-1，继续比较下一个字符</span><br><span class="line">  dec cx</span><br><span class="line">  ; 从DS:SI读取一个字节到寄存器AL，然后SI+=1（取决与DF）</span><br><span class="line">  lodsb</span><br><span class="line">  ; 比较目标字符串中对应的字符与AL中的字符是否相等</span><br><span class="line">  cmp al, byte [es:di]</span><br><span class="line">  ; 如果相等，继续比较下一个字符(跳转到GOON)</span><br><span class="line">  jz GoOn</span><br><span class="line">  ; 如果不相等,就继续下一个文件项</span><br><span class="line">  jmp Different</span><br><span class="line"></span><br><span class="line">GoOn:</span><br><span class="line">  ; 目标字符串+1，然后继续比较</span><br><span class="line">  inc di</span><br><span class="line">  jmp CmpFileName</span><br><span class="line"></span><br><span class="line">Different:</span><br><span class="line">  ; di低5位清零</span><br><span class="line">  and di, 0xffe0</span><br><span class="line">  ; di += 32，表示指向下一个目录</span><br><span class="line">  and di, 0x20</span><br><span class="line">  ; si指向LoaderFileName的起始地址</span><br><span class="line">  mov si, LoaderFileName</span><br><span class="line">  ; 继续比较</span><br><span class="line">  jmp SearchForLoaderBin</span><br><span class="line"></span><br><span class="line">GotoNextSectorInRoorDir:</span><br><span class="line">  ; 如果在当前扇区找不到loader.bin，继续在下一个扇区找</span><br><span class="line">  ; 扇区号+1</span><br><span class="line">  add word [SectorNo], 1</span><br><span class="line">  jmp SearchInRootDirBegin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="找不到LOADER-BIN文件"><a href="#找不到LOADER-BIN文件" class="headerlink" title="找不到LOADER.BIN文件"></a>找不到LOADER.BIN文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; display on screen: Error LEADER.BIN file not found</span><br><span class="line">NoLoaderBin:</span><br><span class="line">  mov ax, 0x1301</span><br><span class="line">  mov bx, 0x008c</span><br><span class="line">  mov dx, 0x0100</span><br><span class="line">  mov cx, 21</span><br><span class="line">  push ax</span><br><span class="line">  mov ax, ds</span><br><span class="line">  mov es, ax</span><br><span class="line">  pop ax</span><br><span class="line">  mov bp, NoLoaderBinText</span><br><span class="line">  int 0x10</span><br><span class="line">  jmp $</span><br></pre></td></tr></table></figure>

<p>屏幕上显示错误信息</p>
<h2 id="FAT表项解析"><a href="#FAT表项解析" class="headerlink" title="FAT表项解析"></a>FAT表项解析</h2><p>当找到loader.bin文件之后，根据FAT表项提供的簇号顺序依次加载扇区数据到内存中，这会涉及到FAT表项的解析工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; get FAT Entry</span><br><span class="line">; AX = FAT表项号</span><br><span class="line">GetFATEntry:</span><br><span class="line">  push es</span><br><span class="line">  push bx</span><br><span class="line">  push ax</span><br><span class="line">  mov ax, 0x00</span><br><span class="line">  mov es, ax</span><br><span class="line">  pop ax</span><br><span class="line">  ; Odd奇偶标志变量</span><br><span class="line">  mov byte [Odd], 0</span><br><span class="line">  mov bx, 3</span><br><span class="line">  mul bx</span><br><span class="line">  mov bx, 2</span><br><span class="line">  div bx</span><br><span class="line">  ; 判断余数的奇偶性</span><br><span class="line">  cmp dx, 0</span><br><span class="line">  jz Even</span><br><span class="line">  mov byte [Odd], 1</span><br><span class="line"></span><br><span class="line">Even:</span><br><span class="line">  ; 读取FAT表扇区，总共两个扇区</span><br><span class="line">  xor dx, dx</span><br><span class="line">  mov bx, [BPB_BytesPerSec]</span><br><span class="line">  div bx</span><br><span class="line">  push dx</span><br><span class="line">  mov bx, 0x8000</span><br><span class="line">  add ax, SectorNumOfFAT1Start</span><br><span class="line">  mov cl, 2</span><br><span class="line">  call ReadOneSector</span><br><span class="line"></span><br><span class="line">  pop dx</span><br><span class="line">  add bx, dx</span><br><span class="line">  mov ax, [es:bx]</span><br><span class="line">  cmp byte [Odd], 1</span><br><span class="line">  jnz Even2</span><br><span class="line">  shr ax, 4</span><br><span class="line"></span><br><span class="line">Even2:</span><br><span class="line">  and ax, 0xfff</span><br><span class="line">  pop bx</span><br><span class="line">  pop es</span><br><span class="line">  ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该模块<code>GetFATEntry</code>的功能：根据当前FAT表项索引出下一个FAT表项，参数如下：</p>
<ul>
<li>AH&#x3D;FAT表项号（输入&#x2F;输出参数）</li>
</ul>
<p>首先把FAT表项号（AX）保存，并将奇偶标志变量置0，因为每个FAT表项占1.5B，并不是偶数对齐，所以就将FAT表项乘以3再除以2（也就是扩大1.5倍），然后判断余数的奇偶性并保存在变量<code>[Odd]</code>中（奇数为1，偶数为0），再将计算结果除以每扇区字节数，商即为FAT表项的偏移扇区号，余数为FAT表项在扇区中的位置。然后通过<code>ReadOneSector</code>模块，连续读入两个扇区，这样做的目的是，为了解决FAT表项横跨两个扇区的问题，最后根据奇偶标志变量<code>[Odd]</code>处理奇偶项错位问题，即是奇数项向右移动4位。</p>
<h2 id="加载loader-bin到内存"><a href="#加载loader-bin到内存" class="headerlink" title="加载loader.bin到内存"></a>加载loader.bin到内存</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; found loader.bin name in root dir</span><br><span class="line">; 如果在根目录找到了loader.bin文件</span><br><span class="line">FileNameFound:</span><br><span class="line">  ; 如果找到了的话，当前es:di指向的就是目标表项</span><br><span class="line">  ; ax保存根目录占用的扇区</span><br><span class="line">  mov ax, RootDirSectors</span><br><span class="line">  ; 定位到表项起始簇号的位置（偏移0x1a）</span><br><span class="line">  and di, 0xffe0</span><br><span class="line">  add di, 0x1a</span><br><span class="line">  ; 起始簇号保存到cx</span><br><span class="line">  mov cx, word [es:di]</span><br><span class="line">  push cx</span><br><span class="line">  ; 计算数据区起始扇区号</span><br><span class="line">  ; 数据区起始扇区号=根目录起始扇区号+根目录所占扇区数-2</span><br><span class="line">  add cx, ax</span><br><span class="line">  ; SectorBalance = 根目录起始扇区号-2</span><br><span class="line">  add cx, SectorBalance</span><br><span class="line">  ; 配置loader的加载位置es:bx</span><br><span class="line">  mov ax, BaseOfLoader</span><br><span class="line">  mov es, ax</span><br><span class="line">  mov bx, OffsetOfLoader</span><br><span class="line">  ; ax = loader起始扇区号</span><br><span class="line">  mov ax, cx</span><br><span class="line"></span><br><span class="line">GoOnLoadingFile:</span><br><span class="line">  ; 显示字符 &quot;.&quot;</span><br><span class="line">  push ax</span><br><span class="line">  push bx</span><br><span class="line">  mov ah, 0x0e</span><br><span class="line">  mov al, &#x27;.&#x27;</span><br><span class="line">  mov bl, 0xf</span><br><span class="line">  int 0x10</span><br><span class="line">  pop bx</span><br><span class="line">  pop ax</span><br><span class="line"></span><br><span class="line">  ; 读取loader</span><br><span class="line">  ; 每读入一个扇区就通过GetFATEntry模块读取下一个FAT表项</span><br><span class="line">  ; 然后继续读入数据</span><br><span class="line">  mov cl, 1</span><br><span class="line">  call ReadOneSector</span><br><span class="line">  ; 恢复簇号</span><br><span class="line">  pop ax</span><br><span class="line">  ; 读取下一个簇号</span><br><span class="line">  call GetFATEntry</span><br><span class="line">  ; 查看是否已经读取完成</span><br><span class="line">  cmp ax, 0xfff</span><br><span class="line">  jz FileLoaded</span><br><span class="line">  ; 否则保存获取到的簇号</span><br><span class="line">  push ax</span><br><span class="line">  ; 计算loader文件的下一个簇号的位置</span><br><span class="line">  mov dx, RootDirSectors</span><br><span class="line">  add ax, dx</span><br><span class="line">  add ax, SectorBalance</span><br><span class="line">  add bx, [BPB_BytesPerSec]</span><br><span class="line">  ; 继续读取文件</span><br><span class="line">  jmp GoOnLoadingFile</span><br><span class="line"></span><br><span class="line">FileLoaded:</span><br><span class="line">  ; 加载完文件，死循环等待</span><br><span class="line">  jmp $</span><br></pre></td></tr></table></figure>

<h2 id="临时变量和字符串变量"><a href="#临时变量和字符串变量" class="headerlink" title="临时变量和字符串变量"></a>临时变量和字符串变量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; temp variable</span><br><span class="line">RootDirSizeForLoop dw RootDirSectors</span><br><span class="line">SectorNo dw 0</span><br><span class="line">Odd db 0</span><br><span class="line"></span><br><span class="line">; display message</span><br><span class="line">StartBootText: db &quot;Start Boot Anos&quot;</span><br><span class="line">NoLoaderBinText: db &quot;ERROR: LOADER.BIN FILE NOT FOUND&quot;</span><br><span class="line">LoaderFileName: db &quot;LOADER  BIN&quot;, 0</span><br></pre></td></tr></table></figure>

<h1 id="生成镜像测试"><a href="#生成镜像测试" class="headerlink" title="生成镜像测试"></a>生成镜像测试</h1><p>编译boot.bin</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nasm -f bin boot.asm -o boot.bin</span><br></pre></td></tr></table></figure>

<p>生成软盘镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bximage -q -fd=1.44M -func=create ./boot.img</span><br></pre></td></tr></table></figure>

<p>写入引导扇区：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=$(BUILD)/boot.bin of=boot.img bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure>

<p>boches配置：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># configuration file generated by Bochs</span></span><br><span class="line">plugin_ctrl: <span class="attr">unmapped</span>=<span class="literal">true</span>, biosdev=<span class="literal">true</span>, speaker=<span class="literal">true</span>, extfpuirq=<span class="literal">true</span>, parallel=<span class="literal">true</span>, serial=<span class="literal">true</span>, iodebug=<span class="literal">true</span>, pcidev=<span class="literal">false</span>, usb_uhci=<span class="literal">false</span></span><br><span class="line">config_interface: textconfig</span><br><span class="line">display_library: x, <span class="attr">options</span>=<span class="string">&quot;gui_debug&quot;</span></span><br><span class="line">memory: <span class="attr">host</span>=<span class="number">32</span>, guest=<span class="number">32</span></span><br><span class="line">romimage: <span class="attr">file</span>=<span class="string">&quot;/usr/share/bochs/BIOS-bochs-latest&quot;</span>, address=<span class="number">0</span>x00000000, options=none</span><br><span class="line">vgaromimage: <span class="attr">file</span>=<span class="string">&quot;/usr/share/bochs/VGABIOS-lgpl-latest&quot;</span></span><br><span class="line">boot: floppy</span><br><span class="line">floppy_bootsig_check: <span class="attr">disabled</span>=<span class="number">0</span></span><br><span class="line">floppya: <span class="attr">type</span>=<span class="number">1_44</span>, <span class="number">1_44</span>=<span class="string">&quot;boot.img&quot;</span>, status=inserted, write_protected=<span class="number">0</span></span><br><span class="line"><span class="comment"># floppya: type=1_44</span></span><br><span class="line"><span class="comment"># no floppyb</span></span><br><span class="line">ata0: <span class="attr">enabled</span>=<span class="literal">true</span>, ioaddr1=<span class="number">0</span>x1f0, ioaddr2=<span class="number">0</span>x3f0, irq=<span class="number">14</span></span><br><span class="line">ata0-master: <span class="attr">type</span>=none</span><br><span class="line">ata0-slave: <span class="attr">type</span>=none</span><br><span class="line">ata1: <span class="attr">enabled</span>=<span class="literal">true</span>, ioaddr1=<span class="number">0</span>x170, ioaddr2=<span class="number">0</span>x370, irq=<span class="number">15</span></span><br><span class="line">ata1-master: <span class="attr">type</span>=none</span><br><span class="line">ata1-slave: <span class="attr">type</span>=none</span><br><span class="line">ata2: <span class="attr">enabled</span>=<span class="literal">false</span></span><br><span class="line">ata3: <span class="attr">enabled</span>=<span class="literal">false</span></span><br><span class="line">optromimage1: <span class="attr">file</span>=none</span><br><span class="line">optromimage2: <span class="attr">file</span>=none</span><br><span class="line">optromimage3: <span class="attr">file</span>=none</span><br><span class="line">optromimage4: <span class="attr">file</span>=none</span><br><span class="line">optramimage1: <span class="attr">file</span>=none</span><br><span class="line">optramimage2: <span class="attr">file</span>=none</span><br><span class="line">optramimage3: <span class="attr">file</span>=none</span><br><span class="line">optramimage4: <span class="attr">file</span>=none</span><br><span class="line">pci: <span class="attr">enabled</span>=<span class="number">1</span>, chipset=i440fx, slot1=none, slot2=none, slot3=none, slot4=none, slot5=none</span><br><span class="line">vga: <span class="attr">extension</span>=vbe, update_freq=<span class="number">5</span>, realtime=<span class="number">1</span>, ddc=builtin</span><br><span class="line">cpu: <span class="attr">count</span>=<span class="number">1</span>:<span class="number">1</span>:<span class="number">1</span>, ips=<span class="number">4000000</span>, quantum=<span class="number">16</span>, model=bx_generic, reset_on_triple_fault=<span class="number">1</span>, cpuid_limit_winnt=<span class="number">0</span>, ignore_bad_msrs=<span class="number">1</span>, mwait_is_nop=<span class="number">0</span></span><br><span class="line">cpuid: <span class="attr">level</span>=<span class="number">6</span>, stepping=<span class="number">3</span>, model=<span class="number">3</span>, family=<span class="number">6</span>, vendor_string=<span class="string">&quot;AuthenticAMD&quot;</span>, brand_string=<span class="string">&quot;AMD Athlon(tm) processor&quot;</span></span><br><span class="line">cpuid: <span class="attr">mmx</span>=<span class="literal">true</span>, apic=xapic, simd=sse2, sse4a=<span class="literal">false</span>, misaligned_sse=<span class="literal">false</span>, sep=<span class="literal">true</span></span><br><span class="line">cpuid: <span class="attr">movbe</span>=<span class="literal">false</span>, adx=<span class="literal">false</span>, aes=<span class="literal">false</span>, sha=<span class="literal">false</span>, xsave=<span class="literal">false</span>, xsaveopt=<span class="literal">false</span>, avx_f16c=<span class="literal">false</span></span><br><span class="line">cpuid: <span class="attr">avx_fma</span>=<span class="literal">false</span>, bmi=<span class="number">0</span>, xop=<span class="literal">false</span>, fma4=<span class="literal">false</span>, tbm=<span class="literal">false</span>, x<span class="number">86_64</span>=<span class="literal">true</span>, <span class="number">1</span>g_pages=<span class="literal">false</span></span><br><span class="line">cpuid: <span class="attr">pcid</span>=<span class="literal">false</span>, fsgsbase=<span class="literal">false</span>, smep=<span class="literal">false</span>, smap=<span class="literal">false</span>, mwait=<span class="literal">true</span></span><br><span class="line">print_timestamps: <span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line">debugger_log: -</span><br><span class="line">magic_break: <span class="attr">enabled</span>=<span class="number">1</span></span><br><span class="line">port_e9_hack: <span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line">private_colormap: <span class="attr">enabled</span>=<span class="number">0</span></span><br><span class="line">clock: <span class="attr">sync</span>=none, time0=local, rtc_sync=<span class="number">0</span></span><br><span class="line"><span class="comment"># no cmosimage</span></span><br><span class="line">log: -</span><br><span class="line">logprefix: %t%e%d</span><br><span class="line">debug: <span class="attr">action</span>=ignore</span><br><span class="line">info: <span class="attr">action</span>=report</span><br><span class="line">error: <span class="attr">action</span>=report</span><br><span class="line">panic: <span class="attr">action</span>=ask</span><br><span class="line">keyboard: <span class="attr">type</span>=mf, serial_delay=<span class="number">250</span>, paste_delay=<span class="number">100000</span>, user_shortcut=none</span><br><span class="line">mouse: <span class="attr">type</span>=ps2, enabled=<span class="literal">false</span>, toggle=ctrl+mbutton</span><br><span class="line">speaker: <span class="attr">enabled</span>=<span class="literal">true</span>, mode=system</span><br><span class="line">parport1: <span class="attr">enabled</span>=<span class="literal">true</span>, file=none</span><br><span class="line">parport2: <span class="attr">enabled</span>=<span class="literal">false</span></span><br><span class="line">com1: <span class="attr">enabled</span>=<span class="literal">true</span>, mode=null</span><br><span class="line">com2: <span class="attr">enabled</span>=<span class="literal">false</span></span><br><span class="line">com3: <span class="attr">enabled</span>=<span class="literal">false</span></span><br><span class="line">com4: <span class="attr">enabled</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>boches加载镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bochs -q -f bochsrc.floppy -unlock</span><br></pre></td></tr></table></figure>

<p>此时可以看到虚拟机输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR: LOADER.BIN FILE NOT FOUND</span><br></pre></td></tr></table></figure>

<h1 id="加载简单的LOADER-BIN"><a href="#加载简单的LOADER-BIN" class="headerlink" title="加载简单的LOADER.BIN"></a>加载简单的LOADER.BIN</h1><p>首先修改加载文件后的跳转地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileLoaded:</span><br><span class="line">  jmp BaseOfLoader:OffsetOfLoader</span><br></pre></td></tr></table></figure>

<p>编写简单的loader.bin文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[org 0x10000]</span><br><span class="line"></span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov ax, 0x00</span><br><span class="line">mov ss, ax</span><br><span class="line">mov sp, 0x7c00</span><br><span class="line"></span><br><span class="line">; display start loader ...</span><br><span class="line">mov ax, 0x1301</span><br><span class="line">mov bx, 0xf</span><br><span class="line">mov dx, 0x200</span><br><span class="line">mov cx, 15</span><br><span class="line">push ax</span><br><span class="line">mov ax, ds</span><br><span class="line">mov es, ax</span><br><span class="line">pop ax</span><br><span class="line">mov bp, StartLoaderText</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">StartLoaderText: db &quot;Start Loader...&quot;</span><br></pre></td></tr></table></figure>

<p>就是在屏幕上输出：<code>Start Loader...</code></p>
<h2 id="加载测试"><a href="#加载测试" class="headerlink" title="加载测试"></a>加载测试</h2><p>测试编译loader.bin</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nasm -f bin loader.asm -o loader.bin</span><br></pre></td></tr></table></figure>

<p>将loader.bin拷贝进软盘中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ./tmp</span><br><span class="line">mount boot.img tmp -t vfat -o loop</span><br><span class="line"><span class="built_in">cp</span> loader.bin tmp</span><br><span class="line"><span class="built_in">sync</span></span><br><span class="line">umount ./tmp</span><br></pre></td></tr></table></figure>

<p>再次运行测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bochs -q -f bochsrc.floppy -unlock</span><br></pre></td></tr></table></figure>

<p>此时可以看到屏幕输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Start Loader...</span><br></pre></td></tr></table></figure>

<p>Loader.bin成功加载</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-Loader引导加载程序</title>
    <url>/posts/de9aab27.html</url>
    <content><![CDATA[<h1 id="Loader需要做的事"><a href="#Loader需要做的事" class="headerlink" title="Loader需要做的事"></a>Loader需要做的事</h1><ul>
<li>检测硬件信息</li>
<li>处理器模式切换</li>
<li>向内核传递数据</li>
</ul>
<h1 id="Loader详解"><a href="#Loader详解" class="headerlink" title="Loader详解"></a>Loader详解</h1><h2 id="基础数据定义和头文件引用"><a href="#基础数据定义和头文件引用" class="headerlink" title="基础数据定义和头文件引用"></a>基础数据定义和头文件引用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[org 0x10000]</span><br><span class="line">jmp LabelStart</span><br><span class="line"></span><br><span class="line">%include &quot;boot/fat12.inc&quot;</span><br><span class="line"></span><br><span class="line">BaseOfKernelFile equ 0x00</span><br><span class="line">OffsetOfKernelFile equ 0x100000</span><br><span class="line"></span><br><span class="line">BaseTmpOfKernelAddr equ 0x00</span><br><span class="line">OffsetTmpOfKernelFile equ 0x7e00</span><br><span class="line"></span><br><span class="line">MemoryStructBufferAddr equ 0x7e00</span><br></pre></td></tr></table></figure>

<p><code>fat12.inc</code>为FAT12文件系统结构。</p>
<p>定义内核程序的起始地址为<code>0x100000</code>（1MB），因为1MB以下的内存并不是全部可用的空间。这段内存被划分为若干个子空间段，可以是内存空间、非内存空间以及地址空间。内核程序很可能超过1MB，所以让内核跳过这段复杂的空间。</p>
<p><code>0x7e00</code>是内核程序的临时转存空间，由于内核读取是通过BIOS中断<code>INT 0x13</code>调用，BIOS在实模式下只支持1MB的物理地址空间寻址，所以需要先存储到临时空间，然后再通过特殊的操作传到1MB以上空间中。当内核程序全部转存到内存空间后，这个临时转存空间可以改为内存结构数据的存储空间，供内核程序在初始化时候使用。</p>
<h2 id="LOADER引导程序入口"><a href="#LOADER引导程序入口" class="headerlink" title="LOADER引导程序入口"></a>LOADER引导程序入口</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SECTION .s16]</span><br><span class="line">[BITS 16]</span><br><span class="line">LableStart:</span><br></pre></td></tr></table></figure>

<p><code>[SECTION .s16]</code>为定义一个<code>.s16</code>的段，<code>[BITS 16]</code>伪指令可以通知编译器编译代码时在16位宽的处理器上运行</p>
<h2 id="开启实模式下4GB寻址功能"><a href="#开启实模式下4GB寻址功能" class="headerlink" title="开启实模式下4GB寻址功能"></a>开启实模式下4GB寻址功能</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SECTION gdt]</span><br><span class="line">LABEL_GDT: dd 0,0</span><br><span class="line">LABEL_DESC_CODE32: dd 0x0000FFFF,0x00CF9A00</span><br><span class="line">LABEL_DESC_DATA32: dd 0x0000FFFF,0x00CF9200</span><br><span class="line"></span><br><span class="line">GdtLen equ $ - LABEL_GDT</span><br><span class="line">GdtPtr dw GdtLen - 1</span><br><span class="line">       dd LABEL_GDT</span><br><span class="line"></span><br><span class="line">SelectorCode32 equ LABEL_DESC_CODE32 - LABEL_GDT</span><br><span class="line">SelectorData32 equ LABEL_DESC_DATA32 - LABEL_GDT</span><br><span class="line"></span><br><span class="line">; ......</span><br><span class="line"></span><br><span class="line">  ; open address A20</span><br><span class="line">  push ax</span><br><span class="line">  in al, 0x92</span><br><span class="line">  or al, 00000010b</span><br><span class="line">  out 0x92, al</span><br><span class="line">  pop ax</span><br><span class="line">  </span><br><span class="line">  cli</span><br><span class="line"></span><br><span class="line">  db 0x66</span><br><span class="line">  lgdt [GdtPtr]</span><br><span class="line"></span><br><span class="line">  mov eax, cr0</span><br><span class="line">  or eax, 1</span><br><span class="line">  mov cr0, eax</span><br><span class="line"></span><br><span class="line">  mov ax, SelectorData32</span><br><span class="line">  mov fs, ax</span><br><span class="line">  mov eax, cr0</span><br><span class="line">  and al, 11111110b</span><br><span class="line">  mov cr0, eax</span><br><span class="line"></span><br><span class="line">  sti</span><br></pre></td></tr></table></figure>

<p>开启地址A20功能，此功能属于历史遗留问题。最初处理器只有20根地址线，只有1MB的寻址能力，如果超过了1MB的寻址范围操作，也只有低20位是有效的。为了保证向下兼容，便出现了一个控制开启&#x2F;禁止1MB以上地址空间的开关。当时的8042键盘控制器上恰好有空闲的端口引脚（输出端口P2，引脚P21），从而使用此引脚作为控制开关，即A20功能。如果A20引脚为低电平，那么只有低20位有效。</p>
<p>开启A20功能的方法：</p>
<ul>
<li>操作键盘控制器，由于键盘控制器是低速设备，以至于功能开启速度过慢</li>
<li>A20快速门（Fast Gate A20），它使用I&#x2F;O端口0x92来处理A20信号线。对于不含键盘控制器的操作系统，就只能使用0x92端口来控制，但是该端口可能被其他设备使用</li>
<li>通过读0xee端口来开启A20信号线，而写该端口则会禁止A20信号线</li>
</ul>
<p>上面代码通过A20快速门来开启A20。</p>
<p>当A20功能开启后，紧接着使用<code>cli</code>指令关闭外部中断，再通过指令LGDT加载保护模式结构数据信息，并置CR0寄存器的第0位来开启保护模式。当进入保护模式后，为FS段寄存器加载新的数据段值，一旦完成数据加载就从保护模式中退出，并开启外部中断。</p>
<p>整个操作实现了保护模式的开启和关闭，其目的是为了FS段寄存器可以在实模式下寻址能力超过1MB，也就是Big Real Mode模式。</p>
<h2 id="FAT12文件系统搜索内核文件程序"><a href="#FAT12文件系统搜索内核文件程序" class="headerlink" title="FAT12文件系统搜索内核文件程序"></a>FAT12文件系统搜索内核文件程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ; search kernel.bin</span><br><span class="line">  mov word [SectorNo], SectorNumOfRootDirStart</span><br><span class="line"></span><br><span class="line">SearchInRootDirBegin:</span><br><span class="line">  cmp word [RootDirSizeForLoop], 0</span><br><span class="line">  jz NoKernelBin</span><br><span class="line">  dec word [RootDirSizeForLoop]</span><br><span class="line">  mov ax, 0x0000</span><br><span class="line">  mov es, ax</span><br><span class="line">  mov bx, 0x8000</span><br><span class="line">  mov ax, [SectorNo]</span><br><span class="line">  mov cl, 1</span><br><span class="line">  call ReadOneSector</span><br><span class="line">  mov si, KernelFileName</span><br><span class="line">  mov di, 0x8000</span><br><span class="line">  cld</span><br><span class="line">  mov dx, 0x10</span><br><span class="line"></span><br><span class="line">SearchForKernelBin:</span><br><span class="line">  cmp dx, 0</span><br><span class="line">  jz GotoNextSectorInRoorDir</span><br><span class="line">  dec dx</span><br><span class="line">  mov cx, 11</span><br><span class="line"></span><br><span class="line">CmpFileName:</span><br><span class="line">  cmp cx, 0</span><br><span class="line">  jz FileNameFound</span><br><span class="line">  dec cx</span><br><span class="line">  lodsb</span><br><span class="line">  cmp al, byte [es:di]</span><br><span class="line">  jz GoOn</span><br><span class="line">  jmp Different</span><br><span class="line"></span><br><span class="line">GoOn:</span><br><span class="line">  inc di</span><br><span class="line">  jmp CmpFileName</span><br><span class="line"></span><br><span class="line">Different:</span><br><span class="line">  and di, 0xffe0</span><br><span class="line">  add di, 0x20</span><br><span class="line">  mov si, KernelFileName</span><br><span class="line">  jmp SearchForKernelBin</span><br><span class="line"></span><br><span class="line">GotoNextSectorInRoorDir:</span><br><span class="line">  add word [SectorNo], 1</span><br><span class="line">  jmp SearchInRootDirBegin</span><br><span class="line"></span><br><span class="line">; display on screen: Error: KERNEL NOT FOUNT</span><br><span class="line">NoKernelBin:</span><br><span class="line">  mov ax, 0x1301</span><br><span class="line">  mov bx, 0x008c</span><br><span class="line">  mov dx, 0x0300 ; row 3</span><br><span class="line">  mov cx, 23</span><br><span class="line">  push ax</span><br><span class="line">  mov ax, ds</span><br><span class="line">  mov es, ax</span><br><span class="line">  pop ax</span><br><span class="line">  mov bp, NoKernelBinMessage</span><br><span class="line">  int 0x10</span><br><span class="line">  jmp $</span><br></pre></td></tr></table></figure>

<h2 id="将KERNEL读取到物理内存中"><a href="#将KERNEL读取到物理内存中" class="headerlink" title="将KERNEL读取到物理内存中"></a>将KERNEL读取到物理内存中</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; found kernel.bin name in root dir</span><br><span class="line">FileNameFound:</span><br><span class="line">  mov ax, RootDirSectors</span><br><span class="line">  and di, 0xffe0</span><br><span class="line">  add di, 0x1a</span><br><span class="line">  mov cx, word [es:di]</span><br><span class="line">  push cx</span><br><span class="line">  add cx, ax</span><br><span class="line">  add cx, SectorBalance</span><br><span class="line">  mov eax, BaseTmpOfKernelAddr ; base of kernel file</span><br><span class="line">  mov es, ax</span><br><span class="line">  mov bx, OffsetTmpOfKernelFile ; offset of kernel file</span><br><span class="line">  mov ax, cx</span><br><span class="line"></span><br><span class="line">GoOnLoadingFile:</span><br><span class="line">  push ax</span><br><span class="line">  push bx</span><br><span class="line">  mov ah, 0x0e</span><br><span class="line">  mov al, &#x27;.&#x27;</span><br><span class="line">  mov bl, 0x0f</span><br><span class="line">  int 0x10</span><br><span class="line">  pop bx</span><br><span class="line">  pop ax</span><br><span class="line"></span><br><span class="line">  mov cl, 1</span><br><span class="line">  call ReadOneSector</span><br><span class="line">  pop ax</span><br><span class="line"></span><br><span class="line">  push cx</span><br><span class="line">  push eax</span><br><span class="line">  push fs</span><br><span class="line">  push edi</span><br><span class="line">  push ds</span><br><span class="line">  push esi</span><br><span class="line"></span><br><span class="line">  mov cx, 0x200</span><br><span class="line">  mov ax, BaseOfKernelFile</span><br><span class="line">  mov fs, ax</span><br><span class="line">  mov edi, dword [OffsetOfKernelFileCount]</span><br><span class="line"></span><br><span class="line">  mov ax, BaseTmpOfKernelAddr</span><br><span class="line">  mov ds, ax</span><br><span class="line">  mov esi, OffsetTmpOfKernelFile</span><br><span class="line"></span><br><span class="line">MovKernel:</span><br><span class="line">  mov al, byte [ds:esi]</span><br><span class="line">  mov byte [fs:edi], al</span><br><span class="line">  inc esi</span><br><span class="line">  inc edi</span><br><span class="line"></span><br><span class="line">  loop MovKernel</span><br><span class="line"></span><br><span class="line">  mov eax, 0x1000</span><br><span class="line">  mov ds, eax</span><br><span class="line">  mov dword [OffsetOfKernelFileCount], edi</span><br><span class="line"></span><br><span class="line">  pop esi</span><br><span class="line">  pop ds</span><br><span class="line">  pop edi</span><br><span class="line">  pop fs</span><br><span class="line">  pop eax</span><br><span class="line">  pop cx</span><br><span class="line"></span><br><span class="line">  call GetFATEntry</span><br><span class="line">  cmp ax, 0xfff</span><br><span class="line">  jz FileLoaded</span><br><span class="line">  push ax</span><br><span class="line">  mov dx, RootDirSectors</span><br><span class="line">  add ax, dx</span><br><span class="line">  add ax, SectorBalance</span><br><span class="line">  jmp GoOnLoadingFile</span><br></pre></td></tr></table></figure>

<p>这部分负责将内核程序读取到临时转存空间中，随后再将它移动到1MB以上的物理内存空间。为了避免转存发生错误，一个字节一个字节的复制，借助汇编的<code>LOOP</code>指令可以完成。由于内核体积庞大必须逐个簇读取和转存，那么每次转存的时候必须保存目标偏移，该值（<code>EDI</code>寄存器）保存于临时变量<code>OffsetOfKernelFileCount</code>中。</p>
<h2 id="加载完成后显示字母G"><a href="#加载完成后显示字母G" class="headerlink" title="加载完成后显示字母G"></a>加载完成后显示字母G</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileLoaded:</span><br><span class="line">  mov ax, 0xb800</span><br><span class="line">  mov gs, ax</span><br><span class="line">  mov ah, 0x0f ; 0000 black background, 1111 white word</span><br><span class="line">  mov al, &#x27;G&#x27;</span><br><span class="line">  mov [gs:((80*0+39)*2)], ax ; 0 row, 39 colum</span><br></pre></td></tr></table></figure>

<h2 id="关闭软驱马达"><a href="#关闭软驱马达" class="headerlink" title="关闭软驱马达"></a>关闭软驱马达</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KillMotor:</span><br><span class="line">  push dx</span><br><span class="line">  mov dx, 0x03f2</span><br><span class="line">  mov al, 0</span><br><span class="line">  out dx, al</span><br><span class="line">  pop dx</span><br></pre></td></tr></table></figure>

<p>关闭软驱马达是通过向I&#x2F;O端口<code>0x3f2</code>写入控制命令实现的，此端口控制着软盘驱动器的不少硬件功能</p>
<p><img src="https://img.ansore.de/2022/07/9/24e2e9db417aec58589dbbc4e5ad08fd.png" alt="Screenshot_20220709_004852"></p>
<p>内核程序从软盘加载到内存，可以向此I&#x2F;O端口写入0关闭全部软盘驱动器。在使用OUT汇编指令操作I&#x2F;O端口时，需要注意8位端口与16位端口的使用区别。</p>
<blockquote>
<p>OUT指令的源操作数根据端口位宽可以选用AL&#x2F;AX&#x2F;EAX寄存器；目的操作数可以是立即数或DX寄存器，其中立即数的取值范围只能是8位宽（0~0xFF），而DX寄存器允许的取值范围是16位宽（0~0xFFFF）</p>
</blockquote>
<h2 id="物理地址空间信息获取"><a href="#物理地址空间信息获取" class="headerlink" title="物理地址空间信息获取"></a>物理地址空间信息获取</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ; get memory address size type</span><br><span class="line">  mov ax, 0x1301</span><br><span class="line">  mov bx, 0xf</span><br><span class="line">  mov dx, 0x400</span><br><span class="line">  mov cx, 24</span><br><span class="line">  push ax</span><br><span class="line">  mov ax, ds</span><br><span class="line">  mov es, ax</span><br><span class="line">  pop ax</span><br><span class="line">  mov bp, StartGetMemStructMessage</span><br><span class="line">  int 0x10</span><br><span class="line"></span><br><span class="line">  mov ebx, 0</span><br><span class="line">  mov ax, 0x00</span><br><span class="line">  mov es, ax</span><br><span class="line">  mov di, MemoryStructBufferAddr</span><br><span class="line"></span><br><span class="line">GetMemStruct:</span><br><span class="line">  mov eax, 0x0e820</span><br><span class="line">  mov ecx, 20</span><br><span class="line">  mov edx, 0x534d4150</span><br><span class="line">  int 0x15</span><br><span class="line">  jc GetMemFailed</span><br><span class="line">  add di, 20</span><br><span class="line"></span><br><span class="line">  cmp ebx, 0</span><br><span class="line">  jne GetMemStruct</span><br><span class="line">  jmp GetMemOk</span><br><span class="line"></span><br><span class="line">GetMemFailed:</span><br><span class="line">  mov ax, 0x1301</span><br><span class="line">  mov bx, 0x008c</span><br><span class="line">  mov dx, 0x0500</span><br><span class="line">  mov cx, 23</span><br><span class="line">  push ax</span><br><span class="line">  mov ax, ds</span><br><span class="line">  mov es, ax</span><br><span class="line">  pop ax</span><br><span class="line">  mov bp, GetMemStructErrorMessage</span><br><span class="line">  int 0x10</span><br><span class="line">  jmp $</span><br><span class="line"></span><br><span class="line">GetMemOk:</span><br><span class="line">  mov ax, 0x1301</span><br><span class="line">  mov bx, 0x000f</span><br><span class="line">  mov dx, 0x0600</span><br><span class="line">  mov cx, 29</span><br><span class="line">  push ax</span><br><span class="line">  mov ax, ds</span><br><span class="line">  mov es, ax</span><br><span class="line">  pop ax</span><br><span class="line">  mov bp, GetMemStructOkMessage</span><br><span class="line">  int 0x10</span><br></pre></td></tr></table></figure>

<p>物理地址空间信息由一个结构体数组构成，计算机平台的地址空间划分情况都能从这个结构体数组中反映出来，它记录的地址空间类型包括可用物理内存地址空间、设备寄存器地址空间、内存空洞等。</p>
<p>这段程序借助BIOS中断服务程序<code>INT 0x15</code>来获取物理地址空间信息，并将其保存到<code>0x7e00</code>地址处的临时空间内，操作系统会在初始化内存管理单元时解析该结构体数组。</p>
<h2 id="显示AL寄存器"><a href="#显示AL寄存器" class="headerlink" title="显示AL寄存器"></a>显示AL寄存器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; display num in al</span><br><span class="line">DisplauAL:</span><br><span class="line">  push ecx</span><br><span class="line">  push edx</span><br><span class="line">  push edi</span><br><span class="line"></span><br><span class="line">  mov edi, [DispalyPosition]</span><br><span class="line">  mov ah, 0x0f</span><br><span class="line">  mov dl, al</span><br><span class="line">  shr al, 4</span><br><span class="line">  mov ecx, 2</span><br><span class="line"></span><br><span class="line">.begin:</span><br><span class="line">  and al, 0x0f</span><br><span class="line">  cmp al, 9</span><br><span class="line">  jz .1</span><br><span class="line">  add al, &#x27;0&#x27;</span><br><span class="line">  jmp .2</span><br><span class="line"></span><br><span class="line">.1:</span><br><span class="line">  sub al, 0x0a</span><br><span class="line">  add al, &#x27;A&#x27;</span><br><span class="line"></span><br><span class="line">.2:</span><br><span class="line">  mov [gs:edi], ax</span><br><span class="line">  add edi, 2</span><br><span class="line"></span><br><span class="line">  mov al, dl</span><br><span class="line">  loop .begin</span><br><span class="line">  mov [DispalyPosition], edi</span><br><span class="line"></span><br><span class="line">  pop edi</span><br><span class="line">  pop edx</span><br><span class="line">  pop ecx</span><br><span class="line"></span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

<p><code>DisplauAL</code>的功能：显示16进制数字</p>
<ul>
<li>AL&#x3D;要显示的十六进制数</li>
</ul>
<p>先保存即将变更的寄存器值到栈中，然后把变量<code>DispalyPosition</code>保存的屏幕偏移值（字符游标索引值）载入到<code>edi</code>寄存器中，并向AH寄存器存入字体的颜色属性值。为了先显示AL寄存器的高四位数据，暂时吧AL寄存器的低4位数据保存在DL寄存器。然后将AL寄存器的高4位与9比较，如果大于9，则减去<code>0x0a</code>并与字符<code>A</code>相加，否则与字符<code>0</code>相加。然后将AX寄存器（AL与AH寄存器组合而成）的值，保存到GS段寄存器的基地址、<code>DispalyPosition</code>变量为偏移的显示字符内存空间中。</p>
<h2 id="显示视频图像芯片的查询信息"><a href="#显示视频图像芯片的查询信息" class="headerlink" title="显示视频图像芯片的查询信息"></a>显示视频图像芯片的查询信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; set the SVGA mode (VESA VBE)</span><br><span class="line">mov ax, 0x4f02</span><br><span class="line">mov bx, 0x4180 ; model: 0x180 or 0x143</span><br><span class="line">int 0x10</span><br><span class="line"></span><br><span class="line">cmp ax, 0x004f</span><br><span class="line">jnz SetSVGAModeVesaVbeFailed</span><br></pre></td></tr></table></figure>

<p>这段程序设置了SVGA芯片的显示模式， <code>0x180</code> 和 <code>0x143</code>是显示模式：</p>
<p><img src="https://img.ansore.de/2022/07/13/537f8ad772fe8226b1538fc74de3e000.png" alt="Screenshot_20220713_225659"></p>
<h2 id="切换保护模式需要的系统数据结构"><a href="#切换保护模式需要的系统数据结构" class="headerlink" title="切换保护模式需要的系统数据结构"></a>切换保护模式需要的系统数据结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SECTION gdt]</span><br><span class="line">GDT: dd 0,0</span><br><span class="line">DESC_CODE32: dd 0x0000FFFF,0x00CF9A00</span><br><span class="line">DESC_DATA32: dd 0x0000FFFF,0x00CF9200</span><br><span class="line"></span><br><span class="line">GdtLen equ $ - GDT</span><br><span class="line">GdtPtr dw GdtLen - 1</span><br><span class="line">       dd GDT</span><br><span class="line"></span><br><span class="line">SelectorCode32 equ DESC_CODE32 - GDT</span><br><span class="line">SelectorData32 equ DESC_DATA32 - GDT</span><br></pre></td></tr></table></figure>

<p>这是个临时的GDT表。为了避免保护模式段结构的复杂型，此处将代码段和数据段的段地址都设置在0x00000000地址处，此处限长位0xffffffff，即段可以索引0~4GB的内存地址空间。</p>
<p>GDT表的基地址和长度必须借助<code>LGDT</code>指令才能加载得到<code>GDTR</code>寄存器，而GDTR寄存器是一个6B的结构，结构中的低2B保存GDT表的长度，高4B保存GDT表的基地址，标识符GdtPrt是此结构的起始地址。这个GDT表用于开启Big Real Mode模式，由于其数据结构被设置成平坦地址空间（0~4GB地址空间），所以FS段寄存器可以寻址整个4GB内存地址空间。</p>
<p><code>SelectorCode32</code>和<code>SelectorData32</code>是两个段选择子，它们是段描述符在GDT表中的索引号。</p>
<h2 id="开辟IDT内存空间"><a href="#开辟IDT内存空间" class="headerlink" title="开辟IDT内存空间"></a>开辟IDT内存空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; tmp IDT</span><br><span class="line">IDT:</span><br><span class="line">  times 0x50 dq 0</span><br><span class="line">IDT_END:</span><br><span class="line"></span><br><span class="line">IDT_POINTER:</span><br><span class="line">  dw IDT_END - IDT - 1</span><br><span class="line">  dd IDT</span><br></pre></td></tr></table></figure>

<h2 id="切换到保护模式"><a href="#切换到保护模式" class="headerlink" title="切换到保护模式"></a>切换到保护模式</h2><p>在处理器切换到保护模式之前，引导加载程序已使用CLI指令禁止外部中断，所以在切换到保护模式的过程中不会产生中断和异常，进而不必完整初始化IDT，只要有相应的结构体即可。如果能保证在切换过程中不会产生任何异常，即使没有IDT也可以。</p>
<p>处理器进入保护模式的标志：执行MOV汇编指令置位CR0控制寄存器的PE标志位（可同时置CR0寄存器的PG标志位开启分页机制）。进入保护模式后，处理器将从0特权级开始执行。具体步骤如下：</p>
<ol>
<li>执行<code>CLI</code>指令禁止可屏蔽的硬件中断，对于不可屏蔽中断NMI只能借助外部电路才能禁止。（模式切换过程中必须保证在切换过程中不能产生中断和异常）</li>
<li>执行<code>LGDT</code>指令将GDT的基地址和长度加载到<code>GDTR</code>寄存器</li>
<li>执行<code>MOV CR0</code>指令置CR0控制寄存器的PE标志位。（可同时置CR0控制寄存器的PG标志位）</li>
<li>一旦<code>MOV CR0</code>指令执行结束，其后必须执行一条远跳转（far JMP）或远调用（far CALL）指令，切换到保护模式的代码区执行</li>
<li>通过执行<code>JMP</code>或<code>CALL</code>指令，可以改变处理器的执行流水先，进而使处理器加载执行保护模式的代码段</li>
<li>如果开启分页机制，那么<code>MOV CR0</code>指令和<code>JMP/CALL</code>指令必须位于同一地址映射页面内。（因为保护模式和分页机制使能后的物理地址，与执行<code>JMP/CALL</code>指令的线性地址相同）至于<code>JMP</code>或<code>CALL</code>指令的目标地址，则无需进行同一性地址映射（线性地址和物理地址重合）</li>
<li>如需使用<code>LDT</code>，则需借助<code>LLDT</code>汇编指令将GDT内的LDT段选择子加载到LDTR寄存器中。</li>
<li>执行LTR指令将一个TSS段描述符的段选择子加载到TR任务寄存器。处理器对TSS段结构无特殊要求，凡是可写内存空间都可以</li>
<li>进入保护模式后，数据段寄存器仍然保留这实模式的段数据，必须重新加载数据段选择子或使用JMP&#x2F;CALL执行新任务，便可以将其更新为保护模式。对于不使用的数据段寄存器（DS和SS寄存器除外），可将NULL段选择子加载到其中。</li>
<li>执行LIDT指令，将保护模式下的IDT表的基地址和长度加载到IDTR寄存器</li>
<li>执行STI指令使能可屏蔽硬件中断，并执行必要的硬件操作使能NMI不可屏蔽中断。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; init IDT GDT goto protect mode</span><br><span class="line">cli ; close interrupt</span><br><span class="line"></span><br><span class="line">db 0x66</span><br><span class="line">lgdt [GdtPtr]</span><br><span class="line"></span><br><span class="line">mov eax, cr0</span><br><span class="line">or eax, 1</span><br><span class="line">mov cr0, eax</span><br><span class="line"></span><br><span class="line">jmp dword SelectorCode32:GoToTmpProtect</span><br></pre></td></tr></table></figure>

<p><code>db 0x66</code>这个字节是LGDT和LIDT汇编指令的前缀，用于修饰当前指令的操作数是32位宽。而最后一条远跳指令明确指定目标代码段选择子和段内偏移地址。</p>
<h2 id="从保护模式到IA-32e模式"><a href="#从保护模式到IA-32e模式" class="headerlink" title="从保护模式到IA-32e模式"></a>从保护模式到IA-32e模式</h2><p>在进入IA-32e模式前，处理器依然要位IA-32e模式准备执行代码，必要的系统数据结构以及配置相关控制寄存器。此外处理器只能在开启分页机制的保护模式下才能切换到IA-32e模式</p>
<ul>
<li>系统数据结构。系统各个描述符表寄存器必须重新加载（GDRT、LDTR、IDTR、TR）为IA-32e模式的64位描述符表</li>
<li>中断和异常。在IDTR寄存器更新为64位中断描述符表IDT前不要触发中断和异常。</li>
</ul>
<p><code>IA32_EFER</code>寄存器（位于MSR寄存器组）的<code>LME</code>标志位用于控制IA-32e模式的开启和关闭，该寄存器会伴随处理器的重启而清零。IA-32e模式的页管理机制将物理地址扩展为4层页表结构。IA-32e模式激活前（<code>CR0.PG=1</code>，处理器运行在32位兼容模式），CR3寄存器仅有低32位可写入数据，从而限制页表只能寻址4GB的物理内存空间、</p>
<p>IA-32e模式的初始化步骤：</p>
<ol>
<li>在保护模式下，使用<code>MOV CR0</code>汇编指令复位<code>CR0</code>控制寄存器的PG标志位，以关闭分页机制。</li>
<li>置位<code>CR4</code>控制寄存器的PAE标志位，开启物理地址扩展功能（PAE）。在IA-32e模式的初始化过程中，如果PAE开启失败，将会产生通用保护性异常。</li>
<li>将页目录（顶层页表<code>PML4</code>）的物理基地址加载到<code>CR3</code>控制寄存器</li>
<li>置<code>IA32_EFER</code>寄存器的<code>LME</code>标志位，开启IA-32e模式</li>
<li>置CR0控制寄存器的PG标志位开启分页机制，此时处理器会自从置<code>IA32_EFER</code>的LMA标志位。当执行MOV CR0指令开启分页机制时，其后指令必须位于同一性地址映射的页面内（直到处理器进入IA-32e模式后，才可以使用非同一性地址映射的页面）</li>
</ol>
<p>如果试图改变<code>IA32_EFER</code>、<code>CR0.PG</code>和<code>CR4.PAE</code>等影响IA-32e模式开启的标志位，处理器会进行64位模式的一致性检测，以确保处理器不会进入未定义模式或不可预测状态。如果一致性检测失败，处理器将会产生通用保护性异常（#GP）。以下之一会导致检测失败：</p>
<ul>
<li>当开启分页机制后，再试图使能或禁止IA-32e模式</li>
<li>当开启IA-32e模式后，试图在开启物理地址扩展（<code>PAE</code>）功能前使能分页机制</li>
<li>在激活IA-32e模式后，试图禁止<code>PAE</code></li>
<li>当<code>CS</code>寄存器的L位被置位时，在试图激活IA-32e模式</li>
<li>如果<code>TR</code>寄存器加载的是16位<code>TSS</code>段结构</li>
</ul>
<h2 id="IA-32e模式的临时GDT表"><a href="#IA-32e模式的临时GDT表" class="headerlink" title="IA-32e模式的临时GDT表"></a>IA-32e模式的临时GDT表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SECTION gdt64]</span><br><span class="line">GDT64: dq 0x0000000000000000</span><br><span class="line">DESC_CODE64: dq 0x0020980000000000</span><br><span class="line">DESC_DATA64: dq 0x0000920000000000</span><br><span class="line"></span><br><span class="line">GdtLen64 equ $ - GDT64</span><br><span class="line">GdtPtr64 dw GdtLen64 - 1</span><br><span class="line">         dd GDT64</span><br><span class="line"></span><br><span class="line">SelectorCode64 equ DESC_CODE64 - GDT64</span><br><span class="line">SelectorData64 equ DESC_DATA64 - GDT64</span><br></pre></td></tr></table></figure>

<p>IA-32e模式简化了保护模式的段结构，删掉冗余的段基地址和段限长，使段直接覆盖整个线性地址空间，进而变成平坦地址空间。</p>
<h2 id="初始化各个段寄存器以及栈指针"><a href="#初始化各个段寄存器以及栈指针" class="headerlink" title="初始化各个段寄存器以及栈指针"></a>初始化各个段寄存器以及栈指针</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SECTION .s32]</span><br><span class="line">[BITS 32]</span><br><span class="line">GoToTmpProtect:</span><br><span class="line">  ; go to tmp long mode</span><br><span class="line">  mov ax, 0x10</span><br><span class="line">  mov ds, ax</span><br><span class="line">  mov es, ax</span><br><span class="line">  mov fs, ax</span><br><span class="line">  mov ss, ax</span><br><span class="line">  mov esp, 0x7e00</span><br><span class="line">  call SupportLongMode</span><br><span class="line">  test eax, eax</span><br><span class="line">  jz NoSupport</span><br></pre></td></tr></table></figure>

<h2 id="检测处理器是否支持IA-32e模式"><a href="#检测处理器是否支持IA-32e模式" class="headerlink" title="检测处理器是否支持IA-32e模式"></a>检测处理器是否支持IA-32e模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; test support long mode or not</span><br><span class="line">SupportLongMode:</span><br><span class="line">  mov eax, 0x80000000</span><br><span class="line">  cpuid</span><br><span class="line">  cmp eax, 0x80000001</span><br><span class="line">  setnb al</span><br><span class="line">  jb SupportLongModeDone</span><br><span class="line">  mov eax, 0x80000001</span><br><span class="line">  cpuid</span><br><span class="line">  bt edx, 29</span><br><span class="line">  setc al</span><br><span class="line"></span><br><span class="line">SupportLongModeDone:</span><br><span class="line">  movzx eax, al</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">NoSupport:</span><br><span class="line">  jmp $</span><br></pre></td></tr></table></figure>

<p>由于<code>CPUID</code>指令的扩展功能项<code>0x80000001</code>的第29位，指示处理器是否支持IA-32e模式。首先检测当前处理器对<code>CPUID</code>指令的支持情况，判断该指令的最大扩展功能号是否超过<code>0x80000000</code>。只有当<code>CPUID</code>指令的扩展功能号大于等于<code>0x80000001</code>时，才有可能支持64位长模式。所以需要先检测<code>CPUID</code>指令支持的扩展功能号，再读取相应的标志位。最后将读取的结果存入EAX寄存器供模块调用者判断。</p>
<p><code>CPUID</code>指令：</p>
<ul>
<li><code>EFLAGS</code>标志寄存器的ID标志位（第21位）表明处理器是否支持<code>CPUID</code>指令，如果程序可以操作（置位和复位）此标志位，则说明处理器支持<code>CPUID</code>指令，<code>CPUID</code>指令在64位模式和32位模式执行效果相同。</li>
<li><code>CPUID</code>指令会根据EAX寄存器传入的基础功能号，查询处理器的鉴定信息和机能信息，其返回结构将保存在<code>EAX</code>、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>寄存器中</li>
</ul>
<h2 id="配置临时页目录项和页表项"><a href="#配置临时页目录项和页表项" class="headerlink" title="配置临时页目录项和页表项"></a>配置临时页目录项和页表项</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; init temporary page table 0x90000</span><br><span class="line">mov dword [0x90000], 0x91007</span><br><span class="line">mov dword [0x90800], 0x91007</span><br><span class="line">mov dword [0x91000], 0x92007</span><br><span class="line">mov dword [0x92000], 0x000083</span><br><span class="line">mov dword [0x92008], 0x200083</span><br><span class="line">mov dword [0x92010], 0x400083</span><br><span class="line">mov dword [0x92018], 0x600083</span><br><span class="line">mov dword [0x92020], 0x800083</span><br><span class="line">mov dword [0x92028], 0xa00083</span><br></pre></td></tr></table></figure>

<p>将IA-32e模式的页目录首地址设置在<code>0x90000</code>处，并相继配置各级页表项的值（该值由页表起始地址和页属性组成）。</p>
<h2 id="重新加载全局描述符表GDT"><a href="#重新加载全局描述符表GDT" class="headerlink" title="重新加载全局描述符表GDT"></a>重新加载全局描述符表GDT</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; load GDTR</span><br><span class="line">db 0x66</span><br><span class="line">lgdt [GdtPtr64]</span><br><span class="line">mov ax, 0x10</span><br><span class="line">mov ds, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov fs, ax</span><br><span class="line">mov gs, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov esp, 0x7e00</span><br></pre></td></tr></table></figure>

<p>使用<code>LGDT</code>汇编指令，加载IA-32e模式的临时GDT表到GDTR寄存器中，并将临时GDT表的数据段初始化到各个数据段寄存器（除了CS段寄存器），由于CS寄存器不能采用直接复制方式来该表，所以必须借助跨段跳转指令（far JMP）或跨段调用指令（far CALL）才能改变</p>
<h2 id="开启物理地址扩展功能（PAE）"><a href="#开启物理地址扩展功能（PAE）" class="headerlink" title="开启物理地址扩展功能（PAE）"></a>开启物理地址扩展功能（PAE）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; open PAE</span><br><span class="line">mov eax, cr4</span><br><span class="line">bts eax, 5</span><br><span class="line">mov cr4, eax</span><br></pre></td></tr></table></figure>

<p>CR4控制寄存器的第5位是PAE功能的标志位，置位该标志位可开启PAE。</p>
<h2 id="CR3控制寄存器设置"><a href="#CR3控制寄存器设置" class="headerlink" title="CR3控制寄存器设置"></a>CR3控制寄存器设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; load cr3</span><br><span class="line">mov eax, 0x90000</span><br><span class="line">mov cr3, eax</span><br></pre></td></tr></table></figure>

<p>将页目录基地址加载到CR3控制寄存器。</p>
<h2 id="置位IA32-EFER寄存器LME标志位激活IA-32e模式"><a href="#置位IA32-EFER寄存器LME标志位激活IA-32e模式" class="headerlink" title="置位IA32_EFER寄存器LME标志位激活IA-32e模式"></a>置位IA32_EFER寄存器LME标志位激活IA-32e模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; enble long-mode</span><br><span class="line">mov ecx, 0x0c0000080 ; IA32_EFER</span><br><span class="line">rdmsr</span><br><span class="line"></span><br><span class="line">bts eax, 8</span><br><span class="line">wrmsr</span><br></pre></td></tr></table></figure>

<ul>
<li><p>借助<code>RDMSR/WRMSR</code>指令可以访问64位的<code>MSR</code>寄存器。在访问<code>MSR</code>寄存器前，必须向<code>ECX</code>寄存器（在64位模式下，<code>RCX</code>寄存器的高32位被忽略）传入寄存器地址。而目标<code>MSR</code>寄存器则是由<code>EDX:EAX</code>组成的64位寄存器代表，其中<code>EDX</code>寄存器保存<code>MSR</code>寄存器的高32位，<code>EAX</code>寄存器保存低32位。（64位模式下，<code>RAX</code>和<code>RDX</code>寄存器的高32位均为0）</p>
</li>
<li><p><code>RDMSR</code>与<code>WRMSR</code>指令必须在0特权级或者实模式下执行。在使用这两条指令前，应该使用<code>CPUID</code>指令（<code>CPUID.01h:EDX[5]=1</code>）来检测处理器是否支持<code>MSR</code>寄存器组。</p>
</li>
</ul>
<h2 id="使能分页寄存器"><a href="#使能分页寄存器" class="headerlink" title="使能分页寄存器"></a>使能分页寄存器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; open PE and paging</span><br><span class="line">mov eax, cr0</span><br><span class="line">bts eax, 0</span><br><span class="line">bts eax, 31</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure>

<p>置位CR0控制寄存器的PG标志位。到这里处理器进入IA-32e模式。但是处理器目前还在执行保护模式的程序，这种状态叫做兼容模式，即运行在IA-32e模式下的32位模式程序。若要真正运行在IA-32e模式，还需要一条跨段跳转&#x2F;调用指令将CS段寄存器的值更新为IA-32e模式的代码段描述符。</p>
<h2 id="从Loader跳转到内核程序"><a href="#从Loader跳转到内核程序" class="headerlink" title="从Loader跳转到内核程序"></a>从Loader跳转到内核程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp SelectorCode64:OffsetOfKernelFile</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>开启bochs虚拟机，使用<code>b</code>命令在<code>0x100000</code>处设置一个断点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Num Type           Disp Enb Address</span><br><span class="line">  1 pbreakpoint    keep y   0x000000100000 </span><br></pre></td></tr></table></figure>

<p><code>c</code>执行到端点处，查看各个段寄存器状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">es:0x0010, dh=0x00009300, dl=0x00000000, valid=1</span><br><span class="line">	Data segment, base=0x00000000, limit=0x00000000, Read/Write, Accessed</span><br><span class="line">cs:0x0008, dh=0x00209900, dl=0x00000000, valid=1</span><br><span class="line">	Code segment, base=0x00000000, limit=0x00000000, Execute-Only, Non-Conforming, Accessed, 64-bit</span><br><span class="line">ss:0x0010, dh=0x00009300, dl=0x00000000, valid=1</span><br><span class="line">	Data segment, base=0x00000000, limit=0x00000000, Read/Write, Accessed</span><br><span class="line">ds:0x0010, dh=0x00009300, dl=0x00000000, valid=1</span><br><span class="line">	Data segment, base=0x00000000, limit=0x00000000, Read/Write, Accessed</span><br><span class="line">fs:0x0010, dh=0x00009300, dl=0x00000000, valid=1</span><br><span class="line">	Data segment, base=0x00000000, limit=0x00000000, Read/Write, Accessed</span><br><span class="line">gs:0x0010, dh=0x00009300, dl=0x00000000, valid=1</span><br><span class="line">	Data segment, base=0x00000000, limit=0x00000000, Read/Write, Accessed</span><br><span class="line">ldtr:0x0000, dh=0x00008200, dl=0x0000ffff, valid=1</span><br><span class="line">tr:0x0000, dh=0x00008b00, dl=0x0000ffff, valid=1</span><br><span class="line">gdtr:base=0x0000000000010064, limit=0x17</span><br><span class="line">idtr:base=0x0000000000000000, limit=0x3ff</span><br></pre></td></tr></table></figure>

<p>可以看出所有段寄存器均被赋值为IA-32a模式的段描述符，经过跳转后的CS段寄存器，它也运行在IA-32e模式下。</p>
<p><code>q</code>退出时也可看到状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00015213659i[      ] dbg: Quit</span><br><span class="line">00015213659i[CPU0  ] CPU is in long mode (active)</span><br><span class="line">00015213659i[CPU0  ] CS.mode = 64 bit</span><br><span class="line">00015213659i[CPU0  ] SS.mode = 64 bit</span><br><span class="line">00015213659i[CPU0  ] EFER   = 0x00000500</span><br><span class="line">00015213659i[CPU0  ] | RAX=00000000e0000011  RBX=0000000000000000</span><br><span class="line">00015213659i[CPU0  ] | RCX=00000000c0000080  RDX=0000000000000000</span><br><span class="line">00015213659i[CPU0  ] | RSP=0000000000007e00  RBP=00000000000094cd</span><br><span class="line">00015213659i[CPU0  ] | RSI=00000000000080ae  RDI=000000000000c800</span><br><span class="line">00015213659i[CPU0  ] |  R8=0000000000000000   R9=0000000000000000</span><br><span class="line">00015213659i[CPU0  ] | R10=0000000000000000  R11=0000000000000000</span><br><span class="line">00015213659i[CPU0  ] | R12=0000000000000000  R13=0000000000000000</span><br><span class="line">00015213659i[CPU0  ] | R14=0000000000000000  R15=0000000000000000</span><br><span class="line">00015213659i[CPU0  ] | IOPL=0 id vip vif ac vm rf nt of df if tf sf zf af pf cf</span><br><span class="line">00015213659i[CPU0  ] | SEG sltr(index|ti|rpl)     base    limit G D</span><br><span class="line">00015213659i[CPU0  ] |  CS:0008( 0001| 0|  0) 00000000 00000000 0 0</span><br><span class="line">00015213659i[CPU0  ] |  DS:0010( 0002| 0|  0) 00000000 00000000 0 0</span><br><span class="line">00015213659i[CPU0  ] |  SS:0010( 0002| 0|  0) 00000000 00000000 0 0</span><br><span class="line">00015213659i[CPU0  ] |  ES:0010( 0002| 0|  0) 00000000 00000000 0 0</span><br><span class="line">00015213659i[CPU0  ] |  FS:0010( 0002| 0|  0) 00000000 00000000 0 0</span><br><span class="line">00015213659i[CPU0  ] |  GS:0010( 0002| 0|  0) 00000000 00000000 0 0</span><br><span class="line">00015213659i[CPU0  ] |  MSR_FS_BASE:0000000000000000</span><br><span class="line">00015213659i[CPU0  ] |  MSR_GS_BASE:0000000000000000</span><br><span class="line">00015213659i[CPU0  ] | RIP=0000000000100000 (0000000000100000)</span><br><span class="line">00015213659i[CPU0  ] | CR0=0xe0000011 CR2=0x0000000000000000</span><br><span class="line">00015213659i[CPU0  ] | CR3=0x0000000000090000 CR4=0x00000020</span><br><span class="line">00015213659i[CMOS  ] Last time is 1657731512 (Thu Jul 14 00:58:32 2022)</span><br><span class="line">00015213659i[XGUI  ] Exit</span><br><span class="line">00015213659i[SIM   ] quit_sim called with exit code 0</span><br></pre></td></tr></table></figure>

<p>随着Loader引导加载程序最后一条跳转指令，处理器的控制权就到了内核程序上。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-控制寄存器</title>
    <url>/posts/ea957129.html</url>
    <content><![CDATA[<p> <code>GDT</code>、<code>LDT</code>和<code>IDT</code>表都是描述符表。描述符表是由若干个描述符组成，每个描述符占用8个字节的内存空间，每个描述符表内最多可以有（8K）8129个描述符。描述符是描述一个段的大小，地址及各种状态的。</p>
<h1 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h1><p>CR0～4：</p>
<p><img src="https://img.ansore.de/2022/07/25/daa8767af692da6ae6f43fd0008a21a5.png" alt="Screenshot_20220725_003011"></p>
<p><code>GDTR</code>、<code>IDTR</code>等：</p>
<p><img src="https://img.ansore.de/2022/07/25/b7d8383b21e74abe2fe9a8d5da176e93.png" alt="Screenshot_20220725_002823"></p>
<h1 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h1><h2 id="全局描述符GDT"><a href="#全局描述符GDT" class="headerlink" title="全局描述符GDT"></a>全局描述符GDT</h2><p>全局描述表（GDT Global Descriptor Table）。在整个系统中，全局描述符表<code>GDT</code>只有一张(一个处理器对应一个GDT)，<code>GDT</code>可以被放在内存的任何位置。系统用<code>GDTR</code>寄存器存放当前<code>GDT</code>表的基地址。在保护模式下，对一个段的描述包括3个方面的因素：<code>Base Address</code>、<code>Limit</code>、<code>Access</code>，它们加在一起被放在一个64-bit长的数据结构中，被称为段描述符。段描述符结构如下：</p>
<p><img src="https://img.ansore.de/2022/07/16/905187cc02cb7aed4156b74d2d9b4e5b.png" alt="GDT"></p>
<p><img src="https://img.ansore.de/2022/07/24/a06576c7eb380b99b8051096b29616ba.png" alt="Screenshot_20220724_234640"></p>
<h2 id="GDTR"><a href="#GDTR" class="headerlink" title="GDTR"></a>GDTR</h2><p><code>GDTR</code>是一个长度为48bit的寄存器，内容为一个32位的基地址和一个16位的段限。其中32位的基址是指<code>GDT</code>在内存中的地址。基地址指定<code>GDT</code>表中字节0在线性地址空间中的地址，表长度指明<code>GDT</code>表的字节长度值。指令<code>LGDT</code>和<code>SGDT</code>分别用于加载和保存<code>GDTR</code>寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成<code>0xFFFF</code>。在保护模式初始化过程中必须给<code>GDTR</code>加载一个新值。</p>
<p>段描述符使用数组存储，使用<code>LGDT</code>指令将<code>GDT</code>的入口地址装入<code>GDTR</code>寄存器。基地址指定<code>GDT</code>表中字节0在线性地址空间中的地址，表长度指明<code>GDT</code>表的字节长度值。指令<code>LGDT</code>和<code>SGDT</code>分别用于加载和保存<code>GDTR</code>寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成<code>0xFFFF</code>。在保护模式初始化过程中必须给<code>GDTR</code>加载一个新值。</p>
<h2 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h2><p><img src="https://img.ansore.de/2022/07/24/c14511da8b81d3d2ca08189e8b5d21c9.png" alt="Screenshot_20220724_234238"></p>
<p>段选择子是一个16位的数据结构，其索引号作为GDT表的下标，索引号只有13位，所以GDT表最多有8192个元素，其结构如下：</p>
<p><img src="https://img.ansore.de/2022/07/16/f2f5153bed0b2eecb342a35a3186936a.png" alt="段选择子"></p>
<p>段选择子包括三部分：描述符索引（<code>index</code>）、<code>TI</code>、请求特权级（<code>RPL</code>）。他的<code>index</code>（描述符索引）部分表示所需要的段的描述符在描述符表的位置，由这个位置再根据在<code>GDTR</code>中存储的描述符表基址就可以找到相应的描述符。然后用描述符表中的段基址加上逻辑地址（<code>SEL:OFFSET</code>）的<code>OFFSET</code>就可以转换成线性地址，段选择子中的<code>TI</code>值只有一位0或1，0代表选择子是在<code>GDT</code>选择，1代表选择子是在<code>LDT</code>选择。请求特权级（<code>RPL</code>）则代表选择子的特权级，共有4个特权级（0级、1级、2级、3级）。</p>
<blockquote>
<p>特权级：任务中的每一个段都有一个特定的级别。每当一个程序试图访问某一个段时，就将该程序所拥有的特权级与要访问的特权级进行比较，以决定能否访问该段。系统约定，CPU只能访问同一特权级或级别较低特权级的段。</p>
</blockquote>
<p>如给出逻辑地址：<code>21h:12345678h</code>转换为线性地址</p>
<ol>
<li>选择子<code>SEL=21h=0000000000100 0 01b</code> 他代表的意思是：选择子的<code>index=4</code>即<code>100b</code>选择<code>GDT</code>中的第4个描述符；<code>TI=0</code>代表选择子是在<code>GDT</code>选择；左后的<code>01b</code>代表特权级<code>RPL=1</code></li>
<li><code>OFFSET=12345678h</code>若此时<code>GDT</code>第四个描述符中描述的段基址（<code>Base</code>）为<code>11111111h</code>，则<code>线性地址=11111111h+12345678h=23456789h</code></li>
</ol>
<h1 id="LDT"><a href="#LDT" class="headerlink" title="LDT"></a>LDT</h1><p>局部描述符表<code>LDT</code>（Local Descriptor Table）局部描述符表可以有若干张，每个任务可以有一张。在相应的段寄存器装入段选择子，安装索引号到<code>GDT</code>或<code>LDT</code>中找到对应的段描述符，得到<code>Base Address</code>再加上Offset，就得到了内存地址。</p>
<p>由于每个进程都有自己的一套程序段、数据段、堆栈段，有了局部描述符表则可以将每个进程的程序段、数据段、堆栈段封装在一起，只要改变<code>LDTR</code>就可以实现对不同进程的段进行访问。</p>
<p><code>LDT</code>和<code>GDT</code>从本质上说是相同的，只是<code>LDT</code>嵌套在<code>GDT</code>之中。<code>LDTR</code>记录局部描述符表的起始位置，与<code>GDTR</code>不同，<code>LDTR</code>的内容是一个段选择子。由于<code>LDT</code>本身同样是一段内存，也是一个段，所以它也有个描述符描述它，这个描述符就存储在<code>GDT</code>中，对应这个表述符也会有一个选择子，<code>LDTR</code>装载的就是这样一个选择子。<code>LDTR</code>可以在程序中随时改变，通过使用<code>lldt</code>指令。如上图，如果装载的是<code>Selector 2</code>则<code>LDTR</code>指向的是表<code>LDT2</code>。</p>
<p>如果我们想在表LDT2中选择第三个描述符所描述的段的地址12345678h：</p>
<ol>
<li>首先需要装载<code>LDTR</code>使它指向<code>LDT2</code>，使用指令<code>lldt</code>将<code>Select2</code>装载到<code>LDTR</code></li>
<li>通过逻辑地址（<code>SEL:OFFSET</code>）访问时<code>SEL</code>的<code>index=3</code>代表选择第三个描述符；TI&#x3D;1代表选择子是在LDT选择，此时LDTR指向的是<code>LDT2</code>,所以是在<code>LDT2</code>中选择，此时的<code>SEL</code>值为<code>1Ch</code>(二进制为<code>11 1 00b</code>)。OFFSET&#x3D;12345678h。逻辑地址为1C:12345678h</li>
<li>由SEL选择出描述符，由描述符中的基址（Base）加上<code>OFFSET</code>可得到线性地址，例如基址是11111111h，则<code>线性地址=11111111h+12345678h=23456789h</code></li>
<li>此时若再想访问<code>LDT1</code>中的第三个描述符，只要使用lldt指令将选择子<code>Selector 1</code>装入再执行2、3两步就可以了（因为此时<code>LDTR</code>又指向了<code>LDT1</code>）</li>
</ol>
<p>当进行任务切换时，处理器会把新任务<code>LDT</code>的段选择符和段描述符自动地加载进<code>LDTR</code>中。在机器加电或处理器复位后，段选择符和基地址被默认地设置为0，而段长度被设置成<code>0xFFFF</code>。</p>
<h1 id="IDT"><a href="#IDT" class="headerlink" title="IDT"></a>IDT</h1><p>IDT，Interrupt Descriptor Table，即中断描述符表，和<code>GDT</code>类似，他记录了0~255的中断号和调用函数之间的关系。整个系统IDT表也只有一张，<code>GDT</code>表也可以被放在内存的任何位置寄存器。<code>IDTR</code>寄存器存放IDT表的基地址。x86 CPU最大可以支持256种中断ISR(中断处理程序)，每个表项为8字节。Intel指定或保留了前32个中断号的作用，操作系统可以指定其余的中断号的作用。</p>
<p><img src="https://img.ansore.de/2022/07/16/da9f7dab19119141e7e889eafcc51adb.png" alt="IDT"></p>
<h2 id="IDTR"><a href="#IDTR" class="headerlink" title="IDTR"></a>IDTR</h2><p>与<code>GDTR</code>的作用类似，<code>IDTR</code>寄存器用于存放中断描述符表<code>IDT</code>的32位线性基地址和16位表长度值。指令<code>LIDT</code>和<code>SIDT</code>分别用于加载和保存<code>IDTR</code>寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成<code>0xFFFF</code>。</p>
<h1 id="TR"><a href="#TR" class="headerlink" title="TR"></a>TR</h1><p><code>TR</code>用于寻址一个特殊的任务状态段（<code>Task State Segment，TSS</code>）。<code>TSS</code>中包含着当前执行任务的重要信息。</p>
<p><code>TR</code>寄存器用于存放当前任务<code>TSS</code>段的16位段选择符、32位基地址、16位段长度和描述符属性值。它引用<code>GDT</code>表中的一个<code>TSS</code>类型的描述符。指令<code>LTR</code>和<code>STR</code>分别用于加载和保存TR寄存器的段选择符部分。当使用<code>LTR</code>指令把选择符加载进任务寄存器时，<code>TSS</code>描述符中的段基地址、段限长度以及描述符属性会被自动加载到任务寄存器中。当执行任务切换时，处理器会把新任务的<code>TSS</code>的段选择符和段描述符自动加载进任务寄存器TR中。</p>
<h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>64位4级页表分页模式如下：</p>
<p><img src="https://img.ansore.de/2022/07/17/f3cc66c5587172a41a044ed809c0a0ca.png" alt="Screenshot_20220717_123739"></p>
<ol>
<li><code>PML4</code>：这是IA-32e模式新增的页转换表，每个表4K字节，包含512个PML4E结构</li>
<li><code>PDPT</code>：每个表4K字节，包含512个PDPTE结构</li>
<li><code>PDT</code>：每个表4K字节，包含512个PDE结构</li>
<li><code>PT</code>：每个表4K字节，包含512个PTE结构</li>
</ol>
<p>当前的x64体系中，如果使用4级分页，处理器64位线性地址空间只实现了48位，高16位被用作Bit 47位的符号扩展位，要么全是0，要么全是1。每个页表项结构都是8个字节64位宽，而虚拟地址中的每个页表项索引值都是9位，因此每个页表都是512 * 8 &#x3D; 4K字节。</p>
<h2 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h2><ul>
<li>如果设置寄存器<code>CR0.PG = 1, CR4.PAE = 1, IA32_EFER.LME = 1, and CR4.LA57 = 0</code>，则处理器使用4级分页，4级分页将48位线性地址转换位52位物理地址。虽然52位对应4个字节，但是线性地址只有48位，最多可以访问256TB的线性地址空间。</li>
<li>如果设置寄存器<code>CR0.PG = 1, CR4.PAE = 1, IA32_EFER.LME = 1, and CR4.LA57 = 1</code>，则处理器使用5级分页，5级分页将57位线性地址空间转换为52位物理地址。5级分页的线性地址空间足够访问整个物理地址空间。</li>
</ul>
<p>如果是4级页表，CR3的第一个寻呼地址PML4；如果是5级页表，CR3第一个寻呼地址为PML4。</p>
<p><code>CR3</code>的使用取决于是否设置处理器上下文标识符（PCID）。</p>
<p>如果<code>CR4.PCIDE = 0</code>，则CR3寄存器位使用如下：</p>
<p><img src="https://img.ansore.de/2022/07/17/097c86a46eb1dbb16af9f099b666e518.png" alt="Screenshot_20220717_132906"></p>
<p><img src="https://img.ansore.de/2022/07/17/a0e0a956f3a8de49f9e70bface60cb78.png" alt="Screenshot_20220717_132929"></p>
<p>如果<code>CR4.PCIDE = 1</code>，则<code>CR3</code>寄存器位使用如下：</p>
<p><img src="https://img.ansore.de/2022/07/17/14dc2c8fa5892b029299fff33ab9ee12.png" alt="Screenshot_20220717_133023"></p>
<p>IA-32e模式下<code>CR3</code>以及各页表的结构：</p>
<p><img src="https://img.ansore.de/2022/07/17/41220ac1c2c03d6a4e87de24ec446c95.png" alt="Screenshot_20220717_131048"></p>
<h2 id="PML5E"><a href="#PML5E" class="headerlink" title="PML5E"></a>PML5E</h2><p>PML5E位说明如下：</p>
<p><img src="https://img.ansore.de/2022/07/17/c82829d9e080b4624e1abf5c5a1eea36.png" alt="Screenshot_20220717_133121"></p>
<h2 id="PML4E"><a href="#PML4E" class="headerlink" title="PML4E"></a>PML4E</h2><p>PML4E位说明如下：</p>
<p><img src="https://img.ansore.de/2022/07/17/1eb94257a6900131a9aca34d69e07e39.png" alt="Screenshot_20220717_133155"></p>
<p><img src="https://img.ansore.de/2022/07/17/af58053ff951773aa4561ca059df7739.png" alt="Screenshot_20220717_133207"></p>
<h2 id="PDPTE"><a href="#PDPTE" class="headerlink" title="PDPTE"></a>PDPTE</h2><p>PDPTE位说明：</p>
<p><img src="https://img.ansore.de/2022/07/17/cb95ea538c073a6642d8e3d099a8f907.png" alt="Screenshot_20220717_133325"></p>
<h2 id="PDE"><a href="#PDE" class="headerlink" title="PDE"></a>PDE</h2><p>PDE位说明：</p>
<p><img src="https://img.ansore.de/2022/07/17/de63bf4142f71470533c79c2545cbe1b.png" alt="Screenshot_20220717_133401"></p>
<h2 id="PTE"><a href="#PTE" class="headerlink" title="PTE"></a>PTE</h2><p>PTE位说明：</p>
<p><img src="https://img.ansore.de/2022/07/17/1b78c24ed83d3cd64df10f0c0229cf5c.png" alt="Screenshot_20220717_133427"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-内核头程序</title>
    <url>/posts/d23baf17.html</url>
    <content><![CDATA[<p>内核头程序就是内核程序中的一小段汇编代码。内核的线性地址<code>0xffff800000000000</code>对应物理地址0处，内核程序的起始线性地址位 <code>0xffff800000000000 + 0x100000</code>处。</p>
<h1 id="描述符和段结构信息"><a href="#描述符和段结构信息" class="headerlink" title="描述符和段结构信息"></a>描述符和段结构信息</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// GDT Table</span><br><span class="line">.section .data</span><br><span class="line"></span><br><span class="line">.global GDT_Table</span><br><span class="line"></span><br><span class="line">GDT_Table:</span><br><span class="line">  .quad 0x0000000000000000 // 0 null descriptor 00</span><br><span class="line">  .quad 0x0020980000000000 // 1 kernel code 64bit segment 08</span><br><span class="line">  .quad 0x0000920000000000 // 2 kernel code 64bit segment 10</span><br><span class="line">  .quad 0x0020f80000000000 // 3 user code 64bit segment 18</span><br><span class="line">  .quad 0x0000f20000000000 // 4 user data 64bit segment 20</span><br><span class="line">  .quad 0x00cf9a000000ffff // 5 kernel code 32bit segment 28</span><br><span class="line">  .quad 0x00cf92000000ffff // 6 kernel data 32bit segment 30</span><br><span class="line">  .fill 10, 8, 0 // 8~9 TSS(jmp one segment 7) in long-mode 128bit</span><br><span class="line">GDT_END:</span><br><span class="line"></span><br><span class="line">GDT_POINTER:</span><br><span class="line">GDT_LIMIT: .word GDT_END - GDT_Table - 1</span><br><span class="line">GDT_BASE: .quad GDT_Table</span><br><span class="line"></span><br><span class="line">// IDT Table</span><br><span class="line">.global IDT_Table</span><br><span class="line"></span><br><span class="line">IDT_Table:</span><br><span class="line">  .fill 512, 8, 0</span><br><span class="line">IDT_END:</span><br><span class="line"></span><br><span class="line">IDT_POINTER:</span><br><span class="line">IDT_LIMIT: .word IDT_END - IDT_Table - 1</span><br><span class="line">IDT_BASE: .quad IDT_Table</span><br><span class="line"></span><br><span class="line">// TSS64 Table</span><br><span class="line">.global TSS64_Table</span><br><span class="line"></span><br><span class="line">TSS64_Table:</span><br><span class="line">  .fill 13, 8, 0</span><br><span class="line">TSS64_END:</span><br><span class="line"></span><br><span class="line">TSS64_POINTER:</span><br><span class="line">TSS64_LIMIT: .word TSS64_END - TSS64_Table - 1</span><br><span class="line">TSS64_BASE: .quad TSS64_Table</span><br></pre></td></tr></table></figure>

<p>这段程序将全局描述符GDT、中断描述符IDT、任务状态段TSS刚在内核程序的数据段内，并且手动配置全局描述符GDT内的各个段描述符。</p>
<p>通过伪指令<code>.global</code>来修饰标识符<code>GDT_Table</code>、<code>IDT_Table</code>、<code>TSS64_Table</code>表示这三个标识符可以被外部程序引用或访问。它可以保证本程序可以正确配置描述符，同时内核程序其他部分也能够操作这些表舒服表项。</p>
<h1 id="初始化页表及页表项"><a href="#初始化页表及页表项" class="headerlink" title="初始化页表及页表项"></a>初始化页表及页表项</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// init page</span><br><span class="line">.align 8</span><br><span class="line">.org 0x1000</span><br><span class="line"></span><br><span class="line">__PML4E:</span><br><span class="line">  // bit0,1,2 设置为1，允许读写，不允许用户模式操作</span><br><span class="line">  .quad 0x102007</span><br><span class="line">  .fill 255, 8, 0</span><br><span class="line">  .quad 0x102007</span><br><span class="line">  .fill 255, 8, 0</span><br><span class="line"></span><br><span class="line">.org 0x2000</span><br><span class="line"></span><br><span class="line">__PDPTE:</span><br><span class="line">  // bit0,1 设置为1，允许读写</span><br><span class="line">  .quad 0x103003</span><br><span class="line">  .fill 511, 8, 0</span><br><span class="line"></span><br><span class="line">.org 0x3000</span><br><span class="line">__PDE:</span><br><span class="line">  // bit0,1 设置为1，允许读写，bit7设置1,映射2MB</span><br><span class="line">  // 0</span><br><span class="line">  .quad 0x000083</span><br><span class="line">  .quad 0x200083</span><br><span class="line">  .quad 0x400083</span><br><span class="line">  .quad 0x600083</span><br><span class="line">  .quad 0x800083</span><br><span class="line">  // 10M</span><br><span class="line">  .quad 0xe0000083  // 0xa00000</span><br><span class="line">  .quad 0xe0200083</span><br><span class="line">  .quad 0xe0400083</span><br><span class="line">  .quad 0xe0600083</span><br><span class="line">  .quad 0xe0800083  // 0x1000000</span><br><span class="line">  .quad 0xe0a00083</span><br><span class="line">  .quad 0xe0c00083</span><br><span class="line">  .quad 0xe0e00083</span><br><span class="line">  // 16M</span><br><span class="line">  .fill 499, 8, 0</span><br></pre></td></tr></table></figure>

<p>在64位的IA-32e模式下，页表可分为4个等级，每个页表项由原来的4B扩展到8B，而且分页机制处理提供4KB大小的物理页外，还提供2MB和1G大小的物理页。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th>英文名称</th>
<th>英文简称</th>
<th>对应的地址位</th>
<th>表项名称</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">第四级页表</td>
<td>page map level 4 table</td>
<td>PML4T</td>
<td>40到48，共9位</td>
<td>PML4E(Entry)</td>
<td></td>
</tr>
<tr>
<td align="center">第三级页表</td>
<td>page directory pointer table</td>
<td>PDPT</td>
<td>第31到39，共9位</td>
<td>PDPTE</td>
<td></td>
</tr>
<tr>
<td align="center">第二级页表</td>
<td>page directory table</td>
<td>PDT</td>
<td>第22到30，共9位</td>
<td>PDTE</td>
<td></td>
</tr>
<tr>
<td align="center">页表</td>
<td>page table</td>
<td>PT</td>
<td>第13到21位，共9位</td>
<td>PTE</td>
<td></td>
</tr>
</tbody></table>
<p><code>.org 0x1000</code>定位页目录，将页表置于内核指向头程序的<code>0x1000</code>偏移处，然后链接器再根据链接脚本描述，将内核执行头程序的起始线性地址设置在<code>0xffff800000000000 + 0x100000</code>处，因此可以推断处页目录的起始地址位于<code>0xffff800000100000 + 0x1000</code>处。此页表将线性地址0和<code>0xffff800000100000</code>映射为同一物理页以方便页表切换，即程序在配置页表前运行于线性地址<code>0x100000</code>处，经过跳转后运行于线性地址<code>0xffff800000000000</code>附近。</p>
<p>这段程序将前10MB的物理地址内存分别映射到线性地址0处和<code>0xffff800000000000</code>处，接着把物理地址<code>0xe0000000</code>开始的16MB内存映射到线性地址<code>0xa00000</code>处和<code>0xffff800000a00000</code>处，最后使用伪指令<code>.fill</code>将数值0填充到页表剩余的499个页表项里。</p>
<h1 id="寄存器初始化"><a href="#寄存器初始化" class="headerlink" title="寄存器初始化"></a>寄存器初始化</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">.globl _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">  mov $0x10, %ax</span><br><span class="line">  mov %ax, %ds</span><br><span class="line">  mov %ax, %es</span><br><span class="line">  mov %ax, %fs</span><br><span class="line">  mov %ax, %ss</span><br><span class="line">  mov $0x7e00, %esp</span><br><span class="line"></span><br><span class="line">  // load GDTR</span><br><span class="line">  lgdt GDT_POINTER(%rip)</span><br><span class="line"></span><br><span class="line">  // load IDTR</span><br><span class="line">  lidt IDT_POINTER(%rip)</span><br><span class="line"></span><br><span class="line">  mov $0x10, %ax</span><br><span class="line">  mov %ax, %ds</span><br><span class="line">  mov %ax, %es</span><br><span class="line">  mov %ax, %fs</span><br><span class="line">  mov %ax, %gs</span><br><span class="line">  mov %ax, %ss</span><br><span class="line">  movq $0x7e00, %rsp</span><br><span class="line"></span><br><span class="line">  // load cr3</span><br><span class="line">  movq $0x101000, %rax</span><br><span class="line">  movq %rax, %cr3</span><br><span class="line">  movq switch_seg(%rip), %rax</span><br><span class="line">  pushq $0x08</span><br><span class="line">  pushq %rax</span><br><span class="line">  lretq</span><br><span class="line"></span><br><span class="line">switch_seg:</span><br><span class="line">  .quad entry64</span><br><span class="line"></span><br><span class="line">entry64:</span><br><span class="line">  movq $0x10, %rax</span><br><span class="line">  movq %rax, %ds</span><br><span class="line">  movq %rax, %es</span><br><span class="line">  movq %rax, %gs</span><br><span class="line">  movq %rax, %ss</span><br><span class="line">  movq $0xffff800000007e00, %rsp</span><br><span class="line"></span><br><span class="line">  movq go_to_kernel(%rip), %rax</span><br><span class="line">  pushq $0x08</span><br><span class="line">  pushq %rax</span><br><span class="line">  lretq</span><br><span class="line"></span><br><span class="line">.go_to_kernel:</span><br><span class="line">  .quad start_kernel</span><br></pre></td></tr></table></figure>

<p>在GAS编译器中，使用标识符<code>_start</code>作为程序的默认起始位置，同时还要使用伪指令<code>.globl</code>对<code>_start</code>标识符添加修饰。</p>
<p><code>lgdt GDT_POINTER(%rip)</code>采用RIP-Relative寻址模式，这是为IA-32e模式新引入的寻址方式。基于 <code>RIP</code> 计算目标地址时，目标地址等于当前指令的下一条指令所在地址加上偏移量。</p>
<p><img src="https://img.ansore.de/2022/07/16/5473400f66b5ca64f25fda9b2ab05552.png" alt="Screenshot_20220716_203811"></p>
<p>表中<code>displacement</code>是一个有32位整数值，而目标地址值又依赖RIP寄存器（指令指针寄存器），那么<code>displacement</code>将提供RIP范围内2GB的寻址范围。</p>
<p>GAS编译器不支持远跳转<code>JMP</code>、调用<code>CALL</code>指令，所以只能借助<code>lretq</code>来间接跳转，此处先模仿远调用汇编代码<code>lcall</code>的执行过程，伪造了程序执行现场，并结合<code>RIP-Relative</code>寻址模式将段选择子和段内偏移保存到栈中，然后执行代码<code>lretq</code>恢复调用现场，即返回到目标代码段的程序地址中。借助汇编代码<code>lretq</code>跳转到模块<code>entry64</code>的起始地址处，从而完成了从线性地址<code>0x100000</code>向地址<code>0xffff800000100000</code>的切换工作</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">head.o: head.S</span></span><br><span class="line">  gcc -E head.S &gt; heas.s</span><br><span class="line">  as --64 -o head.o head.s</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-lds链接脚本</title>
    <url>/posts/9ed871c4.html</url>
    <content><![CDATA[<p> 系统程序的链接过程使用到链接脚本文件，通常情况下链接器都会使用默认的链接脚本文件。内核程序段的位置需要精心设计，所以默认链接脚本就不能使用，段名往往由操作系统独立命令。</p>
<p>链接脚本的主要作用是描述如何输入文件中的各个程序段（数据段、代码段、堆、栈、BSS）部署到输出文件中，并规划输出文件各程序段在内存中的布局。</p>
<p>链接脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf64-x86-64&quot;, &quot;elf64-x86-64&quot;, &quot;elf64-x86-64&quot;)</span><br><span class="line">OUTPUT_ARCH(i386:x86-64)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  . = 0xffff800000000000 + 0x100000;</span><br><span class="line">  .text :</span><br><span class="line">  &#123;</span><br><span class="line">      _text = .;</span><br><span class="line">      *(.text)</span><br><span class="line">      _etext = .;</span><br><span class="line">  &#125;</span><br><span class="line">  . = ALIGN(8);</span><br><span class="line">  .data :</span><br><span class="line">  &#123;</span><br><span class="line">      _data = .;</span><br><span class="line">      *(.data)</span><br><span class="line">      _edata = .;</span><br><span class="line">  &#125;</span><br><span class="line">  .bss :</span><br><span class="line">  &#123;</span><br><span class="line">      _bss = .;</span><br><span class="line">      *(.bss)</span><br><span class="line">      _ebss = .;</span><br><span class="line">  &#125;</span><br><span class="line">  _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>符号<code>.</code>是一个定位器或位置指针，它用于定位程序的地址或 调整程序的布局位置。<code>. = 0xffff800000000000 + 0x100000</code>就是将定位器设置这个地址处，这个地址是线性地址。</li>
<li><code>OUTPUT_FORMAT(DEFAULT,BIG,LITTLE)</code>。它为链接过程提供<code>DEFAULT</code>（默认）、<code>BIG</code>（大端）、<code>LITTLE</code>（小端）三种输出文件格式。程序链接过程中，若链接使用<code>-EB</code>选项，那么程序将链接成BIG指定的文件格式；如果链接命令中由<code>-EL</code>选项，那么程序将链接成LITTLE指定的文件格式；否则链接成默认模式。此脚本执行将文件的三种输出格式设置位<code>elf64-x86-64</code>格式</li>
<li><code>OUTPUT_ARCH(BFDARCH)</code>指定输出文件的处理器体系结构。</li>
<li><code>ENTRY(SYMBOL)</code>将标识符<code>SYMBOL</code>设置位程序入口，即程序执行的第一条指令所在的地址。</li>
<li><code>SECTIONS</code>关键则负责向链接器描述如何将文件中的各程序段（数据段、代码段、堆、栈、BSS）部署到输出文件中，同时还将规划各程序段在内存中的布局。内核程序的代码段<code>.text</code>起始于线性地址<code>0xffff800000100000</code>处，这个线性地址经过页管理机制转换后，对应的物理地址是<code>0x100000</code>。而链接脚本中的正则表达式<code>*(.text)</code>说明了输出文件的<code>.text</code>程序段保存着所有输入文件的<code>.text</code>程序段。而且<code>.text</code>程序段还使用了<code>_text</code>和<code>_etext</code>标识符来表示<code>.text</code>程序段的起始线性地址和结束线性地址，这两个标识符可在程序中通过代码<code>extern _text</code>和<code>extern _etext</code>进行引用（可以看作全局变量）。此处的符号<code>.</code>表示程序定位器的当前位置（线性地址）。</li>
<li><code>ALIGN(NUM)</code>将地址向后按NUM字节对齐</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-内核主程序</title>
    <url>/posts/181cefd9.html</url>
    <content><![CDATA[<p>内核主程序相当于应用程序的主函数。负责调用各个系统模块的初始化函数，在这些模块初始化结束后，它会创建处系统的第一个<code>init</code>进程，并将控制权交给<code>init</code>进程。</p>
<p>当前主程序不具备任何功能，只是为了让内核执行头程序有目标跳转而已。</p>
<p><code>start_kernel</code>函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译脚本：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(BUILD_KERNEL)</span>/main.o: <span class="variable">$(KERNEL)</span>/main.c</span><br><span class="line">	gcc -mcmodel=large -fno-builtin -m64 -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>使用<code>kernel.lds</code>负责将编译生成的<code>main.o</code>文件和<code>header.o</code>文件链接成可执行程序，输出名为<code>system</code>。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(BUILD_KERNEL)</span>/system: <span class="variable">$(BUILD_KERNEL)</span>/header.o \</span><br><span class="line">								 				<span class="variable">$(BUILD_KERNEL)</span>/main.o</span><br><span class="line">	ld -b elf64-x86-64 -o <span class="variable">$@</span> <span class="variable">$^</span> -T <span class="variable">$(KERNEL)</span>/kernel.lds</span><br></pre></td></tr></table></figure>

<p>经过编译后生成的文件<code>system</code>依然不是最终的内核程序，还需要将<code>system</code>文件中的二进制提取出来：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(BUILD_KERNEL)</span>/kernel.bin: <span class="variable">$(BUILD_KERNEL)</span>/system</span><br><span class="line">	objcopy -I elf64-x86-64 -S -R <span class="string">&quot;.eh_frame&quot;</span> -R <span class="string">&quot;.comment&quot;</span> -O binary <span class="variable">$&lt;</span> <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>此段<code>Makefile</code>脚本命令的作用是剔除<code>system</code>程序中多余的段信息，并提取出二进制程序段数据（<code>text</code>、<code>data</code>、<code>bss</code>段等）。</p>
<p>反汇编<code>system</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -D system</span><br></pre></td></tr></table></figure>

<p>必须反编译<code>system</code>，只有这个文件记录内核程序的各个段信息。</p>
<p>可看到<code>start_kernel</code>的信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">ffff800000104000 &lt;start_kernel&gt;:</span><br><span class="line">ffff800000104000:	55                   	push   %rbp</span><br><span class="line">ffff800000104001:	48 89 e5             	mov    %rsp,%rbp</span><br><span class="line">ffff800000104004:	48 8d 05 f9 ff ff ff 	lea    -0x7(%rip),%rax        # ffff800000104004 &lt;start_kernel+0x4&gt;</span><br><span class="line">ffff80000010400b:	49 bb 94 11 00 00 00 	movabs $0x1194,%r11</span><br><span class="line">ffff800000104012:	00 00 00 </span><br><span class="line">ffff800000104015:	4c 01 d8             	add    %r11,%rax</span><br><span class="line">ffff800000104018:	eb fe                	jmp    ffff800000104018 &lt;start_kernel+0x18&gt;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><code>jmp ffff800000104018</code>这条指令是一个死循环语句。</p>
<p>使用<code>bochs</code>虚拟机运行后，输出寄存器信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">00567966634i[CPU0  ] CPU is in long mode (active)</span><br><span class="line">00567966634i[CPU0  ] CS.mode = 64 bit</span><br><span class="line">00567966634i[CPU0  ] SS.mode = 64 bit</span><br><span class="line">00567966634i[CPU0  ] EFER   = 0x00000500</span><br><span class="line">00567966634i[CPU0  ] | RAX=ffff800000105198  RBX=0000000000000000</span><br><span class="line">00567966634i[CPU0  ] | RCX=00000000c0000080  RDX=0000000000000000</span><br><span class="line">00567966634i[CPU0  ] | RSP=ffff800000007df8  RBP=ffff800000007df8</span><br><span class="line">00567966634i[CPU0  ] | RSI=00000000000080ae  RDI=000000000000c800</span><br><span class="line">00567966634i[CPU0  ] |  R8=0000000000000000   R9=0000000000000000</span><br><span class="line">00567966634i[CPU0  ] | R10=0000000000000000  R11=0000000000001194</span><br><span class="line">00567966634i[CPU0  ] | R12=0000000000000000  R13=0000000000000000</span><br><span class="line">00567966634i[CPU0  ] | R14=0000000000000000  R15=0000000000000000</span><br><span class="line">00567966634i[CPU0  ] | IOPL=0 id vip vif ac vm rf nt of df if tf SF zf af pf cf</span><br><span class="line">00567966634i[CPU0  ] | SEG sltr(index|ti|rpl)     base    limit G D</span><br><span class="line">00567966634i[CPU0  ] |  CS:0008( 0001| 0|  0) 00000000 00000000 0 0</span><br><span class="line">00567966634i[CPU0  ] |  DS:0010( 0002| 0|  0) 00000000 00000000 0 0</span><br><span class="line">00567966634i[CPU0  ] |  SS:0010( 0002| 0|  0) 00000000 00000000 0 0</span><br><span class="line">00567966634i[CPU0  ] |  ES:0010( 0002| 0|  0) 00000000 00000000 0 0</span><br><span class="line">00567966634i[CPU0  ] |  FS:0010( 0002| 0|  0) 00000000 00000000 0 0</span><br><span class="line">00567966634i[CPU0  ] |  GS:0010( 0002| 0|  0) 00000000 00000000 0 0</span><br><span class="line">00567966634i[CPU0  ] |  MSR_FS_BASE:0000000000000000</span><br><span class="line">00567966634i[CPU0  ] |  MSR_GS_BASE:0000000000000000</span><br><span class="line">00567966634i[CPU0  ] | RIP=ffff800000104018 (ffff800000104018)</span><br><span class="line">00567966634i[CPU0  ] | CR0=0xe0000011 CR2=0x0000000000000000</span><br><span class="line">00567966634i[CPU0  ] | CR3=0x0000000000101000 CR4=0x00000020</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><code>RIP=ffff800000104018</code>记录<code>RIP</code>寄存器的值，与编译处的<code>jmp ffff800000104018</code>指令地址一致。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-屏幕显示</title>
    <url>/posts/6e1a5d82.html</url>
    <content><![CDATA[<p>为了在屏幕上显示颜色，必须通过桢缓冲存储器完成。桢缓冲存储器（Frame Buffer），简称桢缓存或桢存。它是屏幕显示画面的一个内存映像，桢缓存的每个存储单元对应屏幕的一个像素，整个桢缓存对应一幅图像。桢缓存的特点是可对每个像素点进行操作，不仅可以借助它在屏幕上画出屏幕上色彩，还可以在屏幕上用像素点绘制文字以及图片。</p>
<p>此前设置说显示芯片的显示模式（模式号：<code>0x180</code>，分辨率：<code>1400*900</code>，颜色深度：<code>32bit</code>），而且内核执行头程序还将桢缓存的物理基地址映射到线性地址<code>0xffff800000000000</code>和<code>0xa00000</code>处。</p>
<h1 id="屏幕上显示色彩"><a href="#屏幕上显示色彩" class="headerlink" title="屏幕上显示色彩"></a>屏幕上显示色彩</h1><p>桢缓存格式：一个像素点能够显示的颜色值位宽。Loader引导加载程序设置的显示模式可支持32位颜色深度的像素点，其中0~7位代表蓝色，8~15位代表吝啬，16~23位代表红色，24~31位是保留位。</p>
<p>如果想设置屏幕上某个像素点的颜色，必须知道这个点在屏幕上的位置，并计算处该点距离屏幕原点的偏移值。屏幕坐标位于左上角。</p>
<p><img src="https://img.ansore.de/2022/07/17/f0cb431f8823fce8937065a5dc12a1cb.png" alt="Screenshot_20220717_202647"></p>
<p>显示屏幕色带如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> *addr = (<span class="type">int</span> *)<span class="number">0xffff800000a00000</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>桢缓存区被映射的线性地址是<code>0xffff800000a00000</code>，在显示模式的过程中，有个寄存器位可以在设置显示模式后清除屏幕上的数据。Loader引导加载程序已将该寄存器位置位，所以先前在屏幕上显示的信息已经被清除。</p>
<h1 id="在屏幕上显示LOG"><a href="#在屏幕上显示LOG" class="headerlink" title="在屏幕上显示LOG"></a>在屏幕上显示LOG</h1><p>在一个固定像素方块内用像素点画出字符，即可实现屏幕上的字符显示功能。</p>
<h2 id="ASCII字符库"><a href="#ASCII字符库" class="headerlink" title="ASCII字符库"></a>ASCII字符库</h2><p>ASCII字符集共有256个字符，其中包括字母、数字、符号和一些非显示信息。当前只显示一些常用的显示字符。</p>
<p><img src="https://img.ansore.de/2022/07/17/f8954db257145db17c014f52bb72f95e.png" alt="Screenshot_20220717_204028"></p>
<p>数字0和一个8*16的像素点矩阵，像素点矩阵中的黑色像素点在屏幕上映射组成了数字0，它们是数字0的字体颜色。只要根据像素点矩阵的映射原理，计算出每行的16进制数值，再将这16行数值组合起来就构成了字符像素位图。一行刚好一个字节，所以只需要保留16字节的位图即可。</p>
<h2 id="显示彩色字符"><a href="#显示彩色字符" class="headerlink" title="显示彩色字符"></a>显示彩色字符</h2><p>实现color_printk函数前，需要先准备一个用于屏幕信息的结构体struct position。该结构体记录这当前屏幕的分辨率、字符光标所在位置、字符像素矩阵尺寸、桢缓冲区起始地址和桢缓冲区容量大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">position</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> XResolution; <span class="comment">// 配置屏幕的分辨率</span></span><br><span class="line">  <span class="type">int</span> YResolution;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> XPosition; <span class="comment">// 光标所在列</span></span><br><span class="line">  <span class="type">int</span> YPosition; <span class="comment">// 光标所在行</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> XCharSize; <span class="comment">//一个字符的宽度</span></span><br><span class="line">  <span class="type">int</span> YCharSize; <span class="comment">// 一个字符的高度</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *FB_addr; <span class="comment">//帧缓冲区起始线性地址</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> FB_length; <span class="comment">//每个像素点需要4字节的值进行控制</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化全局屏幕信息描述：</p>
<p><code>kernel/main.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">position</span> <span class="title">pos</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> *addr = (<span class="type">int</span> *)<span class="number">0xffff800000a00000</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// 配置屏幕的分辨率/光标位置/字符矩阵的尺寸/帧缓冲区起始线性地址/缓冲区长度</span></span><br><span class="line">  pos.x_resolution = <span class="number">1440</span>; <span class="comment">// 从左到右横向1440</span></span><br><span class="line">  pos.y_resolution = <span class="number">900</span>; <span class="comment">// 从上到下纵向900</span></span><br><span class="line">  pos.x_position = <span class="number">0</span>; <span class="comment">// 光标所在列</span></span><br><span class="line">  pos.y_position = <span class="number">0</span>; <span class="comment">// 光标所在行</span></span><br><span class="line">  pos.x_char_size = <span class="number">8</span>; <span class="comment">//一个字符的宽度</span></span><br><span class="line">  pos.y_char_size = <span class="number">16</span>; <span class="comment">// 一个字符的高度</span></span><br><span class="line">  pos.fb_addr = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0xffff800000a00000</span>; <span class="comment">//帧缓冲区起始线性地址</span></span><br><span class="line">  pos.fb_length = (pos.x_resolution * pos.y_resolution * <span class="number">4</span>); <span class="comment">//每个像素点需要4字节的值进行控制</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1440</span> * <span class="number">20</span>; i++) &#123;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">0</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">1</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">2</span>) = (<span class="type">char</span>)<span class="number">0xff</span>;</span><br><span class="line">    *((<span class="type">char</span> *)addr + <span class="number">3</span>) = (<span class="type">char</span>)<span class="number">0x00</span>;</span><br><span class="line">    addr += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  color_printk(YELLOW, BLACK, <span class="string">&quot;Hello\t\t World!\n&quot;</span>);</span><br><span class="line">  color_printk(GREEN, BLACK, <span class="string">&quot;Hello %c World!\n&quot;</span>, <span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印字符函数实现：</p>
<p><code>kernel/printk.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * print character of paramters required</span></span><br><span class="line"><span class="comment"> * @param fb 帧缓存线性地址</span></span><br><span class="line"><span class="comment"> * @param x_size 行分辨率</span></span><br><span class="line"><span class="comment"> * @param x 列像素点位置</span></span><br><span class="line"><span class="comment"> * @param y 行像素点位置</span></span><br><span class="line"><span class="comment"> * @param fb_color 颜色</span></span><br><span class="line"><span class="comment"> * @param bk_color 背景</span></span><br><span class="line"><span class="comment"> * @param font 字符位图</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">putchar</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *fb, <span class="type">int</span> x_size, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> fb_color,</span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> bk_color, <span class="type">unsigned</span> <span class="type">char</span> font)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *addr = <span class="literal">NULL</span>; <span class="comment">//指向32位内存空间的指针,用于写入一个像素点的颜色</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *fontp = <span class="literal">NULL</span>;</span><br><span class="line">  fontp = font_ascii[font]; <span class="comment">//字符位图中的一行</span></span><br><span class="line">  <span class="type">int</span> testval; <span class="comment">//用来测试比特位是否有效(是否要填充)</span></span><br><span class="line">  <span class="comment">//这段程序使用到了帧缓存区首地址,将该地址加上字符首像素位置(首像素位置是指字符像素矩阵左上角第一个像素点)的偏移( Xsize * ( y + i ) + x ),可得到待显示字符矩阵的起始线性地址</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    addr = fb + x_size * (y + i) + x;</span><br><span class="line">    testval = <span class="number">0x100</span>; <span class="comment">//256=&gt;1 0000 0000</span></span><br><span class="line">    <span class="comment">//for循环从字符首像素地址开始,将字体颜色和背景色的数值按字符位图的描绘填充到相应的线性地址空间中,每行8个像素点,每个像素点写入32比特位控制颜色</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">      testval = testval &gt;&gt; <span class="number">1</span>; <span class="comment">//右移1位</span></span><br><span class="line">      <span class="keyword">if</span> (*fontp &amp; testval) &#123; <span class="comment">//如果对应的位是1则填充字体颜色,如果字体有颜色,则该位置将不再填充背景</span></span><br><span class="line">        *addr = fb_color;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *addr = bk_color; <span class="comment">//对应的位为0填充背景颜色</span></span><br><span class="line">      &#125;</span><br><span class="line">      addr++; <span class="comment">//填充完一位自增到下一个位置,addr是int类型32位</span></span><br><span class="line">    &#125;</span><br><span class="line">    fontp++; <span class="comment">//字符位图下一个char序列</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能将数值字母转换成整数值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> is_digit(c) ((c) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (c) &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * convert numeric letters to integer values</span></span><br><span class="line"><span class="comment"> * @param s string address of numeric</span></span><br><span class="line"><span class="comment"> * @return number after conversion</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">skip_atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **s)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (is_digit(**s)) &#123; <span class="comment">//判断是否是数值字母</span></span><br><span class="line">    i = i * <span class="number">10</span> + *((*s)++) - <span class="string">&#x27;0&#x27;</span>; <span class="comment">// 将当前字符转换成数值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串长度：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get string length</span></span><br><span class="line"><span class="comment"> * @param str the point of string</span></span><br><span class="line"><span class="comment"> * @return string length</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//repne不相等则重复,重复前判断ecx是否为零,不为零则减1,scasb查询di中是否有al中的字符串结束字符0,如果有则退出循环,将ecx取反后减去1得到字符串长度</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">strlen</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">int</span> __res;</span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;cld \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;repne \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;scasb \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;notl %0 \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;decl %0 \n\t&quot;</span></span><br><span class="line">                       : <span class="string">&quot;=c&quot;</span>(__res)</span><br><span class="line">                       : <span class="string">&quot;D&quot;</span>(str), <span class="string">&quot;a&quot;</span>(<span class="number">0</span>), <span class="string">&quot;0&quot;</span>(<span class="number">0xffffffff</span>)); <span class="comment">//输入约束:寄存器约束D令String的首地址约束在edi,立即数约束令al=0,通用约束0令ecx=0xffff ffff</span></span><br><span class="line">  <span class="keyword">return</span> __res; <span class="comment">//ecx=0xffff ffff,al=0,edi指向String首地址,方向从低到高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>strlen</code>先将AL寄存器赋值为0，随后借助<code>scasb</code>汇编指令逐字节扫描字符串，每次扫描都会与AL寄存器进行对比，并根据对比结果置位相应的标志位，如果扫描的数值与AL寄存器的数值相等，ZF标志位被置位。<code>repne</code>对一直重复执行<code>scasb</code>指令，知道ecx寄存器递减为0或ZF标志位被置位。又因为ecx寄存器的初始值是负值（0xffffffff），<code>repne</code>指令执行结束后，ecx寄存器依然是负值（ecx寄存器在函数执行过程中递减，使用负值可统计出扫描次数），对ECX寄存器取反减1后得到字符串长度。</p>
<p>将长整型变量值转换成指定进制规格的字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * converts the value of a long integer variable to a string with a spacified</span></span><br><span class="line"><span class="comment"> * hexadecimal spacifition</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param str buffer of save parse result</span></span><br><span class="line"><span class="comment"> * @param num convert variable</span></span><br><span class="line"><span class="comment"> * @param base base number</span></span><br><span class="line"><span class="comment"> * @param field_width</span></span><br><span class="line"><span class="comment"> * @param precision dipaly precision</span></span><br><span class="line"><span class="comment"> * @param flags</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 不管number函数将整数值转换成大写还是小写字母,它最高支持36进制的数值转换</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">number</span><span class="params">(<span class="type">char</span> *str, <span class="type">long</span> num, <span class="type">int</span> base, <span class="type">int</span> field_width,</span></span><br><span class="line"><span class="params">                    <span class="type">int</span> precision, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">  <span class="type">char</span> c, sign, tmp[<span class="number">50</span>]; <span class="comment">// c用来存放填充的进制前缀后前导字符,sign正负</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *digits = <span class="string">&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>; <span class="comment">//默认大写共36个符号(36进制)</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">36</span>) &#123; <span class="comment">//不支持小于2或大于36的进制</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; SMALL) &#123; <span class="comment">// 定义了使用小写字母</span></span><br><span class="line">    digits = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; LEFT) &#123; <span class="comment">// 对齐后字符放在左边则字符前面将不填充0,而在后面填充空格,填充0将破坏数据大小,则令ZEROPAD位域为0表示不填充0</span></span><br><span class="line">    flags &amp;= ~ZEROPAD; <span class="comment">// 显示的字符前面填充0取代空格,对于所有的数字格式用前导零而不是空格填充字段宽度,如果出现-标志或者指定了精度(对于整数)则忽略该标志</span></span><br><span class="line">  &#125;</span><br><span class="line">  c = (flags &amp; ZEROPAD) ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27; &#x27;</span>; <span class="comment">//c用来存放填充的进制前缀后前导字符,如果左对齐,则前面已经令ZEROPAD位域为0,这个表达式c=空格,如果右对齐且ZEROPAD位域为1,这个表达式c=0,表示显示的字符前面填充0取代空格,因为右对齐的话字符显示在右边,前导用0填充不会破坏数据</span></span><br><span class="line">  sign = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; SIGN &amp;&amp; num &lt; <span class="number">0</span>) &#123; <span class="comment">//如果是有符号数且获取到的数小于0</span></span><br><span class="line">    sign = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    num = -num; <span class="comment">//将负数转换成一般正数</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果是无符号数或者获取到的是正数再根据对齐方式决定前导填充什么符号</span></span><br><span class="line">    sign = (flags &amp; PLUS) ? <span class="string">&#x27;+&#x27;</span> : ((flags &amp; SPACE) ? <span class="string">&#x27; &#x27;</span> : <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sign) &#123; <span class="comment">//如果要在正数前面补充显示的是+号或者空格,这个符号占用一个宽度,则数据域宽度减去1,如果是0符号则留给后面的来填充,此次不管</span></span><br><span class="line">    field_width--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; SPECIAL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">16</span>) &#123; </span><br><span class="line">      field_width -= <span class="number">2</span>; <span class="comment">// 十六进制的0x占用两个宽度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base == <span class="number">8</span>) &#123;</span><br><span class="line">      field_width--; <span class="comment">// 八进制的0占用一个宽度</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (num == <span class="number">0</span>) &#123; <span class="comment">//如果取出的数等于0,将字符串结束符&#x27;0&#x27;存入临时数组tmp第一位中</span></span><br><span class="line">    tmp[i++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123; <span class="comment">//如果取出的数不等于0则除去进制直到num=0</span></span><br><span class="line">      tmp[i++] = digits[do_div(num, base)]; <span class="comment">//将整数值转换成字符串(按数值倒序排列),然后再将tmp数组中的字符倒序插入到显示缓冲区,do_div(num,base)的值等于num除以base的余数,余数部分即是digits数组的下标索引值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; precision) &#123; <span class="comment">//进制转换完的数值的长度大于精度,则精度等于进制转换完的数值的长度,比如%5.3限定,1000转十进制=&gt;1000,i=4大于精度3,精度变成4,再由剩下的数据域宽度 = 剩下的数据域宽度 - 精度,得到剩下的数据域宽度等于1,也就是要填充的位数1</span></span><br><span class="line">    precision = i; <span class="comment">//否则精度不变,比如%5.3限定,10转十进制=&gt;10,i=2小于精度3,精度还是3,再由剩下的数据域宽度 = 剩下的数据域宽度 - 精度,得到剩下的数据域宽度等于2,也就是要填充的位数2</span></span><br><span class="line">  &#125;</span><br><span class="line">  field_width -= precision; <span class="comment">//剩下的数据域宽度 = 数据域宽度 - 精度,至此得到数据域宽度,也就是要填充的位数</span></span><br><span class="line">  <span class="keyword">if</span> (!(flags &amp; (ZEROPAD + LEFT))) &#123; <span class="comment">//如果显示的字符前面填充的是空格且对齐后字符放在右边才可以在前导填充空格,否则放到后边if (!(flags &amp; LEFT))再填充,因为如果对齐后字符放在左边还有进制前缀未填充</span></span><br><span class="line">    <span class="keyword">while</span> (field_width-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sign) &#123; <span class="comment">//填充前面决定的前导符号,空格或者+号,如果既不是空格也不是+号,而是0就不填充避免破坏数据,前面的if(sign)也没有执行,至此已经填充完毕(包括0 + 空格)</span></span><br><span class="line">    *str++ = sign;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; SPECIAL) &#123;</span><br><span class="line">    <span class="keyword">if</span> (base == <span class="number">8</span>) &#123;</span><br><span class="line">      *str++ = <span class="string">&#x27;0&#x27;</span>; <span class="comment">//八进制前缀0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base == <span class="number">16</span>) &#123;</span><br><span class="line">      *str++ = <span class="string">&#x27;0&#x27;</span>; <span class="comment">//十六进制前缀0x或0X</span></span><br><span class="line">      *str++ = digits[<span class="number">33</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!(flags &amp; LEFT)) &#123; <span class="comment">//对齐完字符在右边的情况可以用前导0填充而不破坏数据</span></span><br><span class="line">    <span class="keyword">while</span> (field_width-- &gt; <span class="number">0</span>) &#123; <span class="comment">//c用来存放填充的进制前缀后前导字符,如果左对齐,则前面已经令ZEROPAD位域为0,这个表达式c=空格,如果右对齐且ZEROPAD位域为1,这个表达式c=0,表示显示的字符前面填充0取代空格,因为右对齐的话字符显示在右边,前导用0填充不会破坏数据</span></span><br><span class="line">      *str++ = c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//比如%5.3限定,10转十进制=&gt;10,i=2小于精度3,精度还是3,再由剩下的数据域宽度 = 剩下的数据域宽度 - 精度,得到剩下的数据域宽度等于2,也就是要填充的位数2,至此要填充进制前缀后的数值部分了</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; precision--) &#123; <span class="comment">//i等于除去进制得到几位,precision精度</span></span><br><span class="line">    *str++ = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123; <span class="comment">//填充完前缀后的前导符,逆序复制有效数值过去</span></span><br><span class="line">    *str++ = tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (field_width-- &gt; <span class="number">0</span>) &#123; <span class="comment">//前面会改变field_width数据的条件是(填充空格且右对齐/填充0且右对齐),而此处的条件是剩下的条件左对齐,则填充空格</span></span><br><span class="line">    *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于解析<code>color_printk</code>函数所提供的格式化字符串及其参数，<code>vsprintf</code>函数会将格式化后(就像汇编语言用db定义的一串字符那样，可以直接搬运到显存输出那样)的字符串结果保存到一个4096B的缓冲区中buf，并返回字符串长度</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * parse the formatted string and paramters provided by color_printk function</span></span><br><span class="line"><span class="comment"> * @param buf buffer of save parse result</span></span><br><span class="line"><span class="comment"> * @param fmt the format</span></span><br><span class="line"><span class="comment"> * @param args the paramters</span></span><br><span class="line"><span class="comment"> * @return string length</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *str, *s;</span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line">  <span class="type">int</span> field_width; <span class="comment">//宽度</span></span><br><span class="line">  <span class="type">int</span> precision;</span><br><span class="line">  <span class="type">int</span> len, i; <span class="comment">//len用在格式符s,i用在临时循环</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> qualifier; <span class="comment">//&#x27;h&#x27;, &#x27;l&#x27;, &#x27;L&#x27; or &#x27;Z&#x27; for integer fields//基本上只实现了l</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (str = buf; *fmt; fmt++) &#123; <span class="comment">//str直接指向缓冲区buf</span></span><br><span class="line">    <span class="keyword">if</span> (*fmt != <span class="string">&#x27;%&#x27;</span>) &#123; <span class="comment">//该循环体会逐个解析字符串,如果字符不为%就认为它是个可显示字符,直接将其存入缓冲区buf中,否则进一步解析其后的字符串格式</span></span><br><span class="line">      *str++ = *fmt;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flags = <span class="number">0</span>;<span class="comment">//按照字符串规定,符号%后面可接 - + 空格 # 0等格式符,如果下一个字符是上述格式符,则设置标志变量flags的标志位(标志位定义在printk.h),随后计算出数据区域的宽度</span></span><br><span class="line">  repeat:</span><br><span class="line">    fmt++; <span class="comment">//后续的自增都是指向下一地址</span></span><br><span class="line">    <span class="keyword">switch</span> (*fmt) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">      flags |= LEFT; <span class="comment">//对齐后字符放在左边</span></span><br><span class="line">      <span class="keyword">goto</span> repeat;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">      flags |= PLUS; <span class="comment">//有符号的值若为正则显示带加号的符号,若为负则显示带减号的符号</span></span><br><span class="line">      <span class="keyword">goto</span> repeat;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">      flags |= SPACE;<span class="comment">//有符号的值若为正则显示时带前导空格但是不显示符号,若为负则带减号符号,+标志会覆盖空格标志</span></span><br><span class="line">      <span class="keyword">goto</span> repeat;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">      flags |= SPECIAL; <span class="comment">//0x</span></span><br><span class="line">      <span class="keyword">goto</span> repeat;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">      flags |= ZEROPAD; <span class="comment">//显示的字符前面填充0取代空格,对于所有的数字格式用前导零而不是空格填充字段宽度。如果出现-标志或者指定了精度(对于整数)则忽略该标志</span></span><br><span class="line">      <span class="keyword">goto</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这部分程序可提取出后续字符串中的数字,并将其转化为数值以表示数据区域的宽度,如果下一个字符不是数字而是字符*,那么数据区域的宽度将由可变参数提供,根据可变参数值亦可判断数据区域的对齐显示方式(左/右对齐)</span></span><br><span class="line">    <span class="comment">// get fied with</span></span><br><span class="line">    field_width = <span class="number">-1</span>; <span class="comment">//不限定宽度默认为-1</span></span><br><span class="line">    <span class="keyword">if</span> (is_digit(*fmt)) &#123;</span><br><span class="line">      field_width = skip_atoi(&amp;fmt); <span class="comment">//得到数据域的宽度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">//如果下一个字符不是数字而是字符*,那么数据区域的宽度将由可变参数提供,例如printf(&quot;dnumber = %*.*f\n&quot;, width, precision, dnumber);</span></span><br><span class="line">      fmt++; <span class="comment">//有限定*号则指向下一位</span></span><br><span class="line">      field_width = va_arg(args, <span class="type">int</span>); <span class="comment">//通过可变参数取得数据域宽度</span></span><br><span class="line">      <span class="keyword">if</span> (field_width &lt; <span class="number">0</span>) &#123; <span class="comment">//数据域宽度是负数</span></span><br><span class="line">        field_width = -field_width; <span class="comment">//数据域宽度必须是正数,负负得正</span></span><br><span class="line">        flags |= LEFT; <span class="comment">//字符放在左边</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取数据区宽度后,下一步提取出显示数据的精度,如果数据区域的宽度后面跟有字符.,说明其后的数值是显示数据的精度,这里采用与计算数据区域宽度相同的方法计算出显示数据的精度,随后还要获取显示数据的规格</span></span><br><span class="line">    precision = <span class="number">-1</span>; <span class="comment">//不限定精度默认为-1,如果有写.但没有后续精度限定则前两个if都不执行,精度设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (*fmt == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">      fmt++; <span class="comment">//有限定小数点则指向下一位</span></span><br><span class="line">      <span class="keyword">if</span> (is_digit(*fmt)) &#123;</span><br><span class="line">        precision = skip_atoi(&amp;fmt); <span class="comment">//int skip_atoi(const char **s)//将数值字母转换成整数值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        fmt++;</span><br><span class="line">        field_width = va_arg(args, <span class="type">int</span>); <span class="comment">//通过可变参数取得数据域精度</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (field_width &lt; <span class="number">0</span>) &#123; <span class="comment">//如果精度小于0则精度设置为0</span></span><br><span class="line">        precision = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取显示数据的规格,比如%ld格式化字符串中的字母l,就表示显示数据的规格是长整型</span></span><br><span class="line">    qualifier = <span class="number">-1</span>; <span class="comment">//不限定规格默认为-1</span></span><br><span class="line">    <span class="keyword">if</span> (*fmt == <span class="string">&#x27;h&#x27;</span> || *fmt == <span class="string">&#x27;l&#x27;</span> || *fmt == <span class="string">&#x27;L&#x27;</span> || *fmt == <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">      qualifier = *fmt; <span class="comment">//获得数据规格</span></span><br><span class="line">      fmt++; <span class="comment">//有限定规格则指向下一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经过逐个格式符的解析,数据区域的宽度和精度等信息皆已获取,现在将遵照这些信息把可变参数格式化成字符串,并存入buf缓冲区,下面进入可变参数的字符串转化过程,目前支持的格式符有c s o p x X d i u n %等</span></span><br><span class="line">    <span class="keyword">switch</span> (*fmt) &#123;</span><br><span class="line">    <span class="comment">// char</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (!(flags &amp; LEFT)) &#123; <span class="comment">//如果对齐后字符要放在右边</span></span><br><span class="line">        <span class="comment">// on the right</span></span><br><span class="line">        <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>) &#123; <span class="comment">//比如宽度是2,那么将会填充1个空格凑成两个宽度</span></span><br><span class="line">          *str++ = <span class="string">&#x27; &#x27;</span>; <span class="comment">//补齐前面得空格</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      *str++ = (<span class="type">unsigned</span> <span class="type">char</span>)va_arg(args, <span class="type">int</span>); <span class="comment">//从可变参数列表取出一个字符结合填充到缓冲区</span></span><br><span class="line">      <span class="keyword">while</span> (--field_width &gt; <span class="number">0</span>) &#123; <span class="comment">//如果对齐后字符要放在左边,补齐后面的空格</span></span><br><span class="line">        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// string</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>: <span class="comment">//整个显示过程会把字符串的长度与显示精度进行比对,根据数据区的宽度和精度等信息截取待显示字符串的长度并补齐空格符,涉及到内核通用库函数strlen</span></span><br><span class="line">      s = va_arg(args, <span class="type">char</span> *);</span><br><span class="line">      <span class="keyword">if</span> (!s) &#123; <span class="comment">//如果字符串只有结束符</span></span><br><span class="line">        *s = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      len = <span class="built_in">strlen</span>(s); <span class="comment">//字符串不是只有一个结束符则获取长度</span></span><br><span class="line">      <span class="keyword">if</span> (precision &lt; <span class="number">0</span>) &#123; <span class="comment">//如果不限定精度默认为-1,改写成字符串长度</span></span><br><span class="line">        precision = len;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; precision) &#123; <span class="comment">//如果限定了精度并且len大于精度则精度由len决定</span></span><br><span class="line">        len = precision;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!(flags &amp; LEFT)) &#123; <span class="comment">//如果对齐后字符要放在右边则先填充空格</span></span><br><span class="line">        <span class="keyword">while</span> (len &lt; field_width--) &#123;</span><br><span class="line">          *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123; <span class="comment">//将字符串依次复制到缓冲区buf</span></span><br><span class="line">        <span class="comment">// copy the string to the buffer</span></span><br><span class="line">        *str++ = *s++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (len &lt; field_width--) &#123; <span class="comment">//如果对齐后字符要放在左边则最后填充空格</span></span><br><span class="line">        *str++ = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// octal number</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (qualifier == <span class="string">&#x27;l&#x27;</span>) &#123; <span class="comment">//如果规格是长整型</span></span><br><span class="line">        str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">8</span>, field_width,</span><br><span class="line">                     precision, flags);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">8</span>, field_width, precision,</span><br><span class="line">                     flags);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// address</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (field_width == <span class="number">-1</span>) &#123; <span class="comment">//如果未限定数据域宽度</span></span><br><span class="line">        field_width = <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">void</span> *);</span><br><span class="line">        flags |= ZEROPAD; <span class="comment">//显示的字符前面填充0取代空格,对于所有的数字格式用前导零而不是空格填充字段宽度,如果出现-标志或者指定了精度(对于整数)则忽略该标志</span></span><br><span class="line">      &#125;</span><br><span class="line">      str = number(str, (<span class="type">unsigned</span> <span class="type">long</span>)va_arg(args, <span class="type">void</span> *), <span class="number">16</span>, field_width,</span><br><span class="line">                   precision, flags);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">//十六进制的处理过程x设置为小写,其余跟X一样</span></span><br><span class="line">      flags |= SMALL;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (qualifier == <span class="string">&#x27;l&#x27;</span>) &#123; <span class="comment">//如果规格是长整型</span></span><br><span class="line">        str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">16</span>, field_width,</span><br><span class="line">                     precision, flags);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">16</span>, field_width,</span><br><span class="line">                     precision, flags);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">//十进制</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: <span class="comment">//有符号处理过程跟无符号差别在于flags的SIGN域</span></span><br><span class="line">      flags |= SIGN;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span> (qualifier == <span class="string">&#x27;l&#x27;</span>) &#123; <span class="comment">//如果规格是长整型</span></span><br><span class="line">        str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">long</span>), <span class="number">10</span>, field_width,</span><br><span class="line">                     precision, flags);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        str = number(str, va_arg(args, <span class="type">unsigned</span> <span class="type">int</span>), <span class="number">10</span>, field_width,</span><br><span class="line">                     precision, flags);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//函数的最后一部分代码负责格式化字符串的扫尾工作</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: <span class="comment">//格式符%n的功能是把目前已格式化的字符串长度返回给函数的调用者,意思是把刚刚接收的数据的字符个数赋给对应的变量</span></span><br><span class="line">      <span class="keyword">if</span> (qualifier == <span class="string">&#x27;l&#x27;</span>) &#123; <span class="comment">//如果规格是长整型</span></span><br><span class="line">					&#123;</span><br><span class="line">        <span class="type">long</span> *ip = va_arg(args, <span class="type">long</span> *); <span class="comment">//对应的变量,CLanguageMINEOS项目里有标准库printf的测试程序</span></span><br><span class="line">        *ip = (str - buf);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> *ip = va_arg(args, <span class="type">int</span> *);</span><br><span class="line">        *ip = (str - buf);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// if appear %%, the first % as an escape character, after formatting, only</span></span><br><span class="line">    <span class="comment">// one character %</span></span><br><span class="line">    <span class="comment">//如果格式化字符串中出现字符%%,则把第一个格式符%视为转义符,经过格式化解析后,最终只显示一个字符%</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">      *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// if not support, direct output without any processing</span></span><br><span class="line">    <span class="comment">//如果在格式符解析过程中出现任何不支持的格式符,比如f,则不做任何处理,直接将其视为字符串输出到buf缓冲区</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      *str++ = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (*fmt) &#123;</span><br><span class="line">        *str++ = *fmt;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//碰到字符串结束符fmt指针回退并break,退出外层循环后又因为碰到结束符,for循环结束,整个函数结束</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *str = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> str - buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>color_printk</code>函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">color_printk</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fr_color, <span class="type">unsigned</span> <span class="type">int</span> bk_color, <span class="type">const</span> <span class="type">char</span> *fmt,</span></span><br><span class="line"><span class="params">                 ...)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> line = <span class="number">0</span>;</span><br><span class="line">  va_list args;</span><br><span class="line">  va_start(args, fmt);</span><br><span class="line">  i = <span class="built_in">vsprintf</span>(buf, fmt, args);</span><br><span class="line">  va_end(args);</span><br><span class="line">  <span class="comment">//缓冲区里存放的是已经格式化后的字符串,接下来color_printk开始检索buf缓冲区里的格式化字符串,从中找出\n \b \t等转义字符,并在打印过程中解析这些转义字符 </span></span><br><span class="line">  <span class="comment">//通过for语句逐个字符检测格式化后的字符串,&lt;运算符优先级高于逻辑或||,i是buf缓冲区的字符串的长度</span></span><br><span class="line">  <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; i || line; count++) &#123; <span class="comment">//字符串还未输出完或者当前光标距下一个制表位还需要填充空格</span></span><br><span class="line">    <span class="keyword">if</span> (line &gt; <span class="number">0</span>) &#123; <span class="comment">//line保存当前光标距下一个制表位需要填充的空格符数量,如果要填充的空格数大于0</span></span><br><span class="line">      count--; <span class="comment">//因为这里处理的是填充空格符,但是会影响到循环变量count,此处将count自减避免影响</span></span><br><span class="line">      <span class="keyword">goto</span> label_tab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">char</span>)*(buf + count) == <span class="string">&#x27;\n&#x27;</span>) &#123; <span class="comment">//如果发现某个待显示字符是\n转移字符,则将光标行数加1,列数设置为0,否则判断待显示字符是否为\b转义符</span></span><br><span class="line">      pos.y_position++; <span class="comment">//将光标行数加1</span></span><br><span class="line">      pos.x_position = <span class="number">0</span>; <span class="comment">//列数设置为0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">char</span>)*(buf + count) == <span class="string">&#x27;\b&#x27;</span>) &#123; <span class="comment">//如果确定待显示字符是\b转义字符,那么调整列位置并调用putchar函数打印空格符覆盖之前的字符,如果既不是\n也不是\b,则继续判断其是否为\t转义字符</span></span><br><span class="line">		&#123;</span><br><span class="line">      pos.x_position--; <span class="comment">//列数减去1</span></span><br><span class="line">      <span class="keyword">if</span> (pos.x_position &lt; <span class="number">0</span>) &#123; <span class="comment">//列数小于0(本来就在第0列),则回退到上一行的最后一列</span></span><br><span class="line">        pos.x_position = pos.x_resolution / pos.x_char_size - <span class="number">1</span>; <span class="comment">//列数 = 从左到右横向1440 / 从左到右横向8 - 1 =&gt;最后一列</span></span><br><span class="line">        pos.y_position--;</span><br><span class="line">        <span class="keyword">if</span> (pos.y_position &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          pos.y_position = pos.y_position * pos.x_char_size - <span class="number">1</span>; <span class="comment">//行数 = 从上到下纵向900 / 从上到下纵向16 - 1 =&gt;最后一行</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//因为这里在给putchar传递光标位置时是乘上了位图尺寸的,所以上面的不可以再乘</span></span><br><span class="line">      <span class="built_in">putchar</span>(pos.fb_addr, pos.x_resolution, pos.x_position * pos.x_char_size,</span><br><span class="line">              pos.y_position * pos.y_char_size, fr_color, bk_color, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">char</span>)*(buf + count) == <span class="string">&#x27;\t&#x27;</span>) &#123; <span class="comment">//如果确定待显示字符是\t转义字符,则计算当前光标距下一个制表位需要填充的空格符数量,将计算结果保存到局部变量line中,再结合for循环和if判断,把显示位置调整到下一个制表位,并使用空格填补调整过程中占用的字符显示空间</span></span><br><span class="line">      <span class="comment">//8表示一个制表位占用8个显示字符</span></span><br><span class="line">      line = ((pos.x_position + <span class="number">8</span>) &amp; ~(<span class="number">8</span> - <span class="number">1</span>)) - pos.x_position;</span><br><span class="line">    <span class="comment">//需要填充的空格符数量 = ((列数 + 8) &amp; ~(8 - 1)) - 列数),比如现在光标在(2, 2),则需要填充的空格符数量 = ((2 + 8) &amp; ~(8 - 1)) - 2) = (8 - 2) = 6</span></span><br><span class="line">    label_tab:</span><br><span class="line">      line--;</span><br><span class="line">      <span class="built_in">putchar</span>(pos.fb_addr, pos.x_resolution, pos.x_position * pos.x_char_size,</span><br><span class="line">              pos.y_position * pos.y_char_size, fr_color, bk_color, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      pos.x_position++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//排除待显示字符是\n\b\t转义字符之后,那么它就是一个普通字符,使用putchar函数将字符打印在屏幕上,参数帧缓存线性地址/行分辨率/屏幕列像素点位置/屏幕行像素点位置/字体颜色/字体背景色/字符位图</span></span><br><span class="line">      <span class="built_in">putchar</span>(pos.fb_addr, pos.x_resolution, pos.x_position * pos.x_char_size,</span><br><span class="line">              pos.y_position * pos.y_char_size, fr_color, bk_color,</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">char</span>)*(buf + count));</span><br><span class="line">      pos.x_position++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//收尾工作:字符显示结束还要为下次字符显示做准备,更新当前字符的显示位置,此处的字符显示位置可理解为光标位置,下面这段程序负责调整光标的列位置和行位置</span></span><br><span class="line">    <span class="keyword">if</span> (pos.x_position &gt;= (pos.x_resolution / pos.x_char_size)) &#123; <span class="comment">//列数 &gt;= (1440 / 8),也就是最后一列了,则换到下一行并令列数=0,相当于回车换行</span></span><br><span class="line">      pos.y_position++;</span><br><span class="line">      pos.x_position = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos.y_position &gt;= (pos.y_resolution / pos.y_char_size)) &#123; <span class="comment">//行数 &gt;= (900 / 16),也就是最后一行了,则行数=0,列数不变,相当于换行</span></span><br><span class="line">      pos.y_position = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-系统异常</title>
    <url>/posts/70237c47.html</url>
    <content><![CDATA[<h1 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h1><ul>
<li>错误（fault）：错误是一种可以被修正的以上。只要错误被修正，处理器可将程序或任务的运行环境还原至异常发生前（已在栈中保存的CS和EIP寄存器值），并重新执行产生异常的指令，也就是异常的返回地址指向错误产生的指令，而不是其后的位置</li>
<li>陷阱（trap）：陷阱异常同样允许处理器继续执行任务或程序，只不过处理器对跳过产生异常的指令，即陷阱异常的返回地址指向诱发陷阱指令之后的地址</li>
<li>终止（abort）：终止异常用于报告非常严重的错误，它往往无法准确提供产生异常的位置，同时页不允许程序或任务继续执行，典型的终止异常有硬件错误或系统表存在不合逻辑、非法值。</li>
</ul>
<p>INTEL处理器目前支持的异常&#x2F;中断：</p>
<p><img src="https://img.ansore.de/2022/07/22/bc5d1d360c412730acb325004b854618.png" alt="Screenshot_20220722_234450"></p>
<p><img src="https://img.ansore.de/2022/07/22/f5e1aef9a88a34939d3f9f2b576486f8.png" alt="Screenshot_20220722_234501"></p>
<h1 id="系统异常处理"><a href="#系统异常处理" class="headerlink" title="系统异常处理"></a>系统异常处理</h1><p>处理器采用类似汇编指令CALL的调用方法来执行异常&#x2F;中断处理程序。当处理器捕获到异常&#x2F;中断时，便会根据异常&#x2F;中断向量号（Interrupt Vector）从中断描述符表IDT索引出对应的门描述符，再由门描述符定位到处理程序的位置。如果向量号索引到一个中断门或陷阱门，处理器将会像执行CALL指令访问调用门一般，去执行异常&#x2F;中断处理程序。如果向量号索引到一个任务门，处理器将会发生任务切换，转而执行异常任务或中断任务，这个过程就像执行CALL指令访问调用任务门一样。</p>
<p>异常&#x2F;中断的处理步骤：</p>
<p><img src="https://img.ansore.de/2022/07/23/8bc0386abe6cf83df1305f89ea8fbcb8.png" alt="Screenshot_20220723_004245"></p>
<p>处理器会根据异常&#x2F;中断向量号从中断描述符表IDT检索出对应门描述符（中断门或陷阱门），并读取门描述符保存的段选择子。随后从GDT或LDT描述符中检索出处理程序所在的代码段，再根据门描述符记录的段内偏移量，来确定异常&#x2F;中断异常处理程序的入口地址。</p>
<p>处理器在执行异常&#x2F;中断处理程序时，会检测异常&#x2F;中断处理程序所在的代码段的特权级，并与代码段寄存器的特权级进行比较</p>
<ul>
<li><p>如果异常&#x2F;中断处理程序的特权级更高，则会在异常&#x2F;中断处理程序执行前切换栈空间，</p>
<ul>
<li>处理器会从任务状态段TSS中取出对应特权级的栈段选择子和栈指针，并将它们作为异常&#x2F;中断处理程序的栈空间进行切换。在栈空间切换过程中，处理器将自动把切换前的SS和ESP寄存器压入异常&#x2F;中断串处理程序栈</li>
<li>在栈空间切换过程中，处理器还会保存被中断程序的EFLAGS、CS和EIP寄存器值到异常&#x2F;中断处理程序栈</li>
<li>如果异常会产生错误码，则将其保存在异常任务栈内，位于EIP寄存器之后</li>
</ul>
</li>
<li><p>如果异常&#x2F;中断处理程序的特权级与代码段寄存器的特权级相等</p>
<ul>
<li>处理器将保存被中断程序的EFLGAS、CS和EIP寄存器值到栈中</li>
<li>如果异常会产生错误码，则将其保存在异常栈内，位于EIP寄存器之后</li>
</ul>
</li>
</ul>
<p><img src="https://img.ansore.de/2022/07/23/ecd8491af2b0d7b9bc0ecf842828f5f2.png" alt="Screenshot_20220723_005856"></p>
<p>处理器必须借助<code>IRET</code>指令才能从异常&#x2F;中断处理程序返回。<code>IRET</code>指令会还原之前保存的<code>EFLAGS</code>寄存器的值。<code>EFLAGS</code>寄存器的<code>IOPL</code>标志位只有在<code>CPL=0</code>时才可被还原，而IF标志位只有在<code>CPL&lt;=IOPL</code>时候才能改变。如果在执行处理程序时发生过栈空间切换，那么执行<code>IRET</code>指令将切换回被中断程序栈。</p>
<p><strong>异常&#x2F;中断处理的标志位</strong>。当处理器穿过中断门执行异常&#x2F;中断处理程序时，处理器会在标志寄存器EFLAGS入栈后复位TF标志位，以关闭单步调试功能（处理器还会复位VM、RF和NT标志位）。在执行IRET指令过程中，处理器还会被中断程序的标志寄存器EFLAGS，进而相继还原TF、VM、RF、NT等标志位。</p>
<ul>
<li>当处理器穿过中断门执行异常&#x2F;中断处理程序时，处理器将复位IF标志位，以防止其他中断请求干扰异常&#x2F;中断处理程序。处理器在随后执行的IRET指令时，将栈中保存的EFLAGS寄存器值还原，进而置位IF标志位。</li>
<li>当处理器穿过陷阱门执行异常&#x2F;中断处理程序时，处理器却不对复位IF标志位。</li>
</ul>
<p>中断和异常向量在同一张IDT内，IDT表的前32个向量号被异常占用，而且每个异常的向量号固定不能更改，从向量号32开始被中断处理程序所用。</p>
<p>当异常&#x2F;中断发生时，执行<code>ignore_int</code>模块，显示<code>unknow interrupt or fault at RIP</code>提示信息。</p>
<h2 id="设置IDT"><a href="#设置IDT" class="headerlink" title="设置IDT"></a>设置IDT</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup_IDT:</span><br><span class="line">  # 使用lea取出ignore_int标识符的基地址</span><br><span class="line">  # 这个基地址要被拆分成第0-15位和第48-63位，分别放在EAX和EDX寄存器中</span><br><span class="line">  # 然后在将EAX的值加載到中断描述符的低位，將EDX的值加載到中断描述符的高位。</span><br><span class="line">  # 假设ignore_int地址为0x222 3333 4444 5555</span><br><span class="line">  leaq ignore_int(%rip), %rdx</span><br><span class="line">  # 位数: </span><br><span class="line">  # 0-1 RPL 请求特权级</span><br><span class="line">  # 1-2   TI 指示目标段描述符所在描述符表类型</span><br><span class="line">  # 3-15 用于索引目标段描述符</span><br><span class="line">  # 2</span><br><span class="line">  # 段选择符，我们要选用代码段的段选择符，所以使用0008h号GDT段选择符。</span><br><span class="line">  # %rax = 0x0000 0000 0008 0000 = 0b ... 0000 0000 0000 1000 ...</span><br><span class="line">  movq $(0x08 &lt;&lt; 16), %rax</span><br><span class="line">  # 段内偏移 15:00  %ax =  ignore_int 函数的低16位</span><br><span class="line">  # %ax = 0x5555</span><br><span class="line">  # %rax = 0x0000 0000 0008 5555</span><br><span class="line">  movw %dx, %ax</span><br><span class="line">  # %rcx = 0x0000 8E00 0000 0000 = 0b00 ... 1000 1110 ...</span><br><span class="line">  # 32-34 IST ( Interrupt Stack Table，中断枝表)是IA-32e模式为任务状态段引人的新型战指针，其功能与 RSP相同，只不过IST切换中断棋指针时不会考虑特权级切换。</span><br><span class="line">  # 35-39:0</span><br><span class="line">  # 40-43:Type 第40-43位为段描述符类型标志（TYPE），我们设置的是1110.即将此段描述符标记为“386中断门”。</span><br><span class="line">  # 44-44:0</span><br><span class="line">  # 45-46:DPL 描述符特权级</span><br><span class="line">  # 47-48:P 指定调用门描述符是否有效</span><br><span class="line">  movq $(0x8e00 &lt;&lt; 32), %rcx</span><br><span class="line">  # %rax = 0x0000 8E00 0008 5555</span><br><span class="line">  # %rcx = 0x0000 8E00 0000 0000   </span><br><span class="line">  addq %rcx, %rax</span><br><span class="line">  # %ecx = ignore_int 函数的低32位 0x4444 5555    %rcx = 0x0000 8E00 4444 5555</span><br><span class="line">  movl %edx, %ecx</span><br><span class="line">  # %ecx =  0x0000 4444 %rcx = 0x0000 8E00 0000 4444 </span><br><span class="line">  shrl $16, %ecx</span><br><span class="line">  # %rcx =  4444 0000 0000 0000</span><br><span class="line">  shlq $48, %rcx</span><br><span class="line">  # %rax =  0x4444 8E00 0008 5555</span><br><span class="line">  addq %rcx, %rax</span><br><span class="line">  # %rdx = 0x0000 0000 2222 3333</span><br><span class="line">  shrq $32, %rdx</span><br><span class="line">  leaq IDT_Table(%rip), %rdi</span><br><span class="line">  mov $256, %rcx</span><br><span class="line"></span><br><span class="line"># 将256个中断描述符同一初始化</span><br><span class="line"># rax寄存器保存低8字节，rdx寄存器保存高8字节，循环256次</span><br><span class="line">rp_sidt:</span><br><span class="line">  movq %rax, (%rdi)</span><br><span class="line">  movq %rdx, 8(%rdi)</span><br><span class="line">  addq $0x10, %rdi</span><br><span class="line">  dec %rcx</span><br><span class="line">  jne rp_sidt</span><br></pre></td></tr></table></figure>

<p><code>setup_IDT</code>负责初始化中断描述符表<code>IDT</code>内的每个中断描述符（共256项）。它将<code>ignore_int</code>模块的起始地址和其他配置信息，有序地格式化成IA-32e模式的中断门描述符结构信息，并把结构信息保存到RAX寄存器（结构信息的低8字节）和RDX寄存器（结构信息的高8字节）中。最后借助<code>rp_sidt</code>模块将这256个中断描述符项统一初始化。</p>
<p>中断描述符格式如下：</p>
<p><img src="https://img.ansore.de/2022/07/24/1cd64cb18e77498950f7b1d0e8299898.png" alt="Screenshot_20220724_012727"></p>
<p>IDT初始化完毕之后，我们还需要对任务状态段描述符<code>TSS Descriptor</code>进行初始化。</p>
<h2 id="设置TSS"><a href="#设置TSS" class="headerlink" title="设置TSS"></a>设置TSS</h2><p>TSS描述如下：</p>
<p><img src="https://img.ansore.de/2022/07/24/02e8b7ddfad80e6d6cc303d435de7a55.png" alt="Screenshot_20220724_014307"></p>
<p>64位TSS：</p>
<p><img src="https://img.ansore.de/2022/07/24/af76e1fb155124d529b57671ee4c39a5.png" alt="Screenshot_20220724_015431"></p>
<p>对任务状态段描述符<code>TSS Descriptor</code>进行初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup_TSS64:</span><br><span class="line">  leaq TSS64_Table(%rip), %rdx</span><br><span class="line">  xorq %rax, %rax</span><br><span class="line">  xorq %rcx, %rcx</span><br><span class="line">  movq $0x89, %rax</span><br><span class="line">  shlq $40, %rax</span><br><span class="line">  movl %edx, %ecx</span><br><span class="line">  shrl $24, %ecx</span><br><span class="line">  shlq $56, %rcx</span><br><span class="line">  addq %rcx, %rax</span><br><span class="line">  xorq %rcx, %rcx</span><br><span class="line">  movl %edx, %ecx</span><br><span class="line">  andl $0xffffff, %ecx</span><br><span class="line">  shlq $16, %rcx</span><br><span class="line">  addq %rcx, %rax</span><br><span class="line">  addq $103, %rax</span><br><span class="line">  leaq GDT_Table(%rip), %rdi</span><br><span class="line">  movq %rax, 64(%rdi)</span><br><span class="line">  shrq $32, %rdx</span><br><span class="line">  movq %rdx, 72(%rdi)</span><br><span class="line"></span><br><span class="line">  mov $0x40, %ax</span><br><span class="line">  ltr %ax</span><br><span class="line"></span><br><span class="line">  movq go_to_kernel(%rip), %rax</span><br><span class="line">  pushq $0x08</span><br><span class="line">  pushq %rax</span><br><span class="line">  lretq</span><br><span class="line"></span><br><span class="line">go_to_kernel:</span><br><span class="line">  .quad start_kernel</span><br></pre></td></tr></table></figure>

<p>这部分程序负责初始化<code>GDT</code>（IA-32e模式）内的<code>TSS Descriptor</code>，并通过<code>LTR</code>汇编指令吧<code>TSS Descriptor</code>的选择子加载到TR寄存器中。因为当前内核程序已经运行于0特权级，即使产生异常页不会切换任务栈，从而无需访问<code>TSS</code>，那么暂且无需初始化<code>TSS</code>。在特权级无变化的情况下，即使不加载<code>TSS Descriptor</code>的选择子到<code>TR</code>寄存器，异常仍可以被捕获并处理。</p>
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><p>中断处理模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ignore int</span><br><span class="line">ignore_int:</span><br><span class="line">  # CLD指令即告诉程序si，di向內存地址增大的方向走。</span><br><span class="line">  cld</span><br><span class="line">  pushq %rax</span><br><span class="line">  pushq %rbx</span><br><span class="line">  pushq %rcx</span><br><span class="line">  pushq %rdx</span><br><span class="line">  pushq %rbp</span><br><span class="line">  pushq %rdi</span><br><span class="line">  pushq %rsi</span><br><span class="line"></span><br><span class="line">  pushq %r8</span><br><span class="line">  pushq %r9</span><br><span class="line">  pushq %r10</span><br><span class="line">  pushq %r11</span><br><span class="line">  pushq %r12</span><br><span class="line">  pushq %r13</span><br><span class="line">  pushq %r14</span><br><span class="line">  pushq %r15</span><br><span class="line"></span><br><span class="line">  movq %es, %rax</span><br><span class="line">  pushq %rax</span><br><span class="line">  movq %ds, %rax</span><br><span class="line">  pushq %rax</span><br><span class="line"></span><br><span class="line">  movq $0x10, %rax</span><br><span class="line">  movq %rax, %ds</span><br><span class="line">  movq %rax, %es</span><br><span class="line"></span><br><span class="line">  leaq int_msg(%rip), %rax</span><br><span class="line">  pushq %rax</span><br><span class="line">  movq %rax, %rdx</span><br><span class="line">  movq $0x00000000, %rsi</span><br><span class="line">  movq $0x00ff0000, %rdi</span><br><span class="line">  movq $0, %rax</span><br><span class="line">  callq color_printk</span><br><span class="line">  addq $0x8, %rsp</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">  jmp loop</span><br><span class="line">  </span><br><span class="line">  popq %rax</span><br><span class="line">  movq %rax, %ds</span><br><span class="line">  popq %rax</span><br><span class="line">  movq %rax, %es</span><br><span class="line"></span><br><span class="line">  popq %r15</span><br><span class="line">  popq %r14</span><br><span class="line">  popq %r13</span><br><span class="line">  popq %r12</span><br><span class="line">  popq %r11</span><br><span class="line">  popq %r10</span><br><span class="line">  popq %r9</span><br><span class="line">  popq %r8</span><br><span class="line"></span><br><span class="line">  popq %rsi</span><br><span class="line">  popq %rdi</span><br><span class="line">  popq %rbp</span><br><span class="line">  popq %rdx</span><br><span class="line">  popq %rcx</span><br><span class="line">  popq %rbx</span><br><span class="line">  popq %rax</span><br><span class="line">  iretq</span><br><span class="line"></span><br><span class="line">int_msg:</span><br><span class="line">  .asciz &quot;unknown interrupt or fault at RIP\n&quot;</span><br></pre></td></tr></table></figure>

<p>这段程序先保存各个寄存器的值，然后将<code>DS</code>和<code>ES</code>段寄存器设置成内核数据段，紧接着将<code>color_printk</code>函数准备参数，并采用寄存器传递方式传递参数。显示提示信息后，再执行JMP指令死循环在<code>ignore_int</code>模块中。</p>
<p>触发<code>#DE</code>（除0）异常：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://img.ansore.de/2022/07/24/5e417f4ad0630a4f9b98c64d187a7d9d.png" alt="Screenshot_20220724_010331"></p>
<h1 id="系统异常处理-1"><a href="#系统异常处理-1" class="headerlink" title="系统异常处理"></a>系统异常处理</h1><h2 id="初始化IDT"><a href="#初始化IDT" class="headerlink" title="初始化IDT"></a>初始化IDT</h2><p>为各个异常量身定制处理函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_vector_init</span><span class="params">()</span> &#123;</span><br><span class="line">  set_trap_gate(<span class="number">0</span>, <span class="number">1</span>, divide_error);</span><br><span class="line">  set_trap_gate(<span class="number">1</span>, <span class="number">1</span>, debug);</span><br><span class="line">  set_intr_gate(<span class="number">2</span>, <span class="number">1</span>, nmi);</span><br><span class="line">  set_system_gate(<span class="number">3</span>, <span class="number">1</span>, int3);</span><br><span class="line">  set_system_gate(<span class="number">4</span>, <span class="number">1</span>, overflow);</span><br><span class="line">  set_system_gate(<span class="number">5</span>, <span class="number">1</span>, bounds);</span><br><span class="line">  set_trap_gate(<span class="number">6</span>, <span class="number">1</span>, undefined_opcode);</span><br><span class="line">  set_trap_gate(<span class="number">7</span>, <span class="number">1</span>, dev_not_available);</span><br><span class="line">  set_trap_gate(<span class="number">8</span>, <span class="number">1</span>, double_fault);</span><br><span class="line">  set_trap_gate(<span class="number">9</span>, <span class="number">1</span>, coprocessor_segment_overrun);</span><br><span class="line">  set_trap_gate(<span class="number">10</span>, <span class="number">1</span>, invalid_TSS);</span><br><span class="line">  set_trap_gate(<span class="number">11</span>, <span class="number">1</span>, segment_not_present);</span><br><span class="line">  set_trap_gate(<span class="number">12</span>, <span class="number">1</span>, stack_segment_fault);</span><br><span class="line">  set_trap_gate(<span class="number">13</span>, <span class="number">1</span>, general_protection);</span><br><span class="line">  set_trap_gate(<span class="number">14</span>, <span class="number">1</span>, page_fault);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 15 intel reserved. do not use</span></span><br><span class="line">  set_trap_gate(<span class="number">16</span>, <span class="number">1</span>, x87_FPU_error);</span><br><span class="line">  set_trap_gate(<span class="number">17</span>, <span class="number">1</span>, alignment_check);</span><br><span class="line">  set_trap_gate(<span class="number">18</span>, <span class="number">1</span>, machine_check);</span><br><span class="line">  set_trap_gate(<span class="number">19</span>, <span class="number">1</span>, SIMD_exception);</span><br><span class="line">  set_trap_gate(<span class="number">20</span>, <span class="number">1</span>, virtualization_exception);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段程序为各个异常向量配置了处理函数和栈指针，此处使用64为TSS里的IST1区域来记录栈基地址。函数<code>set_intr_gate</code>、<code>set_trap_gate</code>、<code>set_system_gate</code>分别用于初始化IDT内的各表项，这些函数会根据异常的功能，把描述符配置为<code>DPL=0</code>的中断门和陷阱门或者<code>DPL=3</code>的陷阱门。</p>
<p>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_intr_gate</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">char</span> ist, <span class="type">void</span> *addr)</span> &#123;</span><br><span class="line">  _set_gate(IDT_Table + n, <span class="number">0x8e</span>, ist, addr); <span class="comment">// P, DPL=0, TYPE=E</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_trap_gate</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">char</span> ist, <span class="type">void</span> *addr)</span> &#123;</span><br><span class="line">  _set_gate(IDT_Table + n, <span class="number">0x8f</span>, ist, addr); <span class="comment">// P, DPL=0, TYPE=F</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_system_gate</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">char</span> ist, <span class="type">void</span> *addr)</span> &#123;</span><br><span class="line">  _set_gate(IDT_Table + n, <span class="number">0xef</span>, ist, addr); <span class="comment">// P, DPL=3, TYPE=F</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_system_intr_gate</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n, <span class="type">unsigned</span> <span class="type">char</span> ist,</span></span><br><span class="line"><span class="params">                                 <span class="type">void</span> *addr)</span> &#123;</span><br><span class="line">  _set_gate(IDT_Table + n, <span class="number">0xee</span>, ist, addr); <span class="comment">// P, DPL=3, TYPE=E</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_set_gate</code>来初始化IDT内的各个表项，这个宏函数的参数<code>IDT_Table</code>是内核执行头文件head.S内声明的标识符<code>.global IDT_Table</code>，在<code>gate.h</code>文件中使用代码<code>extern struct gate_struct IDT_Table[];</code>将其声明为外部变量供<code>_set_gate</code>等函数使用。</p>
<p><code>_set_gate</code>函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _set_gate(gate_selector_addr, attr, ist, code_addr)                    \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                         \</span></span><br><span class="line"><span class="meta">    unsigned long __d0, __d1;                                                  \</span></span><br><span class="line"><span class="meta">    __asm__ __volatile__(<span class="string">&quot;movw %%dx, %%ax \n\t&quot;</span>                                \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;andq $0x7, %%rcx \n\t&quot;</span>                               \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;addq %4, %%rcx \n\t&quot;</span>                                 \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;shlq $32, %%rcx \n\t&quot;</span>                                \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;addq %%rcx, %%rax \n\t&quot;</span>                              \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;xorq %%rcx, %%rcx \n\t&quot;</span>                              \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;movl %%edx, %%ecx \n\t&quot;</span>                              \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;shrq $16, %%rcx \n\t&quot;</span>                                \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;shlq $48, %%rcx \n\t&quot;</span>                                \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;addq %%rcx, %%rax \n\t&quot;</span>                              \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;movq %%rax, %0 \n\t&quot;</span>                                 \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;shrq $32, %%rdx \n\t&quot;</span>                                \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;movq %%rdx, %1 \n\t&quot;</span>                                 \</span></span><br><span class="line"><span class="meta">                         : <span class="string">&quot;=m&quot;</span>(*((unsigned long *)(gate_selector_addr))),     \</span></span><br><span class="line"><span class="meta">                           <span class="string">&quot;=m&quot;</span>(*(1 + (unsigned long *)(gate_selector_addr))), \</span></span><br><span class="line"><span class="meta">                           <span class="string">&quot;=&amp;a&quot;</span>(__d0), <span class="string">&quot;=&amp;d&quot;</span>(__d1)                            \</span></span><br><span class="line"><span class="meta">                         : <span class="string">&quot;i&quot;</span>(attr &lt;&lt; 8), <span class="string">&quot;3&quot;</span>((unsigned long *)(code_addr)),  \</span></span><br><span class="line"><span class="meta">                           <span class="string">&quot;2&quot;</span>(0x8 &lt;&lt; 16), <span class="string">&quot;c&quot;</span>(ist)                            \</span></span><br><span class="line"><span class="meta">                         : <span class="string">&quot;memory&quot;</span>);                                          \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>该宏函数通过内嵌汇编语句（使用64位汇编指令和通用寄存器）实现，其主要作用是初始化中断描述符表内的门描述符（每个门描述符16B）。</p>
<h2 id="异常处理调用过程"><a href="#异常处理调用过程" class="headerlink" title="异常处理调用过程"></a>异常处理调用过程</h2><p>异常的处理过程会涉及程序执行现场的保存工作，由于C语言无法实现寄存器压栈操作，那么就必须先借助汇编语句在异常处理程序的入口处保存程序的现场环境，然后再执行C语言的异常处理函数。</p>
<p>定义各个寄存器（程序执行现场）在栈中的保存顺序（基于栈指针的偏移值）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;linkage.h&quot;</span><br><span class="line"></span><br><span class="line">R15 = 0x00</span><br><span class="line">R14 = 0x08</span><br><span class="line">R13 = 0x10</span><br><span class="line">R12 = 0x18</span><br><span class="line">R11 = 0x20</span><br><span class="line">R10 = 0x28</span><br><span class="line">R9 = 0x30</span><br><span class="line">R8 = 0x38</span><br><span class="line">RBX = 0x40</span><br><span class="line">RCX = 0x48</span><br><span class="line">RDX = 0x50</span><br><span class="line">RSI = 0x58</span><br><span class="line">RDI = 0x60</span><br><span class="line">RBP = 0x68</span><br><span class="line">DS = 0x70</span><br><span class="line">ES = 0x78</span><br><span class="line">RAX = 0x80</span><br><span class="line">FUNC = 0x88</span><br><span class="line">ERRORCODE = 0x90</span><br><span class="line">RIP = 0x98</span><br><span class="line">CS = 0xa0</span><br><span class="line">RFLAGS = 0xa8</span><br><span class="line">OLDRSP = 0xb0</span><br><span class="line">OLDSS = 0xb8</span><br></pre></td></tr></table></figure>

<p>异常处理程序或者中断处理程序，在处理程序的起始处都必须保存被中断程序的执行现场，上面这些符号常量定义了栈中各个寄存器相对于栈顶（进程执行现场保存完毕时的栈顶地址）的增量偏移。由于栈向下生长，借助当前栈指针寄存器RSP加符号常量，便可取得程序执行现场的寄存器值。<code>OLDSS</code>、<code>OLDRSP</code>、<code>RFLAGS</code>、<code>CS</code>、<code>RIP</code>等符号常量，用于有特权级切换的场景；如果没有特权级切换，则只有<code>RFLAGS</code>、<code>CS</code>、<code>RIP</code>等符号常量可用。符号常量<code>ERRORCODE</code>必须根据异常的实际功能才可确定是否有错误码入栈，并且在返回被中断程序时必须手动弹出栈中的错误码（<code>IRET</code>指令无法自动弹出错误码）</p>
<p>还原被中断程序的执行现场：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RESTORE_ALL:</span><br><span class="line">  popq %r15</span><br><span class="line">  popq %r14</span><br><span class="line">  popq %r13</span><br><span class="line">  popq %r12</span><br><span class="line">  popq %r11</span><br><span class="line">  popq %r10</span><br><span class="line">  popq %r9</span><br><span class="line">  popq %r8</span><br><span class="line">  popq %rbx</span><br><span class="line">  popq %rcx</span><br><span class="line">  popq %rdx</span><br><span class="line">  popq %rsi</span><br><span class="line">  popq %rdi</span><br><span class="line">  popq %rbp</span><br><span class="line">  popq %rax</span><br><span class="line">  movq %rax, %ds</span><br><span class="line">  popq %rax</span><br><span class="line">  movq %rax, %es</span><br><span class="line">  popq %rax</span><br><span class="line">  addq $0x10, %rsp</span><br><span class="line">  iretq</span><br></pre></td></tr></table></figure>

<p>根据保存程序执行现场时的寄存器压栈顺序，从栈中反向弹出各个寄存器的值。64位汇编中<code>PUSH CS/DS/ES/SS</code>和<code>POP DS/ES/SS</code>都是无效指令，所以使用<code>popq %rax; movq %rax, %ds;</code>来替代。汇编代码<code>addq $0x10, %rsp</code>将栈指针向上移动16B，目的是弹出栈中变量<code>FUNC</code>和<code>ERRORCODE</code>，之后便可以执行<code>iretq</code>还原被中断程序的执行现场，该指令可以自行判断还原过程是否设计特权级切换，如果是就将<code>OLDSS</code>、<code>OLDRSP</code>从栈中弹出。</p>
<p>程序执行现场的保存过程和异常处理函数，<code>#DE</code>异常的处理模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(divide_error)</span><br><span class="line">  pushq $0</span><br><span class="line">  pushq %rax</span><br><span class="line">  leaq do_divide_error(%rip), %rax</span><br><span class="line">  xchgq %rax, (%rsp)</span><br><span class="line"></span><br><span class="line">error_code:</span><br><span class="line">  pushq %rax</span><br><span class="line">  movq %es, %rax</span><br><span class="line">  pushq %rax</span><br><span class="line">  movq %ds, %rax</span><br><span class="line">  pushq %rax</span><br><span class="line">  xorq %rax, %rax</span><br><span class="line"></span><br><span class="line">  pushq %rbp</span><br><span class="line">  pushq %rdi</span><br><span class="line">  pushq %rsi</span><br><span class="line">  pushq %rdx</span><br><span class="line">  pushq %rcx</span><br><span class="line">  pushq %rbx</span><br><span class="line">  pushq %r8</span><br><span class="line">  pushq %r9</span><br><span class="line">  pushq %r10</span><br><span class="line">  pushq %r11</span><br><span class="line">  pushq %r12</span><br><span class="line">  pushq %r13</span><br><span class="line">  pushq %r14交互</span><br><span class="line">  pushq %r15</span><br><span class="line">  </span><br><span class="line">  cld</span><br><span class="line">  movq ERRORCODE(%rsp), %rsi</span><br><span class="line">  movq FUNC(%rsp), %rdx</span><br><span class="line"></span><br><span class="line">  movq $0x10, %rdi</span><br><span class="line">  movq %rdi, %ds</span><br><span class="line">  movq %rdi, %es</span><br><span class="line"></span><br><span class="line">  movq %rsp, %rdi</span><br><span class="line"></span><br><span class="line">  callq *%rdx</span><br><span class="line">  jmp ret_from_exception</span><br></pre></td></tr></table></figure>

<p>由于<code>#DE</code>异常不会产生错误码，但是为了确保所有异常处理程序的寄存器压栈顺序一致，便向栈中压入数值0来占位。之后将RAX寄存器值压入栈中，再将异常处理函数<code>do_divide_error</code>的起始地址存入RAX寄存器，并借助汇编代码<code>xchgq</code>将RAX寄存器与栈中的值交互。将<code>do_divide_error</code>函数的起始地址存入栈中，而且还恢复了RAX寄存器的值。</p>
<p>进程的执行现场保存完毕后，就可以执行对应异常处理函数。由于被中断程序可能运行在应用层（3特权级），而异常处理程序运行与内核层（0特权级），那么进入内核层后，<code>DS</code>和<code>ES</code>段寄存器应该重新加载为内核层数据段。紧接着把异常处理函数的起始地址装入<code>RDX</code>寄存器，将错误码和栈指针分别存入<code>RSI</code>和<code>RDI</code>寄存器，供异常处理函数使用，并使用汇编代码<code>callq</code>调用异常处理函数。AT&amp;T汇编中，<code>CALL</code>和<code>JMP</code>指令的操作数前缀中含有符号<code>*</code>，则表示调用&#x2F;跳转的目标是绝对地址，否则调用&#x2F;跳转的目标是相对地址。</p>
<p>异常处理函数执行完毕后，跳转到<code>ret_from_exception</code>还原被中断程序的执行现场：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ret_from_exception:</span><br><span class="line">ENTRY(ret_from_intr)</span><br><span class="line">  jmp RESTORE_ALL</span><br></pre></td></tr></table></figure>

<p>当前仅负责还原被中断程序的执行现场。</p>
<p><code>NMI</code>不可屏蔽中断处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(nmi)</span><br><span class="line">  pushq %rax</span><br><span class="line">  cld</span><br><span class="line">  pushq %rax</span><br><span class="line">  </span><br><span class="line">  pushq %rax</span><br><span class="line">  movq %es, %rax</span><br><span class="line">  pushq %rax</span><br><span class="line">  movq %ds, %rax</span><br><span class="line">  pushq %rax</span><br><span class="line">  xorq %rax, %rax</span><br><span class="line"></span><br><span class="line">  pushq %rbp</span><br><span class="line">  pushq %rdi</span><br><span class="line">  pushq %rsi</span><br><span class="line">  pushq %rdx</span><br><span class="line">  pushq %rcx</span><br><span class="line">  pushq %rbx</span><br><span class="line">  pushq %r8</span><br><span class="line">  pushq %r9</span><br><span class="line">  pushq %r10</span><br><span class="line">  pushq %r11</span><br><span class="line">  pushq %r12</span><br><span class="line">  pushq %r13</span><br><span class="line">  pushq %r14</span><br><span class="line">  pushq %r15</span><br><span class="line">  </span><br><span class="line">  movq $0x10, %rdx</span><br><span class="line">  movq %rdx, %ds</span><br><span class="line">  movq %rdx, %es</span><br><span class="line">  </span><br><span class="line">  movq $0, %rsi</span><br><span class="line">  movq %rsp, %rdi</span><br><span class="line"></span><br><span class="line">  callq do_nmi</span><br><span class="line">  jmp RESTORE_ALL</span><br></pre></td></tr></table></figure>

<p><code>#NMI</code>不可屏蔽中断不是异常，而是一个外部中断，从而不会产生错误码。<code>#NMI</code>应该执行中断处理过程，所以与异常处理相似。</p>
<p><code>#TS</code>异常处理过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(invalid_TSS)</span><br><span class="line">  pushq %rax</span><br><span class="line">  leaq do_invalid_TSS(%rip), %rax</span><br><span class="line">  xchgq %rax, (%rsp)</span><br><span class="line">  jmp error_code</span><br></pre></td></tr></table></figure>

<p>有错误码的<code>#TS</code>异常处理模块无需项栈中压入数值0占位，而是直接使用同一返回模块，其他执行步骤与<code>#DE</code>异常一致。</p>
<p><code>#PF</code>异常处理模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(page_fault)</span><br><span class="line">  pushq %rax</span><br><span class="line">  leaq do_page_fault(%rip), %rax</span><br><span class="line">  xchgq %rax, (%rsp)</span><br><span class="line">  jmp error_code</span><br></pre></td></tr></table></figure>

<p><code>#PF</code>处理过程与<code>#TS</code>一致，区别在于错误码的位图格式不同。</p>
<h2 id="异常处理函数"><a href="#异常处理函数" class="headerlink" title="异常处理函数"></a>异常处理函数</h2><h3 id="DE"><a href="#DE" class="headerlink" title="#DE"></a>#DE</h3><p><code>#DE</code>异常的处理函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_divide_error</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> rsp, <span class="type">unsigned</span> <span class="type">long</span> error_code)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">  p = (<span class="type">unsigned</span> <span class="type">long</span> *)(rsp + <span class="number">0x98</span>);</span><br><span class="line">  color_printk(</span><br><span class="line">      RED, BLACK,</span><br><span class="line">      <span class="string">&quot;do_divide_error(0), ERROR_CODE:%#018lx,RSP:%#018lx,RIP:%#018lx\n&quot;</span>,</span><br><span class="line">      error_code, rsp, *p);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>#DE</code>异常处理目前只有打印错误信息功能，即显示错误码、栈指针和异常产生的错误地址。由于<code>#DE</code>异常没有错误码，这里会显示之前入栈的0值。其中代码<code>p = (unsigned long *)(rsp + 0x98);</code>中数值<code>0x98</code>对应着上文的符号常量<code>RIP=0x98</code>，意思是将栈指针寄存器<code>RSP</code>（异常处理模块将栈指针寄存器<code>RSP</code>的值作为参数存入<code>RDI</code>寄存器）的值向上索引<code>0x98</code>个字节，以获取被中断程序执行现场的<code>RIP</code>寄存器值，并将其作为产生异常指令的地址值。然后借助<code>while(1);</code>保持死循环。</p>
<h3 id="NMI"><a href="#NMI" class="headerlink" title="#NMI"></a>#NMI</h3><p><code>#NMI</code>的处理函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_nmi</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> rsp, <span class="type">unsigned</span> <span class="type">long</span> error_code)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">  p = (<span class="type">unsigned</span> <span class="type">long</span> *)(rsp + <span class="number">0x98</span>);</span><br><span class="line">  color_printk(RED, BLACK,</span><br><span class="line">               <span class="string">&quot;do_nmi(2), ERROR_CODE:%#018lx,RSP:%#018lx,RIP:%#018lx\n&quot;</span>,</span><br><span class="line">               error_code, rsp, *p);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>#DE</code>相同，目前只有打印错误信息的功能。</p>
<h3 id="TS"><a href="#TS" class="headerlink" title="#TS"></a>#TS</h3><p>如果异常产生的原因（外部中断或<code>INT n</code>指令不会产生错误码），关系到一个特殊的段选择子或IDT向量，那么处理器就会在异常处理程序栈中存入错误码。指向<code>IRET</code>指令并不会在异常返回过程中弹出错误码，因此在异常返回前必须手动将错误码从栈中弹出。</p>
<p>根据中断门、陷阱门或任务门的操作数位宽，错误码可以是一个字或双字，为了保证双字错误码入栈时的栈对齐，错误码的高半部分被保留。这个格式与段选择子相似，只不过段选择子中的<code>TI</code>标志位与<code>RPL</code>区域此刻已变为错误码的三个标志。</p>
<p><img src="https://img.ansore.de/2022/07/24/1cba1b0453fdf71eb8b29f332e08f452.png" alt="Screenshot_20220724_214223"></p>
<ul>
<li>EXT。如果该位被置位，说明异常是在向程序投递外部事件的过程中触发，如一个中断或一个更早期的异常。</li>
<li>IDT。如果该位被置位，说明错误码的段选择子部分记录的是中断描述符IDT内的门描述符；而复位则说明其记录的是描述符表GDT&#x2F;IDT内的描述符。</li>
<li>TI。只有当IDT标志位复位时才有效。如果被置位，则说明错误码的段选择子部分记录的是局部描述符表LDT内的段描述符或门描述符；而复位则说明它记录的是全局描述符表GDT的描述符。</li>
</ul>
<p>错误码的段选择子部分可以所以IDT、GDT或LDT等描述符表内的段描述符或门描述符。在某些条件下，错误码是NULL值（除EXT位外所有都被清零），这表明并非由引用特殊段或访问NULL段描述符而产生的。</p>
<p><code>#TS</code>异常处理函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_invalid_TSS</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> rsp, <span class="type">unsigned</span> <span class="type">long</span> error_code)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">  p = (<span class="type">unsigned</span> <span class="type">long</span> *)(rsp + <span class="number">0x98</span>);</span><br><span class="line">  color_printk(</span><br><span class="line">      RED, BLACK,</span><br><span class="line">      <span class="string">&quot;do_invalid_TSS(10), ERROR_CODE:%#018lx,RSP:%#018lx,RIP:%#018lx\n&quot;</span>,</span><br><span class="line">      error_code, rsp, *p);</span><br><span class="line">  <span class="keyword">if</span> (error_code &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">    color_printk(</span><br><span class="line">        RED, BLACK,</span><br><span class="line">        <span class="string">&quot;The exception occurred during delivery of an event external to the &quot;</span></span><br><span class="line">        <span class="string">&quot;program, such as an interrupt or an earlier exception.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (error_code &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">    color_printk(RED, BLACK, <span class="string">&quot;Refers to a gate descriptor in the IDT.\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    color_printk(RED, BLACK,</span><br><span class="line">                 <span class="string">&quot;Refers to a descriptor in the IDT or the current LDT.\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((error_code &amp; <span class="number">0x02</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error_code &amp; <span class="number">0x04</span>) &#123;</span><br><span class="line">      color_printk(RED, BLACK,</span><br><span class="line">                   <span class="string">&quot;Refers to a segment or gate descriptor in the LDT.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      color_printk(RED, BLACK, <span class="string">&quot;Refers to a descriptor in the current GDT.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;Segment Selector Index:%#010x\n&quot;</span>,</span><br><span class="line">               error_code &amp; <span class="number">0xfff8</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TS</code>异常处理函数<code>do_invalid_TSS</code>首先会显示异常的错误码值、栈指针值、异常产生的程序地址等日志信息，然后解析错误码显示详细信息。</p>
<h3 id="PF"><a href="#PF" class="headerlink" title="#PF"></a>#PF</h3><p>处理器为页错误异常提供了两条信息，来帮助诊断异常产生的原因以及恢复方法。</p>
<ul>
<li>栈中的错误码。页错误页异常的错误码格式与其他异常完全不同，处理器使用了5个标志来描述页错误异常。<ul>
<li>P标志指示异常是否由一个不存在的页所引发（p&#x3D;0），或者进入了违规区域（p&#x3D;1），或者使用保留位（p&#x3D;1）</li>
<li>W&#x2F;R标志位指示异常是否由读取页（W&#x2F;R&#x3D;0）或写入页（W&#x2F;R&#x3D;1）所产生</li>
<li>U&#x2F;S标志位指示异常是否由用户模式（U&#x2F;S&#x3D;1）或超级模式（U&#x2F;S&#x3D;0）所产生</li>
<li>当CR4控制寄存器的PSE标志位或PAE标志位被置位时，处理器将检测页表项的保留位，RSVD标志位指示异常是否由保留位所产生</li>
<li>I&#x2F;D标志位指示异常是否由获取指令所产生</li>
</ul>
</li>
<li>CR2寄存器。CR2控制寄存器保存触发异常时的线性地址，异常处理程序可根据线性地址定位到页目录项和页表项。页处理错误程序应该在第二个页错误发生前保存CR2寄存器的值，以免再次触发页错误异常。</li>
</ul>
<p><img src="https://img.ansore.de/2022/07/24/3e4e93f2cc4ecac0991278aee7f627d5.png" alt="Screenshot_20220724_215114"></p>
<p>在异常触发时，处理器会将CS和EIP寄存器的值保存到处理程序栈内，通常情况下这两个寄存器值指向触发异常的指令。如果<code>#PF</code>异常发生在任务切换期间，那么CS和EIP寄存器可能指向新任务的第一条指令。</p>
<p><code>#PF</code>异常处理如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_page_fault</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> rsp, <span class="type">unsigned</span> <span class="type">long</span> error_code)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> cr2 = <span class="number">0</span>;</span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;movq %%cr2, %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(cr2)::<span class="string">&quot;memory&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p = (<span class="type">unsigned</span> <span class="type">long</span> *)(rsp + <span class="number">0x98</span>);</span><br><span class="line">  color_printk(RED, BLACK,</span><br><span class="line">               <span class="string">&quot;do_page_fault(14), &quot;</span></span><br><span class="line">               <span class="string">&quot;ERROR_CODE:%#018lx,RSP:%#018lx,RIP:%#018lx\n&quot;</span>,</span><br><span class="line">               error_code, rsp, *p);</span><br><span class="line">  <span class="keyword">if</span> (error_code &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">    color_printk(RED, BLACK, <span class="string">&quot;Page Not-Present.\t&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (error_code &amp; <span class="number">0x02</span>) &#123;</span><br><span class="line">    color_printk(RED, BLACK, <span class="string">&quot;Wirte Cause Fault.\t&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    color_printk(RED, BLACK, <span class="string">&quot;Read Cause Fault.\t&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (error_code &amp; <span class="number">0x04</span>) &#123;</span><br><span class="line">    color_printk(RED, BLACK, <span class="string">&quot;Fault int user(3)\t&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    color_printk(RED, BLACK, <span class="string">&quot;Fault in supervisor(0,1,2)\t&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (error_code &amp; <span class="number">0x08</span>) &#123;</span><br><span class="line">    color_printk(RED, BLACK, <span class="string">&quot;,Reserved Bit Cause Fault\t&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (error_code &amp; <span class="number">0x10</span>) &#123;</span><br><span class="line">    color_printk(RED, BLACK, <span class="string">&quot;,Instruction fetch Case Fault&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;CR2:%#018lx\n&quot;</span>, cr2);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_page_fault</code>首先将CR2控制寄存器的值保存到变量<code>cr2</code>中，C不支持寄存器操作，所以使用内联汇编将CR2寄存器的值复制到<code>cr2</code>变量中。</p>
<h2 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h2><p>借助<code>i=1/0</code>触发<code>#DE</code>异常：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> load_TR(n)                                                             \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                         \</span></span><br><span class="line"><span class="meta">    __asm__ __volatile__(<span class="string">&quot;ltr %%ax&quot;</span> : : <span class="string">&quot;a&quot;</span>(n &lt;&lt; 3) : <span class="string">&quot;memory&quot;</span>);               \</span></span><br><span class="line"><span class="meta">  &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  load_TR(<span class="number">8</span>);</span><br><span class="line">  set_tss64(<span class="number">0xffff800000007c00</span>, <span class="number">0xffff800000007c00</span>, <span class="number">0xffff800000a00000</span>,</span><br><span class="line">            <span class="number">0xffff800000007c00</span>, <span class="number">0xffff800000007c00</span>, <span class="number">0xffff80</span>ng<span class="number">&#x27;</span> to your Pictures folder. <span class="number">0000007</span>c00,</span><br><span class="line">            <span class="number">0xffff800000007c0</span>, <span class="number">0xffff800000007c00</span>, <span class="number">0xffff800000007c00</span>,</span><br><span class="line">            <span class="number">0xffff800000007c00</span>);</span><br><span class="line">  sys_vector_init();</span><br><span class="line"></span><br><span class="line">  i = <span class="number">1</span> / <span class="number">0</span>; <span class="comment">// divide 0 exception</span></span><br><span class="line">  <span class="comment">// i = *(int*) 0xffff80000aa00000; // #PF exception</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段程序通过<code>load_TR</code>宏将TSS段描述符的段选择子加载到TR寄存器，而函数<code>set_tss64</code>则负责配置TSS段内各个RSP和IST项。</p>
<p>TSS段描述符被加载到TR寄存器后，其B标志（Busy）会被置位，如果重复加载此描述符则产生#TS异常。所以需要将加载TSS段选择子的汇编代码删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// mov $0x40, %ax</span><br><span class="line">// ltr %ax</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://img.ansore.de/2022/07/24/fd6649f70d01f44325f7eddc20163d77.png" alt="Screenshot_20220724_220733"></p>
<p>将代码中改为<code>i = *(int*) 0xffff80000aa00000;</code>，可触发<code>PF</code>异常。</p>
<p>运行结果如下：</p>
<p><img src="https://img.ansore.de/2022/07/24/5a815daae9edc1f2618abcf09cfb163b.png" alt="Screenshot_20220724_220816"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-内存管理</title>
    <url>/posts/984d9bff.html</url>
    <content><![CDATA[<h1 id="获取物理内存信息"><a href="#获取物理内存信息" class="headerlink" title="获取物理内存信息"></a>获取物理内存信息</h1><p>之前再Loader阶段通过BIOS中断服务程序<code>int 0x15; ax=0xe820</code>，包保存到物理地址<code>0x7e00</code>。此处存储的物理地址空间信息存有若干组，描述计算机平台的地址空间划分情况，数据量回根据当前主板硬件配置和物理内存容量而定，每条物理地址空间信息占用<code>20B</code>，详细定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memory_E820_Formate</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> address1;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> address2;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> length1;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> length2;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该结构体格式化物理地址<code>0x7e00</code>处的数据。还必须经过页表映射后才能使用，转换后的线性地址是<code>0xffff800000007e00</code>。</p>
<p>显示内存信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">memory_init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> total_memory;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Memory_E820_Formate</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  p = (<span class="keyword">struct</span> Memory_E820_Formate *)<span class="number">0xffff800000007e00</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    color_printk(ORANGE, BLACK,</span><br><span class="line">                 <span class="string">&quot;Adress:%#010x, %08x\tLength:%#010x,%08x\tType:%010x\n&quot;</span>,</span><br><span class="line">                 p-&gt;address2, p-&gt;address1, p-&gt;length2, p-&gt;length1, p-&gt;type);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;type == <span class="number">1</span>) &#123;</span><br><span class="line">      tmp = p-&gt;length2;</span><br><span class="line">      total_memory += p-&gt;length1;</span><br><span class="line">      total_memory += tmp &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;type &gt; <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  color_printk(ORANGE, BLACK, <span class="string">&quot;OS can used total ram: %018lx\n&quot;</span>, total_memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将指针变量p指向线性地址<code>0xffff800000007e00</code>处，通过32次循环逐条显示地址空间的分布信息。其<code>type</code>值不会大于4，如果出现了大于4的情况，则是程序程序出现了脏数据，就跳出循环。</p>
<p>显示结果如下：</p>
<p><img src="https://img.ansore.de/2022/07/30/57552b7a1279ca7363ecfa0f972fbd00.png" alt="Screenshot_20220730_180936"></p>
<p>可以看出可用的物理内存空间（type&#x3D;1）由两部分组成，一部分是容量为<code>0x9f00</code>的段，另一部分是容量为<code>0x7fef0000</code>的段，可以计算处可用的物理总内存容量为<code>0x9f000+0x7fef0000=7ff8f000 B</code>大约是<code>2047.55MB</code>。与Bochs的内存设置一致：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memory: host=2048M, guest=2048M</span><br></pre></td></tr></table></figure>

<h1 id="计算可用物理内存页数"><a href="#计算可用物理内存页数" class="headerlink" title="计算可用物理内存页数"></a>计算可用物理内存页数</h1><p>可用物理地址页数通常间接描述了操作系统可以使用的物理内存数，这些页必须按照页大小进行物理地址对齐。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 8 bytes per cell</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTRS_PER_PAGE 512</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_OFFSET ((unsigned long)0xffff800000000000)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_GDT_SHIFT 39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_1G_SHIFT 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_2M_SHIFT 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_4K_SHIFT 12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_2M_SIZE (1UL &lt;&lt; PAGE_2M_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_4K_SIZE (1UL &lt;&lt; PAGE_4K_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_2M_MASK (~(PAGE_2M_SIZE - 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_4K_MASK (~(PAGE_4K_SIZE - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_2M_ALIGN(addr)                                                    \</span></span><br><span class="line"><span class="meta">  (((unsigned long)(addr) + PAGE_2M_SIZE - 1) &amp; PAGE_2M_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_4K_ALIGN(addr)                                                    \</span></span><br><span class="line"><span class="meta">  (((unsigned long)(addr) + PAGE_4K_SIZE - 1) &amp; PAGE_4K_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIRT_TO_PHY(addr) ((unsigned long)(addr)-PAGE_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHY_TO_VIRT(addr)                                                      \</span></span><br><span class="line"><span class="meta">  ((unsigned long *)((unsigned long)(addr) + PAGE_OFFSET))</span></span><br></pre></td></tr></table></figure>

<p><code>PTRS_PER_PAGE</code>代表页表项个数，在64位模式下每个页表项占用字节数由原来的4个字节扩展为8个字节，每个页表大小为4KB，因此页表项个数为4KB&#x2F;8B&#x3D;512。</p>
<p><code>PAGE_OFFSET</code>代表内核的起始线性地址，该地址位于物理地址0处。</p>
<p><code>PAGE_4K_SHIFT</code>代表$2^{PAGE_4K_SHIFT}$B&#x3D;4KB，同理$2^{PAGE_2M_SHIFT}$B&#x3D;2MB、$2^{PAGE_1G_SHIFT}$B&#x3D;1GB，以此类推，它们将64位模式下的每种页表项代表的物理页容量都表示出来。</p>
<p><code>PAGE_2M_SIZE</code>代表2MB页的容量，展开后将1向左移动<code>PAGE_2M_SHIFT</code>位。</p>
<p><code>PAGE_2M_MASK</code>是2MB数值的屏蔽码，通常用于屏蔽低于2MB的数值。</p>
<p><code>PAGE_2M_ALIGN(addr)</code>的作用是将参数addr按2MB页的上边界对齐。</p>
<p><code>VIRT_TO_PHY(addr)</code>用于将内核层虚拟地址转换成物理地址。<code>PHY_TO_VIRT(addr)</code>的功能恰好相反。</p>
<p>定义全局结构体<code>struct global_memory_descriptor</code>用来保存有关内存信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E820</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> address;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> type;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">global_memory_descriptor</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">E820</span> <span class="title">e820</span>[32];</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> e820_length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">global_memory_descriptor</span> <span class="title">memory_management_struct</span>;</span></span><br></pre></td></tr></table></figure>

<p><code>__attribute__((packed))</code>修饰该结构体不会对齐空间，改用紧凑格式，这样才能解析内存空间的分布信息。</p>
<p>全局变量初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">global_memory_descriptor</span> <span class="title">memory_management_struct</span> =</span> &#123;&#123;<span class="number">0</span>&#125;, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>获取内存信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = (<span class="keyword">struct</span> E820 *)<span class="number">0xffff800000007e00</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">  color_printk(ORANGE, BLACK,</span><br><span class="line">               <span class="string">&quot;Address:%#018lx\tLength:%#018lx\tType:%#010x\n&quot;</span>, p-&gt;address,</span><br><span class="line">               p-&gt;length, p-&gt;type);</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;type == <span class="number">1</span>) &#123;</span><br><span class="line">    total_memory += p-&gt;length;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  memory_management_struct.e820[i].address += p-&gt;address;</span><br><span class="line">  memory_management_struct.e820[i].length += p-&gt;length;</span><br><span class="line">  memory_management_struct.e820[i].type += p-&gt;type;</span><br><span class="line">  memory_management_struct.e820_length = i;</span><br><span class="line"></span><br><span class="line">  p++;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;type &gt; <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">color_printk(ORANGE, BLACK, <span class="string">&quot;OS can used total ram: %018lx\n&quot;</span>, total_memory);</span><br></pre></td></tr></table></figure>

<p>将内存信息都保存到全局变量<code>memory_management_struct</code>。</p>
<p>然后对<code>E820</code>结构体数组中可用的内存段进行2MB物理页边界对齐，并统计出可用物理页的总量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">total_memory = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= memory_management_struct.e820_length; i++) &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start, end;</span><br><span class="line">  <span class="keyword">if</span> (memory_management_struct.e820[i].type != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  start = PAGE_2M_ALIGN(memory_management_struct.e820[i].address);</span><br><span class="line">  end = ((memory_management_struct.e820[i].address +</span><br><span class="line">          memory_management_struct.e820[i].length) &gt;&gt;</span><br><span class="line">         PAGE_2M_SHIFT)</span><br><span class="line">        &lt;&lt; PAGE_2M_SHIFT;</span><br><span class="line">  <span class="keyword">if</span> (end &lt;= start) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  total_memory += (end - start) &gt;&gt; PAGE_2M_SHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">color_printk(ORANGE, BLACK, <span class="string">&quot;OS can used total 2M PAGEs: %#010x=%010d\n&quot;</span>,</span><br><span class="line">             total_memory, total_memory);</span><br></pre></td></tr></table></figure>

<p>使用宏函数<code>PAGE_2M_ALIGN</code>将这些段的结束地址按<code>2MB</code>页的上边界对齐，经过对齐处理后的地址才是段的有效内存起始地址。这些段结束地址是由段的起始地址和段长度相加，随后将计算结果用移位的方式按<code>2MB</code>页的下边界对齐，也可以使用之前定义的宏常量<code>PAGE_2M_MASK</code>进行页的下边界对齐操作。如果计算后的起始地址小于等于计算后的结束地址，则视这个段为有效内存段，进而计算可用的物理页数量，并在屏幕上打印可用的物理页总数量。</p>
<p>虚拟机可用内存页数量为<code>1022</code>，运行结果如下：</p>
<p><img src="https://img.ansore.de/2022/07/30/3ffb2df992b5e9dc96934bff6ac3d036.png" alt="Screenshot_20220730_225903"></p>
<h1 id="分配可用的物理内存页"><a href="#分配可用的物理内存页" class="headerlink" title="分配可用的物理内存页"></a>分配可用的物理内存页</h1><h2 id="物理页管理结构的定义和初始化"><a href="#物理页管理结构的定义和初始化" class="headerlink" title="物理页管理结构的定义和初始化"></a>物理页管理结构的定义和初始化</h2><h3 id="物理内存描述定义"><a href="#物理内存描述定义" class="headerlink" title="物理内存描述定义"></a>物理内存描述定义</h3><p>为了汇总可用物理内存信息并方便以后管理，现在特将整个内存空间（通过<code>E820</code>功能返回的各个内存段信息，包括RAM空间、ROM空间、保留空间等），按<code>2MB</code>大小的物理内存页进行分割和对齐。分割后的每个物理内存页由一个<code>struct page</code>结构体负责管理，然后使用区域空间结构体<code>struct zone</code>代表各个可用物理内存区域（可用物理内存段，<code>zone</code>是一个比<code>page</code>更大的概念），并记录和管理本区域物理内存页的分配情况。最后将<code>struct page</code>结构体和<code>struct zone</code>结构体都保存到全局结构体<code>struct global_memory_descriptor</code>内。</p>
<p>物理内存页的管理结构示意图：</p>
<p><img src="https://img.ansore.de/2022/07/30/88f511487f511185bbd77d5910a6d1ec.png" alt="Screenshot_20220730_231227"></p>
<p><code>pages_struct</code>结构包含所有内存结构体，<code>zones_struct</code>结构包含所有区域空间结构体，它们增强全局结构体<code>struct global_memory_descriptor</code>的管理能力。每当执行页的分配或回收等操作时，内核回从全局结构体<code>struct global_memory_descriptor</code>中索引处对应的区域空间结构和页结构，并调整区域空间结构的管理信息与页结构的属性和参数。</p>
<p>内存页结构、区域空间结构和全局结构体详细定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone_struct</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> phy_address;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> attribute;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> reference_count;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>zone_struct</code>：指向本页所属的区域结构体</li>
<li><code>phy_address</code>：页的物理地址</li>
<li><code>attribute</code>：页的属性，描述当前页的映射状态、活动状态、使用者等信息</li>
<li><code>reference_count</code>：描述该页的引用次数</li>
<li><code>age</code>：描述页的创建时间</li>
</ul>
<p><code>phy_address</code>和<code>zone_struct</code>结构成员可以通过计算获得，添加这两个成员是为了节省计算时间，以空间换时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">pages_group</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> pages_length;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> zone_start_address;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> zone_end_address;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> zone_length;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> attribute;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">global_memory_descriptor</span> *<span class="title">gmd_struct</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> page_using_count;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> page_free_count;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> total_pages_link;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pages_group</code>：<code>struct page</code>结构体数组指针</li>
<li><code>pages_length</code>：本区域包含的<code>struct page</code>结构体数量</li>
<li><code>zone_start_address</code>：本区域的起始页对齐地址</li>
<li><code>zone_end_address</code>：本区域的结束页对齐地址</li>
<li><code>zone_length</code>：本区域经过对齐后的地址长度</li>
<li><code>attribute</code>：本区域空间的属性</li>
<li><code>gdm_struct</code>：指向全局结构体<code>struct global_memory_descriptor</code></li>
<li><code>page_using_count</code>：本区域已经使用的物理内存页数量</li>
<li><code>page_free_count</code>：本区域空闲物理内存页数量</li>
<li><code>total_pages_link</code>：本区域物理页被引用次数</li>
</ul>
<p>一个物理页可以同时映射到线性地址空间的多个位置上，所有<code>total_pages_link</code>与<code>page_using_count</code>在数值上不一定相等。而成员变量<code>attribute</code>则用于描述当前区域是否支持DMA、页是否经过页表映射等信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">global_memory_descriptor</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">E820</span> <span class="title">e820</span>[32];</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> e820_length;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *bits_map;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> bits_size;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> bits_length;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">pages_strust</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> pages_size;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> pages_length;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zones_struct</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> zones_size;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> zones_length;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, end_data, end_brk;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> end_of_struct;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>e820[32]</code>：物理内存段结构数组</p>
</li>
<li><p><code>e820_length</code>：物理内存段结构数组长度</p>
</li>
<li><p><code>bits_map</code>：物理地址空间页映射位图</p>
</li>
<li><p><code>bits_size</code>：物理地址空间页数量</p>
</li>
<li><p><code>bits_length</code>：物理地址空间页数量</p>
</li>
<li><p><code>pages_struct</code>：指向全局<code>struct page</code>结构体数组的指针</p>
</li>
<li><p><code>pages_size</code>：<code>struct page</code>结构体总数</p>
</li>
<li><p><code>pages_length</code>：<code>struct page</code>结构体数组长度</p>
</li>
<li><p><code>zones_struct</code>：指向全局<code>struct zone</code>结构体数组的指针</p>
</li>
<li><p><code>zones_size</code>：<code>struct zone</code>结构体总数</p>
</li>
<li><p><code>zones_length</code>：<code>struct zone</code>结构体数组长度</p>
</li>
<li><p><code>start_code</code>：内核程序的起始代码段地址</p>
</li>
<li><p><code>end_code</code>：内核程序的结束地址段地址</p>
</li>
<li><p><code>end_data</code>：内核程序的结束数据段地址</p>
</li>
<li><p><code>end_brk</code>：内核程序的结束地址</p>
</li>
<li><p><code>end_of_struct</code>：内存页管理结构的结尾地址</p>
</li>
</ul>
<p><code>bits_*</code>相关字段是<code>struct page</code>结构体的位图映射，它们一一对应的关系。建立<code>bits</code>位图映射的目的是为方便检索<code>pages_struct</code>中的空闲页表，而<code>pages_*</code>和<code>zones_*</code>相关变量用来记录<code>struct page</code>和<code>struct zone</code>结构体数组的首地址以及资源分配情况的信息。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _text;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _etext;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _edata;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> _end;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  pos.fb_length = (pos.x_resolution * pos.y_resolution * <span class="number">4</span> + PAGE_4K_SIZE - <span class="number">1</span>) &amp;</span><br><span class="line">                  PAGE_4K_MASK;</span><br><span class="line"></span><br><span class="line">  memory_management_struct.start_code = (<span class="type">unsigned</span> <span class="type">long</span>) &amp;_text;</span><br><span class="line">  memory_management_struct.end_code = (<span class="type">unsigned</span> <span class="type">long</span>) &amp;_etext;</span><br><span class="line">  memory_management_struct.end_data = (<span class="type">unsigned</span> <span class="type">long</span>) &amp;_edata;</span><br><span class="line">  memory_management_struct.end_brk = (<span class="type">unsigned</span> <span class="type">long</span>) &amp;_end;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>end_brk</code>成员变量保存内核程序的结束地址，这个地址后的内存空间可以被任意使用。</p>
<p>保存<code>struct page</code>和<code>struct zone</code>数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">memory_init</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 剔除e820结构体数组中的脏数据</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;type &gt; <span class="number">4</span> || p-&gt;length == <span class="number">0</span> || p-&gt;type &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...init</span><br><span class="line">  <span class="comment">// 根据物理地址空间的结束地址，把物理地址按照2MB页对齐，从而统计出物理地址空间可分页数量。这个物理地址空间可分页数不仅包括可用的物理内存，还包括内存空洞和ROM地址指针</span></span><br><span class="line">  total_memory =</span><br><span class="line">      memory_management_struct.e820[memory_management_struct.e820_length]</span><br><span class="line">          .address +</span><br><span class="line">      memory_management_struct.e820[memory_management_struct.e820_length]</span><br><span class="line">          .length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bits map construction</span></span><br><span class="line">  <span class="comment">// bits_map是映射位图的指针，它指向内核程序结束地址end_brk的4KB边界上对齐位置处</span></span><br><span class="line">  memory_management_struct.bits_map =</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">long</span> *)((memory_management_struct.end_brk + PAGE_4K_SIZE - <span class="number">1</span>) &amp;</span><br><span class="line">                        PAGE_4K_MASK);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将物理地址空间可分页数赋值给bits_size成员变量</span></span><br><span class="line">  memory_management_struct.bits_size = total_memory &gt;&gt; PAGE_2M_SHIFT;</span><br><span class="line"></span><br><span class="line">  memory_management_struct.bits_length =</span><br><span class="line">      (((<span class="type">unsigned</span> <span class="type">long</span>)(total_memory &gt;&gt; PAGE_2M_SHIFT) + <span class="keyword">sizeof</span>(<span class="type">long</span>) * <span class="number">8</span> - <span class="number">1</span>) /</span><br><span class="line">       <span class="number">8</span>) &amp;</span><br><span class="line">      (~(<span class="keyword">sizeof</span>(<span class="type">long</span>) - <span class="number">1</span>));</span><br><span class="line">  <span class="comment">// bits_map置位，以标注非内存页（内存空洞和ROM空间）已被使用，随后再通过程序将映射位图中的可用物理内存页复位</span></span><br><span class="line">  <span class="built_in">memset</span>(memory_management_struct.bits_map, <span class="number">0xff</span>,</span><br><span class="line">         memory_management_struct.bits_length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为<code>struct page</code>结构体建立存储空间，并对其进行初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// page construction init</span></span><br><span class="line">memory_management_struct.pages_struct =</span><br><span class="line">    (<span class="keyword">struct</span> page *)(((<span class="type">unsigned</span> <span class="type">long</span>)memory_management_struct.bits_map +</span><br><span class="line">                     memory_management_struct.bits_length + PAGE_4K_SIZE -</span><br><span class="line">                     <span class="number">1</span>) &amp;</span><br><span class="line">                    PAGE_4K_MASK);</span><br><span class="line">memory_management_struct.pages_size = total_memory &gt;&gt; PAGE_2M_SHIFT;</span><br><span class="line">memory_management_struct.pages_length =</span><br><span class="line">    ((total_memory &gt;&gt; PAGE_2M_SHIFT) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> page) + <span class="keyword">sizeof</span>(<span class="type">long</span>) -</span><br><span class="line">     <span class="number">1</span>) &amp;</span><br><span class="line">    (~(<span class="keyword">sizeof</span>(<span class="type">long</span>) - <span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(memory_management_struct.pages_struct, <span class="number">0x00</span>,</span><br><span class="line">       memory_management_struct.pages_length);</span><br></pre></td></tr></table></figure>

<p><code>struct page</code>结构体数组的存储空间位于bit映射位图之后，数组的元素数量为物理地址空间可分页数，其分配与计算方式同bit映射位图相似。</p>
<p>为<code>struct zone</code>结构体建立存储空间并初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zones construction init</span></span><br><span class="line">memory_management_struct.zones_struct =</span><br><span class="line">    (<span class="keyword">struct</span> zone *)(((<span class="type">unsigned</span> <span class="type">long</span>)memory_management_struct.pages_struct +</span><br><span class="line">                     memory_management_struct.pages_length + PAGE_4K_SIZE -</span><br><span class="line">                     <span class="number">1</span>) &amp;</span><br><span class="line">                    PAGE_4K_MASK);</span><br><span class="line"></span><br><span class="line">memory_management_struct.zones_size = <span class="number">0</span>;</span><br><span class="line">memory_management_struct.zones_length =</span><br><span class="line">    (<span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> zone) + <span class="keyword">sizeof</span>(<span class="type">long</span>) - <span class="number">1</span>) &amp; (~(<span class="keyword">sizeof</span>(<span class="type">long</span>) - <span class="number">1</span>));</span><br><span class="line"><span class="built_in">memset</span>(memory_management_struct.zones_struct, <span class="number">0x00</span>,</span><br><span class="line">       memory_management_struct.zones_length);</span><br></pre></td></tr></table></figure>

<p>执行流程与上下文的<code>struct page</code>结构体初始化过程基本相同。当前暂时无法计算<code>struct zone</code>结构体数组的元素个数，只能将成员变量<code>zone_size</code>设置为0，将<code>zone_length</code>成员变量暂时按照5个<code>struct zone</code>结构体来计算。</p>
<p>再次遍历<code>E820</code>数组完成各个数组成员变量的初始化工作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= memory_management_struct.e820_length; i++) &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start, end;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">z</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (memory_management_struct.e820[i].type != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  start = PAGE_2M_ALIGN(memory_management_struct.e820[i].address);</span><br><span class="line">  end = ((memory_management_struct.e820[i].address +</span><br><span class="line">          memory_management_struct.e820[i].length) &gt;&gt;</span><br><span class="line">         PAGE_2M_SHIFT)</span><br><span class="line">        &lt;&lt; PAGE_2M_SHIFT;</span><br><span class="line">  <span class="keyword">if</span> (end &lt;= start) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// zone init</span></span><br><span class="line">  z = memory_management_struct.zones_struct +</span><br><span class="line">      memory_management_struct.zones_size;</span><br><span class="line">  memory_management_struct.zones_size++;</span><br><span class="line">  z-&gt;zone_start_address = start;</span><br><span class="line">  z-&gt;zone_end_address = end;</span><br><span class="line">  z-&gt;zone_length = end - start;</span><br><span class="line"></span><br><span class="line">  z-&gt;page_using_count = <span class="number">0</span>;</span><br><span class="line">  z-&gt;page_free_count = end - start;</span><br><span class="line"></span><br><span class="line">  z-&gt;total_pages_link = <span class="number">0</span>;</span><br><span class="line">  z-&gt;attribute = <span class="number">0</span>;</span><br><span class="line">  z-&gt;gmd_struct = &amp;memory_management_struct;</span><br><span class="line"></span><br><span class="line">  z-&gt;pages_length = (end - start) &gt;&gt; PAGE_2M_SHIFT;</span><br><span class="line">  z-&gt;pages_group = (<span class="keyword">struct</span> page *)(memory_management_struct.pages_struct +</span><br><span class="line">                                   (start &gt;&gt; PAGE_2M_SHIFT));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// page init</span></span><br><span class="line">  p = z-&gt;pages_group;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; z-&gt;pages_length; j++, p++) &#123;</span><br><span class="line">    p-&gt;zone_struct = z;</span><br><span class="line">    p-&gt;phy_address = start + PAGE_2M_SIZE * j;</span><br><span class="line">    p-&gt;attribute = <span class="number">0</span>;</span><br><span class="line">    p-&gt;reference_count = <span class="number">0</span>;</span><br><span class="line">    p-&gt;age = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将当前struct page结构体所代表的物理地址转换成bits_map映射位图中对应的位</span></span><br><span class="line">    <span class="comment">// 由于此前已将bits_map映射位图全部置位，将可用物理页对应的位和1执行异或操作，将对应的可用物理页标注位未被使用</span></span><br><span class="line">    *(memory_management_struct.bits_map +</span><br><span class="line">      ((p-&gt;phy_address &gt;&gt; PAGE_2M_SHIFT) &gt;&gt; <span class="number">6</span>)) ^=</span><br><span class="line">        <span class="number">1UL</span> &lt;&lt; (p-&gt;phy_address &gt;&gt; PAGE_2M_SHIFT) % <span class="number">64</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历全部物理内存段信息以初始化可用物理内存段。代码首先过滤非物理内存段，再将剩下的可用物理内存段进行页对齐，如果本段物理内存有可用物理页，则把该段内存空间视为一个可用的<code>struct zone</code>区域空间，并初始化。</p>
<p>首尾：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init address 0 to page struct 0; because the</span></span><br><span class="line"><span class="comment">// memory_management_struct.e820[0].type ! = 1</span></span><br><span class="line">memory_management_struct.pages_struct-&gt;zone_struct =</span><br><span class="line">    memory_management_struct.zones_struct;</span><br><span class="line">memory_management_struct.pages_struct-&gt;phy_address = <span class="number">0UL</span>;</span><br><span class="line">memory_management_struct.pages_struct-&gt;attribute = <span class="number">0</span>;</span><br><span class="line">memory_management_struct.pages_struct-&gt;reference_count = <span class="number">0</span>;</span><br><span class="line">memory_management_struct.pages_struct-&gt;age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">memory_management_struct.zones_length =</span><br><span class="line">    (memory_management_struct.zones_size * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> zone) +</span><br><span class="line">     <span class="keyword">sizeof</span>(<span class="type">long</span>) - <span class="number">1</span>) &amp;</span><br><span class="line">    (~(<span class="keyword">sizeof</span>(<span class="type">long</span>) - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>打印关键信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">color_printk(</span><br><span class="line">    ORANGE, BLACK, <span class="string">&quot;bits_map:%#018lx,bits_size:%#018lx,bits_length:%#018lx\n&quot;</span>,</span><br><span class="line">    memory_management_struct.bits_map, memory_management_struct.bits_size,</span><br><span class="line">    memory_management_struct.bits_length);</span><br><span class="line"></span><br><span class="line">color_printk(ORANGE, BLACK,</span><br><span class="line">             <span class="string">&quot;pages_struct:%#018lx,pages_size:%#018lx,pages_length:%#018lx\n&quot;</span>,</span><br><span class="line">             memory_management_struct.pages_struct,</span><br><span class="line">             memory_management_struct.pages_size,</span><br><span class="line">             memory_management_struct.pages_length);</span><br><span class="line"></span><br><span class="line">color_printk(ORANGE, BLACK,</span><br><span class="line">             <span class="string">&quot;zones_struct:%#018lx,zones_size:%#018lx,zones_length:%#018lx\n&quot;</span>,</span><br><span class="line">             memory_management_struct.zones_struct,</span><br><span class="line">             memory_management_struct.zones_size,</span><br><span class="line">             memory_management_struct.zones_length);</span><br><span class="line"></span><br><span class="line">ZONE_DMA_INDEX = <span class="number">0</span>;</span><br><span class="line">ZONE_NORMAL_INDEX = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>全局变量<code>ZONE_DMA_INDEX</code>与<code>ZONE_NORMAL_INDEX</code>暂时无法区分，所以先将它们指向同一个<code>struct zone</code>区域空间，然后再显示<code>struct zone</code>结构体信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memory_management_struct.zones_size;</span><br><span class="line">     i++) <span class="comment">// need rewrite in the future</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">z</span> =</span> memory_management_struct.zones_struct + i;</span><br><span class="line">  color_printk(ORANGE, BLACK,</span><br><span class="line">               <span class="string">&quot;zone_start_address:%#018lx,zone_end_address:%#018lx,zone_&quot;</span></span><br><span class="line">               <span class="string">&quot;length:%#018lx,pages_group:%#018lx,pages_length:%#018lx\n&quot;</span>,</span><br><span class="line">               z-&gt;zone_start_address, z-&gt;zone_end_address, z-&gt;zone_length,</span><br><span class="line">               z-&gt;pages_group, z-&gt;pages_length);</span><br><span class="line">  <span class="keyword">if</span> (z-&gt;zone_start_address == <span class="number">0x100000000</span>)</span><br><span class="line">    ZONE_UNMAPED_INDEX = i;</span><br><span class="line">&#125;</span><br><span class="line">memory_management_struct.end_of_struct =</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>)((<span class="type">unsigned</span> <span class="type">long</span>)memory_management_struct.zones_struct +</span><br><span class="line">                    memory_management_struct.zones_length +</span><br><span class="line">                    <span class="keyword">sizeof</span>(<span class="type">long</span>) * <span class="number">32</span>) &amp;</span><br><span class="line">    (~(<span class="keyword">sizeof</span>(<span class="type">long</span>) -</span><br><span class="line">       <span class="number">1</span>)); <span class="comment">////need a blank to separate memory_management_struct</span></span><br></pre></td></tr></table></figure>

<p>显示区域空间结构体<code>struct zone</code>的详细统计信息，如果当前区域的起始地址是<code>0x100000000</code>，就将此区域索引值记录在全局变量<code>ZONE_UNMAPED_INDEX</code>内，表示该区域空间开始的物理页未曾经过页表映射。最后还需要调整<code>end_of_struct</code>的值，以记录上述结构的结束地址，并且预留一段内存空间防止越界访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">color_printk(</span><br><span class="line">    ORANGE, BLACK,</span><br><span class="line">    <span class="string">&quot;start_code:%#018lx,end_code:%#018lx,end_data:%#018lx,end_brk:%#018lx,&quot;</span></span><br><span class="line">    <span class="string">&quot;end_of_struct:%#018lx\n&quot;</span>,</span><br><span class="line">    memory_management_struct.start_code, memory_management_struct.end_code,</span><br><span class="line">    memory_management_struct.end_data, memory_management_struct.end_brk,</span><br><span class="line">    memory_management_struct.end_of_struct);</span><br><span class="line"></span><br><span class="line">i = VIRT_TO_PHY(memory_management_struct.end_of_struct) &gt;&gt; PAGE_2M_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">  page_init(memory_management_struct.pages_struct + j,</span><br><span class="line">            PG_PTABLE_MAPED | PG_KERNEL_INIT | PG_ACTIVE | PG_KERNEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印<code>start_code</code>、<code>end_code</code>、<code>end_data</code>、<code>end_brk</code>、<code>end_of_struct</code>，还将系统内核与内存管理单元结构所占物理页的<code>page</code>结构体全部初始化成 <code>PG_PTABLE_MAPED</code>（经过页表映射的页）| <code>PG_KERNEL_INIT</code>（内核初始化程序） | <code>PG_ACTIVE</code>（使用中的页） | <code>PG_KERNEL</code>（内核层页）属性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">global_cr3 = get_gdt();</span><br><span class="line"></span><br><span class="line">color_printk(INDIGO, BLACK, <span class="string">&quot;Global_CR3\t:%#018lx\n&quot;</span>, global_cr3);</span><br><span class="line">color_printk(INDIGO, BLACK, <span class="string">&quot;*Global_CR3\t:%#018lx\n&quot;</span>,</span><br><span class="line">             *PHY_TO_VIRT(global_cr3) &amp; (~<span class="number">0xff</span>));</span><br><span class="line">color_printk(PURPLE, BLACK, <span class="string">&quot;**global_cr3\t:%#018lx\n&quot;</span>,</span><br><span class="line">             *PHY_TO_VIRT(*PHY_TO_VIRT(global_cr3) &amp; (~<span class="number">0xff</span>)) &amp; (~<span class="number">0xff</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  *(PHY_TO_VIRT(global_cr3) + i) = <span class="number">0UL</span>;</span><br><span class="line"></span><br><span class="line">FLUSH_TLB();</span><br></pre></td></tr></table></figure>

<p><code>get_gdt()</code>用于读取CR3控制寄存器内保存的页目录基地址。然后打印几层页表的首地址。由于页表项只能保存物理地址，那么根据内核执行头程序（<code>head.S</code>）初始化的页表项可知，<code>global_cr3</code>变量保存的物理地址是<code>0x0000000000101000</code>，<code>*global_cr3</code>保存的物理地址是<code>0x0000000000102000</code>，而<code>**global_cr3</code>保存的物理地址是<code>0x0000000000103000</code></p>
<p>为了消除一致性页表映射，将页目录（PML4页表）中的前10个页表项清零（其实只要第一个清零就可以了）。虽然已将这些页表项清零，但是它们不会立即生效，必须使用<code>FLUSH_TLB()</code>函数才能让更改的页表项生效</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLUSH_TLB()                                                            \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                         \</span></span><br><span class="line"><span class="meta">    unsigned long tmpreg;                                                      \</span></span><br><span class="line"><span class="meta">    __asm__ __volatile__(<span class="string">&quot;movq %%cr3, %0 \n\t&quot;</span>                                 \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;movq %0, %%cr3 \n\t&quot;</span>                                 \</span></span><br><span class="line"><span class="meta">                         : <span class="string">&quot;=r&quot;</span>(tmpreg)                                        \</span></span><br><span class="line"><span class="meta">                         :                                                     \</span></span><br><span class="line"><span class="meta">                         : <span class="string">&quot;memory&quot;</span>);                                          \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>函数实现非常简单，仅仅重新赋值了一次<code>CR3</code>控制寄存器，以使更改后的页表项生效。</p>
<p>在更改页表项后，原页表项依然缓存与<code>TLB</code>（Translation Lookaside Buffer，旁路转换缓冲存储器）内，重新加载页目录基地址到<code>CR3</code>控制寄存器将迫使<code>TLB</code>自动刷新，这样就达到了更新页表项的目的</p>
<p><code>get_gdt</code>函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> *<span class="title function_">get_gdt</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *tmp;</span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;movq %%cr3, %0 \n\t&quot;</span> : <span class="string">&quot;=r&quot;</span>(tmp) : : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>CR3</code>控制寄存器里的页目录物理基地址读取出来，并将其传递给函数调用者。</p>
<p><code>page_init</code>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">page_init</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">unsigned</span> <span class="type">long</span> flags)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!page-&gt;attribute) &#123;</span><br><span class="line">    *(memory_management_struct.bits_map +</span><br><span class="line">      ((page-&gt;phy_address &gt;&gt; PAGE_2M_SHIFT) &gt;&gt; <span class="number">6</span>)) |=</span><br><span class="line">        (page-&gt;phy_address &gt;&gt; PAGE_2M_SHIFT) % <span class="number">64</span>;</span><br><span class="line">    page-&gt;attribute = flags;</span><br><span class="line">    page-&gt;reference_count++;</span><br><span class="line">    page-&gt;zone_struct-&gt;page_using_count++;</span><br><span class="line">    page-&gt;zone_struct-&gt;page_free_count++;</span><br><span class="line">    page-&gt;zone_struct-&gt;total_pages_link++;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((page-&gt;attribute &amp; PG_REFRENCED) ||</span><br><span class="line">             (page-&gt;attribute &amp; PG_K_SHARE_TO_U) || (flags &amp; PG_REFRENCED) ||</span><br><span class="line">             (flags &amp; PG_K_SHARE_TO_U)) &#123;</span><br><span class="line">    page-&gt;attribute |= flags;</span><br><span class="line">    page-&gt;reference_count++;</span><br><span class="line">    page-&gt;zone_struct-&gt;total_pages_link++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *(memory_management_struct.bits_map +</span><br><span class="line">      ((page-&gt;phy_address &gt;&gt; PAGE_2M_SHIFT) &gt;&gt; <span class="number">6</span>)) |=</span><br><span class="line">        <span class="number">1UL</span> &lt;&lt; (page-&gt;phy_address &gt;&gt; PAGE_2M_SHIFT) % <span class="number">64</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>struct page</code>进行初始化，如果当前页面结构或参数<code>flags</code>中含有引用属性<code>PG_REFRENCED</code>或共享属性<code>PG_K_SHARE_TO_U</code>，那么就只增加<code>struct page</code>结构体的引用计数和<code>struct zone</code>结构体的页面被引用计数。否则就仅仅添加页表属性，并置位bit映射位图的相应位。</p>
<h3 id="可用物理内存页的分配"><a href="#可用物理内存页的分配" class="headerlink" title="可用物理内存页的分配"></a>可用物理内存页的分配</h3><p><code>alloc_pages</code>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alloc page</span></span><br><span class="line"><span class="comment"> * @param zone_select</span></span><br><span class="line"><span class="comment"> * @param number</span></span><br><span class="line"><span class="comment"> * @param page_flags</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">alloc_pages</span><span class="params">(<span class="type">int</span> zone_select, <span class="type">int</span> number,</span></span><br><span class="line"><span class="params">                         <span class="type">unsigned</span> <span class="type">long</span> page_flags)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> page = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> zone_start = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> zone_end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (zone_select) &#123;</span><br><span class="line">  <span class="keyword">case</span> ZONE_DMA:</span><br><span class="line">    zone_start = <span class="number">0</span>;</span><br><span class="line">    zone_end = ZONE_DMA_INDEX;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ZONE_NOMAL:</span><br><span class="line">    zone_start = ZONE_DMA_INDEX;</span><br><span class="line">    zone_end = ZONE_NORMAL_INDEX;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ZONE_UNMAPED:</span><br><span class="line">    zone_start = ZONE_UNMAPED_INDEX;</span><br><span class="line">    zone_end = memory_management_struct.zones_size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    color_printk(RED, BLACK, <span class="string">&quot;alloc_pages error zone_select ZONE_DMA_INDE\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = zone_start; i &lt;= zone_end; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">z</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> j;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start, end, length;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((memory_management_struct.zones_struct + i)-&gt;page_free_count &lt; number) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z = memory_management_struct.zones_struct + i;</span><br><span class="line">    start = z-&gt;zone_start_address &gt;&gt; PAGE_2M_SHIFT;</span><br><span class="line">    end = z-&gt;zone_end_address &gt;&gt; PAGE_2M_SHIFT;</span><br><span class="line">    length = z-&gt;zone_length &gt;&gt; PAGE_2M_SHIFT;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="number">64</span> - start % <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = start; j &lt;= end; j += j % <span class="number">64</span> ? tmp : <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">long</span> *p = memory_management_struct.bits_map + (j &gt;&gt; <span class="number">6</span>);</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">long</span> shift = j % <span class="number">64</span>;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">long</span> k;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (k = shift; k &lt; <span class="number">64</span> - shift; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(((*p &gt;&gt; k) | (*(p + <span class="number">1</span>) &lt;&lt; (<span class="number">64</span> - k))) &amp;</span><br><span class="line">              (number == <span class="number">64</span> ? <span class="number">0xffffffffffffffff</span>UL : ((<span class="number">1UL</span> &lt;&lt; number) - <span class="number">1</span>)))) &#123;</span><br><span class="line">          <span class="type">unsigned</span> <span class="type">long</span> l;</span><br><span class="line">          page = j + k - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; number; l++) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">x</span> =</span> memory_management_struct.pages_struct + page + l;</span><br><span class="line">            page_init(x, page_flags);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> find_free_pages;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">find_free_pages:</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">struct</span> page *)(memory_management_struct.pages_struct + page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>alloc_pages</code>会根据<code>zone_select</code>参数来判定需要检索的内存区域空间。</p>
<p>当前Bochs虚拟机能开辟处2GB空间，以至于虚拟平台仅有一个可用物理内存段，因此<code>ZONE_DMA_INDEX</code>、<code>ZONE_NORMAL_INDEX</code>和<code>ZONE_UNMAPED_INDEX</code>三个变量均代表同一内存区域空间，即使用默认值0代表的内存区域空间。</p>
<p>分配内存代码从目标内存区域空间的起始内存页结构开始逐一遍历，直至内存区域空间的结尾。由于起始内存页结构对应的BIT映射位图往往位于非对齐（按<code>UNSIGNED LONG</code>类型对齐）位置处，而且每次将按<code>UNSIGNED LONG</code>类型作为遍历的步进长度，同时步进过程还会按<code>UNSIGNED LONG</code>类型对齐。因此起始页的BIT映射位图只能检索<code>tmp = 64 - start % 64;</code>次，随后借助代码<code>j += j % 64 ? tmp : 64</code>将索引变量<code>j</code>调整到对齐位置处。为了保证<code>alloc_pages</code>函数可以检索出64个连续的物理页，使用程序<code>(*p &gt;&gt; k) | (*(p + 1) &lt;&lt; (64 - k))</code>，将后一个<code>UNSIGNED LONG</code>变量的低位部分补齐到正在检索的变量中，只有这样才能保证最多可申请连续的64个物理页。</p>
<p>如果检索出满足条件的物理页组，便将BIT映射位图对应的内存页结构<code>struct page</code>初始化，并返回第一个内存页结构地址。</p>
<p><code>main.c</code>测试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">color_printk(RED, BLACK, <span class="string">&quot;memory_management_struct.bits_map:%#018lx\n&quot;</span>,</span><br><span class="line">             *memory_management_struct.bits_map);</span><br><span class="line">color_printk(RED, BLACK, <span class="string">&quot;memory_management_struct.bits_map:%#018lx\n&quot;</span>,</span><br><span class="line">             *(memory_management_struct.bits_map + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">page = alloc_pages(ZONE_NOMAL, <span class="number">64</span>, PG_PTABLE_MAPED | PG_ACTIVE | PG_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">64</span>; i++) &#123;</span><br><span class="line">  color_printk(INDIGO, BLACK, <span class="string">&quot;page%d\tattribute:%#018lx\taddress:%#018lx\t&quot;</span>,</span><br><span class="line">               i, (page + i)-&gt;attribute, (page + i)-&gt;phy_address);</span><br><span class="line">  i++;</span><br><span class="line">  color_printk(INDIGO, BLACK, <span class="string">&quot;page%d\tattribute:%#018lx\taddress:%#018lx\t\n&quot;</span>,</span><br><span class="line">               i, (page + i)-&gt;attribute, (page + i)-&gt;phy_address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">color_printk(RED, BLACK, <span class="string">&quot;memory_management_struct.bits_map:%#018lx\n&quot;</span>,</span><br><span class="line">             *memory_management_struct.bits_map);</span><br><span class="line">color_printk(RED, BLACK, <span class="string">&quot;memory_management_struct.bits_map:%#018lx\n&quot;</span>,</span><br><span class="line">             *(memory_management_struct.bits_map + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://img.ansore.de/2022/08/19/458ec2ab80204f6242ea7ea42ef934ab.png" alt="Screenshot_20220819_003356"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-中断处理</title>
    <url>/posts/ae9beb13.html</url>
    <content><![CDATA[<h1 id="8259A-PIC"><a href="#8259A-PIC" class="headerlink" title="8259A PIC"></a>8259A PIC</h1><p>通常PC机会采用两片8258A芯片级联的方式，将外部硬件设备的中断请求和引脚与处理器的中断接收引脚关联起来。两个芯片级联如下：</p>
<p><img src="https://img.ansore.de/2022/08/19/53ce0b946589a2d7d449ea426250b6ed.png" alt="Screenshot_20220819_222701"></p>
<p>其中一个8259A作为主芯片，与CPU的<code>INTR</code>引脚相连；另一个作为从芯片，与主芯片的<code>IR2</code>引脚相连。</p>
<p>通常情况下，会按照如下情况与外部设备相连：</p>
<p><img src="https://img.ansore.de/2022/08/19/39e82476075e523d07dd92f9a4494806.png" alt="Screenshot_20220819_223002"></p>
<p>一个8259A PIC包含两组寄存器，分别是ICW（初始化命令字）寄存器组和OCW（操作控制字）寄存器组。ICW用于初始化中断控制器，OCW用于操作中断控制寄存器。</p>
<p>PC采用I&#x2F;O地址映射方式，将8259A PIC的寄存器映射到I&#x2F;O端口地址空间，因此必须借助<code>IN</code>和<code>OUT</code>汇编指令才能访问8259A PIC。主8259A芯片的I&#x2F;O端口地址是20h和21h，从8259A芯片的I&#x2F;O端口地址是A0h和A1h。内部结构如下：</p>
<p><img src="https://img.ansore.de/2022/08/19/c4a9a4bf9e3c25ca29eada9d6a2545d9.png" alt="Screenshot_20220819_223439"></p>
<p>通过I&#x2F;O端口可操作中断控制寄存器的ICW和OCW寄存器组，进而配置IRR、PR、ISR、IMR等寄存器。</p>
<ul>
<li>IRR（Interrput Request Register，中断请求寄存器）用来保存IR0~IR7引脚上接收的中断请求，该寄存器有8bit分别对应外部引脚IR0~IR7。</li>
<li>IMR（Interrupt Mask Register，中断屏蔽寄存器）用于级联屏蔽的外部引脚，该寄存器同样有8位分别对应IRR寄存器中的每一位，当IMR中的某一位或几位被置位时，相应的IR引脚的中断请求信号将会被屏蔽，不处理。</li>
<li>PR（Priority Resolver，优先级解析器）将从IRR寄存器接收的中断请求中选取最高优先级者，将其发往ISR</li>
<li>ISR（In-Service Resigter，正在服务寄存器）记录着正在处理的中断请求，同时8259A芯片还会向CPU发送一个INT信号，而CPU在每执行完一条指令后检测是否接收到中断请求信号。如果收到中断请求信号，处理器将不再继续执行指令，转而向8259A芯片发送一个INTA来应答中断请求信号。8259A芯片收到这个应答信号后，便会把这个中断请求保存到ISR中（置位相应寄存器位）。与此同时，复位IRR寄存器中的对应中断请求信号位，以表示中断请求正在处理。随后，CPU还会发送第二个INTA脉冲信号，其作用是通知8259A芯片发送中断向量号，此时8259A性别会把中断向量号（8位数据）发送到数据总线上供CPU读取。当CPU收到中断向量号后，随即跳转到中断描述符表IDT检索向量号对应的门描述符，并自动执行描述符中的处理程序。</li>
</ul>
<p>如果8259A芯片采用AEOI（Automatic End of Interrupt，自动结束中断）方式，那么它会在第二个INTA脉冲信号的结尾处复位正在服务寄存器ISR的对应位。如果采用非自动结束方式，那么CPU必须在中断处理程序的结尾处向8259A芯片发送一个EOI（End of Interrupt，结束中断）命令，来复位ISR的对应位。如果中断请求来自级联的8259A芯片，则必须向两个芯片都发送EOI命令。此后8259A继续判断下一个最高优先级的中断，并重复处理过程。</p>
<h2 id="初始化命令字ICW"><a href="#初始化命令字ICW" class="headerlink" title="初始化命令字ICW"></a>初始化命令字ICW</h2><p>ICW寄存器组共包括ICW1、ICW2、ICW3、ICW4四个寄存器，必须按照ICW1到ICW4顺序初始化。主8259A芯片的ICW1寄存器映射到I&#x2F;O端口的20h地址处，ICW2、ICW3、ICW4寄存器映射到I&#x2F;O端口21h地址处；从8259A芯片的ICW1寄存器映射到I&#x2F;O端口A0h处，ICW2、ICW3、ICW4映射到I&#x2F;O端口A1h地址处。</p>
<p>对主从性别而初始化顺序可以是先后式（先配置主芯片的ICW寄存器组，再配置从芯片的ICW寄存器组）或交替式（先配置主&#x2F;从芯片的ICW1寄存器，再设置主&#x2F;从芯片的ICW2寄存器，以此类推知道ICW4寄存器）</p>
<h3 id="ICW1寄存器"><a href="#ICW1寄存器" class="headerlink" title="ICW1寄存器"></a>ICW1寄存器</h3><p>ICW1寄存器共有8位，各个位的功能描述：</p>
<p><img src="https://img.ansore.de/2022/08/19/42e8920a671fc02f37e853fb555bd98b.png" alt="Screenshot_20220819_230011"></p>
<p>主从芯片的ICW1寄存器都固定初始化为00010001B(11h)。</p>
<h3 id="ICW2寄存器"><a href="#ICW2寄存器" class="headerlink" title="ICW2寄存器"></a>ICW2寄存器</h3><p>ICW2寄存器共有8位，各个位的功能描述：</p>
<p><img src="https://img.ansore.de/2022/08/19/ee11ca802d1c1df71f96908ffc596bfb.png" alt="Screenshot_20220819_230204"></p>
<p>对中断向量号没有特殊要求，通常情况下，主8259A芯片的中断向量号设置位20h（占用中断向量号20h~21h），从8259A芯片的中断向量号设置为28h（占用中断向量号28h~2fh）</p>
<h3 id="ICW3寄存器"><a href="#ICW3寄存器" class="headerlink" title="ICW3寄存器"></a>ICW3寄存器</h3><p>ICW2寄存器共有8位，对于主&#x2F;从8259A芯片的ICW3寄存器含义不同，主8259A芯片各个位的功能描述：</p>
<p><img src="https://img.ansore.de/2022/08/19/7fca25ee780b47fc085dae3712eabdf8.png" alt="Screenshot_20220819_230435"></p>
<p>主8259A芯片的ICW3寄存器用于记录各IR引脚与从8259A芯片的级联状态。而从8259A芯片的ICW3寄存器则用于级联其与主8259A芯片的级联状态。</p>
<p>从8259A芯片的ICW3寄存器位：</p>
<p><img src="https://img.ansore.de/2022/08/19/a68a345e04d3857d37c36375372aeab5.png" alt="Screenshot_20220819_230652"></p>
<p>从级联结构可以看出，主8259A芯片的ICW3寄存器值被设置为04h，从8259A芯片的ICW3寄存器被设置为02h。</p>
<h3 id="ICW4寄存器"><a href="#ICW4寄存器" class="headerlink" title="ICW4寄存器"></a>ICW4寄存器</h3><p>ICW4寄存器有8位，含义如下：</p>
<p><img src="https://img.ansore.de/2022/08/19/3973eb7ce26434507c67c4daf28c2517.png" alt="Screenshot_20220819_230858"></p>
<p>功能说明：</p>
<ul>
<li>AEOI模式：此模式可使用中断控制寄存器收到CPU发来的第2个INTA中断响应脉冲，自动复位ISR寄存器的对应位</li>
<li>EOI模式：此模式下，处理器执行完中断处理程序后，必须手动向中断控制寄存器发送中断结束EOI指令，来复位ISR寄存器的对应位</li>
<li>FNM（Fully Nested Mode，全嵌套模式）：此模式下，中断请求的优先级按照引脚名从高到低依次为IR0~IR7。如果从8259A芯片的中断请求正在被处理，那么该从芯片将被主芯片屏蔽直到处理结束，即使从芯片产生更高优先级的中断请求也不会得到执行。</li>
<li>SFNM（Special Fully Nested Mode，特殊全嵌套模式）：该模式与FNM基本相同，不同点在于主芯片不会屏蔽从芯片，主芯片可以接收来自从芯片更高优先级的中断。在中断处理程序返回时，需要先向从芯片发送EOI命令，并检测从芯片的ISR寄存器值，如果ISR寄存器仍有其他中断请求，则无需向主芯片发送EOI命令。</li>
</ul>
<p>通常情况下，只需要将主&#x2F;从芯片的ICW4寄存器设置为01h即可。</p>
<h2 id="操作控制字OCW"><a href="#操作控制字OCW" class="headerlink" title="操作控制字OCW"></a>操作控制字OCW</h2><p>OCW寄存器组包含OCW1、OCW2、OCW3，用于控制和调整工作期间的中断控制寄存器，这3个寄存器没有操作顺序之分。主8259A芯片的OCW1寄存器映射到I&#x2F;O端口21h地址处，OCW2、OCW3寄存器映射到I&#x2F;O端口20h地址处；从8259A的OCW1寄存器映射到I&#x2F;O端口A1地址处，OCW2、OCW3寄存器映射到I&#x2F;O端口A0h地址处。</p>
<h3 id="OCW1寄存器"><a href="#OCW1寄存器" class="headerlink" title="OCW1寄存器"></a>OCW1寄存器</h3><p>OCW1是中断屏蔽寄存器，共有8位：</p>
<p><img src="https://img.ansore.de/2022/08/19/c88a2ac8f3d0bfc4abaefc85989fd3f2.png" alt="Screenshot_20220819_232621"></p>
<p>尽量屏蔽不用的中断，防止接收不必要的中断请求，从而导致中断请求过于拥堵。</p>
<h3 id="OCW2寄存器"><a href="#OCW2寄存器" class="headerlink" title="OCW2寄存器"></a>OCW2寄存器</h3><p>OCW2依然是个8位寄存器：</p>
<p><img src="https://img.ansore.de/2022/08/19/23e8d89ee11a25b5ee4e52b68418e021.png" alt="Screenshot_20220819_232753"></p>
<p>对于OCW2寄存器的D5~D7位，它们可以组合成多种模式：</p>
<p><img src="https://img.ansore.de/2022/08/19/80a6f2be08b0f575249a4fe191dcdf2f.png" alt="Screenshot_20220819_232914"></p>
<p>循环模式（D7&#x3D;1）：8259A芯片使用一个8位循环队列保存各个引脚的中断请求，当一个中断请求结束后，这个引脚的优先级将自动将为最低，然后排入优先级队列的末尾，依次类推</p>
<p>特殊循环（D7&#x3D;1，D6&#x3D;1）：特殊循环模式在循环模式的基础上，将D0~D2位指定的优先级设置为最低优先级，随后再按照循环模式循环降低中断请求中的优先级。</p>
<h3 id="OCW3寄存器"><a href="#OCW3寄存器" class="headerlink" title="OCW3寄存器"></a>OCW3寄存器</h3><p>OCW3寄存器也是8位寄存器：</p>
<p><img src="https://img.ansore.de/2022/08/19/f8b72adc9ccecbbf2048134ea05a3a4a.png" alt="Screenshot_20220819_233343"></p>
<p>特殊屏蔽模式：在某些场合，中断处理程序能够被更低优先级的中断请求打断，从用特殊屏蔽模式，可在置位IMR寄存器（OCW1寄存器）的同时复位对应的ISR寄存器位，从而可以处理其他优先级的中断请求。</p>
<h1 id="触发中断"><a href="#触发中断" class="headerlink" title="触发中断"></a>触发中断</h1><p>中断和异常的处理工作都需要保存和还原任务现场</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SAVE_ALL                                                               \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;cld; \n\t&quot;</span>                                                                  \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %rax; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %rax; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;movq %es, %rax; \n\t&quot;</span>                                                       \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %rax; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;movq %ds, %rax; \n\t&quot;</span>                                                       \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %rax; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;xorq %rax, %rax; \n\t&quot;</span>                                                      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %rbp; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %rdi; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %rsi; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %rdx; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %rcx; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %rbx; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %r8; \n\t&quot;</span>                                                            \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %r9; \n\t&quot;</span>                                                            \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %r10; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %r11; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %r12; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %r13; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %r14; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;pushq %r15; \n\t&quot;</span>                                                           \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;movq $0x10, %rdx; \n\t&quot;</span>                                                     \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;movq %rdx, %ds; \n\t&quot;</span>                                                       \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;movq %rdx, %es; \n\t&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>与<code>entry.S</code>文件的<code>error_code</code>模块极其相似，只不过中断处理程序的调用入口均指向同一中断处理函数<code>do_irq</code>，而且中断触发时不会压入错误码，所以此处无法复用代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_NAME2(nr) nr##_interrupt(void)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_NAME(nr) IRQ_NAME2(IRQ##nr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUILD_IRQ(nr)                                                          \</span></span><br><span class="line"><span class="meta">  void IRQ_NAME(nr);                                                           \</span></span><br><span class="line"><span class="meta">  __asm__(SYMBOL_NAME_STR(IRQ) #nr <span class="string">&quot;_interrupt: \n\t&quot;</span>                          \</span></span><br><span class="line"><span class="meta">                                   <span class="string">&quot;pushq $0x00 \n\t&quot;</span> SAVE_ALL                 \</span></span><br><span class="line"><span class="meta">                                   <span class="string">&quot;movq %rsp, %rdi \n\t&quot;</span>                      \</span></span><br><span class="line"><span class="meta">                                   <span class="string">&quot;leaq ret_from_intr(%rip), %rax \n\t&quot;</span>       \</span></span><br><span class="line"><span class="meta">                                   <span class="string">&quot;pushq %rax \n\t&quot;</span>                           \</span></span><br><span class="line"><span class="meta">                                   <span class="string">&quot;movq $&quot;</span> #nr <span class="string">&quot;, %rsi \n\t&quot;</span>                  \</span></span><br><span class="line"><span class="meta">                                   <span class="string">&quot;jmp do_irq \n\t&quot;</span>);</span></span><br></pre></td></tr></table></figure>

<p><code>##</code>用于连接两个宏值，宏展开过程中，会将操作符两边的内容连接起来，组成一个完整的内容。</p>
<p><code>#</code>操作符可以将后面的内容强制转换位字符串，</p>
<p><code>leaq ret_from_intr(%rip), %rax</code>用于取得中断处理程序的返回地址<code>ret_from_intr</code>，并将其保存到中断处理程序栈内。由于<code>SAVE_ALL</code>模块使用<code>JMP</code>指令进入中断处理程序<code>do_irq</code>，所以中断处理程序必须借助栈里的返回地址才能构成完整的调用过程（<code>JMP</code>指令在跳转过程中不会压入返回地址，而<code>RET</code>指令在函数返回时却需要返回地址）。使用<code>JMP</code>指令加放回地址的方法来替代<code>CALL</code>指令，可使函数调用过程更灵活</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BUILD_IRQ(<span class="number">0x20</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x21</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x22</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x23</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x24</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x25</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x26</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x27</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x28</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x29</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x2a</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x2b</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x2c</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x2d</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x2e</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x2f</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x30</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x31</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x32</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x33</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x34</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x35</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x36</span>)</span><br><span class="line">BUILD_IRQ(<span class="number">0x37</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*interrupt[<span class="number">24</span>])(<span class="type">void</span>) = &#123;</span><br><span class="line">    IRQ0x20_interrupt, IRQ0x21_interrupt, IRQ0x22_interrupt, IRQ0x23_interrupt,</span><br><span class="line">    IRQ0x24_interrupt, IRQ0x25_interrupt, IRQ0x26_interrupt, IRQ0x27_interrupt,</span><br><span class="line">    IRQ0x28_interrupt, IRQ0x29_interrupt, IRQ0x2a_interrupt, IRQ0x2b_interrupt,</span><br><span class="line">    IRQ0x2c_interrupt, IRQ0x2e_interrupt, IRQ0x2f_interrupt, IRQ0x30_interrupt,</span><br><span class="line">    IRQ0x31_interrupt, IRQ0x32_interrupt, IRQ0x33_interrupt, IRQ0x34_interrupt,</span><br><span class="line">    IRQ0x35_interrupt, IRQ0x36_interrupt, IRQ0x37_interrupt&#125;;</span><br></pre></td></tr></table></figure>

<p>使用宏函数<code>BUILD_IRQ</code>声明24个中断处理函数的入口代码片段，同时还定义了一个函数指针数组，数组的每个元素都指向宏函数<code>BUILD_IRQ</code>定义一个中断处理函数入口。</p>
<p>初始化主&#x2F;从9258A中断控制器和中断描述符表IDT内的各门描述符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">32</span>; i &lt; <span class="number">56</span>; i++) &#123;</span><br><span class="line">    set_intr_gate(i, <span class="number">2</span>, interrupt[i - <span class="number">32</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;8259A init \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8259A master ICW1-4</span></span><br><span class="line">  io_out8(<span class="number">0x20</span>, <span class="number">0x11</span>);</span><br><span class="line">  io_out8(<span class="number">0x21</span>, <span class="number">0x20</span>);</span><br><span class="line">  io_out8(<span class="number">0x21</span>, <span class="number">0x04</span>);</span><br><span class="line">  io_out8(<span class="number">0x21</span>, <span class="number">0x01</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8259A slave ICW1-4</span></span><br><span class="line">  io_out8(<span class="number">0xa0</span>, <span class="number">0x11</span>);</span><br><span class="line">  io_out8(<span class="number">0xa1</span>, <span class="number">0x28</span>);</span><br><span class="line">  io_out8(<span class="number">0xa1</span>, <span class="number">0x02</span>);</span><br><span class="line">  io_out8(<span class="number">0xa1</span>, <span class="number">0x01</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 8259A-M/S OCW1</span></span><br><span class="line">  io_out8(<span class="number">0x21</span>, <span class="number">0x00</span>);</span><br><span class="line">  io_out8(<span class="number">0xa1</span>, <span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">  sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用函数<code>set_intr_gate</code>将中断向量、中断处理函数配置到对应的门描述符中。外部硬件设备的中断向量号从32开始。主&#x2F;从8259A中断控制器进行初始化赋值：</p>
<p><img src="https://img.ansore.de/2022/08/20/dfab1f38bafdfd900c732b6281a8c5ac.png" alt="Screenshot_20220820_193524"></p>
<p>最后复位主&#x2F;从8259A中断控制器的中断屏蔽寄存器<code>IMR</code>全部中断屏蔽位，并使能中断（置位<code>EFLAGS</code>标志寄存器中的中断标志位<code>IF</code>）</p>
<p>中断处理函数<code>do_irq</code>负责分发中断请求到各个中断处理函数，当前进打印中断向量号，表明处理器正在处理中断处理函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> regs, <span class="type">unsigned</span> <span class="type">long</span> nr)</span> &#123; <span class="comment">// regs: rep, nr</span></span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;do_irq:%#08x\t&quot;</span>, nr);</span><br><span class="line">  io_out8(<span class="number">0x20</span>, <span class="number">0x20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其主要功能是显示当前中断请求的中断向量号，并向主8259A中断控制器发送EOI命令复位ISR寄存器。</p>
<p>程序运行的瞬间结束：</p>
<p><img src="https://img.ansore.de/2022/08/20/b110a0c21bffa1942585437b5a471436.png" alt="Screenshot_20220820_194709"></p>
<p><code>0x20</code>号中断是时钟中断，在没有配置时钟控制器之前开启时钟中断，从而导致不断有中断请求产生。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-键盘驱动</title>
    <url>/posts/678e8aa.html</url>
    <content><![CDATA[<h1 id="键盘功能"><a href="#键盘功能" class="headerlink" title="键盘功能"></a>键盘功能</h1><p>目前，键盘控制器芯片大多数采用Intel 8042芯片，键盘控制器芯片通过PS&#x2F;2接口或USB接口与外部设备相连。键盘舍内通常会包含一个Intel 8048或兼容芯片，这个芯片会时刻扫描键盘设备的每个按键，并将扫描到的按键进行编码，每个按键的编码是唯一的。8042芯片还负责控制系统的其他功能，如鼠标、A20地址线等。</p>
<p><img src="https://img.ansore.de/2022/08/20/0d2603d675d883788baa1f6954b775a2.png" alt="Screenshot_20220820_195522"></p>
<p>当8048芯片检测到按键被按下时，它会将按键对应的编码值通过PS&#x2F;2接口发送到8042键盘控制器芯片中。8042键盘控制器在接收到编码值后，会将其解析并转换成统一键盘扫描码（第1套XT扫描码集）。并存放到输出缓冲区等待处理器读取。如果此时还有新键被按下，8042芯片将不再接收新的数据，直到输出缓冲区被清空后，8042芯片才会继续接收编码数据。</p>
<p>键盘扫描码共三套，第1套为原始XT扫描码；第2套为AT扫描码；第三套为PS&#x2F;2扫描码。现在键盘默认使用第二套AT扫描码，出于兼容性考虑，第二套扫描码最终都会转换为第一套XT扫描码供处理器使用。</p>
<p>第1套扫描码，每个按键扫描码由1B数据组成，这1B数据的低7位代表按键的扫描码，最高位代表按键状态（0：按下，1：松开）。当某个按键被按下时，键盘控制器输出的扫描码叫做Make Code，松开按键时的扫描码叫做Break Code码。如按下字母b是<code>0x30</code>，松开是<code>0xb0</code></p>
<p>此外，还有一些扩展按键使用2B键盘扫描码，当扩展按键被按下后，键盘编码将相继产生两个中断请求，第一个中断请求将向处理器发送1B的扩展码前缀0xe0，第二个中断请求将向处理器发送1B的扩展Break Code码。当松开按键后，键盘编码器依然后相继产生两个中断请求，第一个中断请求向处理器发送1B的扩展前缀0xe0，第二个中断请求向处理器发送1B的扩展Break Code码。</p>
<p>还有两个特殊的按键，PrtScn和Pause&#x2F;Break。当PrtScn按键被按下时，处理器共会收到两组含有扩展码前缀的Make Code码，它们的字节顺序依次是<code>0xe0</code>、<code>0x2a</code>、<code>0xe0</code>、<code>0x37</code>；当松开PrtScn按键时，会依次产生<code>0xe0</code>、<code>0xb7</code>、<code>0xe0</code>、<code>0xaa</code>四个键盘扫描码。而在按下Pause&#x2F;Break键时，键盘编码器产生扩展码字节顺序<code>0xe1</code>、<code>0x1d</code>、<code>0x45</code>、<code>0xe1</code>、<code>0x9d</code>、<code>0xc5</code>，与其他按键不同的是，松开此按键并不会产生键盘扫描码。</p>
<p>键盘控制器的寄存器地址同样采用I&#x2F;O地址映射方式，使用IN和OUT汇编指令可对寄存器进行访问。键盘控制器的I&#x2F;O端口地址时60h和64h，其中60h地址处的寄存器时读写缓冲区，64h地址处的寄存器是用于读取寄存器状态或者向芯片发送控制命令。</p>
<h1 id="键盘中断捕捉"><a href="#键盘中断捕捉" class="headerlink" title="键盘中断捕捉"></a>键盘中断捕捉</h1><p>先屏蔽键盘中断请求以外的请求：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  io_out8(<span class="number">0x21</span>, <span class="number">0xfd</span>);</span><br><span class="line">  io_out8(<span class="number">0xa1</span>, <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">  sti();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_irq</code>添加键盘扫描码的接收代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> regs, <span class="type">unsigned</span> <span class="type">long</span> nr)</span> &#123; <span class="comment">// regs: rep, nr</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> x;</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;do_irq:%#08x\t&quot;</span>, nr);</span><br><span class="line">  x = io_in8(<span class="number">0x60</span>);</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;key code: %#08x\n&quot;</span>, x);</span><br><span class="line">  io_out8(<span class="number">0x20</span>, <span class="number">0x20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助汇编指令IN从I&#x2F;O端口地址60h处读取键盘扫描码，并打印到屏幕上</p>
<p><img src="https://img.ansore.de/2022/08/20/f569d275a7ad643336ac7f8814ce3cf4.png" alt="Screenshot_20220820_202406"></p>
<p>如图是依次打印按下然后松开键盘b、PrtScn、Pause的扫描码。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-进程管理</title>
    <url>/posts/5c82fe62.html</url>
    <content><![CDATA[<h1 id="进程管理模块"><a href="#进程管理模块" class="headerlink" title="进程管理模块"></a>进程管理模块</h1><p>进程是拥有执行资源的最小单位，它为每个程序维护着运行时的各种资源，如进程ID、进程的页表、进程执行现场的寄存器值、进程各个段地址空间分布信息以及进程执行时的维护信息等，它们在程序的运行期间会被经常或实时更新。这些资源被结构化到PCB（Process Control Block，进程控制结构体）内，PCB作为进程调度的决策信息供调度算法使用。</p>
<p>进程调度策略负责将满足运行条件或迫切需要执行的进程到空闲处理器中执行。进程调度策略直接影响程序的执行效率。</p>
<h1 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h1><p>PCB用于记录进程的资源使用情况（包括软件资源是硬件资源）和运行状态等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list</span> <span class="title">list</span>;</span> <span class="comment">//连接各个进程控制结构体的双向链表</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">long</span> state; <span class="comment">// 进程状态(运行态/停止态/可中断态)volatile修饰,处理器每次使用这个进程状态前都必须重新读取这个值而不能使用寄存器中的备份值</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">// 进程标志(进程/线程/内核线程)</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">// 内存空间分布结构体,记录内存页表和程序段信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">thread</span>;</span> <span class="comment">// 进程切换时保留的状态信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0x0000000000000000 - 0x00007fffffffffff user</span></span><br><span class="line">  <span class="comment">// 0xffff800000000000 - 0xffffffffffffffff kernel</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> addr_limit; <span class="comment">// 进程地址空间范围</span></span><br><span class="line"></span><br><span class="line">  <span class="type">long</span> pid; <span class="comment">// 进程ID号</span></span><br><span class="line">  <span class="type">long</span> counter; <span class="comment">// 进程可用时间片</span></span><br><span class="line">  <span class="type">long</span> signal; <span class="comment">// 进程持有的信号</span></span><br><span class="line">  <span class="type">long</span> priority; <span class="comment">// 进程优先级</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员变量<code>mm</code>与<code>thread</code>负责在进程调度过程中保存或还原CR3控制寄存器的页目录基地址和通用寄存器值</p>
<p><img src="https://img.ansore.de/2022/08/21/503a1dfccdacfdabeca5188357a0da4e.png" alt="Screenshot_20220821_194848"></p>
<p><code>state</code>成员变量使用<code>volatile</code>关键字修饰，说明该变量可能会在意想不到的情况下修改，因此编译器不要对此成员变量进行优化。处理器每次使用这个变量前，必须重新读取该变量的值，而不能使用保存在寄存器的值。</p>
<p>内存空间分布结构体<code>struct mm_struct</code>描述了进程的页表结构和各程序段信息，其中有页目录基地址、代码段、数据段、只读数据段、应用层栈顶地址等信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">  <span class="type">pml4t_t</span> *pgd; <span class="comment">// page table point 内存页表指针,保存CR3控制寄存器值(页目录基地址与页表属性的组合值)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code; <span class="comment">// 代码段空间</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start_data, end_data; <span class="comment">// 数据段空间</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start_rodata, end_rodata; <span class="comment">// 只读数据段空间</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start_brk, end_brk; <span class="comment">// 动态内存分配区(堆区域)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start_stack; <span class="comment">// 应用层栈基地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>mm_struct</code>结构体各个成员变量的功能说明，其中成员变量<code>pgd</code>保存在<code>CR3</code>控制寄存器值（页目录基地址与页表属性的组合值），成员变量<code>start_stack</code>记录应用程序在应用层的栈顶地址，其他成员变量描述了应用程序的各段地址空间。<img src="https://img.ansore.de/2022/08/21/57dcd2f5cc3fc188187f2f54b6fb3c2e.png" alt="Screenshot_20220821_195640"></p>
<p><img src="https://img.ansore.de/2022/08/21/8bca385335deadb4702f7681bface903.png" alt="Screenshot_20220821_195707"></p>
<p>每当进程发生调度切换时，都必须将执行现场的寄存器保存起来，已备再次执行时使用。</p>
<p>这些数据都保存在<code>struct thread_struct</code>结构体内：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rsp0; <span class="comment">// in tss 应用程序在内核层使用的栈基地址</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rip; <span class="comment">// 内核层代码指针(进程切换回来时执行代码的地址)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rsp; <span class="comment">// 内核层当前栈指针(进程切换时的栈指针值)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> fs; <span class="comment">// FS段寄存器</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> gs; <span class="comment">// GS段寄存器</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> cr2; <span class="comment">// CR2控制寄存器</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trap_nr; <span class="comment">// 产生异常的异常号</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> error_code; <span class="comment">// 异常的错误码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中成员变量<code>rsp0</code>记录应用程序在内核层使用的栈基地址，<code>rsp</code>保存这进程切换时的栈指针值，<code>rip</code>成员保存着进程切换回来时执行代码的地址。</p>
<p><img src="https://img.ansore.de/2022/08/21/cace5d8741f2e7588d034feed71403fe.png" alt="Screenshot_20220821_200012"></p>
<p>关于进程的内核层栈空间实现，借鉴Linux内核设计思想，把进程控制结构体<code>struct task_struct</code>与进程的内核层栈空间融为一体。其中，低地址处存放<code>struct task_struct</code>结构体，余下高地址空间作为进程内核层栈空间使用，如下：</p>
<p><img src="https://img.ansore.de/2022/08/21/ae370888ce62f58d82e510ec79fa0e46.png" alt="Screenshot_20220821_200307"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">stack</span>[STACK_SIZE / <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)]; <span class="comment">// 这个stack数组将占用32KB以至于这个结构体实际上按32KB对齐</span></span><br><span class="line">&#125; __attribute__((aligned(<span class="number">8</span>))); <span class="comment">// 8 bytes align</span></span><br></pre></td></tr></table></figure>

<p>借助联合体，把进程控制结构体<code>struct task_struct</code>与进程的内核层栈空间连续到了一起，其中宏常量<code>TASK_SIZE</code>被定义为32768B（32KB），它表示进程的内核栈空间和<code>struct task_struct</code>结构体占用的存储空间总量为32KB，在Intel i386处理器架构的Linux内核中默认使用8KB的内核栈空间。由于64位处理器的寄存器位宽扩大一倍，相应的栈空间也必须扩大，此处暂时设定为32KB，待到存储空间不足再扩容</p>
<p>这个联合体占用32KB，并将这段空间按8B进行对齐，实际上这个联合体的起始地址必须按照32KB进行对齐。</p>
<p>初始化全局变量<code>init_task_union</code>，并作为系统的第一个进程。进程控制结构体数组<code>init_task</code>（指针数组）是为各个处理器创建的初始控制结构体，当前只有第0个元素使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> <span class="title">init_mm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">init_thread</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_TASK(tsk)                                                         \</span></span><br><span class="line"><span class="meta">  &#123;                                                                            \</span></span><br><span class="line"><span class="meta">    .state = TASK_UNINTERRUPTIBLE, .flags = PF_KTHREAD, .mm = &amp;init_mm,        \</span></span><br><span class="line"><span class="meta">    .thread = &amp;init_thread, .addr_limit = 0xffff800000000000, .pid = 0,        \</span></span><br><span class="line"><span class="meta">    .counter = 1, .signal = 0, .priority = 0                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span> <span class="title">init_task_union</span> __<span class="title">attribute__</span>((</span></span><br><span class="line"><span class="class">    __<span class="title">section__</span>(&quot;.<span class="title">data</span>.<span class="title">init_task</span>&quot;))) =</span> &#123;INIT_TASK(init_task_union.task)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程控制结构体数组init_task(指针数组)是为各处理器创建的初始进程控制结构体,目前只有数组第0个投入使用,剩余成员将在多核处理器初始化后创建</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">init_task</span>[<span class="title">NR_CPUS</span>] =</span> &#123;&amp;init_task_union.task, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> <span class="title">init_mm</span> =</span> &#123;<span class="number">0</span>&#125;; <span class="comment">// 由Start_Kernel调用task_init函数填充完整</span></span><br><span class="line"><span class="comment">//系统第一个进程的执行现场信息结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">init_thread</span> =</span> &#123;</span><br><span class="line">    .rsp0 = (<span class="type">unsigned</span> <span class="type">long</span>)(init_task_union.<span class="built_in">stack</span> +</span><br><span class="line">                            STACK_SIZE / <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)), <span class="comment">//in tss//应用程序在内核层使用的栈基地址</span></span><br><span class="line">    .rsp = (<span class="type">unsigned</span> <span class="type">long</span>)(init_task_union.<span class="built_in">stack</span> +</span><br><span class="line">                           STACK_SIZE / <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)), <span class="comment">//内核层当前栈指针(进程切换时的栈指针值)</span></span><br><span class="line">    .fs = KERNEL_DS,</span><br><span class="line">    .gs = KERNEL_DS,</span><br><span class="line">    .cr2 = <span class="number">0</span>,</span><br><span class="line">    .trap_nr = <span class="number">0</span>,</span><br><span class="line">    .error_code = <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><code>init_task_union</code>使用<code>__attribute__((__section__(&quot;.data.init_task&quot;)))</code>修饰，从而将该全局变量链接到一个特别的程序段内。</p>
<p>链接脚本<code>kernel.lds</code>为这个程序规划地址空间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  .rodata :</span><br><span class="line">  &#123;</span><br><span class="line">      _rodata = .;</span><br><span class="line">      *(.rodata)</span><br><span class="line">      _erodata = .;</span><br><span class="line">  &#125;</span><br><span class="line">  . = ALIGN(32768);</span><br><span class="line">  .data.init_task : &#123;*(.data.init_task)&#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.data.init_task</code>被放置在只读数据段<code>rodata</code>之后，并按照32KB对齐。此处采用32KB对齐而非8B对齐，因为处理<code>init_task_union</code>联合体都使用<code>kmalloc</code>函数申请，函数<code>kmalloc</code>返回的内存空间起始地址均按照32KB对齐。如果把<code>.data.init_task</code>段按8B对齐，在使用宏<code>current</code>和<code>GET_CURRENT</code>的过程中会有隐患。</p>
<p>IA-32e模式下的TSS结构，<code>INIT_TSS</code>初始化宏以及各处理器的TSS结构体数组<code>init_tss</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IA-32e模式下的TSS结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> reserved0;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rsp0;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rsp1;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rsp2;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> reserved1;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ist1;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ist2;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ist3;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ist4;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ist5;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ist6;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ist7;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> reserved2;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> reserved3;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> iomapbaseaddr;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_TSS                                                               \</span></span><br><span class="line"><span class="meta">  &#123;                                                                            \</span></span><br><span class="line"><span class="meta">    .reserved0 = 0,                                                            \</span></span><br><span class="line"><span class="meta">    .rsp0 = (unsigned long)(init_task_union.stack +                            \</span></span><br><span class="line"><span class="meta">                            STACK_SIZE / sizeof(unsigned long)),               \</span></span><br><span class="line"><span class="meta">    .rsp1 = (unsigned long)(init_task_union.stack +                            \</span></span><br><span class="line"><span class="meta">                            STACK_SIZE / sizeof(unsigned long)),               \</span></span><br><span class="line"><span class="meta">    .rsp2 = (unsigned long)(init_task_union.stack +                            \</span></span><br><span class="line"><span class="meta">                            STACK_SIZE / sizeof(unsigned long)),               \</span></span><br><span class="line"><span class="meta">    .reserved1 = 0, .ist1 = 0xffff800000007c00, .ist2 = 0xffff800000007c00,    \</span></span><br><span class="line"><span class="meta">    .ist3 = 0xffff800000007c00, .ist4 = 0xffff800000007c00,                    \</span></span><br><span class="line"><span class="meta">    .ist5 = 0xffff800000007c00, .ist6 = 0xffff800000007c00,                    \</span></span><br><span class="line"><span class="meta">    .ist7 = 0xffff800000007c00, .reserved2 = 0, .reserved3 = 0,                \</span></span><br><span class="line"><span class="meta">    .iomapbaseaddr = 0                                                         \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line"><span class="comment">//各个处理器的TSS结构体数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tss_struct</span> <span class="title">init_tss</span>[<span class="title">NR_CPUS</span>] =</span> &#123;[<span class="number">0</span> ... NR_CPUS - <span class="number">1</span>] = INIT_TSS&#125;;</span><br></pre></td></tr></table></figure>

<p><code>__attribute__((packed))</code>修饰这个结构体，表示编译器不会对此结构体内的成员变量进行字节对齐。</p>
<p>将执行现场的数据组织成一个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rbx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rcx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rdx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rsi;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rdi;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rbp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ds;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> es;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rax;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> func;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> errcode;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rip;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rflags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> rsp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>get_current</code>函数和<code>GET_CURRENT</code>宏的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *<span class="title function_">get_current</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">current</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;andq %%rsp,%0 \n\t&quot;</span> : <span class="string">&quot;=r&quot;</span>(current) : <span class="string">&quot;0&quot;</span>(~<span class="number">32767UL</span>));</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> current get_current()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_CURRENT                                                            \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;movq %rsp, %rbx \n\t&quot;</span>                                                       \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;andq $-32768,%rbx \n\t&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>借助<code>struct task_union</code>时使用的32KB对齐技巧实现。<code>get_current</code>与<code>GET_CURRENT</code>均是在当前栈指针寄存器<code>RSP</code>的基础上，按32KB下边界对齐实现的。实现方法是将数值32767（32KB-1）取反，再将取得的结果<code>0xffffffffffff8000</code>与栈指针寄存器<code>RSP</code>的值执行逻辑与计算，结果就是当前进程<code>struct task_struct</code>结构体基地址。（将32KB对齐的地址清零，之后则是task的起始地址）</p>
<h1 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h1><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>进程切换示意图：</p>
<p><img src="https://img.ansore.de/2022/08/22/4ef4270e1f116939610ef52c89e6cf1c.png" alt="Screenshot_20220822_220738"></p>
<p><code>prev</code>进程通过调用<code>switch_to</code>模块来保存RSP寄存器的当前值，并指定切换会<code>prev</code>进程时的RIP寄存器值，此处默认将其指定在标识符<code>1:</code>处。随后将<code>next</code>进程的栈指针恢复到RSP寄存器中，再把<code>next</code>进程执行现场的RIP寄存器值压入<code>next</code>进程的内核层栈空间中（RSP寄存器的恢复在前，此后的数据将压入<code>next</code>进程的内核层栈空间）。最后借助<code>JMP</code>指令执行<code>__switch_to</code>函数，<code>__switch_to</code>函数执行完成返回执行<code>RET</code>指令，进而跳转到<code>next</code>进程继续执行（恢复执行现场的RIP寄存器）。至此，进程间的切换完毕。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(prev, next)                                                  \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                         \</span></span><br><span class="line"><span class="meta">    __asm__ __volatile__(<span class="string">&quot;pushq %%rbp \n\t&quot;</span>                                    \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;pushq %%rax \n\t&quot;</span>                                    \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;movq %%rsp, %0 \n\t&quot;</span>                                 \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;movq %2, %%rsp \n\t&quot;</span>                                 \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;leaq 1f(%%rip), %%rax \n\t&quot;</span>                          \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;movq %%rax, %1 \n\t&quot;</span>                                 \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;pushq %3 \n\t&quot;</span>                                      \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;jmp __switch_to \n\t&quot;</span>                                \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;1: \n\t&quot;</span>                                             \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;popq %%rax \n\t&quot;</span>                                     \</span></span><br><span class="line"><span class="meta">                         <span class="string">&quot;popq %%rbp \n\t&quot;</span>                                     \</span></span><br><span class="line"><span class="meta">                         : <span class="string">&quot;=m&quot;</span>(prev-&gt;thread-&gt;rsp), <span class="string">&quot;=m&quot;</span>(prev-&gt;thread-&gt;rip)    \</span></span><br><span class="line"><span class="meta">                         : <span class="string">&quot;m&quot;</span>(next-&gt;thread-&gt;rsp), <span class="string">&quot;m&quot;</span>(next-&gt;thread-&gt;rip),     \</span></span><br><span class="line"><span class="meta">                           <span class="string">&quot;D&quot;</span>(prev), <span class="string">&quot;S&quot;</span>(next)                                \</span></span><br><span class="line"><span class="meta">                         : <span class="string">&quot;memory&quot;</span>);                                          \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p><code>RDI</code>和<code>RSI</code>寄存器分别保存宏参数<code>prev</code>和<code>next</code>所代表的进程控制块结构体，执行<code>__switch_to</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __switch_to(<span class="keyword">struct</span> task_struct *prev, <span class="keyword">struct</span> task_struct *next) &#123;</span><br><span class="line"></span><br><span class="line">  init_tss[<span class="number">0</span>].rsp0 = next-&gt;thread-&gt;rsp0; </span><br><span class="line">  <span class="comment">//首先将next进程的内核层栈基地址设置到TSS结构体中</span></span><br><span class="line">  set_tss64(init_tss[<span class="number">0</span>].rsp0, init_tss[<span class="number">0</span>].rsp1, init_tss[<span class="number">0</span>].rsp2,</span><br><span class="line">            init_tss[<span class="number">0</span>].ist1, init_tss[<span class="number">0</span>].ist2, init_tss[<span class="number">0</span>].ist3,</span><br><span class="line">            init_tss[<span class="number">0</span>].ist4, init_tss[<span class="number">0</span>].ist5, init_tss[<span class="number">0</span>].ist6,</span><br><span class="line">            init_tss[<span class="number">0</span>].ist7);</span><br><span class="line">  <span class="comment">//保存当前进程的FS和GS段寄存器值</span></span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;movq %%fs, %0 \n\t&quot;</span> : <span class="string">&quot;=a&quot;</span>(prev-&gt;thread-&gt;fs));</span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;movq %%gs, %0 \n\t&quot;</span> : <span class="string">&quot;=a&quot;</span>(prev-&gt;thread-&gt;gs));</span><br><span class="line">  <span class="comment">//将next进程保存的FS和GS段寄存器值还原</span></span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;movq %0, %%fs \n\t&quot;</span> ::<span class="string">&quot;a&quot;</span>(next-&gt;thread-&gt;fs));</span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;movq %0, %%gs \n\t&quot;</span> ::<span class="string">&quot;a&quot;</span>(next-&gt;thread-&gt;gs));</span><br><span class="line"></span><br><span class="line">  color_printk(WHITE, BLACK, <span class="string">&quot;prev-&gt;thread-&gt;rsp0:%#018lx\n&quot;</span>,</span><br><span class="line">               prev-&gt;thread-&gt;rsp0);</span><br><span class="line">  color_printk(WHITE, BLACK, <span class="string">&quot;next-&gt;thread-&gt;rsp0:%#018lx\n&quot;</span>,</span><br><span class="line">               next-&gt;thread-&gt;rsp0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。。当参数超过6个时，参数会向地址压栈</p>
<p>1、%rax作为函数返回值使用<br>2、%rsp指向栈顶<br>3、%rdi、%rsi、%rdx、%rcx、%r8、%r9、%r10等寄存器用于存放函数参数</p>
</blockquote>
<p>执行过程如下：</p>
<ul>
<li>把<code>rbp</code>, <code>rax</code>入栈（执行switch_to函数的进程的栈，一般为prev）</li>
<li>把当前<code>rsp</code>、<code>1f(%%rip)</code>的值都存入<code>prev-&gt;thread</code>对应变量中（若切换回<code>prev</code>进程执行，则执行<code>1:</code>处的指令，即从栈中弹出<code>rax</code>, <code>rbp</code>）</li>
<li>把<code>next-&gt;thread-&gt;rsp</code>的值放入<code>rsp</code>中</li>
<li>把<code>next-&gt;thread-&gt;rip</code>的值入栈</li>
<li>执行<code>jmp __switch_to</code>指令，跳转到 <code>task.c</code> 中执行，使用<code>RDI(=prev)</code>和<code>RSI(=next)</code>传递参数</li>
<li>设置<code>tss</code></li>
<li>把当前<code>fs</code>, <code>gs</code>的值都存入<code>prev-&gt;thread</code>对应变量中</li>
<li>把<code>next-&gt;thread</code>对应值存入<code>fs</code>, <code>gs</code>中</li>
<li>执行<code>ret</code>指令，从栈中弹出<code>next-&gt;thread-&gt;rip</code>的值，CPU跳转至<code>next-&gt;thread-&gt;rip</code>处执行</li>
</ul>
<p>现在假设 <strong>1号进程</strong> 已经初始化完毕，有了自己的32-kb栈和进程信息。需要 <strong>0号进程</strong> 执行<code>switch_to(prev, next)</code>，进行进程切换，其中<code>prev</code>是0号进程，<code>next</code>是1号进程。<strong>切换结果是</strong>当前CPU的<code>rsp</code>, <code>rip</code>, <code>fs</code>, <code>gs</code>值存入<code>prev-&gt;thread</code>对应变量中，加载<code>next-&gt;thread</code>的对应值到<code>rsp</code>, <code>rip</code>, <code>fs</code>, <code>gs</code>中，并开始执行<code>next-&gt;thread-&gt;rip</code>处的指令。这样，栈（<code>rsp</code>）和指令（<code>rip</code>）都切换到了<code>next</code>进程，开始执行<code>next</code>进程。</p>
<h2 id="初始化第一个进程"><a href="#初始化第一个进程" class="headerlink" title="初始化第一个进程"></a>初始化第一个进程</h2><p>对第一个进程进行初始化，调用<code>kernel_thread</code>为系统创建处一个新进程，随后借助<code>switch_to</code>执行进程切换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>; <span class="comment">//PCB进程控制块指针</span></span><br><span class="line"></span><br><span class="line">  init_mm.pgd = (<span class="type">pml4t_t</span> *)global_cr3; <span class="comment">// 补充完系统第一个进程的页表结构和各个段信息的内存空间分布结构体</span></span><br><span class="line"></span><br><span class="line">  init_mm.start_code = memory_management_struct.start_code; <span class="comment">// 内核代码段开始地址0xffff 8000 0010 0000</span></span><br><span class="line">  init_mm.end_code = memory_management_struct.end_code; <span class="comment">// 内核代码段结束地址</span></span><br><span class="line"></span><br><span class="line">  init_mm.start_data = (<span class="type">unsigned</span> <span class="type">long</span>)&amp;_data; <span class="comment">//内核数据段开始地址</span></span><br><span class="line">  init_mm.end_data = memory_management_struct.end_data; <span class="comment">//内核数据段结束地址</span></span><br><span class="line"></span><br><span class="line">  init_mm.start_rodata = (<span class="type">unsigned</span> <span class="type">long</span>)&amp;_rodata; <span class="comment">//只读数据段空间</span></span><br><span class="line">  init_mm.end_rodata = (<span class="type">unsigned</span> <span class="type">long</span>)&amp;_erodata;</span><br><span class="line"></span><br><span class="line">  init_mm.start_brk = <span class="number">0</span>;</span><br><span class="line">  init_mm.end_brk = memory_management_struct.end_brk; <span class="comment">// 内核代码结束地址</span></span><br><span class="line"></span><br><span class="line">  init_mm.start_stack = _stack_start;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// init_thread,init_tss 设置当前TSS为系统第一个进程的TSS</span></span><br><span class="line">  set_tss64(init_thread.rsp0, init_tss[<span class="number">0</span>].rsp1, init_tss[<span class="number">0</span>].rsp2,</span><br><span class="line">            init_tss[<span class="number">0</span>].ist1, init_tss[<span class="number">0</span>].ist2, init_tss[<span class="number">0</span>].ist3,</span><br><span class="line">            init_tss[<span class="number">0</span>].ist4, init_tss[<span class="number">0</span>].ist5, init_tss[<span class="number">0</span>].ist6,</span><br><span class="line">            init_tss[<span class="number">0</span>].ist7);</span><br><span class="line"></span><br><span class="line">  init_tss[<span class="number">0</span>].rsp0 = init_thread.rsp0;</span><br><span class="line"></span><br><span class="line">  list_init(&amp;init_task_union.task.<span class="built_in">list</span>); <span class="comment">//初始化PCB链表,前驱指向自己,后继指向自己</span></span><br><span class="line">  <span class="comment">//接下来task_init函数执行kernel_thread函数为系统创建第二个进程(通常称为init进程),对于调用kernel_thread函数传入的CLONE_FS | CLONE_FILES | CLONE_SIGNAL等克隆标志位,目前未实现相应功能,预留使用</span></span><br><span class="line">  kernel_thread(init, <span class="number">10</span>, CLONE_FS | CLONE_FILES | CLONE_SIGNAL);</span><br><span class="line"></span><br><span class="line">  init_task_union.task.state = TASK_RUNNING; <span class="comment">//本来是不可中断等待状态,现在修改为可运行状态,以接受调度</span></span><br><span class="line"></span><br><span class="line">  p = container_of(list_next(&amp;current-&gt;<span class="built_in">list</span>), <span class="keyword">struct</span> task_struct, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取得init进程控制结构体后调用switch_to切换至init内核线程</span></span><br><span class="line">  switch_to(current, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_stack_start</code>在<code>header.S</code>中实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _stack_start</span><br><span class="line">_stack_start:</span><br><span class="line">   .quad init_task_union + 32768</span><br></pre></td></tr></table></figure>

<p>全局变量<code>_stack_start</code>保存的数值与<code>init_thread</code>结构体变量中<code>rsp0</code>变量的数值是一样的，都指向了系统第一个进程的内核栈基地址。定义全局变量<code>_stack_start</code>可让内核执行头程序直接使用该进程的内核层栈空间，进而减少栈空间切换带来的隐患。</p>
<h2 id="init进程-1"><a href="#init进程-1" class="headerlink" title="init进程"></a>init进程</h2><p>系统的第二个进程，无实际功能，只是打印由创建者传入的参数并返回1以证明运行<br>其实init函数和日常编写的main主函数一样，经过编译器编译生成若干个程序片段并记录程序的入口地址，当操作系统为程序创建进程控制结构体时，操作系统会取得程序的入口地址，并从这个入口地址处执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">init</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;init task is running, arg:%#018lx\n&quot;</span>, arg);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p><code>kernel_thread</code>创建进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为操作系统创建进程,需要的参数:程序入口地址(函数指针)/参数/flags</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> (*fn)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> arg,</span></span><br><span class="line"><span class="params">                  <span class="type">unsigned</span> <span class="type">long</span> flags)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> <span class="title">regs</span>;</span> <span class="comment">//首先为新进程准备执行现场信息而创建pt_regs结构体</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;regs, <span class="number">0</span>, <span class="keyword">sizeof</span>(regs)); <span class="comment">//全部初始化置0</span></span><br><span class="line"></span><br><span class="line">  regs.rbx = (<span class="type">unsigned</span> <span class="type">long</span>)fn; <span class="comment">//程序入口地址(函数指针)</span></span><br><span class="line">  regs.rdx = (<span class="type">unsigned</span> <span class="type">long</span>)arg; </span><br><span class="line"></span><br><span class="line">  regs.ds = KERNEL_DS; <span class="comment">//#define KERNEL_DS (0x10)//选择子</span></span><br><span class="line">  regs.es = KERNEL_DS;</span><br><span class="line">  regs.cs = KERNEL_CS; <span class="comment">//#define KERNEL_CS (0x08)//选择子</span></span><br><span class="line">  regs.ss = KERNEL_DS;</span><br><span class="line">  regs.rflags = (<span class="number">1</span> &lt;&lt; <span class="number">9</span>); <span class="comment">//位9是IF位,置1可以响应中断</span></span><br><span class="line">  regs.rip = (<span class="type">unsigned</span> <span class="type">long</span>)kernel_thread_func;</span><br><span class="line">  <span class="comment">//引导程序(kernel_thread_func模块),这段引导程序会在目标程序(保存于参数fn内)执行前运行</span></span><br><span class="line">  <span class="comment">//至此创建完新的执行现场主要信息,次要信息置0</span></span><br><span class="line">  <span class="comment">//随后将执行现场数据传递给do_fork函数,来创建进程控制结构体并完成进程运行前的初始化工作,可见do_fork和kernel_thread模块才是创建进程的关键代码</span></span><br><span class="line">  <span class="keyword">return</span> do_fork(&amp;regs, flags, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>RBX</code>寄存器保存程序入口，<code>RDX</code>寄存器保存着进程创建者传入的参数，<code>RIP</code>寄存器保存着引导程序，这段引导程序会在目标程序（保存在参数<code>fn</code>中）执行前运行。</p>
<p>随后将参数传递给<code>do_fork</code>函数来创建进程结构体完成运行前的初始化工作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//目前的do_fork函数已基本实现进程控制结构体的创建以及相关数据的初始化工作,由于内核层尚未实现内存分配功能,内存空间的使用只能暂时以物理页为单位</span></span><br><span class="line"><span class="comment">//同时为了检测alloc_pages的执行效果,在分配物理页的前后打印出物理内存页的位图映射信息</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">do_fork</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span><br><span class="line"><span class="params">                      <span class="type">unsigned</span> <span class="type">long</span> stack_start, <span class="type">unsigned</span> <span class="type">long</span> stack_size)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> <span class="literal">NULL</span>; <span class="comment">//任务控制块PCB</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">thd</span> =</span> <span class="literal">NULL</span>; <span class="comment">//执行现场的主要寄存器状态</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>; <span class="comment">//物理页</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//分配物理页前后打印位图映射信息</span></span><br><span class="line">  color_printk(WHITE, BLACK, <span class="string">&quot;alloc_pages, bitmap:%#018lx\n&quot;</span>,</span><br><span class="line">               *memory_management_struct.bits_map);</span><br><span class="line">  p = alloc_pages(ZONE_NOMAL, <span class="number">1</span>, PG_PTABLE_MAPED | PG_ACTIVE | PG_KERNEL); <span class="comment">//ZONE_NORMAL区域申请一个页面,属性为经过页表映射的页/使用中/内核层的页</span></span><br><span class="line">  color_printk(WHITE, BLACK, <span class="string">&quot;alloc_pages, bitmap:%#018lx\n&quot;</span>,</span><br><span class="line">               *memory_management_struct.bits_map);</span><br><span class="line"></span><br><span class="line">  tsk = (<span class="keyword">struct</span> task_struct *)PHY_TO_VIRT(p-&gt;phy_address); <span class="comment">// 将申请到的物理页转换成虚拟地址给进程控制结构体使用</span></span><br><span class="line">  color_printk(WHITE, BLACK, <span class="string">&quot;struct task_struct address:%#018lx\n&quot;</span>,</span><br><span class="line">               (<span class="type">unsigned</span> <span class="type">long</span>)tsk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前进程控制结构体中的数据复制到新分配的物理页中(物理页的线性地址起始处),并进一步初始化相关成员变量信息</span></span><br><span class="line">  <span class="comment">// 包括链接入进程队列/分配和初始化thread_struct结构体/伪造进程执行现场(把执行现场数据复制到目标进程的内核层栈顶处)</span></span><br><span class="line">  <span class="built_in">memset</span>(tsk, <span class="number">0</span>, <span class="keyword">sizeof</span>(*tsk));</span><br><span class="line">  *tsk = *current; <span class="comment">//将当前进程控制结构体中的数据复制到新分配的物理页中(物理页的线性地址起始处),*current获得的是当前进程的PCB,以至于新进程的PCB是一份当前进程的克隆</span></span><br><span class="line"></span><br><span class="line">  list_init(&amp;tsk-&gt;<span class="built_in">list</span>); <span class="comment">//初始化新进程PCB的链域</span></span><br><span class="line">  list_add_to_before(&amp;init_task_union.task.<span class="built_in">list</span>, &amp;tsk-&gt;<span class="built_in">list</span>); <span class="comment">//作为前驱链接入当前进程链域</span></span><br><span class="line">  tsk-&gt;pid++; <span class="comment">//设置进程id,克隆自当前进程的PCB,所以变成当前进程id号加1</span></span><br><span class="line">  tsk-&gt;state = TASK_UNINTERRUPTIBLE; <span class="comment">//设置进程状态为未被中断,现在未初始化完成,不可接受调度进入运行</span></span><br><span class="line"></span><br><span class="line">  thd = (<span class="keyword">struct</span> thread_struct *)(tsk + <span class="number">1</span>); <span class="comment">//使用新申请的PCB后续的地址作为执行现场结构体thd的信息存放处</span></span><br><span class="line">  tsk-&gt;thread = thd; <span class="comment">//将进程控制块中的进程切换时的保留信息结构体指向刚创建的thread_struct结构体thd</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//伪造进程执行现场(把执行现场数据复制到目标进程的内核层栈顶处)</span></span><br><span class="line">  <span class="built_in">memcpy</span>(regs,</span><br><span class="line">         (<span class="type">void</span> *)((<span class="type">unsigned</span> <span class="type">long</span>)tsk + STACK_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pt_regs)),</span><br><span class="line">         <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pt_regs));</span><br><span class="line"></span><br><span class="line">  thd-&gt;rsp0 = (<span class="type">unsigned</span> <span class="type">long</span>)tsk + STACK_SIZE; <span class="comment">//新申请的页的剩余空间作为栈空间使用(应用程序在内核层使用的栈基地址)</span></span><br><span class="line">  thd-&gt;rip = regs-&gt;rip; <span class="comment">//指向新的执行现场信息(由kernel_thread构造并传入)中的引导代码</span></span><br><span class="line">  thd-&gt;rsp = (<span class="type">unsigned</span> <span class="type">long</span>)tsk + STACK_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pt_regs); <span class="comment">//内核层当前栈指针(进程切换时的栈指针值),指向修改为指向新进程的regs最后一个元素ss(但是最先弹出),注意顺序问题</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(tsk-&gt;flags &amp; PF_KTHREAD)) &#123; <span class="comment">//最后判断目标进程的PF_KTHREAD标志位以确定目标进程运行在内核层空间还是应用层空间</span></span><br><span class="line">    <span class="comment">//如果复位PF_KTHREAD标志位说明进程运行于应用层空间,那么将进程的执行入口点设置在ret_from_intr处</span></span><br><span class="line">    <span class="comment">//否则将进程的执行入口点设置在kernel_thread_func地址处</span></span><br><span class="line">    thd-&gt;rip = regs-&gt;rip = (<span class="type">unsigned</span> <span class="type">long</span>)ret_from_intr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在初始化进程控制结构体时,未曾分配mm_struct的存储空间,而依然沿用全局变量init_mm,这是考虑到分配页表是一件无聊的体力活,既然init进程此时还运行在内核层空间,那么在实现内存分配功能前暂且不创建新的页目录和页表</span></span><br><span class="line">  tsk-&gt;state = TASK_RUNNING; <span class="comment">//当do_fork函数将目标进程设置为可运行态后,在全局链表init_task_union.task.list中已经有两个可运行的进程控制结构体,一旦task_init函数执行switch_to模块, 操作系统便会切换进程,从而使得处理器开始执行init进程,由于init进程运行在内核层空间,因此init进程在执行init函数前会先执行kernel_thread_func模块</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//do_fork才是创建进程的核心函数,而kernel_thread更像是对创建出的进程做了特殊限制,这个有kernel_thread函数创建出来的进程看起来更像是一个线程,尽管kernel_thread函数借助do_fork函数</span></span><br><span class="line">  <span class="comment">//创建出了进程控制结构体,但是这个进程却没有应用层空间(复制系统第一个进程的PCB),其实kernel_thread只能创建出没有应用层空间的进程,如果有诸多这样的进程同时运行在内核中,看起来就像是内核主进程</span></span><br><span class="line">  <span class="comment">//创建出的若干个线程一样,所以叫做内核线程,这段程序参考了Linux1到4各个版本中关于内核线程的函数实现,综上所述,kernel_thread函数的功能是创建内核线程,所以init此时是一个内核级的线程,但不会一直是</span></span><br><span class="line">  <span class="comment">//当内核线程执行do_execve函数后会转变为一个用户级进程</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_fork</code>基本实现进程控制结构体的创建以及相关数据的初始化。</p>
<p><code>kernel_thread_func</code>负责还原进程执行现场、运行进程以及退出进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">kernel_thread_func</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">__asm__(<span class="string">&quot;.global kernel_thread_func; kernel_thread_func: \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %r15 \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %r14 \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %r13 \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %r12 \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %r11 \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %r10 \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %r9 \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %r8 \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %rbx \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %rcx \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %rdx \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %rsi \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %rdi \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %rbp \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %rax \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; movq %rax, %ds \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %rax  \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; movq %rax, %es \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; popq %rax  \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; addq $0x38, %rsp \n\t&quot;</span></span><br><span class="line">        <span class="comment">/////////////////////////////////</span></span><br><span class="line">        <span class="string">&quot; movq %rdx, %rdi \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; callq *%rbx  \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; movq %rax, %rdi \n\t&quot;</span></span><br><span class="line">        <span class="string">&quot; callq do_exit  \n\t&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>负责还原进程执行现场&#x2F;运行进程以及退出进程<br>当处理器执行<code>kernel_thread_func</code>模块时，<code>RSP</code>正指向当前进程的内核层栈顶地址处，此刻栈顶位于栈基地址向下偏移<code>pt_regs</code>结构体处，经过若干个<code>POP</code>，最终将<code>RSP</code>平衡到栈基地址处<br>进而达到还原进程执行现场的目的，这个执行现场是在<code>kernel_thread</code>中伪造的（通过构造<code>pt_regs</code>结构体，之后传递给do_fork函数），其中的<code>RBX</code>保存着程序执行片段，<code>RDX</code>保存着传入的参数<br>进程执行现场还原后，将借助<code>CALL</code>执行<code>RBX</code>保存的程序执行片段（init进程），一旦程序片段返回便执行<code>do_exit</code>函数退出进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">do_exit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> code)</span> &#123;</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;exit task is running,arg:%#018lx\n&quot;</span>, code);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>do_exit</code>用于释放进程控制结构体，现在只是打印init进程的返回值</p>
<p>总结进程创建过程：</p>
<p><strong>1号进程init</strong> 的初始化过程： 新申请一个内存页，复制当前进程的<code>struct task_struct</code>结构，在之上新建<code>struct thread_struct</code>结构；构造一个执行现场放到新进程的栈中，其中<code>rbx</code>执行新进程的执行代码入口，<code>rdx</code>保存传入参数；设置<code>rip</code>，若为内核进程，则指向<code>kernel_thread_func</code>，若为应用层进程，则指向<code>ret_from_intr</code>；当进程切换完成后，执行<code>rip</code>指向的位置的代码；开始执行新进程</p>
<ul>
<li>执行 <code>kernel_thread()</code> 来初始化一个进程</li>
<li>构造一个 <code>struct pt_regs regs</code></li>
<li>执行 <code>do_fork()</code></li>
<li>申请一个内存页（2M）</li>
<li>这个页的起始位置设置为 <code>struct task_struct</code> 结构，使用当前进程的task结构初始化这个结构，因此内存结构 <code>mm_struct</code>和当前进程一样</li>
<li>把 <code>task.list</code>添加到 <code>init_task_union.task.list</code>之前</li>
<li>在 <code>struct task_struct</code> 结构之上申请 <code>struct thread_struct</code> 结构</li>
<li>在栈顶处，复制 <code>struct pt_regs regs</code> 结构，并设置<code>rsp</code>指向栈顶。这是一个在 <code>kernel_thread()</code> 中伪造的执行现场，其中<code>rbx</code>保存着执行程序片段的入口地址，<code>rdx</code>保存着传入的参数</li>
<li>若为应用层进程，则进程执行入口 <code>thd-&gt;rip</code> 设置为 <code>ret_from_intr</code> 处；若为内核层进程，则设置为 <code>kernel_thread_func</code> 处</li>
<li>进程初始化完成之后，就可以执行<code>switch_to(prev, next)</code>切换进程了</li>
<li>切换到 <code>init</code> 进程后，由于是内核进程，所以执行 <code>kernel_thread_func()</code> ，从栈中恢复执行现场，并通过<code>call *rbx</code>开始执行<code>init</code>进程。执行完毕后，执行<code>do_exit</code></li>
</ul>
<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>如图所示：</p>
<p><img src="https://img.ansore.de/2022/08/22/5701ddce62b0abca98f9d905406e1329.png" alt="Screenshot_20220822_233247"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-跳转到应用层</title>
    <url>/posts/d18221ab.html</url>
    <content><![CDATA[<h1 id="跳转过程"><a href="#跳转过程" class="headerlink" title="跳转过程"></a>跳转过程</h1><p> 系统内核位于0特权级，应用程序位于3特权级，如果想从内核层进入应用层，在特权级跳转的过程中必须提供目标代码段和栈段以及其他跳转信息。</p>
<ol>
<li>检测目标程序的访问权限，针对段模式的特权级进行检查</li>
<li>临时把<code>SS</code>、<code>ESP</code>、<code>CS</code>、<code>EIP</code>寄存器的当前值保存在处理器内部，以备调用返回使用</li>
<li>根据目标代码段的特权级，处理器从<code>TSS</code>结构中提取处相应特权级的段选择子和栈基地址，并将其作为目标程序的栈空间更新到<code>SS</code>和<code>ESP</code>寄存器</li>
<li>将步骤2临时保存的<code>SS</code>和<code>ESP</code>寄存器存入内目标程序的栈空间</li>
<li>根据调用门描述符记录的参数个数，从调用者栈空间复制参数到目标程序栈</li>
<li>将步骤2临时保存的<code>CS</code>和<code>EIP</code>寄存器值存入目标程序的栈空间</li>
<li>将调用门描述符记录的目标代码段选择子和程序的起始地址加载到<code>CS</code>和<code>EIP</code>寄存器中</li>
<li>处理器在目标代码段特权级下执行程序</li>
</ol>
<p><img src="https://img.ansore.de/2022/08/25/b94626e5f111d9ada754d14b3530df21.png" alt="Screenshot_20220825_200550"></p>
<p>对于相同特权级的程序访问，处理器并不会切换程序的栈空间，所以只有参数、<code>EIP</code>寄存器以及CS寄存器会存入栈空间</p>
<p>还原调用者的执行环境：</p>
<ol>
<li>检测目标程序的访问权限，此处同样针对段模式的特权级进行检查</li>
<li>还原调用者的<code>CS</code>和<code>EIP</code>寄存器值，它们在调用过程中以保存在被调用者的栈空间</li>
<li>如果<code>RET</code>指令带有操作数<code>n</code>，那么栈指针将向上移动<code>n</code>个字节来释放被调用者栈空间。如果访问来自调用门，那么<code>RET n</code>指令将同时释放被调用者与调用者栈空间</li>
<li>还原调用者的<code>SS</code>和<code>EIP</code>寄存器值，是的栈空间被调用者切换会调用者</li>
<li>如果<code>RET</code>指令带有操作数<code>n</code>，则按照步骤3的执行过程释放调用者栈空间</li>
<li>处理器继续执行调用者程序</li>
</ol>
<p><code>RET</code>（调用返回指令）和<code>IRET</code>（中断返回指令）类指令的执行速度特别慢，消耗处理器时钟周期数过多，INTEL退出一套新指令<code>SYSENTER/SYSEXIT</code>实现快速系统调用，这两个指令调用过程不会执行数据压栈，这样避免了访问内存的时间消耗。<code>SYSENTER</code>只能从3特权级跳转到0特权级，而<code>SYSEXIT</code>只能从0特权级跳转到3特权级。因此它们只能为应用程序提供系统调用，无法在内核层执行系统调用，而中断型系统调用确可以在任意权限下执行</p>
<p>在执行<code>SYSEXIT</code>指令之前，处理器必须为其提供3特权级的衔接程序以及3特权级的栈空间，这些数据将保存的<code>MSR</code>寄存器和通用寄存器中：</p>
<ul>
<li><code>IA32_SYSENTER_CS</code>，位于MSR寄存器组地址174h处，它是一个32位寄存器，用于索引3特权级下的代码段选择子和栈段选择子。在IA-32e模式下，代码段选择子位<code>IA32_SYSENTER_CS[15:0]+32</code>，否则为<code>IA32_SYSENTER_CS[15:0]+16</code>，而栈段选择子是将代码段选择子加8</li>
<li><code>RDX</code>寄存器。该寄存器保存者一个Canonical型地址（64位特有的地址结构），在执行指令时会将其载入<code>RIP</code>寄存器中（这是用户程序的第一条指令地址）。如果返回到非64位模式，那么只有低32位被装载到<code>RIP</code>寄存器中</li>
<li><code>RCX</code>寄存器。该寄存器保存者一个Canonical型地址，执行指令是会将其加载到<code>RSP</code>寄存器中（3特权级下的栈指针）。如果返回到非64位模式，只有低32位被装载到<code>RSP</code>寄存器。</li>
</ul>
<p><code>IA32_SYSENTER_CS</code>寄存器可借助<code>RDMSR/WRMSR</code>指令进行访问。在执行<code>SYSEXIT</code>指令的过程中，指令会根据<code>IA32_SYSENTER_CS</code>寄存器的值加载相应的段选择子到<code>CS</code>和<code>SS</code>寄存器。<code>SYSEXIT</code>指令不会从描述符表中加载段描述符到<code>CS</code>和<code>SS</code>寄存器，而是写入固定值 ，需由操作系统确保描述符的正确性。</p>
<h1 id="切换实现"><a href="#切换实现" class="headerlink" title="切换实现"></a>切换实现</h1><p>系统调用返回模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(ret_system_call)</span><br><span class="line">  movq %rax, 0x80(%rsp)</span><br><span class="line">  popq %r15</span><br><span class="line">  popq %r14</span><br><span class="line">  popq %r13</span><br><span class="line">  popq %r12</span><br><span class="line">  popq %r11</span><br><span class="line">  popq %r10</span><br><span class="line">  popq %r9</span><br><span class="line">  popq %r8</span><br><span class="line">  popq %rbx</span><br><span class="line">  popq %rcx</span><br><span class="line">  popq %rdx</span><br><span class="line">  popq %rsi</span><br><span class="line">  popq %rdi</span><br><span class="line">  popq %rbp</span><br><span class="line">  popq %rax</span><br><span class="line">  movq %rax, %ds</span><br><span class="line">  popq %rax</span><br><span class="line">  movq %rax, %es</span><br><span class="line">  popq %rax</span><br><span class="line">  addq $0x38, %rsp</span><br><span class="line">  .byte 0x48</span><br><span class="line">  sysexit</span><br></pre></td></tr></table></figure>

<p>首先将系统调用的返回值更新到程序运行环境的<code>RAX</code>寄存器中，然后恢复应用程序的执行环境。由于<code>sysexit</code>需要借助RDX和RCX寄存器来恢复应用程序的执行现场，所以在进入内核层前应该对两者特殊处理，最后使用<code>sysexit</code>跳转到应用层执行。</p>
<p><code>sysexit</code>指令在64位模式下的默认操作数不是64位，如果要返回到64位模式的应用层，则必须在<code>sysexit</code>指令前插入指令前缀<code>0x48</code>加以修饰，以表示<code>sysexit</code>指令使用64位的操作数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// GDT Table</span><br><span class="line">.section .data</span><br><span class="line"></span><br><span class="line">.global GDT_Table</span><br><span class="line"></span><br><span class="line">GDT_Table:</span><br><span class="line">  .quad 0x0000000000000000 // 0 null descriptor 00</span><br><span class="line">  .quad 0x0020980000000000 // 1 kernel code 64bit segment 08</span><br><span class="line">  .quad 0x0000920000000000 // 2 kernel data 64bit segment 10</span><br><span class="line">  .quad 0x0000000000000000 // 3 user data 32bit segment 18</span><br><span class="line">  .quad 0x0000000000000000 // 4 user data 32bit segment 20</span><br><span class="line">  .quad 0x0020f80000000000 // 5 user code 64bit segment 28</span><br><span class="line">  .quad 0x0000f20000000000 // 6 user data 64bit segment 30</span><br><span class="line">  .quad 0x00cf9a000000ffff // 7 kernel code 32bit segment 38</span><br><span class="line">  .quad 0x00cf92000000ffff // 8 kernel data 32bit segment 40</span><br><span class="line">  .fill 10, 8, 0 // 10~11 TSS(jmp one segment 9) in long-mode 128bit 50</span><br><span class="line">GDT_END:</span><br></pre></td></tr></table></figure>

<p>此处为GDT新增了一个32位的代码段描述符和一个32位的数据段描述符，它们被插入到GDT的第3个描述符处。这导致TSS段描述符向后移动了两个段描述符的位置，从而必须调整TSS段描述符的初始化程序<code>setup_TSS64</code>，以及调用宏函数<code>load_tr</code>时传入的参数值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setup_TSS64:</span><br><span class="line">  leaq TSS64_Table(%rip), %rdx</span><br><span class="line">  xorq %rax, %rax</span><br><span class="line">  xorq %rcx, %rcx</span><br><span class="line">  movq $0x89, %rax</span><br><span class="line">  shlq $40, %rax</span><br><span class="line">  movl %edx, %ecx</span><br><span class="line">  shrl $24, %ecx</span><br><span class="line">  shlq $56, %rcx</span><br><span class="line">  addq %rcx, %rax</span><br><span class="line">  xorq %rcx, %rcx</span><br><span class="line">  movl %edx, %ecx</span><br><span class="line">  andl $0xffffff, %ecx</span><br><span class="line">  shlq $16, %rcx</span><br><span class="line">  addq %rcx, %rax</span><br><span class="line">  addq $103, %rax</span><br><span class="line">  leaq GDT_Table(%rip), %rdi</span><br><span class="line">  movq %rax, 80(%rdi) // tss segment offset</span><br><span class="line">  shrq $32, %rdx</span><br><span class="line">  movq %rdx, 88(%rdi) // tss+1 segment offset</span><br><span class="line"></span><br><span class="line">  // mov $0x40, %ax</span><br><span class="line">  // ltr %ax</span><br><span class="line"></span><br><span class="line">  movq go_to_kernel(%rip), %rax</span><br><span class="line">  pushq $0x08</span><br><span class="line">  pushq %rax</span><br><span class="line">  lretq</span><br></pre></td></tr></table></figure>

<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  。。。</span><br><span class="line">  load_TR(<span class="number">10</span>);</span><br><span class="line">  。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两段分别调整了TSS段描述符在GDT中的偏移值和TSS段选择子的值。</p>
<p>修改<code>do_fork</code>函数创建的新进程的返回地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">do_fork</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span><br><span class="line"><span class="params">                      <span class="type">unsigned</span> <span class="type">long</span> stack_start, <span class="type">unsigned</span> <span class="type">long</span> stack_size)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (!(tsk-&gt;flags &amp; PF_KTHREAD)) &#123;</span><br><span class="line">    thd-&gt;rip = regs-&gt;rip = (<span class="type">unsigned</span> <span class="type">long</span>)ret_system_call;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统数据结构准备就绪后，为<code>IA32_SYSENTER_CS</code>寄存器设置段选择子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_init</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  init_mm.start_stack = _stack_start;</span><br><span class="line"></span><br><span class="line">  wrmsr(<span class="number">0x174</span>, KERNEL_CS);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IA32_SYSENTER_CS</code>寄存器位于MSR寄存器组的<code>0x174</code>地址处，所以处理器只能借助<code>WRMSR</code>汇编指令才能向MSR寄存器组写入数据。</p>
<p><code>wrmsr</code>函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wrmsr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">unsigned</span> <span class="type">long</span> value)</span> &#123;</span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;wrmsr \n\t&quot;</span> ::<span class="string">&quot;d&quot;</span>(value &gt;&gt; <span class="number">32</span>), <span class="string">&quot;a&quot;</span>(value &amp; <span class="number">0xffffffff</span>),</span><br><span class="line">                       <span class="string">&quot;c&quot;</span>(address)</span><br><span class="line">                       : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>系统目前还没有应用层程序，此时<code>init</code>还是个内核进程。执行<code>execve</code>系统调用API，可以使init内核线程执行新的程序，进而转变为应用程序。但是由于<code>SYSENTER/SYSEXIT</code>指令无法像中断指令那样，可以在内核层调用API，所以只能通过直接执行系统调用API处理函数的方法实现。参考<code>switch_to</code>函数的设计思路，调用<code>execve</code>系统调用API的处理函数<code>do_execve</code>，借助<code>push</code>指令，将程序的返回地址压入栈中，并采用<code>JMP</code>指令调用函数<code>do_execve</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">init</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">regs</span>;</span></span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;init task is running, arg:%#018lx\n&quot;</span>, arg);</span><br><span class="line"></span><br><span class="line">  current-&gt;thread-&gt;rip = (<span class="type">unsigned</span> <span class="type">long</span>)ret_system_call;</span><br><span class="line">  current-&gt;thread-&gt;rsp =</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">long</span>)current + STACK_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pt_regs);</span><br><span class="line">  regs = (<span class="keyword">struct</span> pt_regs *)current-&gt;thread-&gt;rsp;</span><br><span class="line"></span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;movq %1, %%rsp \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;pushq %2 \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;jmp do_execve \n\t&quot;</span> ::<span class="string">&quot;D&quot;</span>(regs),</span><br><span class="line">                       <span class="string">&quot;m&quot;</span>(current-&gt;thread-&gt;rsp), <span class="string">&quot;m&quot;</span>(current-&gt;thread-&gt;rip)</span><br><span class="line">                       : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先确定函数<code>init</code>的函数返回地址和栈指针，并取得进程的<code>struct pt_regs</code>结构体。接着采用内嵌汇编方法，更新进程的内核层栈指针，同时调用<code>do_execve</code>函数为新的程序（目标应用程序）准备执行环境，并将<code>struct pt_regs</code>结构体的首地址作为参数传递给<code>do_execve</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// typedef int (*fun)(unsigned int, unsigned int, const char *, ...);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">user_level_function</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// fun f = (void *)0xffff80000010a1b9;</span></span><br><span class="line">  <span class="comment">// char msg[] = &quot;user_level_function task is running...\n&quot;;</span></span><br><span class="line">  <span class="comment">// f(RED, BLACK, msg);</span></span><br><span class="line">  <span class="comment">// color_printk(RED, BLACK, &quot;user_level_function task is running...\n&quot;);</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">do_execve</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span> &#123;</span><br><span class="line">  regs-&gt;rdx = <span class="number">0x800000</span>; <span class="comment">// RIP</span></span><br><span class="line">  <span class="comment">// regs-&gt;rdx = (unsigned long) user_level_function; // RIP</span></span><br><span class="line">  regs-&gt;rcx = <span class="number">0xa00000</span>; <span class="comment">// RSP</span></span><br><span class="line">  regs-&gt;rax = <span class="number">1</span>;</span><br><span class="line">  regs-&gt;ds = <span class="number">0</span>;</span><br><span class="line">  regs-&gt;es = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;do_execve task is running...\n&quot;</span>);</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;do_execve address %#018lx...\n&quot;</span>,</span><br><span class="line">               user_level_function);</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;do_execve address2 %#018lx...\n&quot;</span>, color_printk);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(user_level_function, (<span class="type">void</span> *)<span class="number">0x800000</span>, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处有坑，当将<code>user_level_function</code>函数复制到<code>0x800000</code>地址处时，在<code>user_level_function</code>函数里调用<code>color_printk</code>时，显示物理地址访问不了。</p>
<p>启动bochs虚拟机，使用<code>b 0x800000</code>处打断点，当执行到<code>call</code>指令的时候，发现调用的<code>call r8</code>，<code>r8</code>寄存器值不对，并不是<code>color_printk</code>函数的地址。</p>
<p>由此推测可能由于是将<code>user_level_function</code>函数直接拷贝到<code>0x800000</code>处，而获取<code>color_printk</code>函数的地址是根据<code>user_level_function</code>推出来的绝对地址，而相对位置变了，所以获取不到<code>color_printk</code>的地址。</p>
<p>三种曲线救国的方式</p>
<ol>
<li>不要在拷贝的地址调用其他函数</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">user_level_function</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// color_printk(RED, BLACK, &quot;user_level_function task is running...\n&quot;);</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>指定函数的绝对地址</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*fun)</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">user_level_function</span><span class="params">()</span> &#123;</span><br><span class="line">  fun f = (<span class="type">void</span> *)<span class="number">0xffff80000010a1b9</span>;</span><br><span class="line">  <span class="type">char</span> msg[] = <span class="string">&quot;user_level_function task is running...\n&quot;</span>;</span><br><span class="line">  f(RED, BLACK, msg);</span><br><span class="line">  <span class="comment">// color_printk(RED, BLACK, &quot;user_level_function task is running...\n&quot;);</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>不进行拷贝，直接跳转到原函数地址</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">user_level_function</span><span class="params">()</span> &#123;</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;user_level_function task is running...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">do_execve</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span> &#123;</span><br><span class="line">  <span class="comment">// regs-&gt;rdx = 0x800000; // RIP</span></span><br><span class="line">  regs-&gt;rdx = (<span class="type">unsigned</span> <span class="type">long</span>) user_level_function; <span class="comment">// RIP</span></span><br><span class="line">  regs-&gt;rcx = <span class="number">0xa00000</span>; <span class="comment">// RSP</span></span><br><span class="line">  regs-&gt;rax = <span class="number">1</span>;</span><br><span class="line">  regs-&gt;ds = <span class="number">0</span>;</span><br><span class="line">  regs-&gt;es = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;do_execve task is running...\n&quot;</span>);</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;do_execve address %#018lx...\n&quot;</span>,</span><br><span class="line">               user_level_function);</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;do_execve address2 %#018lx...\n&quot;</span>, color_printk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// memcpy(user_level_function, (void *)0x800000, 1024);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本次采用第一种，不再用户级程序调用其他函数。</p>
<p>当处理器切换到应用层后，应用程序将从应用层的线性地址<code>0x800000</code>处开始执行，而选择线性地址<code>0xa00000</code>作为程序的栈顶地址，则是为了保证它与线性地址<code>0x800000</code>同在一个物理页内。</p>
<p>需要注释掉<code>memory_init</code>的页表映射的清理代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">memory_init</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// for (i = 0; i &lt; 10; i++)</span></span><br><span class="line">  <span class="comment">//   *(PHY_TO_VIRT(global_cr3) + i) = 0UL;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，改变页表属性的标志位：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// init page</span><br><span class="line">.align 8</span><br><span class="line">.org 0x1000</span><br><span class="line"></span><br><span class="line">__PML4E:</span><br><span class="line">  // bit 0,1,2 is 1, read/write, not allow user-mode access</span><br><span class="line">  .quad 0x102007</span><br><span class="line">  .fill 255, 8, 0</span><br><span class="line">  .quad 0x102007</span><br><span class="line">  .fill 255, 8, 0</span><br><span class="line"></span><br><span class="line">.org 0x2000</span><br><span class="line"></span><br><span class="line">__PDPTE:</span><br><span class="line">  // bit 0,1 is 1, read/write</span><br><span class="line">  .quad 0x103007 // 0x103003</span><br><span class="line">  .fill 511, 8, 0</span><br><span class="line"></span><br><span class="line">.org 0x3000</span><br><span class="line">__PDE:</span><br><span class="line">  // bit 0,1 is 1, read/write, bit 7 is 1, maps 2MB</span><br><span class="line">  // 0MB</span><br><span class="line">  .quad 0x000087</span><br><span class="line">  .quad 0x200087</span><br><span class="line">  .quad 0x400087</span><br><span class="line">  .quad 0x600087</span><br><span class="line">  .quad 0x800087    // 0x800083</span><br><span class="line">  // 10MB</span><br><span class="line">  .quad 0xe0000087 // 0xa00000</span><br><span class="line">  .quad 0xe0200087</span><br><span class="line">  .quad 0xe0400087</span><br><span class="line">  .quad 0xe0600087</span><br><span class="line">  .quad 0xe0800087</span><br><span class="line">  .quad 0xe0a00087</span><br><span class="line">  .quad 0xe0c00087</span><br><span class="line">  .quad 0xe0e00087</span><br><span class="line">  // 16MB</span><br><span class="line">  .fill 499, 8, 0</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://img.ansore.de/2022/08/27/e01abfda57525507615905d792437bfd.png" alt="Screenshot_20220827_013450"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-实现系统调用</title>
    <url>/posts/9a1a7cb4.html</url>
    <content><![CDATA[<h1 id="SYSENTER指令"><a href="#SYSENTER指令" class="headerlink" title="SYSENTER指令"></a>SYSENTER指令</h1><p><code>SYSENTER</code>指令可以实现应用层到内核层的跳转。在执行<code>SYSENTER</code>之前，处理器必须为其提供0特权级的衔接程序以及0特权级的栈空间，这些数据将会保存在<code>MSR</code>寄存器组和通用寄存器中。</p>
<ul>
<li><p><code>IA32_SYSENTER_CS</code>，位于<code>MSR</code>寄存器组的地址<code>174h</code>处，这个<code>MSR</code>寄存器的低16位装载的是0特权级的代码段选择子，该值也用于所以0特权级的栈段选择子（<code>IA32_SYSENTER_CS[15:0]+8</code>），所以该值不能为NULL</p>
</li>
<li><p><code>IA32_SYSENTER_ESP</code>，位于<code>MSR</code>寄存器组的地址<code>175h</code>处，这个<code>MSR</code>寄存器里的值会被载入<code>RSP</code>寄存器中，该值必须是Canonical型地址。在保护模式下，只有寄存器的低32位会被载入<code>RSP寄存器</code>。</p>
</li>
<li><p><code>IA32_SYSENTER_EIP</code>，位于<code>MSR</code>寄存器组的地址<code>176h</code>处，这个<code>MSR</code>寄存器里的值会被载入<code>RIP</code>寄存器中，该值必须是Canonical型地址。在保护模式下，只有寄存器的低32位会被载入<code>RIP寄存器</code>。</p>
</li>
</ul>
<p>在执行<code>SYSENTER</code>指令的过程中，处理器会根据<code>IA32_SYSENTER_CS</code>寄存器的值加载相应的段选择子到<code>CS</code>和<code>SS</code>寄存器。</p>
<p><code>SYSENTER/SYSEXIT</code>指令与<code>CALL/RET</code>指令的不同之处在于，执行<code>SYSENTER</code>指令时，处理器不会保存用户代码的状态信息（<code>RIP</code>和<code>RSP</code>寄存器的值），而且两者均不支持内存参数方式。同时<code>SYSENTER/SYSEXIT</code>还必须遵循如下规则：</p>
<ul>
<li><code>SYSENTER/SYSEXIT</code>指令使用的段描述符皆位于同一个段描述符内，并且各个段描述符是相邻的。只有这样才能使处理器根据<code>SYSENTER_CS_MSR</code>寄存器值索引到段选择子。</li>
<li>应用程序在执行<code>SYSENTER</code>指令进入内核层时，必须保存程序的运行环境，并在执行<code>SYSEXIT</code>指令返回应用层时恢复程序的运行环境。</li>
</ul>
<h1 id="实现系统调用"><a href="#实现系统调用" class="headerlink" title="实现系统调用"></a>实现系统调用</h1><p><code>system_call</code>模块实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ...</span><br><span class="line">ENTRY(system_call)</span><br><span class="line">  sti # SYSENTER汇编指令将会使RFLGAS.IF标志复位，在进入内核层后，必须手动使能中断（置位IF标志位）</span><br><span class="line">  subq $0x38, %rsp</span><br><span class="line">  cld</span><br><span class="line">  </span><br><span class="line">  push %rax</span><br><span class="line">  movq %es, %rax</span><br><span class="line">  pushq %rax</span><br><span class="line">  movq %ds, %rax</span><br><span class="line">  pushq %rax</span><br><span class="line">  xorq %rax, %rax</span><br><span class="line">  pushq %rbp</span><br><span class="line">  pushq %rdi</span><br><span class="line">  pushq %rsi</span><br><span class="line">  pushq %rdx</span><br><span class="line">  pushq %rcx</span><br><span class="line">  pushq %rbx</span><br><span class="line">  pushq %r8</span><br><span class="line">  pushq %r9</span><br><span class="line">  pushq %r10</span><br><span class="line">  pushq %r11</span><br><span class="line">  pushq %r12</span><br><span class="line">  pushq %r13</span><br><span class="line">  pushq %r14</span><br><span class="line">  pushq %r15</span><br><span class="line">  movq $0x10, %rdx</span><br><span class="line">  movq %rdx, %ds</span><br><span class="line">  movq %rdx, %es</span><br><span class="line">  movq %rsp, %rdi</span><br><span class="line"></span><br><span class="line">  callq system_call_function</span><br><span class="line"></span><br><span class="line">ENTRY(ret_system_call)</span><br><span class="line">  movq %rax, 0x80(%rsp)</span><br><span class="line">  popq %r15</span><br><span class="line">  popq %r14</span><br><span class="line">  popq %r13</span><br><span class="line">  popq %r12</span><br><span class="line">  popq %r11</span><br><span class="line">  popq %r10</span><br><span class="line">  popq %r9</span><br><span class="line">  popq %r8</span><br><span class="line">  popq %rbx</span><br><span class="line">  popq %rcx</span><br><span class="line">  popq %rdx</span><br><span class="line">  popq %rsi</span><br><span class="line">  popq %rdi</span><br><span class="line">  popq %rbp</span><br><span class="line">  popq %rax</span><br><span class="line">  movq %rax, %ds</span><br><span class="line">  popq %rax</span><br><span class="line">  movq %rax, %es</span><br><span class="line">  popq %rax</span><br><span class="line">  addq $0x38, %rsp</span><br><span class="line">  .byte 0x48</span><br><span class="line">  sysexit</span><br></pre></td></tr></table></figure>

<p><code>system_call</code>模块必须在<code>ret_system_call</code>之前，在执行完成之后返回，也可以用<code>JMP</code>指令跳转。</p>
<p><code>system_call</code>模块是系统调用API的接口模块。当应用程序执行<code>SYSENTER</code>指令进入内核层时，便会通过<code>system_call</code>模块保存应用程序执行现场，随后使用<code>CALL</code>指令调用<code>system_call_function</code>函数。在调用时<code>system_call</code>模块会将当前栈指针作为参数传递给<code>system_call_function</code>函数（<code>movq %rsp, %rdi</code>），此时的栈指针作为参数传递给<code>system_call_function</code>函数。</p>
<p><code>system_call_function</code>函数实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">system_call_function</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> system_call_table[regs-&gt;rax](regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>regs</code>记录着进程执行环境，其中成员变量<code>rax</code>保存着系统调用API的向量号，暂定定128个。</p>
<p>数组<code>system_call_table</code>用于保存每个系统调用的处理函数，目前尚未实现，都赋值为<code>no_system_call</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SYSTEM_CALL_NR 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*<span class="type">system_call_t</span>)</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">no_system_call</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span> &#123;</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;no_system_call is called, NR: %#04x\n&quot;</span>, regs-&gt;rax);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">system_call_t</span> system_call_table[MAX_SYSTEM_CALL_NR] = &#123;</span><br><span class="line">  [<span class="number">0</span> ... MAX_SYSTEM_CALL_NR<span class="number">-1</span>] = no_system_call</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外还需要为<code>SYSENTER</code>汇编指令内核层指针以及系统调用在内核层的入口地址（<code>system_call</code>的起始地址）。分别将两个值的写入<code>MSR</code>寄存器的<code>175h</code>和<code>176h</code>地址处：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">task_init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  wrmsr(<span class="number">0x174</span>, KERNEL_CS);</span><br><span class="line">  wrmsr(<span class="number">0x175</span>, current-&gt;thread-&gt;rsp0);</span><br><span class="line">  wrmsr(<span class="number">0x176</span>, (<span class="type">unsigned</span> <span class="type">long</span>)system_call);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行系统调用API。</p>
<p>在编写调用程序时，<code>SYSEXIT</code>指令执行须要向<code>RCX</code>和<code>RDX</code>写入程序返回地址和栈顶地址。所以在执行<code>SYSENTER</code>指令前，将程序的返回地址和栈顶地址保存在这两个寄存器内：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">user_level_function</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;leaq sysexit_return_address(%%rip), %%rdx \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;movq %%rsp, %%rcx \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;sysenter \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;sysexit_return_address: \n\t&quot;</span></span><br><span class="line">                       : <span class="string">&quot;=a&quot;</span>(ret)</span><br><span class="line">                       : <span class="string">&quot;0&quot;</span>(<span class="number">15</span>)</span><br><span class="line">                       : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过汇编<code>leaq</code>指令取得标识符<code>sysexit_return_address</code>的有效地址，并将有效地址保存到<code>RDX</code>寄存器中。<code>RCX</code>寄存器保存着应用层当前的栈指针，<code>RAX</code>寄存器保存系统调用API的向量号。</p>
<p>运行结果：</p>
<p><img src="https://img.ansore.de/2022/08/28/62648c8e01dbf948fe3e6c6144461fdc.png" alt="Screenshot_20220828_003054"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-实现系统调用处理函数</title>
    <url>/posts/b3303f26.html</url>
    <content><![CDATA[<p> 实现一个<code>sys_printf</code>的系统调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">sys_printf</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span> &#123;</span><br><span class="line">  color_printk(BLACK, WHITE, (<span class="type">char</span>*)regs-&gt;rdi);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">no_system_call</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span> &#123;</span><br><span class="line">  color_printk(RED, BLACK, <span class="string">&quot;no_system_call is called, NR: %#04x\n&quot;</span>, regs-&gt;rax);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">system_call_t</span> system_call_table[MAX_SYSTEM_CALL_NR] = &#123;</span><br><span class="line">  [<span class="number">0</span>] = no_system_call,</span><br><span class="line">  [<span class="number">1</span>] = sys_printf,</span><br><span class="line">  [<span class="number">2</span> ... MAX_SYSTEM_CALL_NR<span class="number">-1</span>] = no_system_call</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sys_printf</code>的系统调用向量号是1，内部封装了函数<code>color_printk</code>函数，并借助<code>RDI</code>寄存器（参数<code>regs</code>的<code>rdi</code>成员变量）向<code>color_printk</code>传递打印的字符串。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">user_level_function</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> msg[] = <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">  __asm__ __volatile__(<span class="string">&quot;leaq sysexit_return_address(%%rip), %%rdx \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;movq %%rsp, %%rcx \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;sysenter \n\t&quot;</span></span><br><span class="line">                       <span class="string">&quot;sysexit_return_address: \n\t&quot;</span></span><br><span class="line">                       : <span class="string">&quot;=a&quot;</span>(ret)</span><br><span class="line">                       : <span class="string">&quot;0&quot;</span>(<span class="number">1</span>), <span class="string">&quot;D&quot;</span>(msg)</span><br><span class="line">                       : <span class="string">&quot;memory&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将字符串的起始地址保存到<code>rdi</code>寄存器中，然后执行系统调用。</p>
<p>运行结果：</p>
<p>![Screenshot_20220828_004650](<a href="https://img.ansore.de/2022/08/28/86f4898524a9cfac15095f1570264036.png">https://img.ansore.de/2022/08/28/86f4898524a9cfac15095f1570264036.png</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-处理器架构</title>
    <url>/posts/466215f.html</url>
    <content><![CDATA[<h1 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h1><ul>
<li>实模式</li>
<li>保护模式。32位处理器的主要模式。</li>
<li>系统管理模式。</li>
<li>虚拟8086模式</li>
<li>IA-32e模式。64位吃处理器的主要运行模式。</li>
</ul>
<p>体系结构各运行模式间切换过程：</p>
<p><img src="https://img.ansore.de/2022/09/12/3b13f20d9cb2462c00546ac43816fe9e.png" alt="Screenshot_20220912_203300"></p>
<p>处理器上电或重启之后首先运行实模式。<code>CR0</code>控制寄存器的PE标志位控制处理器运行在实模式或者保护模式。<code>EFLAGS</code>标志寄存器的<code>VM</code>标志位可使处理器在保护模式可使处理器在保护模式与虚拟8086模式间切换，切换过程往往通过任务切换或中断&#x2F;异常返回程序实现。 在开启分页机制的保护模式下，置位<code>IA32-EFER</code>寄存器的<code>LME</code>标志位（位于<code>IA32-EFER</code>寄存器的第8位）可使处理器进入<code>IA-32e</code>模式。通过<code>IA32-EFER</code>寄存器的<code>LMA</code>标志位（位于<code>IA32-EFER</code>寄存器的第10位）可以判断处理器是否运行在<code>IA-32e</code>模式下。当前处理器运行与<code>IA-32e</code>模式，代码段描述符的<code>L</code>标志位可确定处理器运行于64位模式还是兼容模式。不管处理器正处于什么模式，一旦收到<code>SMI</code>信号便会进入<code>SMM</code>模式。只有在执行<code>RSM</code>指令后，处理器会返回到产生<code>SMI</code>信号前。</p>
<h1 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h1><p><code>IA32</code>体系下的通用寄存器有<code>EAX</code>、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>ESI</code>、<code>EDI</code>、<code>EBP</code>、<code>ESP</code>。<code>ESP</code>已被处理器用于保存栈指针值。</p>
<p>一些指令的执行必须依赖特定的寄存器。例如，<code>ECX</code>、<code>ESI</code>和<code>EDI</code>寄存器经常用于字符串指令操作，<code>DS</code>段寄存器经常使用<code>EBX</code>寄存器来保存段内偏移地址。</p>
<p><img src="https://img.ansore.de/2022/09/12/2f046c9631c8077c70deaf74530c3f35.png" alt="Screenshot_20220912_211629"></p>
<p>在<code>IA-32e</code>体系结构的64位运行模式下，虽然通用寄存器的操作数模式是32位宽。但它们有能力支持64位宽的操作数。Intel公司在64位模式里加入了8个新的通用寄存器，因此处理器可使用<code>RAX</code>、<code>RBX</code>、<code>RCX</code>、<code>RDX</code>、<code>RSI</code>、<code>RBP</code>、<code>RSP</code>、<code>R8</code>~<code>R15</code>这16个通用寄存器，其中的<code>R8</code>~<code>R15</code>寄存器只在64位模式下有效。</p>
<h1 id="CPUID指令"><a href="#CPUID指令" class="headerlink" title="CPUID指令"></a>CPUID指令</h1><p><code>CPUID</code>指令用于鉴别处理器信息以及检测处理器支持的功能，它在任何模式下执行效果相同。通过<code>EFLAGS</code>标志寄存器的ID标志位（位于<code>EFLAGS</code>寄存器的第21位）可检测处理器是否支持<code>CPUID</code>指令。</p>
<p><code>CPUID</code>指令使用<code>EAX</code>寄存器作为输入参数，也叫做主功能号。对于一些复杂的主功能来说，它可能会需要子功能号来辅助查询，此时<code>ECX</code>寄存器会向<code>CPUID</code>指令系统子功能号。<code>CPUID</code>指令执行结束后，<code>CPUID</code>指令会使用<code>EAX</code>、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>寄存器保存执行结果。在64位模式下这些信息仍然是32位的，低32位有效，高32位清零。</p>
<p><code>CPUID</code>指令可以查询两类信息：基础功能和扩展信息。基础信息主功能号从<code>0h</code>开始，目前处理器支持的最大主功能号是<code>14h</code>，处理器通过<code>CPUID</code>指令的主功能号<code>0h</code>可查询出处理器支持的最大基础功能号。扩展信息的主功能号从<code>80000000h</code>开始，目前处理器支持的最大主功能号是<code>80000008h</code>，处理器通过CPUID指令的主功能号<code>80000000h</code>可查询出处理器当前支持的最大扩展功能号。</p>
<p><img src="https://img.ansore.de/2022/09/12/6226b8405f3ed9d617e3418c0797c31b.png" alt="Screenshot_20220912_213406"></p>
<h1 id="标志寄存器EFLAGS"><a href="#标志寄存器EFLAGS" class="headerlink" title="标志寄存器EFLAGS"></a>标志寄存器EFLAGS</h1><p><code>EFLGAS</code>标志寄存器包含有状态标志位、控制标志位以及系统标志位，处理器在初始化时将<code>EFLGAS</code>标志寄存器赋值为<code>00000002h</code>。在<code>IA-32e</code>体系结构中，<code>EFLGAS</code>标志寄存器已从32位扩展为64位，其中高32位暂时保留。</p>
<p><img src="https://img.ansore.de/2022/09/12/905aec8aea01cd1c56ce88c191fc82b3.png" alt="Screenshot_20220912_213731"></p>
<p>某些特殊的汇编指令可以直接修改<code>EFLGAS</code>标志寄存器的标志位。指令<code>LAHF</code>、<code>SAHF</code>、<code>PUSHF</code>、<code>PUSHFD</code>、<code>POPF</code>、<code>POPFD</code>可实现<code>EFLAGS</code>标志寄存器与栈（或<code>EAX</code>寄存器）的互相保存。一旦<code>EFLGAS</code>标志寄存器存有备份，程序便可以借助<code>BT</code>、<code>BTS</code>、<code>BTR</code>、<code>BTC</code>等指令对标志位进行修改或检测。当程序通过调用门执行任务切换时，处理器会把<code>EFLGAS</code>标志寄存器值保存到任务状态段 <code>TSS</code>内，并将目标任务状态段<code>TSS</code>内的值更新到<code>EFLGAS</code>标志寄存器中。</p>
<h2 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h2><p><code>EFLGAS</code>标志寄存器的状态标志（0、2、4、6、7、11位）可以反映汇编指令计算结果的状态，如<code>ADD</code>、<code>SUB</code>、<code>MUL</code>、<code>DIV</code>等汇编指令计算结果的奇偶性、溢出状态、正负值等。</p>
<p><img src="https://img.ansore.de/2022/09/12/7c2711b28b6798ef7a714d19f0e57c9a.png" alt="Screenshot_20220912_214153"></p>
<p><code>CF</code>标志位可反映出有符号整型数计算结果的溢出状态，<code>AF</code>可反映BCD型整数计算结果的溢出状态，<code>SF</code>标志位可反映出有符号整型数计算结果的正负值，<code>ZF</code>标志位可反映整型数的计算结果。</p>
<p>以上标志位，只有<code>CF</code>标志位可通过<code>STC</code>、<code>CLC</code>、<code>CMC</code>汇编指令更改位值，它也可以借助位操作指令（<code>BT</code>、<code>BTS</code>、<code>BTR</code>、<code>BTC</code>指令）将指定位值复制到<code>CF</code>标志位。而且<code>CF</code>标志位还可在多倍精度整型数计算时，结合<code>ADC</code>（含进位的加法计算）或<code>SBB</code>指令（含借位的减法指令）将进位计算或借位计算扩展到下次计算中。</p>
<p>至于状态跳转指令<code>Jcc</code>、状态字节置位指令<code>SETcc</code>、状态循环指令<code>LOOPcc</code>以及状态移动指令<code>CMOVcc</code>，它们可将一个或多个状态标志位作为判断条件，条件分支跳转、字节置位以及循环计数。</p>
<h2 id="方向标志"><a href="#方向标志" class="headerlink" title="方向标志"></a>方向标志</h2><p><code>DF</code>方向标志位位于<code>EFLAGS</code>标志寄存器的第10位，它控制字符串指令（如<code>MOVS</code>、<code>CMPS</code>、<code>SCAS</code>、<code>LODS</code>和<code>STOS</code>等）的操作方向。置位<code>DF</code>标志位可使字符串指令按从高到低的地址方向（自减）操作数据，复位<code>DF</code>标志位可使字符串指令按从低到高的地址方向（自增）操作数据。汇编指令<code>STD</code>与<code>CLD</code>可用于置位和复位<code>DF</code>方向标志位。</p>
<h2 id="系统标志和IOPL区域"><a href="#系统标志和IOPL区域" class="headerlink" title="系统标志和IOPL区域"></a>系统标志和IOPL区域</h2><p><code>EFLAGS</code>标志寄存器的系统标志和IOPL区域，负责控制I&#x2F;O端口地址访问权限、屏蔽硬件中断请求、使能单步调试、任务嵌套以及使能虚拟8086模式等</p>
<p><img src="https://img.ansore.de/2022/09/12/f349fcdfa07420537c4aa15fd64fad96.png" alt="Screenshot_20220912_221521"></p>
<p>如果希望修改系统标志位或IOPL区域，则必须拥有足够的执行权限（0特权级）。<code>VIF</code>和<code>VIP</code>标志只能在虚拟8086模式下有效；<code>AC</code>标志位只能对3特权级的数据对齐检测，如果发现数据未对齐则触发<code>#AC</code>异常；置位<code>RF</code>标志位将临时禁止断点触发<code>#DB</code>异常；<code>IF</code>标志位对<code>NMI</code>（Nonmaskable Interrupt，不可屏蔽中断）不起作用。可以借助汇编指令<code>CLI</code>、<code>STI</code>、<code>POPF</code>、<code>POPFD</code>、<code>IRET</code>操作IF标志位。</p>
<h1 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h1><p>控制寄存器功能表：</p>
<p><img src="https://img.ansore.de/2022/09/12/d45ff10d8acb1d67c1f9404f2218e7b9.png" alt="Screenshot_20220912_222012"></p>
<p>IA-32体系结构下，控制寄存器位宽是32位，而IA-32e体系结构下位宽为64位</p>
<p><img src="https://img.ansore.de/2022/09/12/2f0d05571695e63329be75867dceac60.png" alt="Screenshot_20220912_222118"></p>
<p>可通过<code>MOV CRn</code>汇编指令可对控制寄存器进行操作，其中的保留位必须写入数值0，否则会触发<code>#GP</code>异常。<code>CR2</code>和<code>CR3</code>寄存器不会对写入的地进行检测。<code>CR8</code>控制寄存器只在64位模式下有效。</p>
<p>各个有效标志位的功能说明：</p>
<p><img src="https://img.ansore.de/2022/09/12/6ca56f852bd71d3e4ea92f8bd77e774e.png" alt="Screenshot_20220912_222410"></p>
<p>如果<code>CR0.PE=0</code>时，置位<code>CR0.PG</code>标志寄存器会触发<code>#GP</code>异常。<code>CR0.CD</code>与<code>CR0.NW</code>标志位会联合控制处理器的缓存和读写策略。</p>
<p><img src="https://img.ansore.de/2022/09/12/bcf9ff5fb1d09ad373389ca2357d6521.png" alt="Screenshot_20220912_222546"></p>
<p>处理器的<code>CR0.TS</code>、<code>CR0.EM</code>以及<code>CR0.MP</code>标志位都用于控制浮点处理器（<code>x86 FPU</code>、<code>MMX</code>、<code>SSE</code>、<code>SSE2</code>、<code>SSE3</code>、<code>SSSE3</code>、<code>SSE4</code>等）的执行动作。</p>
<p><img src="https://img.ansore.de/2022/09/12/0455c9cce12d5a340d887af444748323.png" alt="Screenshot_20220912_222740"></p>
<p>标志位<code>TS</code>、<code>EM</code>、<code>MP</code>对<code>MMP</code>、<code>SSE</code>、<code>SSE2</code>、<code>SSE3</code>、<code>SSSE3</code>以及<code>SSE4</code>指令的影响会更复杂一些。</p>
<p>除<code>CRn</code>控制寄存器和<code>XCR0</code>扩展控制寄存器（用于控制浮点计算功能）外，<code>EFER</code>寄存器也用于控制系统功能。它是<code>MSR</code>控制寄存器组的<code>IA32_EFER</code>寄存器，它提供了控制<code>IA-32e</code>运行模式开启的标志位，以及关于页表访问限制的控制区域。</p>
<p><img src="https://img.ansore.de/2022/09/12/9ba53f327c55f30afaa2dc943a046d7d.png" alt="Screenshot_20220912_223143"></p>
<p>其中<code>LME</code>标志位最为重要，它用于开启IA-32e模式，而第0位则是<code>SYSCALL/SYSRET</code>指令的使能位。</p>
<p><img src="https://img.ansore.de/2022/09/12/fa309b62ba0c7b6c948aea33b45b6484.png" alt="Screenshot_20220912_223256"></p>
<h1 id="MSR寄存器组"><a href="#MSR寄存器组" class="headerlink" title="MSR寄存器组"></a>MSR寄存器组</h1><p>MSR寄存器组可提供性能检测、运行轨迹跟踪与调试以及其他处理器功能。在使用MSR寄存器组之前，应该通过<code>CPUID.01h:EDX[5]</code>来检测处理器是否支持MSR寄存器组。每种处理器都有自己的MSR寄存器组，在使用MSR寄存器组前需要根据处理器的家族信息（<code>CPUID.01h</code>查询处理器家族信息）选择与相对应的MSR寄存器组。</p>
<p>处理器可以使用<code>RDMSR</code>和<code>WRMSR</code>对MSR寄存器组进行访问，整个访问过程借助ECX寄存器索引寄存器地址，再由<code>EDX:EAX</code>组成的64位寄存器保存访问值。（64位模式下，<code>RCX</code>、<code>RAX</code>和<code>RDX</code>寄存器的高32位会被忽略）而且这对指令必须在实模式或0特权级下执行，否则将会触发<code>#GP</code>异常，使用MSR寄存器组的保留地址或无效地址都会产生通用保护异常。</p>
<p>通常<code>IA32_EFER</code>寄存器位于地址<code>0c0000080h</code>处，<code>SYSENTER/SYSEXIT</code>指令相关配置寄存器通常在地址<code>174h</code>、<code>175h</code>和<code>176h</code>处。这些寄存器地址可能根据处理器家族不同而变化。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>64位操作系统-地址空间</title>
    <url>/posts/330229db.html</url>
    <content><![CDATA[<h1 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h1><p>虚拟地址是抽象的地址统称，大多数不能独立为物理地址，像逻辑地址、有效地址、线性地址和平坦地址皆属于虚拟地址的管理范畴。</p>
<ul>
<li>逻辑地址。通常格式位<code>Segment:Offset</code>。段内偏移地址Offset也叫做有效地址，在C语言或其他高级编程语言里，获取变量或函数的地址就是获取其有效地址。逻辑地址最终都会转换位线性地址，但不同运行模式下的 转换过程各不相同。</li>
<li>线性地址。通过逻辑地址中的段基地址与段内偏移地址组合而成，这使得程序无法直接访问线性地址。平坦地址作为一种的线性地址，将段基地址和段长度覆盖了整个线性地址空间，而非线性地址空间的某一部分区域。</li>
</ul>
<h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p>物理地址空间中不仅包含物理内存（RAM、ROM）还有硬件设备。在处理器开启分页机制的情况下，线性地址需要经过页表映射才能转换为物理地址；否则线性地址将直接映射为物理地址。</p>
<ul>
<li>I&#x2F;O地址。I&#x2F;O地址空间与内存地址空间相互隔离，它必须借助特殊的<code>IN/OUT</code>指令才能访问。I&#x2F;O地址空间由65536个可独立寻址的I&#x2F;O端口组成，寻址范围0~FFFFh，其中的端口地址F8h~FFh保留使用</li>
<li>内存地址。内存地址空间不止有物理地址，还有其他外部硬件设备的地址空间，这些设备与物理内存共享内存地址空间。随着时间的推移，内存地址空间在保持向前兼容性的同时，不断增强寻址能力，从而造成可用物理内存碎片化、不连续化。所以可用物理内存空间、设备地址空间以及内存地址空间里。操作系统借助BIOS中断服务程序<code>INT 15h</code>的主功能编号<code>AX=E820h</code>可获取内存地址空间的相关信息。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>64位系统实现</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言-字符串操作</title>
    <url>/posts/750880bf.html</url>
    <content><![CDATA[<h1 id="字符测试函数"><a href="#字符测试函数" class="headerlink" title="字符测试函数"></a>字符测试函数</h1><p>字符测试函数，由头文件<code>&quot;ctype.h&quot;</code>定义</p>
<h5 id="数字或字母测试函数isalnum"><a href="#数字或字母测试函数isalnum" class="headerlink" title="数字或字母测试函数isalnum"></a>数字或字母测试函数<code>isalnum</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isalnum</span><span class="params">(<span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>

<p>检查c是否为英文或者阿拉伯数字，若是返回真，否则返回假</p>
<h5 id="字母测试函数isalpha"><a href="#字母测试函数isalpha" class="headerlink" title="字母测试函数isalpha"></a>字母测试函数<code>isalpha</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isalpha</span><span class="params">(<span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>

<p>测试一个字符是不是英文字母，包括大小写</p>
<h5 id="可打印字符测试函数isgraph"><a href="#可打印字符测试函数isgraph" class="headerlink" title="可打印字符测试函数isgraph"></a>可打印字符测试函数<code>isgraph</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isgrath</span><span class="params">(<span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>

<p>不可打印指的是转义字符、格式控制或特殊作用的字符</p>
<h5 id="大小写测试函数islower和isupper"><a href="#大小写测试函数islower和isupper" class="headerlink" title="大小写测试函数islower和isupper"></a>大小写测试函数<code>islower</code>和<code>isupper</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">islower</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isupper</span><span class="params">(<span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>

<p><code>islower</code>用于测试一个字符是不是小写字符，<code>isupper</code>用于测试是不是大写字符</p>
<h5 id="数字测试函数isxdigit"><a href="#数字测试函数isxdigit" class="headerlink" title="数字测试函数isxdigit"></a>数字测试函数<code>isxdigit</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isdigit</span><span class="params">(<span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>

<p>测试一个字母是不是0~9之间的阿拉伯数字</p>
<h5 id="符号测试函数ispunct"><a href="#符号测试函数ispunct" class="headerlink" title="符号测试函数ispunct"></a>符号测试函数<code>ispunct</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ispunct</span><span class="params">(<span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>

<p>测试一个字符是否为标点符号作者特殊符号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> s[] = <span class="string">&quot;123adfa0QsdQDSDF923;sdfa\nsdf;;\tsdfas&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i] != <span class="literal">NULL</span>; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isalnum</span>(s[i])) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c is a number or character.\n&quot;</span>, s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i])) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c is a character.\n&quot;</span>, s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isgraph</span>(s[i])) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c is a printable character.\n&quot;</span>, s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">islower</span>(s[i])) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c is a islower character.\n&quot;</span>, s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isupper</span>(s[i])) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c is a upper character.\n&quot;</span>, s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isxdigit</span>(s[i])) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c is a number.\n&quot;</span>, s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h1><h5 id="字符串转化为浮点型函数atof"><a href="#字符串转化为浮点型函数atof" class="headerlink" title="字符串转化为浮点型函数atof"></a>字符串转化为浮点型函数<code>atof</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">atof</span><span class="params">(<span class="type">char</span> *nptr)</span></span><br></pre></td></tr></table></figure>

<h5 id="字符串转化为浮点数strtod"><a href="#字符串转化为浮点数strtod" class="headerlink" title="字符串转化为浮点数strtod"></a>字符串转化为浮点数<code>strtod</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">strtod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr, <span class="type">char</span> **endptr)</span></span><br></pre></td></tr></table></figure>

<h5 id="字符串转化为整型函数atoi"><a href="#字符串转化为整型函数atoi" class="headerlink" title="字符串转化为整型函数atoi"></a>字符串转化为整型函数<code>atoi</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">char</span> *nptr)</span></span><br></pre></td></tr></table></figure>

<h5 id="字符串转化为长整型函数atol"><a href="#字符串转化为长整型函数atol" class="headerlink" title="字符串转化为长整型函数atol"></a>字符串转化为长整型函数<code>atol</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">aotl</span><span class="params">(<span class="type">char</span> *nptr)</span></span><br></pre></td></tr></table></figure>

<h5 id="字符串转化为无符号长整型strtoul"><a href="#字符串转化为无符号长整型strtoul" class="headerlink" title="字符串转化为无符号长整型strtoul"></a>字符串转化为无符号长整型<code>strtoul</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">strtoul</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span></span><br></pre></td></tr></table></figure>

<h5 id="将浮点型转化为字符串函数ecvt"><a href="#将浮点型转化为字符串函数ecvt" class="headerlink" title="将浮点型转化为字符串函数ecvt"></a>将浮点型转化为字符串函数<code>ecvt</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">ecvt</span><span class="params">(<span class="type">double</span> number, <span class="type">int</span> ndigits, <span class="type">int</span> *decpt, <span class="type">int</span> *sign)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>number</code>是一个<code>double</code>类型的浮点数</li>
<li><code>ndigits</code>在浮点数中从左向右取的位数</li>
<li><code>decpt</code>一个整型的指针，显示浮点数中小数点在第几位</li>
<li><code>sign</code>一个整型的指针，代表数值的正负，正为0，否则1</li>
</ul>
<h5 id="字母大小写转化函数tolower和toupper"><a href="#字母大小写转化函数tolower和toupper" class="headerlink" title="字母大小写转化函数tolower和toupper"></a>字母大小写转化函数<code>tolower</code>和<code>toupper</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tolower</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">toupper</span><span class="params">(<span class="type">int</span> c)</span> </span><br></pre></td></tr></table></figure>

<p><code>tolower</code>把大写字母转化为小写字母，<code>toupper</code>相反</p>
<h5 id="将整数转成合法的ASCII码toascii"><a href="#将整数转成合法的ASCII码toascii" class="headerlink" title="将整数转成合法的ASCII码toascii"></a>将整数转成合法的ASCII码<code>toascii</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">toascii</span><span class="params">(<span class="type">int</span> c)</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h1><p>头文件<code>&quot;string.h&quot;</code>中定义的</p>
<h5 id="字符串比较函数bcmp"><a href="#字符串比较函数bcmp" class="headerlink" title="字符串比较函数bcmp"></a>字符串比较函数<code>bcmp</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>比较两个字符串的前n个字节是否相同，相同返回0，否则返回非0</p>
<h5 id="字符串大小比较函数memcmp"><a href="#字符串大小比较函数memcmp" class="headerlink" title="字符串大小比较函数memcmp"></a>字符串大小比较函数<code>memcmp</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s1, <span class="type">const</span> <span class="type">void</span> *s2, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>

<p>比较两个字符串的大小是否相同，并且返回第一个不相同字符串的差值，n表示比较前n个字符</p>
<h5 id="忽略大小写比较字符串函数strncasecmp"><a href="#忽略大小写比较字符串函数strncasecmp" class="headerlink" title="忽略大小写比较字符串函数strncasecmp"></a>忽略大小写比较字符串函数<code>strncasecmp</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncasecmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>

<p>忽略大小写比较两个字符串</p>
<h1 id="字符串复制"><a href="#字符串复制" class="headerlink" title="字符串复制"></a>字符串复制</h1><h5 id="字符串复制函数bcopy"><a href="#字符串复制函数bcopy" class="headerlink" title="字符串复制函数bcopy"></a>字符串复制函数<code>bcopy</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bcopy</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *src, <span class="type">void</span> *dest, <span class="type">int</span> n)</span></span><br></pre></td></tr></table></figure>

<p><code>src</code>表示需要复制的字符串，<code>dest</code>表示复制到的字符串。n表示需要在字符串中复制的字符数目</p>
<h5 id="字符串复制函数memccpy"><a href="#字符串复制函数memccpy" class="headerlink" title="字符串复制函数memccpy"></a>字符串复制函数<code>memccpy</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memccpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>

<p>将一个字符串中的前n个字节复制到另一个字符串中。与<code>bcopy</code>不同的是<code>memccpy</code>可以检查字符串里是不是有某一字符。<code>src</code>和<code>dest</code>分别表示源字符和目标字符，c表示需要在字符串<code>dest</code>中查找赋值为c的字符，如果找到这个字符，则返回下一个字符的指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a[<span class="number">20</span>] = <span class="string">&quot;asdfagh&quot;</span>;</span><br><span class="line">	<span class="type">char</span> b[<span class="number">20</span>] = <span class="string">&quot;ijklmn&quot;</span>;</span><br><span class="line">	<span class="type">char</span> *s;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n&quot;</span>, a, b);</span><br><span class="line">	s = memccpy(a, b, <span class="string">&#x27;k&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, *s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n&quot;</span>, a, b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**结果</span></span><br><span class="line"><span class="comment">asdfagh</span></span><br><span class="line"><span class="comment">ijklmn</span></span><br><span class="line"><span class="comment">f</span></span><br><span class="line"><span class="comment">ijkfagh</span></span><br><span class="line"><span class="comment">ijklmn</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="字符串复制函数strcpy"><a href="#字符串复制函数strcpy" class="headerlink" title="字符串复制函数strcpy"></a>字符串复制函数<code>strcpy</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br></pre></td></tr></table></figure>

<p>函数返回字符串<code>dest</code>指针，<code>dest</code>必须有足够的空间，否则会发生溢出</p>
<h5 id="字符串复制函数strncpy"><a href="#字符串复制函数strncpy" class="headerlink" title="字符串复制函数strncpy"></a>字符串复制函数<code>strncpy</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure>

<p>将一个字符串中的若干字符复制到另一个字符串中哦你</p>
<h1 id="字符串的清理与填充"><a href="#字符串的清理与填充" class="headerlink" title="字符串的清理与填充"></a>字符串的清理与填充</h1><h5 id="字符串清理函数bzero"><a href="#字符串清理函数bzero" class="headerlink" title="字符串清理函数bzero"></a>字符串清理函数<code>bzero</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bzero</span><span class="params">(<span class="type">void</span> *s,<span class="type">int</span> n)</span> </span><br></pre></td></tr></table></figure>

<p>将字符串中的前n个字符写入<code>NULL</code>值</p>
<h5 id="字符串填充函数memset"><a href="#字符串填充函数memset" class="headerlink" title="字符串填充函数memset"></a>字符串填充函数<code>memset</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memset</span> <span class="params">(<span class="type">void</span> *s ,<span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>

<p>将一个字符的前 n 个字符填充为某一个字符</p>
<h1 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h1><h5 id="字符查找函数index与rindex"><a href="#字符查找函数index与rindex" class="headerlink" title="字符查找函数index与rindex"></a>字符查找函数<code>index</code>与<code>rindex</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">index</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> c)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">rindex</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> c)</span>; </span><br></pre></td></tr></table></figure>

<p> 函数<code>index</code>用来在字符串中找出需要查找字符第一次的出现位置，然后将该字符地址返 回。<code>rindex</code>的使用方法与<code>index</code>相似，但作用是找出字符串中最后一次某字符出现的位置。、</p>
<h5 id="字符查找函数memchr"><a href="#字符查找函数memchr" class="headerlink" title="字符查找函数memchr"></a>字符查找函数<code>memchr</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s,<span class="type">int</span> c,<span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure>

<p>在一个字符串的前 n 个字符中查找某一个字符，返回这个字符的指针地址</p>
<h5 id="字符查找函数strchr与strrchr"><a href="#字符查找函数strchr与strrchr" class="headerlink" title="字符查找函数strchr与strrchr"></a>字符查找函数<code>strchr</code>与<code>strrchr</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strchr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">int</span> c)</span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">strrchr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">int</span> c)</span> </span><br></pre></td></tr></table></figure>

<p><code>strchr</code>的作用是在一个字符串中查找某一个字符第一次出现的位置。<code>strrchr</code>的作用是在一个字符串中查找某一个字符最后一次出现的位置</p>
<h1 id="字符串的连接与分割"><a href="#字符串的连接与分割" class="headerlink" title="字符串的连接与分割"></a>字符串的连接与分割</h1><h5 id="字符串连接函数strcat"><a href="#字符串连接函数strcat" class="headerlink" title="字符串连接函数strcat"></a>字符串连接函数<code>strcat</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span> <span class="params">(<span class="type">char</span> *dest,<span class="type">const</span> <span class="type">char</span> *src)</span> </span><br></pre></td></tr></table></figure>

<p>将一个字符串连接到另一个字符串后面</p>
<h5 id="字符串分割函数strtok"><a href="#字符串分割函数strtok" class="headerlink" title="字符串分割函数strtok"></a>字符串分割函数<code>strtok</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *s,<span class="type">const</span> <span class="type">char</span> *delim)</span>; </span><br></pre></td></tr></table></figure>

<p>将字符串分割成多个字符串，</p>
<p> <code>strtok</code>在参数<code>s</code>字符串中发现参数<code>delim</code>的分割字符时，将该字符改为<code>NULL</code>字符，然后返回更改以后的字符串。再次调用时，将参数<code>s</code>设置成<code>NULL</code>。每次调用成功则返回下一个分割 后的字符串指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *p;</span><br><span class="line">	<span class="type">char</span> a[<span class="number">20</span>] = <span class="string">&quot;qweaQQWEa^!@#aIOP&quot;</span>;</span><br><span class="line">	<span class="type">char</span> s[] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, a);</span><br><span class="line">	p = strtok(a, s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line">	<span class="keyword">while</span>(p = strtok(<span class="literal">NULL</span>, s)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 结果</span></span><br><span class="line"><span class="comment">qweaQQWEa^!@#aIOP</span></span><br><span class="line"><span class="comment">qwe</span></span><br><span class="line"><span class="comment">QQWE</span></span><br><span class="line"><span class="comment">^!@#</span></span><br><span class="line"><span class="comment">IOP</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h1 id="其他字符串函数"><a href="#其他字符串函数" class="headerlink" title="其他字符串函数"></a>其他字符串函数</h1><h5 id="字符串长度函数strlen"><a href="#字符串长度函数strlen" class="headerlink" title="字符串长度函数strlen"></a>字符串长度函数<code>strlen</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>; </span><br></pre></td></tr></table></figure>

<p>返回字符串的长度，也就是字符串里一共有多少个字符。函数的使用</p>
<h5 id="允许出现字符查找函数strspn"><a href="#允许出现字符查找函数strspn" class="headerlink" title="允许出现字符查找函数strspn"></a>允许出现字符查找函数<code>strspn</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strspn</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *s,<span class="type">const</span> <span class="type">char</span> * accept)</span>; </span><br></pre></td></tr></table></figure>

<p>返回一个字符串中首次不包含在指定字符串内容中的字符的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">	<span class="type">char</span> b[] = <span class="string">&quot;aaabbb.ccc&quot;</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="built_in">strspn</span>(b, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 结果</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="不允许出现字符查找函数strcspn"><a href="#不允许出现字符查找函数strcspn" class="headerlink" title="不允许出现字符查找函数strcspn"></a>不允许出现字符查找函数<code>strcspn</code></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strcspn</span> <span class="params">( <span class="type">const</span> <span class="type">char</span> *s,<span class="type">const</span> <span class="type">char</span> * reject)</span> </span><br></pre></td></tr></table></figure>

<p>查找出一个字符串中不允许出现的某个字符的位置</p>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>C之attribute的作用</title>
    <url>/posts/1d6a3c99.html</url>
    <content><![CDATA[<h1 id="attribute-的作用"><a href="#attribute-的作用" class="headerlink" title="__attribute__的作用"></a>__attribute__的作用</h1><p><code>attribute</code>：属性，主要是用来在<code>函数</code>或<code>数据声明</code>中设置其属性，与编译器相关</p>
<p>GNU C 的一大特色就是<code>__attribute__</code>机制。<code>__attribute__</code>可以设置<code>函数属性（Function Attribute）</code>、<code>变量属性（Variable Attribute）</code>和<code>类型属性（Type Attribute）</code>。</p>
<p>语法格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__ ((attribute-<span class="built_in">list</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数据声明：</p>
<p>  <code>__attribute__ ((packed))</code>: 的作用就是告诉编译器取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐，是 GCC 特有的语法。</p>
<p>  <code>__attribute__((aligned(n)))</code>: 内存对齐，指定内存对齐 n 字节</p>
</li>
<li><p>函数声明：</p>
<p>  <code>__attribute__((noreturn))</code>: 的作用告诉编译器这个函数不会返回给调用者，以便编译器在优化时去掉不必要的函数返回代码。</p>
<p>  <code>__attribute__((weak))</code>: 虚函数，弱符号</p>
</li>
</ul>
<p><strong>packed</strong></p>
<p>该属性可以使得变量或者结构体成员使用最小的对齐方式，即对变量是一字节对齐，对域（field）是位对齐。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sc1</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sc1: sizeof-char*  = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc1));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sc3</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sc3: packed sizeof-char*  = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc3));</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sc1: <span class="keyword">sizeof</span>-<span class="type">char</span>*  = <span class="number">16</span></span><br><span class="line">sc3: packed <span class="keyword">sizeof</span>-<span class="type">char</span>*  = <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>aligned(n)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((<span class="title">aligned</span>(4))) <span class="title">sc5</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((<span class="title">aligned</span>(4))) <span class="title">sc6</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> b[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sc5: aligned 4 sizeof-char*  = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc5));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sc6: aligned 4 sizeof-char[] = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc6));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((<span class="title">aligned</span>(2))) <span class="title">sc7</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((<span class="title">aligned</span>(2))) <span class="title">sc8</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">char</span> b[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sc7: aligned 2 sizeof-char*  = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc7));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sc8: aligned 2 sizeof-char[] = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sc8));</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sc5: aligned <span class="number">4</span> <span class="keyword">sizeof</span>-<span class="type">char</span>*  = <span class="number">16</span></span><br><span class="line">sc6: aligned <span class="number">4</span> <span class="keyword">sizeof</span>-<span class="type">char</span>[] = <span class="number">4</span></span><br><span class="line">sc7: aligned <span class="number">2</span> <span class="keyword">sizeof</span>-<span class="type">char</span>*  = <span class="number">16</span></span><br><span class="line">sc8: aligned <span class="number">2</span> <span class="keyword">sizeof</span>-<span class="type">char</span>[] = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>noreturn</strong></p>
<p>函数不会返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span>   __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br></pre></td></tr></table></figure>

<p><strong>weak</strong></p>
<p>func 转成<code>弱符号类型</code></p>
<ul>
<li>如果遇到<code>强符号类型</code>（即外部模块定义了 func, <code>extern int func(void);</code>），那么我们在本模块执行的 func 将会是外部模块定义的 func。</li>
<li>如果外部模块没有定义，那么将会调用这个弱符号，也就是在本地定义的 func，直接返回了一个 1（返回值视具体情况而定）相当于增加了一个<code>默认函数</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  __attribute__((weak))  func(...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原理</strong>：<code>链接器</code>发现同时存在<code>弱符号</code>和<code>强符号</code>，就先选择强符号，如果发现不存在强符号，只存在弱符号，则选择弱符号。如果都不存在：静态链接，恭喜，编译时报错，动态链接：对不起，系统无法启动。</p>
<p>weak 属性只会在静态库 (.o .a) 中生效，动态库 (.so) 中不会生效。</p>
<p><strong>内存地址对齐</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _ALIGH(x, align) (((x) + (align - 1)) &amp; (~(align - 1)))</span></span><br><span class="line"></span><br><span class="line">d_p = (<span class="type">d_t</span> *)_ALIGH((<span class="type">unsigned</span> <span class="type">int</span>)d , <span class="number">64</span>); <span class="comment">//将地址d按64bit进行对其后赋值给d_p指针</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake之编译单个源文件</title>
    <url>/posts/d642b63b.html</url>
    <content><![CDATA[<h1 id="单个源文件"><a href="#单个源文件" class="headerlink" title="单个源文件"></a>单个源文件</h1><p>假设现在我们的项目中只有一个源文件 <a href="http://main.cc/">main.cc</a> ，该程序的用途是计算一个数的指数幂。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * power - Calculate the power of number.</span></span><br><span class="line"><span class="comment"> * @param base: Base value.</span></span><br><span class="line"><span class="comment"> * @param exponent: Exponent value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return base raised to the power exponent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = base;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; exponent; ++i)&#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s base exponent \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> base = atof(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> exponent = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">double</span> result = power(base, exponent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%g ^ %d is %g\n&quot;</span>, base, exponent, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编写-CMakeLists-txt"><a href="#编写-CMakeLists-txt" class="headerlink" title="编写 CMakeLists.txt"></a><strong>编写 CMakeLists.txt</strong></h2><p>首先编写 CMakeLists.txt 文件，并保存在与 <strong><a href="http://main.cc/">main.cc</a></strong> 源文件同个目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line">project (Demo1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line">add_executable(Demo main.cc)</span><br></pre></td></tr></table></figure>

<p>CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 <code>#</code> 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。</p>
<p>对于上面的 CMakeLists.txt 文件，依次出现了几个命令：</p>
<ul>
<li><code>cmake_minimum_required</code>：指定运行此配置文件所需的 CMake 的最低版本；</li>
<li><code>project</code>：参数值是 <code>Demo1</code>，该命令表示项目的名称是 <code>Demo1</code> 。</li>
<li><code>add_executable</code>： 将名为 <strong><a href="http://main.cc/">main.cc</a></strong> 的源文件编译成一个名称为 Demo 的可执行文件。</li>
</ul>
<h2 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译<strong>项目</strong></h2><p>之后，在当前目录执行 <code>cmake .</code> ，得到 Makefile 后再使用 <code>make</code> 命令编译得到 Demo1 可执行文件。</p>
]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake之编译多个源文件</title>
    <url>/posts/9200e496.html</url>
    <content><![CDATA[<h1 id="多个源文件"><a href="#多个源文件" class="headerlink" title="多个源文件"></a>多个源文件</h1><p>现在假如把 <code>power</code> 函数单独写进一个名为 <code>MathFunctions.c</code> 的源文件里，使得这个工程变成如下的形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/Demo2</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.h</span><br></pre></td></tr></table></figure>

<p>这个时候，CMakeLists.txt 可以改成如下的形式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line">project (Demo2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line">add_executable(Demo main.cc MathFunctions.cc)</span><br></pre></td></tr></table></figure>

<p>唯一的改动只是在 <code>add_executable</code> 命令中增加了一个 <code>MathFunctions.cc</code> 源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 <code>aux_source_directory</code> 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">aux_source_directory(&lt;<span class="built_in">dir</span>&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure>

<p>因此，可以修改 CMakeLists.txt 如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line">project (Demo2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line">add_executable(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样，CMake 会将当前目录所有源文件的文件名赋值给变量 <code>DIR_SRCS</code> ，再指示变量 <code>DIR_SRCS</code> 中的源文件需要编译成一个名称为 Demo 的可执行文件。</p>
]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake之编译多个目录、多个源文件</title>
    <url>/posts/1c5b22a6.html</url>
    <content><![CDATA[<h1 id="多个目录，多个源文件"><a href="#多个目录，多个源文件" class="headerlink" title="多个目录，多个源文件"></a>多个目录，多个源文件</h1><p>现在进一步将 MathFunctions.h 和 <a href="http://mathfunctions.cc/">MathFunctions.cc</a> 文件移动到 math 目录下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./Demo3</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- math/</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.cc</span><br><span class="line">          |</span><br><span class="line">          +--- MathFunctions.h</span><br></pre></td></tr></table></figure>

<p>对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。</p>
<p>根目录中的 CMakeLists.txt ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line">project (Demo3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 math 子目录</span></span><br><span class="line">add_subdirectory(math)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标 </span></span><br><span class="line">add_executable(Demo main.cc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line">target_link_libraries(Demo MathFunctions)</span><br></pre></td></tr></table></figure>

<p>该文件添加了下面的内容: 第3行，使用命令 <code>add_subdirectory</code> 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理 。第6行，使用命令 <code>target_link_libraries</code> 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。</p>
<p>子目录中的 CMakeLists.txt：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span></span><br><span class="line">aux_source_directory(. DIR_LIB_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成链接库</span></span><br><span class="line">add_library (MathFunctions <span class="variable">$&#123;DIR_LIB_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>在该文件中使用命令 <code>add_library</code> 将 src 目录中的源文件编译为静态链接库。</p>
]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake学习</title>
    <url>/posts/72bbddf7.html</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">PROJECT_SOURCE_DIR       <span class="comment"># 工程的根目录</span></span><br><span class="line">PROJECT_BINARY_DIR       <span class="comment"># 运行 cmake 命令的目录，通常是 $&#123;PROJECT_SOURCE_DIR&#125;/build </span></span><br><span class="line">PROJECT_NAME             <span class="comment"># 返回通过 project 命令定义的项目名称</span></span><br><span class="line">CMAKE_CURRENT_SOURCE_DIR <span class="comment"># 当前处理的 CMakeLists.txt 所在的路径</span></span><br><span class="line">CMAKE_CURRENT_BINARY_DIR <span class="comment"># target 编译目录</span></span><br><span class="line">CMAKE_CURRENT_LIST_DIR   <span class="comment"># CMakeLists.txt 的完整路径</span></span><br><span class="line">CMAKE_CURRENT_LIST_LINE  <span class="comment"># 当前所在的行</span></span><br><span class="line">CMAKE_MODULE_PATH        <span class="comment"># 定义自己的 cmake 模块所在的路径，SET(CMAKE_MODULE_PATH $&#123;PROJECT_SOURCE_DIR&#125;/cmake)，然后可以用INCLUDE命令来调用自己的模块</span></span><br><span class="line">EXECUTABLE_OUTPUT_PATH   <span class="comment"># 重新定义目标二进制可执行文件的存放位置</span></span><br><span class="line">LIBRARY_OUTPUT_PATH      <span class="comment"># 重新定义目标链接库文件的存放位置</span></span><br></pre></td></tr></table></figure>

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用环境变量</span></span><br><span class="line">$ENV&#123;Name&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入环境变量, 这里没有`$`符号</span></span><br><span class="line"><span class="keyword">set</span>(ENV&#123;Name&#125; value)</span><br></pre></td></tr></table></figure>

<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">CMAKE_MAJOR_VERSION    <span class="comment"># cmake 主版本号, 比如 3.4.1 中的 3</span></span><br><span class="line">CMAKE_MINOR_VERSION    <span class="comment"># cmake 次版本号，比如 3.4.1 中的 4</span></span><br><span class="line">CMAKE_PATCH_VERSION    <span class="comment"># cmake 补丁等级，比如 3.4.1 中的 1</span></span><br><span class="line">CMAKE_SYSTEM           <span class="comment"># 系统名称，比如 Linux-­2.6.22</span></span><br><span class="line">CMAKE_SYSTEM_NAME      <span class="comment"># 不包含版本的系统名，比如 Linux</span></span><br><span class="line">CMAKE_SYSTEM_VERSION   <span class="comment"># 系统版本，比如 2.6.22</span></span><br><span class="line">CMAKE_SYSTEM_PROCESSOR <span class="comment"># 处理器名称，比如 i686</span></span><br><span class="line">UNIX                   <span class="comment"># 在所有的类 UNIX 平台下该值为 TRUE，包括 OS X 和 cygwin</span></span><br><span class="line">WIN32                  <span class="comment"># 在所有的 win32 平台下该值为 TRUE，包括 cygwin</span></span><br></pre></td></tr></table></figure>

<h2 id="主要开关选项"><a href="#主要开关选项" class="headerlink" title="主要开关选项"></a>主要开关选项</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个开关用来控制默认的库编译方式，如果不进行设置，使用 add_library 又没有指定库类型的情况下，默认编译生成的库都是静态库。</span></span><br><span class="line"><span class="comment"># 如果 set(BUILD_SHARED_LIBS ON) 后，默认生成的为动态库</span></span><br><span class="line">BUILD_SHARED_LIBS </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 C 编译选项，也可以通过指令 add_definitions() 添加</span></span><br><span class="line">CMAKE_C_FLAGS     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 C++ 编译选项，也可以通过指令 add_definitions() 添加</span></span><br><span class="line">CMAKE_CXX_FLAGS   </span><br><span class="line"></span><br><span class="line"><span class="comment"># exp: 参数之间用空格分隔</span></span><br><span class="line"><span class="keyword">add_definitions</span>(-DENABLE_DEBUG -DABC) </span><br></pre></td></tr></table></figure>

<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="set设置变量"><a href="#set设置变量" class="headerlink" title="set设置变量"></a><code>set</code>设置变量</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、set 直接设置变量的值</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST main.cpp <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(demo <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、set 追加设置变量的值</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST main.cpp)</span><br><span class="line"><span class="keyword">set</span>(SRC_LIST <span class="variable">$&#123;SRC_LIST&#125;</span> <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(demo <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、list 追加或者删除变量的值</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST main.cpp)</span><br><span class="line"><span class="keyword">list</span>(APPEND SRC_LIST <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM SRC_LIST main.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(demo <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reading</span></span><br><span class="line"><span class="keyword">list</span>(LENGTH &lt;<span class="keyword">list</span>&gt; &lt;out-var&gt;)                            <span class="comment"># 返回list的长度</span></span><br><span class="line"><span class="keyword">list</span>(GET &lt;<span class="keyword">list</span>&gt; &lt;element index&gt; [&lt;index&gt; ...] &lt;out-var&gt;) <span class="comment"># 返回list中index的element到value中</span></span><br><span class="line"><span class="keyword">list</span>(JOIN &lt;<span class="keyword">list</span>&gt; &lt;glue&gt; &lt;out-var&gt;)</span><br><span class="line"><span class="keyword">list</span>(SUBLIST &lt;<span class="keyword">list</span>&gt; &lt;begin&gt; &lt;length&gt; &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Search</span></span><br><span class="line"><span class="keyword">list</span>(FIND &lt;<span class="keyword">list</span>&gt; &lt;value&gt; &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Modification</span></span><br><span class="line"><span class="keyword">list</span>(APPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt;...])                       <span class="comment"># 添加新element到list中</span></span><br><span class="line"><span class="keyword">list</span>(FILTER &lt;<span class="keyword">list</span>&gt; &#123;<span class="keyword">INCLUDE</span> | EXCLUDE&#125; REGEX &lt;regex&gt;)</span><br><span class="line"><span class="keyword">list</span>(INSERT &lt;<span class="keyword">list</span>&gt; &lt;index&gt; [&lt;element&gt;...])</span><br><span class="line"><span class="keyword">list</span>(POP_BACK &lt;<span class="keyword">list</span>&gt; [&lt;out-var&gt;...])</span><br><span class="line"><span class="keyword">list</span>(POP_FRONT &lt;<span class="keyword">list</span>&gt; [&lt;out-var&gt;...])</span><br><span class="line"><span class="keyword">list</span>(PREPEND &lt;<span class="keyword">list</span>&gt; [&lt;element&gt;...])</span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM &lt;<span class="keyword">list</span>&gt; &lt;value&gt;...)</span><br><span class="line"><span class="keyword">list</span>(REMOVE_AT &lt;<span class="keyword">list</span>&gt; &lt;index&gt;...)</span><br><span class="line"><span class="keyword">list</span>(REMOVE_DUPLICATES &lt;<span class="keyword">list</span>&gt;)                          <span class="comment"># 从list中删除重复的element</span></span><br><span class="line"><span class="keyword">list</span>(TRANSFORM &lt;<span class="keyword">list</span>&gt; &lt;ACTION&gt; [...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ordering</span></span><br><span class="line"><span class="keyword">list</span>(REVERSE &lt;<span class="keyword">list</span>&gt;)</span><br><span class="line"><span class="keyword">list</span>(SORT &lt;<span class="keyword">list</span>&gt; [...])</span><br></pre></td></tr></table></figure>

<h2 id="if条件控制"><a href="#if条件控制" class="headerlink" title="if条件控制"></a><code>if</code>条件控制</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、逻辑判断和比较：</span></span><br><span class="line"><span class="keyword">if</span> (expression)                  <span class="comment"># expression 不为空（0,N,NO,OFF,FALSE,NOTFOUND）时为真</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">not</span> exp)                     <span class="comment"># 与上面相反</span></span><br><span class="line"><span class="keyword">if</span> (var1 <span class="keyword">AND</span> var2)               <span class="comment"># 与</span></span><br><span class="line"><span class="keyword">if</span> (var1 <span class="keyword">OR</span> var2)                <span class="comment"># 或</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">COMMAND</span> cmd)                 <span class="comment"># 如果 cmd 确实是命令并可调用为真</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">EXISTS</span> dir)/<span class="keyword">if</span> (<span class="keyword">EXISTS</span> <span class="keyword">file</span>) <span class="comment"># 如果目录或文件存在为真</span></span><br><span class="line"><span class="keyword">if</span> (file1 <span class="keyword">IS_NEWER_THAN</span> file2)   <span class="comment"># 当 file1 比 file2 新，或 file1/file2 中有一个不存在时为真，文件名需使用全路径</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">IS_DIRECTORY</span> dir)            <span class="comment"># 当 dir 是目录时为真</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">DEFINED</span> var)                 <span class="comment"># 如果变量被定义为真</span></span><br><span class="line"><span class="keyword">if</span> (var <span class="keyword">MATCHES</span> regex)           <span class="comment"># 给定的变量或者字符串能够匹配正则表达式 regex 时为真，此处 var 可以用 var 名，也可以用 $&#123;var&#125;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">string</span> <span class="keyword">MATCHES</span> regex)        <span class="comment"># 同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、数字比较：</span></span><br><span class="line"><span class="keyword">if</span> (variable <span class="keyword">LESS</span> number)        <span class="comment"># LESS 小于</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">string</span> <span class="keyword">LESS</span> number)</span><br><span class="line"><span class="keyword">if</span> (variable <span class="keyword">GREATER</span> number)     <span class="comment"># GREATER 大于</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">string</span> <span class="keyword">GREATER</span> number)</span><br><span class="line"><span class="keyword">if</span> (variable <span class="keyword">EQUAL</span> number)       <span class="comment"># EQUAL 等于</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">string</span> <span class="keyword">EQUAL</span> number)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、字母表顺序比较：</span></span><br><span class="line"><span class="keyword">if</span> (variable <span class="keyword">STRLESS</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">string</span> <span class="keyword">STRLESS</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> (variable <span class="keyword">STRGREATER</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">string</span> <span class="keyword">STRGREATER</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> (variable <span class="keyword">STREQUAL</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">string</span> <span class="keyword">STREQUAL</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、示例</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$&#123;CMAKE_BUILD_TYPE&#125;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(UNIX)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11 -fpermissive -g&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">add_definitions</span>(-D_SCL_SECURE_NO_WARNINGS</span><br><span class="line">    -D_CRT_SECURE_NO_WARNINGS</span><br><span class="line">    -D_WIN32_WINNT=<span class="number">0</span>x601</span><br><span class="line">    -D_WINSOCK_DEPRECATED_NO_WARNINGS)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h2 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a><code>while</code>循环语句</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure>

<h2 id="foreach循环语句"><a href="#foreach循环语句" class="headerlink" title="foreach循环语句"></a><code>foreach</code>循环语句</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start 表示起始数，stop 表示终止数，step 表示步长</span></span><br><span class="line"><span class="keyword">foreach</span>(loop_var RANGE start stop [step])</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endforeach</span>(loop_var)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例(输出：1、3、5、7、9)</span></span><br><span class="line"><span class="keyword">foreach</span>(i RANGE <span class="number">1</span> <span class="number">9</span> <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="variable">$&#123;i&#125;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>(i)</span><br></pre></td></tr></table></figure>

<h2 id="macro宏定义"><a href="#macro宏定义" class="headerlink" title="macro宏定义"></a><code>macro</code>宏定义</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MACRO: 用宏来实现封装，自定义一个命令</span></span><br><span class="line"><span class="comment"># 宏的ARGN、ARGV等参数不是通常CMake意义上的变量。 它们是字符串替换，很像C预处理器对宏的处理。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ARGV	是一个下标，0指向第一个参数，累加</span></span><br><span class="line"><span class="comment"># ARGV	所有的定义时要求传入的参数</span></span><br><span class="line"><span class="comment"># ARGN	定义时要求传入的参数以外的参数，比如定义宏（函数）时，要求输入1个，书记输入了3个，则剩下的两个会以数组形式存储在ARGN中</span></span><br><span class="line"><span class="comment"># ARGC	传入的实际参数的个数，也就是调用函数是传入的参数个数</span></span><br><span class="line"><span class="keyword">MACRO</span>(&lt;name&gt; [arg1 [arg2 [arg3 ...]]])</span><br><span class="line">    COMMAND1(ARGS ...)</span><br><span class="line">    COMMAND2(ARGS ...)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">ENDMACRO</span>(&lt;name&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个宏，用来简化测试工作</span></span><br><span class="line"><span class="keyword">macro</span> (do_test arg1 arg2 result)</span><br><span class="line">  <span class="keyword">add_test</span> (test_<span class="variable">$&#123;arg1&#125;</span>_<span class="variable">$&#123;arg2&#125;</span> Demo <span class="variable">$&#123;arg1&#125;</span> <span class="variable">$&#123;arg2&#125;</span>)</span><br><span class="line">  <span class="keyword">set_tests_properties</span> (test_<span class="variable">$&#123;arg1&#125;</span>_<span class="variable">$&#123;arg2&#125;</span></span><br><span class="line">    PROPERTIES PASS_REGULAR_EXPRESSION <span class="variable">$&#123;result&#125;</span>)</span><br><span class="line"><span class="keyword">endmacro</span> (do_test)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用该宏进行一系列的数据测试</span></span><br><span class="line">do_test (<span class="number">5</span> <span class="number">2</span> <span class="string">&quot;is 25&quot;</span>)</span><br><span class="line">do_test (<span class="number">10</span> <span class="number">5</span> <span class="string">&quot;is 100000&quot;</span>)</span><br><span class="line">do_test (<span class="number">2</span> <span class="number">10</span> <span class="string">&quot;is 1024&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="function函数"><a href="#function函数" class="headerlink" title="function函数"></a><code>function</code>函数</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># function: 用函数来实现封装，自定义一个命令</span></span><br><span class="line"><span class="keyword">function</span>(&lt;name&gt; [&lt;arg1&gt; ...])</span><br><span class="line">  &lt;commands&gt;</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个简单的打印函数</span></span><br><span class="line"><span class="keyword">function</span>(_foo)</span><br><span class="line">    <span class="keyword">foreach</span>(arg IN LISTS ARGN)</span><br><span class="line">        <span class="keyword">message</span>(STATUS <span class="string">&quot;this in function is $&#123;arg&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endforeach</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">_foo(a b c)</span><br><span class="line"><span class="comment"># this in function is a</span></span><br><span class="line"><span class="comment"># this in function is b</span></span><br><span class="line"><span class="comment"># this in function is c</span></span><br></pre></td></tr></table></figure>

<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="指定cmake的最小版本"><a href="#指定cmake的最小版本" class="headerlink" title="指定cmake的最小版本"></a>指定<code>cmake</code>的最小版本</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION3.<span class="number">4.1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="设置项目名称"><a href="#设置项目名称" class="headerlink" title="设置项目名称"></a>设置项目名称</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，</span></span><br><span class="line"><span class="comment"># 同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。</span></span><br><span class="line"><span class="keyword">project</span>(demo)</span><br></pre></td></tr></table></figure>

<h2 id="设置编译类型"><a href="#设置编译类型" class="headerlink" title="设置编译类型"></a>设置编译类型</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(demo demo.cpp)       <span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="keyword">add_library</span>(common STATIC util.cpp) <span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(common SHARED util.cpp) <span class="comment"># 生成动态库或共享库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add_library 默认生成是静态库，通过以上命令生成文件名字，</span></span><br><span class="line"><span class="comment"># 在 Linux 下是：demo、libcommon.a、libcommon.so</span></span><br><span class="line"><span class="comment"># 在 Windows 下是：demo.exe、common.lib、common.dll</span></span><br></pre></td></tr></table></figure>

<h2 id="指定编译包含的源文件"><a href="#指定编译包含的源文件" class="headerlink" title="指定编译包含的源文件"></a>指定编译包含的源文件</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、明确指定包含哪些源文件</span></span><br><span class="line"><span class="keyword">add_library</span>(demo demo.cpp <span class="keyword">test</span>.cpp util.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、发现一个目录下所有的源代码文件并将列表存储在一个变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(dir VAR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># exp:搜索当前目录下的所有.cpp文件</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">add_library</span>(demo <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、自定义搜索规则</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;*.cpp&quot;</span> <span class="string">&quot;protocol/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(demo <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_PROTOCOL_LIST <span class="string">&quot;protocol/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(demo <span class="variable">$&#123;SRC_LIST&#125;</span> <span class="variable">$&#123;SRC_PROTOCOL_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SRC_LIST <span class="string">&quot;*.cpp&quot;</span>) <span class="comment"># 递归搜索</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_PROTOCOL RELATIVE <span class="string">&quot;protocol&quot;</span> <span class="string">&quot;*.cpp&quot;</span>) <span class="comment"># 相对protocol目录下搜索</span></span><br><span class="line"><span class="keyword">add_library</span>(demo <span class="variable">$&#123;SRC_LIST&#125;</span> <span class="variable">$&#123;SRC_PROTOCOL_LIST&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(protocol SRC_PROTOCOL_LIST)</span><br><span class="line"><span class="keyword">add_library</span>(demo <span class="variable">$&#123;SRC_LIST&#125;</span> <span class="variable">$&#123;SRC_PROTOCOL_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="查找指定的库文件"><a href="#查找指定的库文件" class="headerlink" title="查找指定的库文件"></a>查找指定的库文件</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找到指定的预编译库，并将它的路径存储在变量中。</span></span><br><span class="line"><span class="comment"># 默认的搜索路径为 cmake 包含的系统库，因此如果是 NDK 的公共库只需要指定库的 name 即可。</span></span><br><span class="line"><span class="keyword">find_library</span>(VAR name path) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似的命令还有 find_file()、find_path()、find_program()、find_package()。</span></span><br><span class="line"><span class="keyword">find_library</span>( <span class="comment"># Sets the name of the path variable.</span></span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              <span class="comment"># Specifies the name of the NDK library that</span></span><br><span class="line">              <span class="comment"># you want CMake to locate.</span></span><br><span class="line">              log )</span><br></pre></td></tr></table></figure>

<h2 id="设置包含的目录"><a href="#设置包含的目录" class="headerlink" title="设置包含的目录"></a>设置包含的目录</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 下还可以通过如下方式设置包含的目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -I$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a subdirectory to the build.（添加一个子目录并构建该子目录。）</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>

<h2 id="设置链接库搜索目录"><a href="#设置链接库搜索目录" class="headerlink" title="设置链接库搜索目录"></a>设置链接库搜索目录</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux 下还可以通过如下方式设置包含的目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -L$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/libs&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="设置-target需要链接的库"><a href="#设置-target需要链接的库" class="headerlink" title="设置 target需要链接的库"></a>设置 <code>target</code>需要链接的库</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 Windows 下，系统会根据链接库目录，搜索xxx.lib 文件，</span></span><br><span class="line"><span class="comment"># Linux 下会搜索 xxx.so 或者 xxx.a 文件，如果都存在会优先链接动态库（so 后缀）。</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>( <span class="comment"># 目标库</span></span><br><span class="line">                       demo</span><br><span class="line"> </span><br><span class="line">                       <span class="comment"># 目标库需要链接的库</span></span><br><span class="line">                       <span class="comment"># log-lib 是上面 find_library 指定的变量名</span></span><br><span class="line">                       <span class="variable">$&#123;log-lib&#125;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、指定链接动态库或静态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo libface.a)  <span class="comment"># 链接libface.a</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo libface.so) <span class="comment"># 链接libface.so</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、指定全路径</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libs/libface.a)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libs/libface.so)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、指定链接多个库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/libs/libface.a</span><br><span class="line">    boost_system.a</span><br><span class="line">    boost_thread</span><br><span class="line">    pthread</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="打印信息"><a href="#打印信息" class="headerlink" title="打印信息"></a>打印信息</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;build with debug mode&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;this is warnning message&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># FATAL_ERROR 会导致编译失败</span></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;this build has many error&quot;</span>) </span><br></pre></td></tr></table></figure>

<h2 id="包含其它cmake文件"><a href="#包含其它cmake文件" class="headerlink" title="包含其它cmake文件"></a>包含其它<code>cmake</code>文件</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(./common.cmake) <span class="comment"># 指定包含文件的全路径</span></span><br><span class="line"><span class="keyword">include</span>(def)            <span class="comment"># 在搜索路径中搜索def.cmake文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置include的搜索路径</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/cmake) </span><br></pre></td></tr></table></figure>

<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 &lt;input&gt; 文件里面的内容全部复制到 &lt;output&gt; 文件中；</span></span><br><span class="line"><span class="comment"># 根据参数规则，替换 @VAR@ 或 $&#123;VAR&#125; 变量；</span></span><br><span class="line"><span class="keyword">configure_file</span>(&lt;input&gt; &lt;output&gt;</span><br><span class="line">               [NO_SOURCE_PERMISSIONS | USE_SOURCE_PERMISSIONS |</span><br><span class="line">                FILE_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]</span><br><span class="line">               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Copies an &lt;input&gt; file to an &lt;output&gt; file and substitutes variable values referenced as @VAR@ or $&#123;VAR&#125; in the input file content. </span></span><br><span class="line"><span class="comment"># Each variable reference will be replaced with the current value of the variable, </span></span><br><span class="line"><span class="comment"># or the empty string if the variable is not defined. Furthermore, input lines of the form</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reading</span></span><br><span class="line"><span class="keyword">file</span>(READ &lt;filename&gt; &lt;out-var&gt; [...])</span><br><span class="line"><span class="keyword">file</span>(STRINGS &lt;filename&gt; &lt;out-var&gt; [...])</span><br><span class="line"><span class="keyword">file</span>(&lt;HASH&gt; &lt;filename&gt; &lt;out-var&gt;)</span><br><span class="line"><span class="keyword">file</span>(TIMESTAMP &lt;filename&gt; &lt;out-var&gt; [...])</span><br><span class="line"><span class="keyword">file</span>(GET_RUNTIME_DEPENDENCIES [...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="keyword">file</span>(&#123;WRITE | APPEND&#125; &lt;filename&gt; &lt;content&gt;...)</span><br><span class="line"><span class="keyword">file</span>(&#123;TOUCH | TOUCH_NOCREATE&#125; [&lt;<span class="keyword">file</span>&gt;...])</span><br><span class="line"><span class="keyword">file</span>(GENERATE OUTPUT &lt;output-<span class="keyword">file</span>&gt; [...])</span><br><span class="line"><span class="keyword">file</span>(CONFIGURE OUTPUT &lt;output-<span class="keyword">file</span>&gt; CONTENT &lt;content&gt; [...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Filesystem</span></span><br><span class="line"><span class="keyword">file</span>(&#123;GLOB | GLOB_RECURSE&#125; &lt;out-var&gt; [...] [&lt;globbing-expr&gt;...])</span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> [&lt;dir&gt;...])</span><br><span class="line"><span class="keyword">file</span>(&#123;<span class="keyword">REMOVE</span> | REMOVE_RECURSE &#125; [&lt;files&gt;...])</span><br><span class="line"><span class="keyword">file</span>(RENAME &lt;oldname&gt; &lt;newname&gt; [...])</span><br><span class="line"><span class="keyword">file</span>(COPY_FILE &lt;oldname&gt; &lt;newname&gt; [...])</span><br><span class="line"><span class="keyword">file</span>(&#123;COPY | <span class="keyword">INSTALL</span>&#125; &lt;<span class="keyword">file</span>&gt;... DESTINATION &lt;dir&gt; [...])</span><br><span class="line"><span class="keyword">file</span>(SIZE &lt;filename&gt; &lt;out-var&gt;)</span><br><span class="line"><span class="keyword">file</span>(READ_SYMLINK &lt;linkname&gt; &lt;out-var&gt;)</span><br><span class="line"><span class="keyword">file</span>(CREATE_LINK &lt;original&gt; &lt;linkname&gt; [...])</span><br><span class="line"><span class="keyword">file</span>(CHMOD &lt;files&gt;... &lt;directories&gt;... PERMISSIONS &lt;permissions&gt;... [...])</span><br><span class="line"><span class="keyword">file</span>(CHMOD_RECURSE &lt;files&gt;... &lt;directories&gt;... PERMISSIONS &lt;permissions&gt;... [...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Path Conversion</span></span><br><span class="line"><span class="keyword">file</span>(REAL_PATH &lt;path&gt; &lt;out-var&gt; [BASE_DIRECTORY &lt;dir&gt;] [EXPAND_TILDE])</span><br><span class="line"><span class="keyword">file</span>(RELATIVE_PATH &lt;out-var&gt; &lt;directory&gt; &lt;<span class="keyword">file</span>&gt;)</span><br><span class="line"><span class="keyword">file</span>(&#123;TO_CMAKE_PATH | TO_NATIVE_PATH&#125; &lt;path&gt; &lt;out-var&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transfer</span></span><br><span class="line"><span class="keyword">file</span>(DOWNLOAD &lt;url&gt; [&lt;<span class="keyword">file</span>&gt;] [...])</span><br><span class="line"><span class="keyword">file</span>(UPLOAD &lt;<span class="keyword">file</span>&gt; &lt;url&gt; [...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Locking</span></span><br><span class="line"><span class="keyword">file</span>(LOCK &lt;path&gt; [...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Archiving</span></span><br><span class="line"><span class="keyword">file</span>(ARCHIVE_CREATE OUTPUT &lt;archive&gt; PATHS &lt;paths&gt;... [...])</span><br><span class="line"><span class="keyword">file</span>(ARCHIVE_EXTRACT INPUT &lt;archive&gt; [...])</span><br></pre></td></tr></table></figure>

<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。</span></span><br><span class="line"><span class="comment"># Provide an option that the user can optionally select.</span></span><br><span class="line"><span class="keyword">option</span>(&lt;variable&gt; <span class="string">&quot;&lt;help_text&gt;&quot;</span> [value])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Provides an option for the user to select as ON or OFF. </span></span><br><span class="line"><span class="comment"># If no initial &lt;value&gt; is provided, OFF is used. </span></span><br><span class="line"><span class="comment"># If &lt;variable&gt; is already set as a normal or cache variable, then the command does nothing (see policy CMP0077).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将预处理器定义添加到源文件的编译中。</span></span><br><span class="line"><span class="comment"># 预处理器定义被添加到当前CMakeLists文件的COMPILE_DEFINITIONS目录属性中。</span></span><br><span class="line"><span class="comment"># 它们还被添加到当前CMakeLists文件中每个目标的COMPILE_DEFINITIONS目标属性中。</span></span><br><span class="line"><span class="keyword">add_compile_definitions</span>(&lt;definition&gt; ...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该命令可用于添加任何选项。向COMPILE_OPTIONS目录属性添加选项。当从当前目录及以下目录编译目标时，将使用这些选项。</span></span><br><span class="line"><span class="comment"># 但是，为了添加预处理器定义和包含目录，建议使用更具体的命令add_compile_definitions()和include_directories()</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(&lt;<span class="keyword">option</span>&gt; ...)</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1-单独设置某个项目的编译参数等(例如有个动态库为 LIB1)</span></span><br><span class="line">add_libraries(LIB1 SHARED <span class="variable">$&#123;src_lib1&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> LIB1 PROPERTY POSITION_INDEPENDENT_CODE <span class="keyword">ON</span>)         <span class="comment"># 代表-fPIC</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> LIB1 PROPERTY COMPILE_FLAGS <span class="string">&quot; -DMACRO1 -DMACRO2&quot;</span>)   <span class="comment"># 定义一些宏</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2-设置符号可视性(export)</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="variable">$&#123;obj&#125;</span> PROPERTIES C_VISIBILITY_PRESET hidden)</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="variable">$&#123;obj&#125;</span> PROPERTIES CXX_VISIBILITY_PRESET hidden)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_VISIBILITY_PRESET hidden)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_VISIBILITY_PRESET hidden)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS$ <span class="string">&quot;$&#123;CMAKE_C_FLAGS&#125; -fvisibility = hidden&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS$ <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -fvisibility = hidden&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3-同时编静态库(.a)和动态库(.so)</span></span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"><span class="keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4- 使用外部库</span></span><br><span class="line"><span class="comment"># 4-1、find_package(&lt;Name&gt;)命令首先会在模块路径中寻找 Find&lt;name&gt;.cmake，这是查找库的一个典型方式。</span></span><br><span class="line"><span class="comment"># 具体查找路径依次为CMake： 变量$&#123;CMAKE_MODULE_PATH&#125;中的所有目录。</span></span><br><span class="line"><span class="comment"># 如果没有，然后再查看它自己的模块目录 /share/cmake-x.y/Modules/ （$CMAKE_ROOT的具体值可以通过CMake中message命令输出）。这称为模块模式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4-2、如果没找到这样的文件，find_package()会在~/.cmake/packages/或/usr/local/share/中的各个包目录中查找，</span></span><br><span class="line"><span class="comment"># 寻找&lt;库名字的大写&gt;Config.cmake 或者 &lt;库名字的小写&gt;-config.cmake </span></span><br><span class="line"><span class="comment"># (比如库Opencv，它会查找/usr/local/share/OpenCV中的OpenCVConfig.cmake或opencv-config.cmake)。这称为配置模式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不管使用哪一种模式，只要找到*.cmake，*.cmake里面都会定义下面这些变量：</span></span><br><span class="line">&lt;NAME&gt;_FOUND</span><br><span class="line">&lt;NAME&gt;_INCLUDE_DIRS <span class="keyword">or</span> &lt;NAME&gt;_INCLUDES</span><br><span class="line">&lt;NAME&gt;_LIBRARIES <span class="keyword">or</span> &lt;NAME&gt;_LIBRARIES <span class="keyword">or</span> &lt;NAME&gt;_LIBS</span><br><span class="line">&lt;NAME&gt;_DEFINITIONS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意大部分包的这些变量中的包名是全大写的，如 LIBFOO_FOUND ，有些包则使用包的实际大小写，如 LibFoo_FOUND</span></span><br><span class="line"><span class="comment"># 如果找到这个包，则可以通过在工程的顶层目录中的CMakeLists.txt 文件添加 include_directories(&lt;NAME&gt;_INCLUDE_DIRS) 来包含库的头文件，</span></span><br><span class="line"><span class="comment"># 添加target_link_libraries(源文件 &lt;NAME&gt;_LIBRARIES)命令将源文件与库文件链接起来。</span></span><br></pre></td></tr></table></figure>

<h1 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h1><h2 id="单个源文件"><a href="#单个源文件" class="headerlink" title="单个源文件"></a>单个源文件</h2><p>假设现在我们的项目中只有一个源文件 <a href="http://main.cc/">main.cc</a> ，该程序的用途是计算一个数的指数幂。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * power - Calculate the power of number.</span></span><br><span class="line"><span class="comment"> * @param base: Base value.</span></span><br><span class="line"><span class="comment"> * @param exponent: Exponent value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return base raised to the power exponent.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = base;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; exponent; ++i)&#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s base exponent \n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> base = atof(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> exponent = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="type">double</span> result = power(base, exponent);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%g ^ %d is %g\n&quot;</span>, base, exponent, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编写 CMakeLists.txt</strong></p>
<p>首先编写 CMakeLists.txt 文件，并保存在与 <strong><a href="http://main.cc/">main.cc</a></strong> 源文件同个目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo1)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo main.cc)</span><br></pre></td></tr></table></figure>

<p>CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 <code>#</code> 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。</p>
<p>对于上面的 CMakeLists.txt 文件，依次出现了几个命令：</p>
<ul>
<li><code>cmake_minimum_required</code>：指定运行此配置文件所需的 CMake 的最低版本；</li>
<li><code>project</code>：参数值是 <code>Demo1</code>，该命令表示项目的名称是 <code>Demo1</code> 。</li>
<li><code>add_executable</code>： 将名为 <strong><a href="http://main.cc/">main.cc</a></strong> 的源文件编译成一个名称为 Demo 的可执行文件。</li>
</ul>
<p><strong>编译项目</strong></p>
<p>之后，在当前目录执行 <code>cmake .</code> ，得到 Makefile 后再使用 <code>make</code> 命令编译得到 Demo1 可执行文件。</p>
<h2 id="多个源文件"><a href="#多个源文件" class="headerlink" title="多个源文件"></a>多个源文件</h2><p>现在假如把 power 函数单独写进一个名为 MathFunctions.c 的源文件里，使得这个工程变成如下的形式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">/Demo2</span><br><span class="line">    |</span><br><span class="line">    +--- main.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.cc</span><br><span class="line">    |</span><br><span class="line">    +--- MathFunctions.h</span><br></pre></td></tr></table></figure>

<p>这个时候，CMakeLists.txt 可以改成如下的形式:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc MathFunctions.cc)</span><br></pre></td></tr></table></figure>

<p>唯一的改动只是在 add_executable 命令中增加了一个 MathFunctions.cc 源文件。这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 aux_source_directory 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure>

<p>因此，可以修改 CMakeLists.txt 如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>这样，CMake 会将当前目录所有源文件的文件名赋值给变量 DIR_SRCS ，再指示变量 DIR_SRCS 中的源文件需要编译成一个名称为 Demo 的可执行文件。</p>
<h2 id="多个目录，多个源文件"><a href="#多个目录，多个源文件" class="headerlink" title="多个目录，多个源文件"></a>多个目录，多个源文件</h2><p>现在进一步将 MathFunctions.h 和 <a href="http://mathfunctions.cc/">MathFunctions.cc</a> 文件移动到 math 目录下。</p>
<p>对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。</p>
<p>根目录中的 CMakeLists.txt ：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 math 子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">math</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定生成目标 </span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo MathFunctions)</span><br></pre></td></tr></table></figure>

<p>该文件添加了下面的内容: 第3行，使用命令 <code>add_subdirectory</code> 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理 。第6行，使用命令 <code>target_link_libraries</code> 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。</p>
<p>子目录中的 CMakeLists.txt：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找当前目录下的所有源文件</span></span><br><span class="line"><span class="comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_LIB_SRCS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成链接库</span></span><br><span class="line"><span class="keyword">add_library</span> (MathFunctions <span class="variable">$&#123;DIR_LIB_SRCS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>在该文件中使用命令 add_library 将 src 目录中的源文件编译为静态链接库。</p>
]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA获取GPU信息</title>
    <url>/posts/fecbd3bb.html</url>
    <content><![CDATA[<h1 id="获取GPU信息"><a href="#获取GPU信息" class="headerlink" title="获取GPU信息"></a>获取GPU信息</h1><p>main.cu</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_ERROR(err) (handle_error(err, __FILE__, __LINE__))</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernelFunc</span><span class="params">(<span class="type">float</span> *a)</span> </span>&#123; a[threadIdx.x] = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_error</span><span class="params">(cudaError_t err, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err != cudaSuccess) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s in %s at line %d\n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(err), file, line);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指定GPU</span></span><br><span class="line">  <span class="built_in">cudaSetDevice</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">float</span> *aGPU;</span><br><span class="line">  <span class="comment">// malloc GPU内存</span></span><br><span class="line">  <span class="built_in">cudaMalloc</span>((<span class="type">void</span> **)&amp;aGPU, <span class="number">16</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">  <span class="type">float</span> a[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="comment">// 从内存中拷贝数据到GPU</span></span><br><span class="line">  <span class="built_in">cudaMemcpy</span>(aGPU, a, <span class="number">16</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice);</span><br><span class="line">  <span class="comment">// 16个线程执行kernel func</span></span><br><span class="line">  kernelFunc&lt;&lt;&lt;<span class="number">1</span>, <span class="number">16</span>&gt;&gt;&gt;(aGPU);</span><br><span class="line">  <span class="comment">// 从GPU拷贝回内存</span></span><br><span class="line">  <span class="built_in">cudaMemcpy</span>(a, aGPU, <span class="number">16</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyDeviceToHost);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f &quot;</span>, a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 释放资源</span></span><br><span class="line">  <span class="built_in">cudaFree</span>(aGPU);</span><br><span class="line">  <span class="built_in">cudaDeviceReset</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> gpuCount = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">cudaGetDeviceCount</span>(&amp;gpuCount);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;gpuCount:%d\n&quot;</span>, gpuCount);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (gpuCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no device!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 指定最后一块GPU</span></span><br><span class="line">  <span class="built_in">cudaSetDevice</span>(gpuCount - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  cudaDeviceProp prop;</span><br><span class="line">  <span class="built_in">cudaGetDeviceProperties</span>(&amp;prop, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;maxThreadsPerBlock: %d\n&quot;</span>, prop.maxThreadsPerBlock);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;maxThreadsDim: %d %d %d\n&quot;</span>, prop.maxThreadsDim[<span class="number">0</span>],</span><br><span class="line">         prop.maxThreadsDim[<span class="number">1</span>], prop.maxThreadsDim[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;maxGridSize: %d %d %d\n&quot;</span>, prop.maxGridSize[<span class="number">0</span>], prop.maxGridSize[<span class="number">1</span>],</span><br><span class="line">         prop.maxGridSize[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;totalConstMem: %ld\n&quot;</span>, prop.totalConstMem);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;clockRate: %d\n&quot;</span>, prop.clockRate);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;integrated: %d\n&quot;</span>, prop.integrated);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> deviceId = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">cudaChooseDevice</span>(&amp;deviceId, &amp;prop);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;deviceId: %d\n&quot;</span>, deviceId);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> deviceList[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="built_in">HANDLE_ERROR</span>(<span class="built_in">cudaSetValidDevices</span>(deviceList, <span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 </span><br><span class="line">gpuCount:1</span><br><span class="line">maxThreadsPerBlock: 1024</span><br><span class="line">maxThreadsDim: 1024 1024 64</span><br><span class="line">maxGridSize: 2147483647 65535 65535</span><br><span class="line">totalConstMem: 65536</span><br><span class="line">clockRate: 1241500</span><br><span class="line">integrated: 0</span><br><span class="line">deviceId: 0</span><br><span class="line">invalid argument in main.cu at line 62</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cuda</category>
      </categories>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA之GPU运算简单步骤</title>
    <url>/posts/d39f83bf.html</url>
    <content><![CDATA[<h1 id="GPU运算简单步骤"><a href="#GPU运算简单步骤" class="headerlink" title="GPU运算简单步骤"></a>GPU运算简单步骤</h1><p>main.cu</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">vector_add</span><span class="params">(<span class="type">float</span> *vec1, <span class="type">float</span> *vec2, <span class="type">float</span> *vec_out, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> tid = threadIdx.x;</span><br><span class="line">  <span class="keyword">if</span>(tid &lt; length) &#123;</span><br><span class="line">    vec_out[tid] = vec1[tid] + vec2[tid];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> length = <span class="number">16</span>;                                      <span class="comment">// 数组长度为16</span></span><br><span class="line">  <span class="type">float</span> a[length], b[length], c[length];                      <span class="comment">// host中的数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;                          <span class="comment">// 初始赋值</span></span><br><span class="line">    a[i] = b[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">float</span>* a_device, *b_device, *c_device;                      <span class="comment">// device中的数组</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;a_device, length * <span class="built_in">sizeof</span>(<span class="type">float</span>));      <span class="comment">// 分配内存</span></span><br><span class="line">  <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;b_device, length * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">  <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;c_device, length * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaMemcpy</span>(a_device, a, length * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice);    <span class="comment">// 将host数组的值拷贝给device数组</span></span><br><span class="line">  <span class="built_in">cudaMemcpy</span>(b_device, b, length * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一：参数配置</span></span><br><span class="line">  <span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span>, <span class="title">block</span><span class="params">(length, <span class="number">1</span>, <span class="number">1</span>)</span></span>;                    <span class="comment">// 设置参数</span></span><br><span class="line">  vector_add&lt;&lt;&lt;grid,block&gt;&gt;&gt;(a_device, b_device, c_device, length);           <span class="comment">// 启动kernel</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaMemcpy</span>(c, c_device, length * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyDeviceToHost);    <span class="comment">// 将结果拷贝到host</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;                          <span class="comment">// 打印出来方便观察</span></span><br><span class="line">    cout &lt;&lt; c[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cuda</category>
      </categories>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA之基本运算</title>
    <url>/posts/38c8e9cc.html</url>
    <content><![CDATA[<h1 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h1><p>main.cu</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *c, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = threadIdx.x;</span><br><span class="line">  <span class="keyword">if</span>(i &lt; num) &#123;</span><br><span class="line">    c[i] = a[i] + b[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> a[num], b[num], c[num];</span><br><span class="line">  <span class="type">int</span> *a_gpu, *b_gpu, *c_gpu;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i ++) &#123;</span><br><span class="line">    a[i] = i;</span><br><span class="line">    b[i] = i + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaMalloc</span>((<span class="type">void</span> **) &amp;a_gpu, num * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="built_in">cudaMalloc</span>((<span class="type">void</span> **) &amp;b_gpu, num * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">  <span class="built_in">cudaMalloc</span>((<span class="type">void</span> **) &amp;c_gpu, num * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy data</span></span><br><span class="line">  <span class="built_in">cudaMemcpy</span>(a_gpu, a, num * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line">  <span class="built_in">cudaMemcpy</span>(b_gpu, b, num * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do</span></span><br><span class="line">  add&lt;&lt;&lt;<span class="number">1</span>, num&gt;&gt;&gt;(a_gpu, b_gpu, c_gpu, num);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get data</span></span><br><span class="line">  <span class="built_in">cudaMemcpy</span>(c, c_gpu, num * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// visualization</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>, a[i], b[i], c[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cudaFree</span>(a_gpu);</span><br><span class="line">  <span class="built_in">cudaFree</span>(b_gpu);</span><br><span class="line">  <span class="built_in">cudaFree</span>(c_gpu);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 + 0 = 0</span><br><span class="line">1 + 2 = 3</span><br><span class="line">2 + 4 = 6</span><br><span class="line">3 + 6 = 9</span><br><span class="line">4 + 8 = 12</span><br><span class="line">5 + 10 = 15</span><br><span class="line">6 + 12 = 18</span><br><span class="line">7 + 14 = 21</span><br><span class="line">8 + 16 = 24</span><br><span class="line">9 + 18 = 27</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cuda</category>
      </categories>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA之数组相加</title>
    <url>/posts/4801d781.html</url>
    <content><![CDATA[<h1 id="数组相加"><a href="#数组相加" class="headerlink" title="数组相加"></a>数组相加</h1><p>main.cu</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">sum</span><span class="params">(<span class="type">float</span> *a, <span class="type">float</span> *b)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t_id = threadIdx.x;</span><br><span class="line"></span><br><span class="line">  __shared__ <span class="type">float</span> sData[<span class="number">16</span>];</span><br><span class="line">  sData[t_id] = a[t_id];</span><br><span class="line">  __syncthreads();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">8</span>; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(t_id &lt; i) &#123;</span><br><span class="line">      sData[t_id] = sData[t_id] + sData[t_id + i];</span><br><span class="line">    &#125;</span><br><span class="line">    __syncthreads();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(t_id == <span class="number">0</span>) &#123;</span><br><span class="line">    b[<span class="number">0</span>] = sData[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">float</span> a[<span class="number">16</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i ++) &#123;</span><br><span class="line">    a[i] = i * (i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">float</span> *aGpu;</span><br><span class="line">  <span class="built_in">cudaMalloc</span>((<span class="type">void</span> **) &amp;aGpu, <span class="number">16</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line">  <span class="built_in">cudaMemcpy</span>(aGpu, a, <span class="number">16</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> *bGpu;</span><br><span class="line">  <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**) &amp;bGpu, <span class="number">1</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">  sum&lt;&lt;&lt;<span class="number">1</span>, <span class="number">16</span>&gt;&gt;&gt;(aGpu, bGpu);</span><br><span class="line">  <span class="type">float</span> b[<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">cudaMemcpy</span>(b, bGpu, <span class="number">1</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), cudaMemcpyDeviceToHost);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;b: %f\n&quot;</span>,b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b: 1360.000000</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cuda</category>
      </categories>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA之卷积</title>
    <url>/posts/1ca8e928.html</url>
    <content><![CDATA[<h1 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h1><p>main.cu</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_ERROR(err) (handleError(err, __FILE__, __LINE__))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handleError</span><span class="params">(cudaError_t err, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err != cudaSuccess) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s in %s at line %d \n&quot;</span>, <span class="built_in">cudaGetErrorString</span>(err), file, line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cudaDeviceProp prop;</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">HANDLE_ERROR</span>(<span class="built_in">cudaGetDeviceCount</span>(&amp;count));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;gpu num: %d\n&quot;</span>, count);</span><br><span class="line">  <span class="built_in">HANDLE_ERROR</span>(<span class="built_in">cudaGetDeviceProperties</span>(&amp;prop, <span class="number">0</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;max thread num: %d\n&quot;</span>, prop.maxThreadsPerBlock);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;max grid dimensions: %d %d %d \n&quot;</span>, prop.maxGridSize[<span class="number">0</span>],</span><br><span class="line">         prop.maxGridSize[<span class="number">1</span>], prop.maxGridSize[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">return</span> prop.maxThreadsPerBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">conv</span><span class="params">(<span class="type">float</span> *img, <span class="type">float</span> *kernel, <span class="type">float</span> *result, <span class="type">int</span> width,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> height, <span class="type">int</span> kernelSize)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> t_i = threadIdx.x;</span><br><span class="line">  <span class="type">int</span> b_i = blockIdx.x;</span><br><span class="line">  <span class="type">int</span> id = (b_i * blockDim.x + t_i);</span><br><span class="line">  <span class="keyword">if</span> (id &gt;= width * height) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> row = id / width;</span><br><span class="line">  <span class="type">int</span> col = id % width;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kernelSize; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; kernelSize; j++) &#123;</span><br><span class="line">      <span class="type">float</span> imgValue = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> curRow = row - kernelSize / <span class="number">2</span> + i;</span><br><span class="line">      <span class="type">int</span> curCol = col - kernelSize / <span class="number">2</span> + j;</span><br><span class="line">      <span class="keyword">if</span> (curRow &lt; <span class="number">0</span> || curCol &lt; <span class="number">0</span> || curRow &gt;= height || curCol &gt;= width) &#123;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        imgValue = img[curRow * width + curCol];</span><br><span class="line">      &#125;</span><br><span class="line">      result[id] += kernel[i * kernelSize + j] * imgValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> width = <span class="number">800</span>;</span><br><span class="line">  <span class="type">int</span> height = <span class="number">600</span>;</span><br><span class="line">  <span class="type">float</span> *img = <span class="keyword">new</span> <span class="type">float</span>[width * height];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; height; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; width; col++) &#123;</span><br><span class="line">      img[col + row * width] = (col + row) % <span class="number">256</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> kernelSize = <span class="number">3</span>;</span><br><span class="line">  <span class="type">float</span> *kernel = <span class="keyword">new</span> <span class="type">float</span>[kernelSize * kernelSize];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kernelSize * kernelSize; i++) &#123;</span><br><span class="line">    kernel[i] = i % kernelSize - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> *imgGpu;</span><br><span class="line">  <span class="type">float</span> *kernelGpu;</span><br><span class="line">  <span class="type">float</span> *resultGpu;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">HANDLE_ERROR</span>(<span class="built_in">cudaMalloc</span>((<span class="type">void</span> **)&amp;imgGpu, width * height * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">  <span class="built_in">HANDLE_ERROR</span>(</span><br><span class="line">      <span class="built_in">cudaMalloc</span>((<span class="type">void</span> **)&amp;kernelGpu, kernelSize * kernelSize * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line">  <span class="built_in">HANDLE_ERROR</span>(<span class="built_in">cudaMalloc</span>((<span class="type">void</span> **)&amp;resultGpu, width * height * <span class="built_in">sizeof</span>(<span class="type">float</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">HANDLE_ERROR</span>(<span class="built_in">cudaMemcpy</span>(imgGpu, img, width * height * <span class="built_in">sizeof</span>(<span class="type">float</span>),</span><br><span class="line">                          cudaMemcpyHostToDevice));</span><br><span class="line">  <span class="built_in">HANDLE_ERROR</span>(<span class="built_in">cudaMemcpy</span>(kernelGpu, kernel,</span><br><span class="line">                          kernelSize * kernelSize * <span class="built_in">sizeof</span>(<span class="type">float</span>),</span><br><span class="line">                          cudaMemcpyHostToDevice));</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> threadNum = <span class="built_in">getThreadNum</span>();</span><br><span class="line">  <span class="type">int</span> blockNum = (width * height - <span class="number">0.5</span>) / threadNum + <span class="number">1</span>;</span><br><span class="line">  conv&lt;&lt;&lt;blockNum, threadNum&gt;&gt;&gt;(imgGpu, kernelGpu, resultGpu, width, height,</span><br><span class="line">                                kernelSize);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> *result = <span class="keyword">new</span> <span class="type">float</span>[width * height];</span><br><span class="line">  <span class="built_in">HANDLE_ERROR</span>(<span class="built_in">cudaMemcpy</span>(result, resultGpu, width * height * <span class="built_in">sizeof</span>(<span class="type">float</span>),</span><br><span class="line">                          cudaMemcpyDeviceToHost));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// visualization</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;img:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">10</span>; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">10</span>; col++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%2.0f &quot;</span>, img[col + row * width]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;kernel:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; kernelSize; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; kernelSize; col++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%2.0f &quot;</span>, kernel[col + row * kernelSize]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;result:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">10</span>; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; <span class="number">10</span>; col++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%2.0f &quot;</span>, result[col + row * width]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpu num: 1</span><br><span class="line">max thread num: 1024</span><br><span class="line">max grid dimensions: 2147483647 65535 65535 </span><br><span class="line">img:</span><br><span class="line"> 0  1  2  3  4  5  6  7  8  9 </span><br><span class="line"> 1  2  3  4  5  6  7  8  9 10 </span><br><span class="line"> 2  3  4  5  6  7  8  9 10 11 </span><br><span class="line"> 3  4  5  6  7  8  9 10 11 12 </span><br><span class="line"> 4  5  6  7  8  9 10 11 12 13 </span><br><span class="line"> 5  6  7  8  9 10 11 12 13 14 </span><br><span class="line"> 6  7  8  9 10 11 12 13 14 15 </span><br><span class="line"> 7  8  9 10 11 12 13 14 15 16 </span><br><span class="line"> 8  9 10 11 12 13 14 15 16 17 </span><br><span class="line"> 9 10 11 12 13 14 15 16 17 18 </span><br><span class="line">kernel:</span><br><span class="line">-1  0  1 </span><br><span class="line">-1  0  1 </span><br><span class="line">-1  0  1 </span><br><span class="line">result:</span><br><span class="line"> 3  4  4  4  4  4  4  4  4  4 </span><br><span class="line"> 6  6  6  6  6  6  6  6  6  6 </span><br><span class="line"> 9  6  6  6  6  6  6  6  6  6 </span><br><span class="line">12  6  6  6  6  6  6  6  6  6 </span><br><span class="line">15  6  6  6  6  6  6  6  6  6 </span><br><span class="line">18  6  6  6  6  6  6  6  6  6 </span><br><span class="line">21  6  6  6  6  6  6  6  6  6 </span><br><span class="line">24  6  6  6  6  6  6  6  6  6 </span><br><span class="line">27  6  6  6  6  6  6  6  6  6 </span><br><span class="line">30  6  6  6  6  6  6  6  6  6</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cuda</category>
      </categories>
      <tags>
        <tag>cuda</tag>
      </tags>
  </entry>
  <entry>
    <title>1.算法基础</title>
    <url>/posts/2f375fe4.html</url>
    <content><![CDATA[<h1 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h1><ol>
<li>有穷性:算法是由若干条指令组成的有穷序列,总是在执行若干次后结束,不可能<br>永不停止。</li>
<li>确定性:每条语句有确定的含义,无歧义。</li>
<li>可行性:算法在当前环境条件下可以通过有限次运算实现。</li>
<li>输入输出:有零个或多个输入,一个或多个输出。</li>
</ol>
<h1 id="衡量算法"><a href="#衡量算法" class="headerlink" title="衡量算法"></a>衡量算法</h1><ul>
<li><p>时间复杂度: 算法运行需要的时间,一般将算法的执行次数作为时间复杂度的度量标准。</p>
</li>
<li><p>空间复杂度: 算法占用空间的大小。一般将算法的辅助空间作为衡量空间复杂度的标准。</p>
</li>
</ul>
<p>算法占用的存储空间包括:</p>
<ol>
<li>输入&#x2F;输出数据;</li>
<li>算法本身;</li>
<li>额外需要的辅助空间</li>
</ol>
<h1 id="常见的算法复杂度"><a href="#常见的算法复杂度" class="headerlink" title="常见的算法复杂度"></a>常见的算法复杂度</h1><ol>
<li>常数阶。常数阶算法运行的次数是一个常数，如 5、20、100。</li>
<li>多项式阶。很多算法时间复杂度是多项式，通常用 О(n)、О(n )、 О(n )等表示</li>
<li>指数阶。指数阶时间复杂度运行效率极差。</li>
<li>对数阶。对数阶时间复杂度运行效率较高,常见的有 О(logn)、О(nlogn)等</li>
</ol>
<p>$$О(1)&lt; О(logn)&lt; О(n)&lt; О(nlogn) &lt; О(n2)&lt; О(n3)&lt; О(2n) &lt; О(n!)&lt; О(nn)$$</p>
<h1 id="兔子数列"><a href="#兔子数列" class="headerlink" title="兔子数列"></a>兔子数列</h1><blockquote>
<p>假设第 1 个月有 1 对刚诞生的兔子,第 2 个月进入成熟期,第 3 个月开始生育兔子,而<br>1 对成熟的兔子每月会生 1 对兔子,兔子永不死去……那么,由 1 对初生兔子开始,12 个月<br>后会有多少对兔子呢?</p>
<p>兔子数列即斐波那契数列</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fib1</span>(n<span class="number">-1</span>) + <span class="built_in">fib1</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度较高</p>
<h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>[n+<span class="number">1</span>];</span><br><span class="line">  a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">    a[i] = a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>指数阶时间复杂度降到多项式阶复杂度，空间复杂度降到$ O(n) $</p>
<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib3</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> s1 = <span class="number">1</span>, s2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">    s2 = s1 + s2;</span><br><span class="line">    s1 = s2 - s1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为$O(n)$，空间复杂度降到$O(1)$</p>
<h1 id="马克思手稿中的数学题"><a href="#马克思手稿中的数学题" class="headerlink" title="马克思手稿中的数学题"></a>马克思手稿中的数学题</h1><blockquote>
<p>马克思手稿中有一道趣味数学问题:有 30 个人,其中有男人、女人和小孩,这些人在<br>一家饭馆吃饭花了 50 先令;每个男人花 3 先令,每个女人花 2 先令,每个小孩花 1 先令;<br>问男人、女人和小孩各有几人?</p>
</blockquote>
<p>由题可得以下方程：</p>
<p>$$ x+y+z&#x3D;30 $$</p>
<p>$$ 3x+2y+x&#x3D;50 $$</p>
<p>两式相减得：</p>
<p>$$ 2x+y&#x3D;20 $$</p>
<p>x的取值范围是1~9，由此可设计出算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y, z, count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(x = <span class="number">1</span>; x &lt;= <span class="number">9</span>; x ++) &#123;</span><br><span class="line">    y = <span class="number">20</span> - <span class="number">2</span>*x;</span><br><span class="line">    z = <span class="number">30</span> - x - y;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">3</span>*x+<span class="number">2</span>*y+z == <span class="number">50</span>) &#123;</span><br><span class="line">      cout &lt;&lt; ++count &lt;&lt; <span class="string">&quot;: x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; z=&quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为$ O(1) $，空间复杂度也为$ O(1) $。</p>
<h1 id="爱因斯坦的阶梯"><a href="#爱因斯坦的阶梯" class="headerlink" title="爱因斯坦的阶梯"></a>爱因斯坦的阶梯</h1><blockquote>
<p>爱因斯坦家里有一条长阶梯,若每步跨 2 阶,则最后剩 1 阶;若每步跨 3 阶,则最后剩<br>2 阶;若每步跨 5 阶,则最后剩 4 阶;若每步跨 6 阶,则最后剩 5 阶。只有每次跨 7 阶,最<br>后才正好 1 阶不剩。请问这条阶梯共有多少阶?</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n=<span class="number">1</span>; <span class="comment">//n 为所设的阶梯数</span></span><br><span class="line">  <span class="keyword">while</span>(!((n%<span class="number">2</span>==<span class="number">1</span>)&amp;&amp;(n%<span class="number">3</span>==<span class="number">2</span>)&amp;&amp;(n%<span class="number">5</span>==<span class="number">4</span>)&amp;&amp;(n%<span class="number">6</span>==<span class="number">5</span>)&amp;&amp;(n%<span class="number">7</span>==<span class="number">0</span>)))</span><br><span class="line">    n++;</span><br><span class="line">  <span class="comment">//判别是否满足一组同余式</span></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;Count the stairs= &quot;</span>&lt;&lt;n&lt;&lt;endl; <span class="comment">//输出阶梯数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法改进：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n=<span class="number">7</span>; <span class="comment">//n 为所设的阶梯数</span></span><br><span class="line">  <span class="keyword">while</span>(!((n%<span class="number">2</span>==<span class="number">1</span>)&amp;&amp;(n%<span class="number">3</span>==<span class="number">2</span>)&amp;&amp;(n%<span class="number">5</span>==<span class="number">4</span>)&amp;&amp;(n%<span class="number">6</span>==<span class="number">5</span>)&amp;&amp;(n%<span class="number">7</span>==<span class="number">0</span>)))</span><br><span class="line">    n=n+<span class="number">7</span>;</span><br><span class="line">  <span class="comment">//判别是否满足一组同余式</span></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;Count the stairs=&quot;</span>&lt;&lt;n&lt;&lt;endl; <span class="comment">//输出阶梯数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哥德巴赫猜想"><a href="#哥德巴赫猜想" class="headerlink" title="哥德巴赫猜想"></a>哥德巴赫猜想</h1><blockquote>
<p>哥德巴赫猜想:任一大于 2 的偶数,都可表示成两个素数之和。<br>验证:2000 以内大于 2 的偶数都能够分解为两个素数之和。</p>
</blockquote>
<p>素数测试的算法可采用试除法,即用 2,3,4,…, n 去除 n,如果能被整除则为合数,不能被整除则为素数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= (<span class="type">int</span>) <span class="built_in">sqrt</span>(n); i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(n%i)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">4</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt; i; j ++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">prime</span>(j) &amp;&amp; <span class="built_in">prime</span>(i-j)) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; i-j &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2.链表</title>
    <url>/posts/afe8c0e1.html</url>
    <content><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>线性表是由n（n≥0）个相同类型的数据元素组成的有限序列，它是最基本、最常用的一种线性结构。顾名思义，线性表就像是一条线，不会分叉。线性表有唯一的开始和结束，除了第一个元素外，每个元素都有唯一的直接前驱，除了最后一个元素外，每个元素都有唯一的直接后继。</p>
<h2 id="前驱和后继"><a href="#前驱和后继" class="headerlink" title="前驱和后继"></a>前驱和后继</h2><p><img src="https://img.ansore.de/2022/05/01/626e3236c44db.png" alt="image-20200809182535992"></p>
<h1 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h1><p>顺序表是顺序存储方式，即逻辑上相邻的数据在计算机内的存储位置也是相邻的。顺序存储方式，元素存储是连续的，中间不允许有空，可以快速定位第几个元素，所以插入、删除时需要移动大量元素。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e32394aec6.png" alt="image-20200809182618326"></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是线性表的链式存储方式，逻辑上相邻的数据在计算机内的存储位置不一定相邻</p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p><img src="https://img.ansore.de/2022/05/01/626e3240955d1.png" alt="image-20200809182952179"></p>
<p><img src="https://img.ansore.de/2022/05/01/626e32450f469.png" alt="image-20200809183002675"></p>
<h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><p><img src="https://img.ansore.de/2022/05/01/626e324731d78.png" alt="image-20200810154434529"></p>
<h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><p><img src="https://img.ansore.de/2022/05/01/626e3249f1c3e.png" alt="image-20200810154453060"></p>
<h4 id="中间添加"><a href="#中间添加" class="headerlink" title="中间添加"></a>中间添加</h4><p><img src="https://img.ansore.de/2022/05/01/626e324f5d960.png" alt="image-20200810155112050"></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p><img src="https://img.ansore.de/2022/05/01/626e32509429b.png" alt="image-20200810155135267"></p>
<h3 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkList</span> &#123;</span></span><br><span class="line">  <span class="comment">// 保存数据</span></span><br><span class="line">  <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">  <span class="comment">// 保存数组长度</span></span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">&#125; LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(LinkList *L)</span> &#123;</span><br><span class="line">  <span class="comment">/* printf(&quot;size: %d &quot;, L-&gt;size); */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L-&gt;size; i ++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, L-&gt;data[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插 移动数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertLinkListInHead</span><span class="params">(LinkList *L, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  <span class="comment">// 所有数往后移动一位</span></span><br><span class="line">  <span class="keyword">if</span>(L-&gt;size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = L-&gt;size; i &gt; <span class="number">0</span>; i --) &#123;</span><br><span class="line">      L-&gt;data[i] = L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第一位重新赋值</span></span><br><span class="line">  L-&gt;data[<span class="number">0</span>] = val;</span><br><span class="line">  L-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertLinkListInEnd</span><span class="params">(LinkList *L, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  L-&gt;data[L-&gt;size] = val;</span><br><span class="line">  L-&gt;size ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第i个位置插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertLinkListInI</span><span class="params">(LinkList *L, <span class="type">int</span> i, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  <span class="comment">// 所有数往后移动一位</span></span><br><span class="line">  <span class="keyword">if</span>(i &lt;= <span class="number">0</span> || i &gt; L-&gt;size) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超出范围\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = L-&gt;size; j &gt; i<span class="number">-1</span>; j --) &#123;</span><br><span class="line">    L-&gt;data[j] = L-&gt;data[j<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 第i个位置重新赋值</span></span><br><span class="line">  L-&gt;data[i<span class="number">-1</span>] = val;</span><br><span class="line">  L-&gt;size ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteListListInI</span><span class="params">(LinkList *L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="comment">// 直接进行覆盖</span></span><br><span class="line">  <span class="keyword">if</span>(i &lt;= <span class="number">0</span> || L-&gt;size == <span class="number">0</span> || i &gt; L-&gt;size) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超出范围\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除操作</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = i<span class="number">-1</span>; j &lt; L-&gt;size<span class="number">-1</span>; j ++) &#123;</span><br><span class="line">    L-&gt;data[j] = L-&gt;data[j+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  L-&gt;size --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  LinkList <span class="built_in">list</span>;</span><br><span class="line">  <span class="built_in">list</span>.size = <span class="number">0</span>;</span><br><span class="line">  insertLinkListInHead(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">  insertLinkListInHead(&amp;<span class="built_in">list</span>, <span class="number">2</span>);</span><br><span class="line">  insertLinkListInHead(&amp;<span class="built_in">list</span>, <span class="number">3</span>);</span><br><span class="line">  insertLinkListInHead(&amp;<span class="built_in">list</span>, <span class="number">4</span>);</span><br><span class="line">  printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">  insertLinkListInEnd(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">  insertLinkListInEnd(&amp;<span class="built_in">list</span>, <span class="number">2</span>);</span><br><span class="line">  insertLinkListInEnd(&amp;<span class="built_in">list</span>, <span class="number">3</span>);</span><br><span class="line">  insertLinkListInEnd(&amp;<span class="built_in">list</span>, <span class="number">4</span>);</span><br><span class="line">  printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">  insertLinkListInI(&amp;<span class="built_in">list</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">  insertLinkListInI(&amp;<span class="built_in">list</span>, <span class="number">3</span>, <span class="number">13</span>);</span><br><span class="line">  printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">  deleteListListInI(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">  deleteListListInI(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">  deleteListListInI(&amp;<span class="built_in">list</span>, <span class="number">5</span>);</span><br><span class="line">  printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单链表实现"><a href="#单链表实现" class="headerlink" title="单链表实现"></a>单链表实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList <span class="title function_">initialList</span><span class="params">()</span> &#123;</span><br><span class="line">  LinkList L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">  <span class="keyword">if</span>(!L) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头部插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertListInHead</span><span class="params">(LinkList L, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  LinkList elem = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">  elem-&gt;val = val;</span><br><span class="line">  elem-&gt;next = L-&gt;next;</span><br><span class="line">  L-&gt;next = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾部插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertListInEnd</span><span class="params">(LinkList L, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  LinkList p = L;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  LinkList elem = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">  elem-&gt;val = val;</span><br><span class="line">  p-&gt;next = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在i处增加</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertListInI</span><span class="params">(LinkList L, <span class="type">int</span> i, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  LinkList p = L;</span><br><span class="line">  <span class="keyword">while</span>(p &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    j ++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!p || j &gt; i<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超出范围\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LinkList elem = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">  elem-&gt;val = val;</span><br><span class="line">  elem-&gt;next = p-&gt;next;</span><br><span class="line">  p-&gt;next = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第i个</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteListInI</span><span class="params">(LinkList L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  LinkList p = L;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(p &amp;&amp; j &lt; i<span class="number">-1</span>) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    j ++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// p-&gt;next 为要删除的</span></span><br><span class="line">  <span class="keyword">if</span>(!p-&gt;next || j &gt; i<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;超出范围\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  LinkList q = p-&gt;next;</span><br><span class="line">  p-&gt;next = q-&gt;next;</span><br><span class="line">  <span class="built_in">free</span>(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line">  <span class="comment">// 头节点没有数据</span></span><br><span class="line">  LinkList p = L-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(p) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \t&quot;</span>, p-&gt;val);</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  LinkList L = initialList();</span><br><span class="line">  insertListInHead(L, <span class="number">1</span>);</span><br><span class="line">  insertListInHead(L, <span class="number">2</span>);</span><br><span class="line">  insertListInHead(L, <span class="number">3</span>);</span><br><span class="line">  insertListInHead(L, <span class="number">4</span>);</span><br><span class="line">  printList(L);</span><br><span class="line">  insertListInEnd(L, <span class="number">1</span>);</span><br><span class="line">  insertListInEnd(L, <span class="number">2</span>);</span><br><span class="line">  insertListInEnd(L, <span class="number">3</span>);</span><br><span class="line">  insertListInEnd(L, <span class="number">4</span>);</span><br><span class="line">  printList(L);</span><br><span class="line">  insertListInI(L, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">  printList(L);</span><br><span class="line">  deleteListInI(L, <span class="number">1</span>);</span><br><span class="line">  printList(L);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList <span class="title function_">initialList</span><span class="params">()</span> &#123;</span><br><span class="line">  LinkList L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">  <span class="keyword">if</span>(!L) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾部插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertListInEnd</span><span class="params">(LinkList L, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  LinkList p = L;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  LinkList elem = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">  elem-&gt;val = val;</span><br><span class="line">  p-&gt;next = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并链表</span></span><br><span class="line">LinkList <span class="title function_">mergeList</span><span class="params">(LinkList L1, LinkList L2)</span> &#123;</span><br><span class="line">  LinkList p = L1-&gt;next;</span><br><span class="line">  LinkList q = L2-&gt;next;</span><br><span class="line">  <span class="comment">// 结果</span></span><br><span class="line">  LinkList r = L1;</span><br><span class="line">  LinkList res = r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(p &amp;&amp; q) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;val &lt; q-&gt;val) &#123;</span><br><span class="line">      res-&gt;next = p;</span><br><span class="line">      res = p;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res-&gt;next = q;</span><br><span class="line">      res = q;</span><br><span class="line">      q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  res-&gt;next = q?q:p;</span><br><span class="line">  <span class="built_in">free</span>(L2);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line">  <span class="comment">// 头节点没有数据</span></span><br><span class="line">  LinkList p = L-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(p) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \t&quot;</span>, p-&gt;val);</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  LinkList L1 = initialList();</span><br><span class="line">  insertListInEnd(L1, <span class="number">1</span>);</span><br><span class="line">  insertListInEnd(L1, <span class="number">3</span>);</span><br><span class="line">  insertListInEnd(L1, <span class="number">7</span>);</span><br><span class="line">  insertListInEnd(L1, <span class="number">9</span>);</span><br><span class="line">  printList(L1);</span><br><span class="line">  LinkList L2 = initialList();</span><br><span class="line">  insertListInEnd(L2, <span class="number">0</span>);</span><br><span class="line">  insertListInEnd(L2, <span class="number">1</span>);</span><br><span class="line">  insertListInEnd(L2, <span class="number">2</span>);</span><br><span class="line">  insertListInEnd(L2, <span class="number">4</span>);</span><br><span class="line">  insertListInEnd(L2, <span class="number">10</span>);</span><br><span class="line">  insertListInEnd(L2, <span class="number">11</span>);</span><br><span class="line">  printList(L2);</span><br><span class="line">  LinkList L3 = mergeList(L1, L2);</span><br><span class="line">  printList(L3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找中间元素"><a href="#查找中间元素" class="headerlink" title="查找中间元素"></a>查找中间元素</h3><p>快慢指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line">LinkList <span class="title function_">initialList</span><span class="params">()</span> &#123;</span><br><span class="line">  LinkList L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">  <span class="keyword">if</span>(!L) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾部插入</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertListInEnd</span><span class="params">(LinkList L, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  LinkList p = L;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  LinkList elem = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">  elem-&gt;val = val;</span><br><span class="line">  p-&gt;next = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出中间元素 快慢指针</span></span><br><span class="line">LinkList <span class="title function_">findMiddle</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line">  LinkList p = L;</span><br><span class="line">  LinkList q = L;</span><br><span class="line">  <span class="keyword">while</span>(p &amp;&amp; p-&gt;next) &#123;</span><br><span class="line">    p = p-&gt;next-&gt;next;</span><br><span class="line">    q = q-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(LinkList L)</span> &#123;</span><br><span class="line">  <span class="comment">// 头节点没有数据</span></span><br><span class="line">  LinkList p = L-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(p) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d \t&quot;</span>, p-&gt;val);</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  LinkList L = initialList();</span><br><span class="line">  insertListInEnd(L, <span class="number">1</span>);</span><br><span class="line">  insertListInEnd(L, <span class="number">2</span>);</span><br><span class="line">  insertListInEnd(L, <span class="number">3</span>);</span><br><span class="line">  insertListInEnd(L, <span class="number">4</span>);</span><br><span class="line">  insertListInEnd(L, <span class="number">5</span>);</span><br><span class="line">  printList(L);</span><br><span class="line">  LinkList el = findMiddle(L);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;middle element is %d\n&quot;</span>, el-&gt;val);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p><img src="https://img.ansore.de/2022/05/01/626e325b97b23.png" alt="image-20200810154824675"></p>
<h3 id="添加操作-1"><a href="#添加操作-1" class="headerlink" title="添加操作"></a>添加操作</h3><p><img src="https://img.ansore.de/2022/05/01/626e3261388a5.png" alt="image-20200810154914081"></p>
<h3 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h3><p><img src="https://img.ansore.de/2022/05/01/626e326714369.png" alt="image-20200810154929003"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>3.队列和栈</title>
    <url>/posts/b9075bb3.html</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>后进先出（Last In First Out，LIFO）的线性序列，称为“栈”。栈也是一种线性表，只不过它是操作受限的线性表，只能在一端进出操作。进出的一端称为栈顶（top），另一端称为栈底（base）。栈可以用顺序存储，也可以用链式存储，分别称为顺序栈和链栈。</p>
<h2 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h2><p><img src="https://img.ansore.de/2022/05/01/626e327dec639.png" alt="image-20200810155449951"></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><img src="https://img.ansore.de/2022/05/01/626e32811c3c3.png" alt="image-20200810155530242"></p>
<h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><p><img src="https://img.ansore.de/2022/05/01/626e32852174a.png" alt="image-20200810155547605"></p>
<h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><p><img src="https://img.ansore.de/2022/05/01/626e328829961.png" alt="image-20200810155602708"></p>
<h3 id="取栈顶"><a href="#取栈顶" class="headerlink" title="取栈顶"></a>取栈顶</h3><p><img src="https://img.ansore.de/2022/05/01/626e328a754f6.png" alt="image-20200810155623513"></p>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p><img src="https://img.ansore.de/2022/05/01/626e3292ca1db.png" alt="image-20200810155641041"></p>
<h3 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h3><p><img src="https://img.ansore.de/2022/05/01/626e3297a11e3.png" alt="image-20200810155657787"></p>
<h3 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h3><p><img src="https://img.ansore.de/2022/05/01/626e329b73d6a.png" alt="image-20200810155709938"></p>
<h3 id="取栈顶-1"><a href="#取栈顶-1" class="headerlink" title="取栈顶"></a>取栈顶</h3><p><img src="https://img.ansore.de/2022/05/01/626e329ed0df2.png" alt="image-20200810155723077"></p>
<h2 id="栈实现（数组）"><a href="#栈实现（数组）" class="headerlink" title="栈实现（数组）"></a>栈实现（数组）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组实现栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">  <span class="comment">// 保存数据</span></span><br><span class="line">  <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">  <span class="comment">// 指向栈顶的下标</span></span><br><span class="line">  <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack *qstack)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(qstack-&gt;top == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *qstack, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(qstack-&gt;top &gt;= MAXSIZE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈满\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  qstack-&gt;data[qstack-&gt;top] = val;</span><br><span class="line">  qstack-&gt;top ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(Stack *qstack)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(qstack-&gt;top == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈为空\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  qstack-&gt;top --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">(Stack *qstack)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(qstack-&gt;top == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈为空\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> qstack-&gt;data[qstack-&gt;top<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  Stack s;</span><br><span class="line">  s.top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  push(&amp;s, <span class="number">1</span>);</span><br><span class="line">  push(&amp;s, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;top : %d \n&quot;</span>, top(&amp;s));</span><br><span class="line">  push(&amp;s, <span class="number">3</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;top : %d \n&quot;</span>, top(&amp;s));</span><br><span class="line">  push(&amp;s, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;top : %d \n&quot;</span>, top(&amp;s));</span><br><span class="line">  push(&amp;s, <span class="number">5</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;top : %d \n&quot;</span>, top(&amp;s));</span><br><span class="line">  pop(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;top : %d \n&quot;</span>, top(&amp;s));</span><br><span class="line">  pop(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;top : %d \n&quot;</span>, top(&amp;s));</span><br><span class="line">  pop(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;top : %d \n&quot;</span>, top(&amp;s));</span><br><span class="line">  pop(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;top : %d \n&quot;</span>, top(&amp;s));</span><br><span class="line">  pop(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;top : %d \n&quot;</span>, top(&amp;s));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈实现（栈链）"><a href="#栈实现（栈链）" class="headerlink" title="栈实现（栈链）"></a>栈实现（栈链）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最顶部不保存数据</span></span><br><span class="line">Stack <span class="title function_">initialStack</span><span class="params">()</span> &#123;</span><br><span class="line">  Stack s = (Stack) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">  <span class="keyword">if</span>(!s) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack s, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  Stack elem = (Stack) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">  elem-&gt;val = val;</span><br><span class="line">  elem-&gt;next = s-&gt;next;</span><br><span class="line">  s-&gt;next = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isEmpty(s)) &#123;</span><br><span class="line">    Stack temp = s-&gt;next;</span><br><span class="line">    s-&gt;next = temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isEmpty(s)) &#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;next-&gt;val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;stack is empty.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(isEmpty(s)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stack is empty.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Stack p = s-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(p) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, p-&gt;val);</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  Stack s = initialStack();</span><br><span class="line">  printStack(s);</span><br><span class="line">  push(s, <span class="number">1</span>);</span><br><span class="line">  push(s, <span class="number">2</span>);</span><br><span class="line">  push(s, <span class="number">3</span>);</span><br><span class="line">  push(s, <span class="number">4</span>);</span><br><span class="line">  printStack(s);</span><br><span class="line">  pop(s);</span><br><span class="line">  pop(s);</span><br><span class="line">  printStack(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;top: %d \n&quot;</span>, top(s));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>先进先出（First In First Out，FIFO）的线性序列，称为“队列”。队列也是一种线性表，只不过它是操作受限的线性表，只能在两端操作：一端进，一端出。进的一端称为队尾（rear），出的一端称为队头（front）。队列可以用顺序存储，也可以用链式存储。</p>
<h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><p>动态分配</p>
<p><img src="https://img.ansore.de/2022/05/01/626e32a74ecf8.png" alt="image-20200810160038775"></p>
<p>静态分配</p>
<p><img src="https://img.ansore.de/2022/05/01/626e32a837ad7.png" alt="image-20200810160047242"></p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p><img src="https://img.ansore.de/2022/05/01/626e32ac179f2.png" alt="image-20200810160103368"></p>
<h3 id="入对"><a href="#入对" class="headerlink" title="入对"></a>入对</h3><p><img src="https://img.ansore.de/2022/05/01/626e32e4af14b.png" alt="image-20200810160142751"></p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p><img src="https://img.ansore.de/2022/05/01/626e32b0c7c37.png" alt="image-20200810160227910"></p>
<p><strong>对空时：Q.front&#x3D;&#x3D;Q.rear</strong></p>
<p><img src="https://img.ansore.de/2022/05/01/626e32b7d815e.png" alt="image-20200810160233669"></p>
<p><strong>对满时：(Q.rear+1)%Maxsize&#x3D;Q.front</strong></p>
<p><img src="https://img.ansore.de/2022/05/01/626e32ba41d66.png" alt="image-20200810160343060"></p>
<h4 id="循环队列入对"><a href="#循环队列入对" class="headerlink" title="循环队列入对"></a>循环队列入对</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Q.base[Q.rear]=x;    <span class="comment">//将元素x放入Q.rear所指空间</span></span><br><span class="line">Q.rear=(Q.rear+<span class="number">1</span>) %Maxsize; <span class="comment">//Q.rear后移一位</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img.ansore.de/2022/05/01/626e32bf4ad03.png" alt="image-20200810160440476"></p>
<h2 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h2><p><img src="https://img.ansore.de/2022/05/01/626e32bfa2884.png" alt="image-20200810160452984"></p>
<h2 id="队列实现（链对）"><a href="#队列实现（链对）" class="headerlink" title="队列实现（链对）"></a>队列实现（链对）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最顶部不保存数据</span></span><br><span class="line">Queue <span class="title function_">initialStack</span><span class="params">()</span> &#123;</span><br><span class="line">  Queue q = (Queue) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">  <span class="keyword">if</span>(!q) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> q-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue q, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  Queue p = q;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue elem = (Queue) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">  elem-&gt;val = val;</span><br><span class="line">  p-&gt;next = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deQueue</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isEmpty(q)) &#123;</span><br><span class="line">    Queue temp = q-&gt;next;</span><br><span class="line">    q-&gt;next = temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getHead</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(isEmpty(q)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;queue is empty.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> q-&gt;next-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(isEmpty(q)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;queue is empty.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue p = q-&gt;next;</span><br><span class="line">  <span class="keyword">while</span>(p) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, p-&gt;val);</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  Queue q = initialStack();</span><br><span class="line">  enQueue(q, <span class="number">1</span>);</span><br><span class="line">  enQueue(q, <span class="number">2</span>);</span><br><span class="line">  enQueue(q, <span class="number">3</span>);</span><br><span class="line">  enQueue(q, <span class="number">4</span>);</span><br><span class="line">  printQueue(q);</span><br><span class="line">  deQueue(q);</span><br><span class="line">  deQueue(q);</span><br><span class="line">  printQueue(q);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;the head is %d \n&quot;</span>, getHead(q));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>4.字符串</title>
    <url>/posts/b8285542.html</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li>串：字符串，有零个或者多个字符组成的有限序列</li>
<li>串长：串中字符的个数</li>
<li>空串：零个字符的串</li>
<li>子串：串中任意个连续字符组成的子序列。原串称为主串</li>
</ul>
<p>字符串的存储可以使用顺序存储和链式存储两种方式。</p>
<h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p>用一段连续的空间存储字符串。可以预先分配一个固定长度Maxsize的空间在这个空间中存储字符串。</p>
<ol>
<li>以**’\0’**表示字符串的结束（C&#x2F;C++、Java）。</li>
<li>在0空间存储字符串的长度。下标0的空间不使用，因此可以预先分配Maxsize+1的空间，在下标为0的空间存储字符串长度。</li>
</ol>
<p><img src="https://img.ansore.de/2022/05/01/626e32fdb362c.png" alt="Screenshot_20200812_123644"></p>
<ol start="3">
<li>结构体变量存储字符串长度。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Str</span> &#123;</span></span><br><span class="line">  <span class="comment">// 存储数组</span></span><br><span class="line">  <span class="type">char</span> ch[Maxsize];</span><br><span class="line">  <span class="comment">// 字符串的长度</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Str</span> &#123;</span></span><br><span class="line">  <span class="comment">// 字符串指针</span></span><br><span class="line">  <span class="type">char</span> *ch;</span><br><span class="line">  <span class="comment">// 字符串的长度</span></span><br><span class="line">  <span class="type">int</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p>顺序存储的串在插入和删除操作时，需要移动大量元素，因此也可以采用链表的形式存储。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e33008b81b.png" alt="Screenshot_20200812_124058"></p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>子串的定位运算称为串的模式匹配或串匹配。</p>
<h1 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h1><p>暴力匹配</p>
<ol>
<li><p>最好情况：每一次都在第一次比较时发现不等，最好情况下的平均时间复杂度为$O(n+m)$</p>
</li>
<li><p>最坏情况：每一次都匹配到T的最后一个字符发现不等。回退重新开始。最坏情况下的平均时间复杂度为$O(m*n)$</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bf</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *t)</span> &#123;</span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(s[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; t[j] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i] == t[j]) &#123;</span><br><span class="line">      i ++;</span><br><span class="line">      j ++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index ++;</span><br><span class="line">      i = index;</span><br><span class="line">      j = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(t[j] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s = <span class="string">&quot;asssasdfasdf&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *t = <span class="string">&quot;sdf&quot;</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;index = %d\n&quot;</span>, bf(s, t));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>KMP的核心在于回退的位置，回退时保证前面的字符相等，也就是求最大相同的前缀和后缀。</p>
<p>部分匹配表（PMT, Partial Match Table），如匹配的字符如下：</p>
<table>
<thead>
<tr>
<th align="center">char</th>
<th align="center">index</th>
<th align="center">pmt</th>
<th align="center">next</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">6</td>
<td align="center">0</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">7</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<ol>
<li>index为1时，a!&#x3D;b，则pmt&#x3D;0，next也回溯到下标0</li>
<li>index为2时，存在a&#x3D;a，而ab!&#x3D;ba，所以pmt&#x3D;1，next也回溯到a的下标0的位置</li>
<li>index为3时，存在ab&#x3D;ab，所以pmt为2，当匹配到ababa，时最后一个a不相等时即可回溯到下标为1的位置，因为前面的ab都相等。</li>
<li>…</li>
</ol>
<p>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getNext</span><span class="params">(<span class="type">char</span> *t)</span> &#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(t);</span><br><span class="line">  <span class="type">int</span> *next = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * len);</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">  next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">-1</span> || t[i] == t[j]) &#123;</span><br><span class="line">      i ++;</span><br><span class="line">      j ++;</span><br><span class="line">      next[i] = j;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kmp</span><span class="params">(<span class="type">char</span> *s, <span class="type">char</span> *t)</span> &#123;</span><br><span class="line">  <span class="type">int</span> *next = getNext(t);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;the next array is : [&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(t); ++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, next[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> slen = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="type">int</span> tlen = <span class="built_in">strlen</span>(t);</span><br><span class="line">  <span class="keyword">while</span>(i &lt; slen &amp;&amp; j &lt; tlen) &#123;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">-1</span> || s[i] == t[j]) &#123;</span><br><span class="line">      i ++;</span><br><span class="line">      j ++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(next);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(j == tlen) &#123;</span><br><span class="line">    <span class="keyword">return</span> i-j;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *t = <span class="string">&quot;abababca&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *s = <span class="string">&quot;1231saabababca1asdf&quot;</span>;</span><br><span class="line">  <span class="type">int</span> r = kmp(s, t);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;result is : %d\n&quot;</span>, r);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>5.二叉树</title>
    <url>/posts/6d7a1835.html</url>
    <content><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树（Tree）是n（n≥0）个结点的有限集合，当n&#x3D;0时，为空树；n&gt;0时，为非空树。任意一棵非空树，满足：</p>
<ol>
<li>有且仅有一个称之为根的结点；</li>
<li>除根结点以外的其余结点可分为$m（m＞0）$个互不相交的有限集$T1, T2, …, Tm$, 其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</li>
</ol>
<hr>
<ul>
<li>节点：节点包含数据元素以及若干子树的分支信息</li>
<li>节点的度：节点拥有的子树个数</li>
<li>树的度：树中节点的最大度数</li>
<li>终端节点：度为0的结点，又称为叶子</li>
<li>分支节点：度大于0的节点。除了叶子都是分支结点</li>
<li>内部节点：除了树根和叶子都是内部节点</li>
<li>节点的层次：从根到该节点的层数（根节点为第一层）</li>
<li>树的深度（高度）：所有节点中的最大层数</li>
</ul>
<p><img src="https://img.ansore.de/2022/05/01/626e33194912f.png" alt="image-20200812155326876"></p>
<ul>
<li>路径：树中两个结点之间的所经过的结点序列。</li>
<li>路径长度：两结点之间路径上经过的边数。</li>
<li>双亲、孩子：结点的子树的根称为该结点的孩子</li>
<li>兄弟：双亲相同的结点互称兄弟。</li>
<li>堂兄弟：双亲是兄弟的结点互称堂兄弟。小</li>
<li>祖先：即从该结点到树根经过的所有结点，称为该结点的祖先。</li>
<li>子孙：结点的子树中的所有结点都称为该结点的子孙。</li>
<li>有序树：结点的各子树从左至右有序，不能互换位置。</li>
<li>无序树：结点各子树可互换位置。</li>
<li>森林：由m（m≥0）棵不相交的树组成的集合。</li>
</ul>
<h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><p><img src="https://img.ansore.de/2022/05/01/626e3319d0773.png" alt="image-20200812160616355"></p>
<h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><p><img src="https://img.ansore.de/2022/05/01/626e3320c3e28.png" alt="image-20200812160636782"></p>
<h2 id="树转换二叉树"><a href="#树转换二叉树" class="headerlink" title="树转换二叉树"></a>树转换二叉树</h2><p>孩子兄弟表示法：长子当作左孩子，兄弟关系向右斜。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e332362ed5.png" alt="image-20200812161213179"></p>
<p><img src="https://img.ansore.de/2022/05/01/626e33257462b.png" alt="image-20200812161219387"></p>
<h2 id="二叉树还原树"><a href="#二叉树还原树" class="headerlink" title="二叉树还原树"></a>二叉树还原树</h2><p><img src="https://img.ansore.de/2022/05/01/626e3328ab149.png" alt="image-20200812161239822"></p>
<h2 id="森林转换二叉树"><a href="#森林转换二叉树" class="headerlink" title="森林转换二叉树"></a>森林转换二叉树</h2><p><img src="https://img.ansore.de/2022/05/01/626e332acba50.png" alt="image-20200812161258049"></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>二叉树（Binary Tree）是n（n≥0）个结点所构成的集合，它或为空树（n&#x3D;0）；或为非空树。对于非空树T满足：</p>
<ol>
<li>有且仅有一个称为根的结点；</li>
<li>除根结点以外，其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身都是二叉树。</li>
</ol>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ol>
<li>在二叉树的第 i层上至多有 $2^{i-1}$个结点。</li>
<li>深度为k的二叉树至多有 $2^k-1$ 个结点。</li>
<li>对于任何一棵二叉树，若叶子数为$n_0$，度为2 的结点数为$n_2$，则$n_0&#x3D;n_2+1$。</li>
<li>具有n个结点的完全二叉树的深度必为$(\log_2n)+1$.</li>
<li>对于完全二叉树，若从上至下、从左至右编号，则编号为i的结点，其左孩子编号必为$2i$。其有孩子编号必为$2i+1$：其双亲的编号必为$i&#x2F;2$。</li>
</ol>
<p>满二叉树：一棵深度为k且有$2^k-1$ 个结点的二叉树。</p>
<p>完全二叉树：除了最后一层外，每一层都是满的（达到最大结点数），最后一层结点是从左向右出现的。</p>
<h2 id="顺序存储-1"><a href="#顺序存储-1" class="headerlink" title="顺序存储"></a>顺序存储</h2><p><img src="https://img.ansore.de/2022/05/01/626e3330d9457.png" alt="image-20200812162337056"></p>
<p>补空法是指如果左子树或者右子树为空时，则用特殊字符补空，如’#’。然后按照先序遍历的顺序，得到先序遍历的序列，根据该序列递归床加你二叉树。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e33349cfd2.png" alt="image-20200812162904787"></p>
<p>补空法还原二叉树，代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 补空法创建二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTree</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BTree</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125; BNode, *BTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符指针</span></span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> slen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">BTree <span class="title function_">newBTree</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">  BTree b = (BTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTree));</span><br><span class="line">  b-&gt;val = val;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTree <span class="title function_">buildBTree</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(s[cur] == <span class="string">&#x27;#&#x27;</span> || cur &gt;= slen) &#123;</span><br><span class="line">    cur ++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    BTree b = newBTree(s[cur]);</span><br><span class="line">    cur ++;</span><br><span class="line">    b-&gt;left = buildBTree(s);</span><br><span class="line">    b-&gt;right = buildBTree(s);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printBTree</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tree) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, tree-&gt;val);</span><br><span class="line">    printBTree(tree-&gt;left);</span><br><span class="line">    printBTree(tree-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *s = <span class="string">&quot;ABD##E##CF#G###&quot;</span>;</span><br><span class="line">  slen = <span class="built_in">strlen</span>(s);</span><br><span class="line">  BTree b = buildBTree(s);</span><br><span class="line">  printBTree(b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式存储-1"><a href="#链式存储-1" class="headerlink" title="链式存储"></a>链式存储</h2><p><img src="https://img.ansore.de/2022/05/01/626e3336b49ee.png" alt="image-20200812162351611"></p>
<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 补空法创建二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTree</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BTree</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125; BNode, *BTree;</span><br><span class="line"></span><br><span class="line">BTree <span class="title function_">newBTree</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">  BTree b = (BTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTree));</span><br><span class="line">  b-&gt;val = val;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">depth</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="type">int</span> m, n;</span><br><span class="line">  <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m = depth(tree-&gt;left);</span><br><span class="line">  n = depth(tree-&gt;right);</span><br><span class="line">  <span class="keyword">return</span> (m&gt;n?m:n)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  BTree t1 = newBTree(<span class="number">1</span>);</span><br><span class="line">  BTree t2 = newBTree(<span class="number">1</span>);</span><br><span class="line">  BTree t3 = newBTree(<span class="number">1</span>);</span><br><span class="line">  BTree t4 = newBTree(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  t1-&gt;left = t2;</span><br><span class="line">  t2-&gt;left = t3;</span><br><span class="line">  t3-&gt;left = t4;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, depth(t1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, depth(t2));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, depth(t3));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d \n&quot;</span>, depth(t4));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的叶子数和节点数"><a href="#二叉树的叶子数和节点数" class="headerlink" title="二叉树的叶子数和节点数"></a>二叉树的叶子数和节点数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 补空法创建二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTree</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BTree</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125; BNode, *BTree;</span><br><span class="line"></span><br><span class="line">BTree <span class="title function_">newBTree</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">  BTree b = (BTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTree));</span><br><span class="line">  b-&gt;val = val;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求二叉树的叶子</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">leafCount</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(tree-&gt;left == <span class="literal">NULL</span> &amp;&amp; tree-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> leafCount(tree-&gt;left) + leafCount(tree-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">nodeCount</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tree == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodeCount(tree-&gt;left) + nodeCount(tree-&gt;right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  BTree t1 = newBTree(<span class="number">1</span>);</span><br><span class="line">  BTree t2 = newBTree(<span class="number">1</span>);</span><br><span class="line">  BTree t3 = newBTree(<span class="number">1</span>);</span><br><span class="line">  BTree t4 = newBTree(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  t1-&gt;left = t2;</span><br><span class="line">  t2-&gt;left = t3;</span><br><span class="line">  t3-&gt;left = t4;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;leafCount: %d \n&quot;</span>, leafCount(t1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;leafCount: %d \n&quot;</span>, leafCount(t2));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;nodeCount: %d \n&quot;</span>, nodeCount(t1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;nodeCount: %d \n&quot;</span>, nodeCount(t2));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p>按照根的访问顺序不同，根在前面称为先序遍历（DLR），根在中间称为中序遍历（LDR），根在最后称为后序遍历（LRD）。</p>
<ol>
<li>先序遍历：先访问根节点，然后先序遍历左子树，再先序遍历右子树</li>
<li>中序遍历：先中序遍历左子树，然后访问根节点，再中序遍历右子树</li>
<li>后序遍历：先后序遍历左子树，然后后序遍历右子树，最后访问根节点</li>
</ol>
<h3 id="二叉树的遍历，代码实现："><a href="#二叉树的遍历，代码实现：" class="headerlink" title="二叉树的遍历，代码实现："></a>二叉树的遍历，代码实现：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 补空法创建二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTree</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BTree</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125; BNode, *BTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">  <span class="type">void</span>* val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *Queue;</span><br><span class="line"></span><br><span class="line">Queue <span class="title function_">initialQueue</span><span class="params">()</span> &#123;</span><br><span class="line">  Queue q = (Queue) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">  <span class="keyword">if</span>(!q) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> q-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue q, <span class="type">void</span>* val)</span> &#123;</span><br><span class="line">  Queue p = q;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue elem = (Queue) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">  elem-&gt;val = val;</span><br><span class="line">  p-&gt;next = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deQueue</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isEmpty(q)) &#123;</span><br><span class="line">    Queue temp = q-&gt;next;</span><br><span class="line">    q-&gt;next = temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">getHead</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(isEmpty(q)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;queue is empty.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> q-&gt;next-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTree <span class="title function_">newBTree</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">  BTree b = (BTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTree));</span><br><span class="line">  b-&gt;val = val;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preorder</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tree) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tree-&gt;val);</span><br><span class="line">    preorder(tree-&gt;left);</span><br><span class="line">    preorder(tree-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tree) &#123;</span><br><span class="line">    inorder(tree-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tree-&gt;val);</span><br><span class="line">    inorder(tree-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">posorder</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tree) &#123;</span><br><span class="line">    posorder(tree-&gt;left);</span><br><span class="line">    posorder(tree-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, tree-&gt;val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层次遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">levelTraverse</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!tree) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue qe = initialQueue();</span><br><span class="line">  enQueue(qe, tree);</span><br><span class="line">  BTree p;</span><br><span class="line">  <span class="keyword">while</span>(!isEmpty(qe)) &#123;</span><br><span class="line">    p = getHead(qe);</span><br><span class="line">    deQueue(qe);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;left) enQueue(qe, p-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;right) enQueue(qe, p-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  BTree t1 = newBTree(<span class="number">1</span>);</span><br><span class="line">  BTree t2 = newBTree(<span class="number">2</span>);</span><br><span class="line">  BTree t3 = newBTree(<span class="number">3</span>);</span><br><span class="line">  BTree t4 = newBTree(<span class="number">4</span>);</span><br><span class="line">  BTree t5 = newBTree(<span class="number">5</span>);</span><br><span class="line">  BTree t6 = newBTree(<span class="number">6</span>);</span><br><span class="line">  BTree t7 = newBTree(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  t1-&gt;left = t2;</span><br><span class="line">  t1-&gt;right = t3;</span><br><span class="line">  t2-&gt;left = t4;</span><br><span class="line">  t2-&gt;right = t5;</span><br><span class="line">  t3-&gt;left = t6;</span><br><span class="line">  t3-&gt;right = t7;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;先序遍历: &quot;</span>);</span><br><span class="line">  preorder(t1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n中序遍历: &quot;</span>);</span><br><span class="line">  inorder(t1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n后序遍历: &quot;</span>);</span><br><span class="line">  posorder(t1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n层次遍历: &quot;</span>);</span><br><span class="line">  levelTraverse(t1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="先序遍历和中序遍历还原二叉树"><a href="#先序遍历和中序遍历还原二叉树" class="headerlink" title="先序遍历和中序遍历还原二叉树"></a>先序遍历和中序遍历还原二叉树</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 补空法创建二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTree</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BTree</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125; BNode, *BTree;</span><br><span class="line"></span><br><span class="line">BTree <span class="title function_">newBTree</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">  BTree b = (BTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTree));</span><br><span class="line">  b-&gt;val = val;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preorder</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tree) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, tree-&gt;val);</span><br><span class="line">    preorder(tree-&gt;left);</span><br><span class="line">    preorder(tree-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tree) &#123;</span><br><span class="line">    inorder(tree-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, tree-&gt;val);</span><br><span class="line">    inorder(tree-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">posorder</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tree) &#123;</span><br><span class="line">    posorder(tree-&gt;left);</span><br><span class="line">    posorder(tree-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, tree-&gt;val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序遍历和中序遍历还原二叉树</span></span><br><span class="line">BTree <span class="title function_">preMidRestore</span><span class="params">(<span class="type">char</span> *pre, <span class="type">char</span> *mid, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 先序遍历中的第一个节点</span></span><br><span class="line">  <span class="type">char</span> ch = pre[<span class="number">0</span>];</span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 中序遍历中找到根节点的左边为左孩子，右边为右孩子</span></span><br><span class="line">  <span class="keyword">while</span>(mid[index] != ch) &#123;</span><br><span class="line">    index ++;</span><br><span class="line">  &#125;</span><br><span class="line">  BTree tree = newBTree(ch);</span><br><span class="line">  tree-&gt;left = preMidRestore(pre+<span class="number">1</span>, mid, index);</span><br><span class="line">  tree-&gt;right = preMidRestore(pre+index+<span class="number">1</span>, mid+index+<span class="number">1</span>, len-index<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *pre = <span class="string">&quot;1245367&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *mid = <span class="string">&quot;4251637&quot;</span>;</span><br><span class="line">  BTree tree = preMidRestore(pre, mid, <span class="number">7</span>);</span><br><span class="line">  preorder(tree);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历和后序遍历还原二叉树"><a href="#中序遍历和后序遍历还原二叉树" class="headerlink" title="中序遍历和后序遍历还原二叉树"></a>中序遍历和后序遍历还原二叉树</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 补空法创建二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTree</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BTree</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">&#125; BNode, *BTree;</span><br><span class="line"></span><br><span class="line">BTree <span class="title function_">newBTree</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">  BTree b = (BTree) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BTree));</span><br><span class="line">  b-&gt;val = val;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preorder</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tree) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, tree-&gt;val);</span><br><span class="line">    preorder(tree-&gt;left);</span><br><span class="line">    preorder(tree-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tree) &#123;</span><br><span class="line">    inorder(tree-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, tree-&gt;val);</span><br><span class="line">    inorder(tree-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">posorder</span><span class="params">(BTree tree)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(tree) &#123;</span><br><span class="line">    posorder(tree-&gt;left);</span><br><span class="line">    posorder(tree-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, tree-&gt;val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历和后序遍历还原二叉树</span></span><br><span class="line">BTree <span class="title function_">midPosRestore</span><span class="params">(<span class="type">char</span> *mid, <span class="type">char</span> *pos, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 先序遍历中的第一个节点</span></span><br><span class="line">  <span class="type">char</span> ch = pos[len<span class="number">-1</span>];</span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 中序遍历中找到根节点的左边为左孩子，右边为右孩子</span></span><br><span class="line">  <span class="keyword">while</span>(mid[index] != ch) &#123;</span><br><span class="line">    index ++;</span><br><span class="line">  &#125;</span><br><span class="line">  BTree tree = newBTree(ch);</span><br><span class="line">  tree-&gt;left = midPosRestore(mid, pos, index);</span><br><span class="line">  tree-&gt;right = midPosRestore(mid+index+<span class="number">1</span>, pos+index, len-index<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *mid = <span class="string">&quot;4251637&quot;</span>;</span><br><span class="line">  <span class="type">char</span> *pos = <span class="string">&quot;4526731&quot;</span>;</span><br><span class="line">  BTree tree = midPosRestore(mid, pos, <span class="number">7</span>);</span><br><span class="line">  preorder(tree);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  inorder(tree);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>6.哈夫曼树与哈夫曼编码</title>
    <url>/posts/ff8e2396.html</url>
    <content><![CDATA[<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>通常的编码方法有固定长度和不等长度编码两种。<br>最优编码方案的目的是使总码长度最短。利用字符的使用频率来编码，是不等长编码方法，使得经常使用的字符编码较短，不常使用的字符编码较长。如果采用等长的编码方案，假设所有字符的编码都等长，则表示n个不同的字符需要位。例如三个不同的字符a,b,c，至少需要2位二进制数表示：a:00，b:01，c:10。如果每个字符的使用频率相等的话，固定长度编码是空间效率最高的方法。</p>
<p>不等长编码方法需要解决两个关键问题：</p>
<ol>
<li>编码尽可能的短。使用频率高的字符编码较短，使用频率低的编码较长，可提高压缩率，节省空间，也能提高运算和通信速度。即频率越高，编码越短。</li>
<li>不能有二义性。解决的办法是：任何一个字符的编码不能是另一个字符编码的前缀，即前缀码特性。</li>
</ol>
<p>设二叉树具有n个带权值的叶节点，那么从根节点到各个节点的路径长度与相应节点权值的乘积的和，叫做二叉树的<strong>带权路径长度WPL(Weighted Path Length)</strong></p>
<p>$$WPL &#x3D; \sum_{i&#x3D;1}^nW_il_i$$</p>
<p><img src="https://img.ansore.de/2022/05/01/626e334c5b322.png" alt="Screenshot_20200818_134025"></p>
<p><strong>具有最小带权路径的二叉树称为哈夫曼树（也称最优树）</strong><br><strong>哈夫曼算法采取的贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树，构造一棵新树，新树根节点的权值为其左右孩子结点权值之和，将新树插入到树的集合中。</strong></p>
<h2 id="构造哈夫曼树的原则"><a href="#构造哈夫曼树的原则" class="headerlink" title="构造哈夫曼树的原则"></a>构造哈夫曼树的原则</h2><ul>
<li><p>权值越大的叶节点越靠近根节点</p>
</li>
<li><p>权值越小的叶节点越远离根节点</p>
</li>
</ul>
<h2 id="构造哈夫曼树的过程"><a href="#构造哈夫曼树的过程" class="headerlink" title="构造哈夫曼树的过程"></a>构造哈夫曼树的过程</h2><ol>
<li><p>给定n个权值${W_1,W_2,…,W_n}$构造n棵树只有一个叶节点的二叉树，从而得到一个二叉树的集合$F&#x3D;{T_1,T_2,…,T_3}$</p>
</li>
<li><p>在F中选取根节点的<strong>权值最小和次小</strong>的两棵二叉树作为左、右子树构造一棵新的二叉树，这可二叉树根节点的权值作为其左、右子树根节点权值之和</p>
</li>
<li><p>在集合F中删除作为左、右子树的两棵二叉树，并将新建立的二叉树加入到集合F中<img src="https://img.ansore.de/2022/05/01/626e334fbad26.png" alt="Screenshot_20200818_135158"></p>
</li>
</ol>
<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>规定哈夫曼树中的<strong>左分支为0，右分支为1</strong>，则从根节点到每个叶节点锁经过的分支对应的0和1组成序列便为该节点对应字符的编码。这样的编码称为<strong>哈夫曼编码</strong>。</p>
<p>哈夫曼编码的特点：<strong>权值越大的字符编码越短，反之越长</strong><img src="https://img.ansore.de/2022/05/01/626e3357446a9.png" alt="Screenshot_20200818_135758"></p>
<p>在一组字符的哈夫曼编码中，不可能出现一个字符的哈夫曼编码是另一个哈夫曼编码的前缀。</p>
<p>例如 $100,001,0,1$ 不是哈夫曼编码</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE 10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBIT 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEAF 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNODE MAXLEAF*2-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义哈夫曼树的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> &#123;</span></span><br><span class="line">  <span class="comment">// 值</span></span><br><span class="line">  <span class="type">char</span> value;</span><br><span class="line">  <span class="comment">// 权值</span></span><br><span class="line">  <span class="type">int</span> weight;</span><br><span class="line">  <span class="comment">// 父节点的数组下标</span></span><br><span class="line">  <span class="type">int</span> parent;</span><br><span class="line">  <span class="comment">// 左孩子的数组下标</span></span><br><span class="line">  <span class="type">int</span> left;</span><br><span class="line">  <span class="comment">// 右孩子的数组下标</span></span><br><span class="line">  <span class="type">int</span> right;</span><br><span class="line">&#125; HuffmanNode, *PtrHuffmanNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanCode</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> bit[MAXBIT];</span><br><span class="line">  <span class="type">int</span> start;</span><br><span class="line">&#125; HuffmanCode, *PtrHuffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createNode</span><span class="params">(PtrHuffmanNode node, <span class="type">int</span> weight, <span class="type">char</span> value)</span> &#123;</span><br><span class="line">  node-&gt;value = value;</span><br><span class="line">  node-&gt;weight = weight;</span><br><span class="line">  node-&gt;parent = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;left = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;right = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入n个叶子节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initialHuffmanTree</span><span class="params">(PtrHuffmanNode huffmanNode, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="comment">// m1,m2最小的两个权值节点</span></span><br><span class="line">  <span class="comment">// x1,x2两个最小权值在数组中的序号</span></span><br><span class="line">  <span class="type">int</span> i, j, m1, m2, x1, x2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环构造哈夫曼树</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i ++) &#123;</span><br><span class="line">    m1 = m2 = MAXVALUE;</span><br><span class="line">    x1 = x2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找出所有节点中权值最小,无父节点的两个节点,并合并成为一棵二叉树</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n+i; j ++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(huffmanNode[j].weight &lt; m1 &amp;&amp; huffmanNode[j].parent == <span class="number">-1</span>) &#123;</span><br><span class="line">        m2 = m1;</span><br><span class="line">        x2 = x1;</span><br><span class="line">        m1 = huffmanNode[j].weight;</span><br><span class="line">        x1 = j;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(huffmanNode[j].weight &lt; m2 &amp;&amp; huffmanNode[j].parent == <span class="number">-1</span>) &#123;</span><br><span class="line">        m2 = huffmanNode[j].weight;</span><br><span class="line">        x2 = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* printf(&quot;x1:%d, x2:%d.\n&quot;, huffmanNode[x1].weight, huffmanNode[x2].weight); */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置找到来两个个子节点x1,x2的父节点信息</span></span><br><span class="line">    huffmanNode[x1].parent = n+i;</span><br><span class="line">    huffmanNode[x2].parent = n+i;</span><br><span class="line">    huffmanNode[n+i].weight = m1+m2;</span><br><span class="line">    huffmanNode[n+i].left = x1;</span><br><span class="line">    huffmanNode[n+i].right = x2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;x1.weight and x2.weight in round %d: %d, %d\n&quot;</span>, i+<span class="number">1</span>, huffmanNode[x1].weight, huffmanNode[x2].weight);  <span class="comment">/* 用于测试 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈夫曼编码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">huffmanDecode</span><span class="params">(PtrHuffmanNode huffNode, PtrHuffmanCode huffCode, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  HuffmanCode cd;</span><br><span class="line">  <span class="type">int</span> i, j, c, p;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">    cd.start = n<span class="number">-1</span>;</span><br><span class="line">    c = i;</span><br><span class="line">    p = huffNode[c].parent;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(huffNode[p].left == c) cd.bit[cd.start] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span> cd.bit[cd.start] = <span class="number">1</span>;</span><br><span class="line">      cd.start --;</span><br><span class="line">      c = p;</span><br><span class="line">      p = huffNode[c].parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把叶子节点的编码从临时cd中复制出来,放入编码结构体</span></span><br><span class="line">    <span class="keyword">for</span>(j = cd.start+<span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">      huffCode[i].bit[j] = cd.bit[j];</span><br><span class="line">    &#125;</span><br><span class="line">    huffCode[i].start = cd.start;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  HuffmanNode node[<span class="number">100</span>];</span><br><span class="line">  HuffmanCode code[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> n = <span class="number">8</span>;</span><br><span class="line">  <span class="comment">/* 初始化存放哈夫曼树数组 HuffNode[] 中的结点 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n<span class="number">-1</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    node[i].weight=<span class="number">0</span>;<span class="comment">//权值</span></span><br><span class="line">    node[i].parent=<span class="number">-1</span>;</span><br><span class="line">    node[i].left=<span class="number">-1</span>;</span><br><span class="line">    node[i].right=<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  createNode(&amp;node[<span class="number">0</span>], <span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">  createNode(&amp;node[<span class="number">1</span>], <span class="number">5</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">  createNode(&amp;node[<span class="number">2</span>], <span class="number">11</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">  createNode(&amp;node[<span class="number">3</span>], <span class="number">23</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">  createNode(&amp;node[<span class="number">4</span>], <span class="number">29</span>, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">  createNode(&amp;node[<span class="number">5</span>], <span class="number">14</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">  createNode(&amp;node[<span class="number">6</span>], <span class="number">7</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">  createNode(&amp;node[<span class="number">7</span>], <span class="number">8</span>, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  initialHuffmanTree(node, n);</span><br><span class="line">  huffmanDecode(node, code, n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c:huffman code is:&quot;</span>, node[i].value);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = code[i].start+<span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, code[i].bit[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>7.图的存储</title>
    <url>/posts/b812386b.html</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>线性表中，数据元素是一对一的关系，除了第一个和最后一个元素外，每个元素有唯一的前驱和后继。</p>
<p>树形结构中，数据元素是一对多的关系，除了根之外，每个结点有唯一的双亲结点，可以有多个孩子。</p>
<p>图形结构是多对多的关系，任何两个数据元素都有可能有关系，每个结点可以有多个前驱和后继。</p>
<p>图通常用一个二元组表示：$G&#x3D;&lt;V,E&gt;$，V表示顶点集，E表示边集。$|V|$表示顶点集中元素的个数，即顶点数，也成为图G的阶，如n阶图，表示图中有n个顶点。$|E|$表示边集中元素的个数，即边数。</p>
<p><strong>V和E均为有限集合，E可以为空集，V不可以为空，也就是说图至少有一个顶点</strong></p>
<ol>
<li>无向图。图中每条边都没有方向，则称为无向图。如顶点$v_1$和$v_3$可记为$(v_1, v_3)$或$(v_2, v_1)$。</li>
</ol>
<p><img src="https://img.ansore.de/2022/05/01/626e336765414.png" alt="Screenshot_20200824_183422"></p>
<ol start="2">
<li>有向图。图中每条边都是有方向的，则称为有向图。有向边也称为弧，每条弧都是由来嗯个顶点组成的有序对。</li>
</ol>
<p><strong>尖括号$&lt;v_i, v_j&gt;$表示有序对，圆括号$(v_i, v_j)$表示无序对</strong></p>
<p><img src="https://img.ansore.de/2022/05/01/626e336a1674c.png" alt="Screenshot_20200824_184045"></p>
<ol start="3">
<li>即不含平行边，也不含自环的图称为简单图。含有平行边或自环的图称为多重图。</li>
</ol>
<p><img src="https://img.ansore.de/2022/05/01/626e3370b1da0.png" alt="Screenshot_20200825_123205"></p>
<ol start="4">
<li>无向图中，任意两点都有一条边，则该图称为<strong>无向完全图</strong>。有向图中，任意两点都有两个方向相反的两条弧，则称该图为<strong>有向完全图</strong>。</li>
</ol>
<p><img src="https://img.ansore.de/2022/05/01/626e336e7a75c.png" alt="Screenshot_20200825_123410"></p>
<ol start="5">
<li><p>有很少边或者弧的图称为稀疏图，反之则为稠密图。一般来说，若图G满足$|E|&lt;|V|*\log{|V|}$，则称G为稀疏图。</p>
</li>
<li><p>网。实际中，经常在边上标注图距离、时间等数值，该数值称为边的权值。带权值的图称为网。</p>
</li>
</ol>
<p><img src="https://img.ansore.de/2022/05/01/626e337641923.png" alt="Screenshot_20200825_123716"></p>
<ol start="7">
<li><p>邻接是指顶点和顶点之间的关系，关联是指边和顶点之间的关系。</p>
</li>
<li><p>顶点的度是指该顶点相关联的边的数码，记为$TD(v)$。握手定理：度数之和等于边数的两倍。即$\sum_{i&#x3D;1}^nTD(v_i)&#x3D;2e$。其中n为顶点数，e为边数。</p>
</li>
<li><p>路径、路径长度、距离</p>
</li>
</ol>
<ul>
<li><p>路径：接续的边的顶点构成的序列。</p>
</li>
<li><p>路径长度：路径上边或弧的数目。</p>
</li>
<li><p>距离：从顶点到另一个顶点的最短路径长度。</p>
</li>
<li><p>子图：设两个图$G&#x3D;(V,E),G_1&#x3D;(V_1,E_1)$。若$V_1 \subseteq V, E_1 \subseteq E$，则称$G_1$是G的子图。从图中选择若干个顶点、若干条边构成的图称为原图的子图。</p>
</li>
<li><p>生成子图：从图中选择所有顶点，若干条构成的图称为原图的生成子图。</p>
</li>
</ul>
<p><img src="https://img.ansore.de/2022/05/01/626e3379ddae4.png" alt="Screenshot_20200825_124857"></p>
<ol start="10">
<li>连通图和连通分量</li>
</ol>
<ul>
<li>连通图：无向图中，如果顶点$V_1$到$V_j$都有路径，则称$V_i$和$V_j$是连通的。如果图中任何两个顶点都是连通的，则称G为连通图。</li>
<li>连通分量：无向图G的极大连通子图称为G的连通分量。极大连通子图的意思是：该子图是G连通子图，如果再加一个顶点，该子图不连通。</li>
<li>对于连通图，则其连通分量就是它自己，对于非连通图，则有两个以上连通分量。</li>
</ul>
<ol start="10">
<li>强连通图和强连通分量</li>
</ol>
<ul>
<li>强连通图：有向图中，如果任何两个顶点$V_1$到$V_j$都有路径，且$V_j$到$V_i$也有路径。则称G为强连通图。</li>
<li>强连通分量：有向图G的极大强连通子图称为G的强连通分量。极大连通子图的意思是：该子图是G的强连通子图，如果再加入一个顶点，该子图不再是强连通的。</li>
</ul>
<p><img src="https://img.ansore.de/2022/05/01/626e338359610.png" alt="image-20200825125955150"></p>
<h1 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h1><ol>
<li>无向图的邻接矩阵</li>
</ol>
<p>无向图中，如果$v_i$到$v_j$有边，则邻接矩阵$M[i][j]&#x3D;M[j][i]&#x3D;1$，否则$M[i][j]&#x3D;0$</p>
<ol start="2">
<li>无向图的邻接矩阵</li>
</ol>
<p>有向图中，如果$v_i$到$v_j$有边，则邻接矩阵$M[i][j]&#x3D;1$，否则$M[i][j]&#x3D;0$</p>
<ol start="3">
<li>网的邻接矩阵</li>
</ol>
<p>如果$v_i$到$v_j$有边，$w_{ij}$为$v_i$到$v_i$的权重，则邻接矩阵$M[i][j]&#x3D;w_{ij}$，否则$M[i][j]&#x3D;\infty$</p>
<p><strong>尖括号$&lt;v_i, v_j&gt;$表示有序对，圆括号$(v_i, v_j)$表示无序对</strong></p>
<p>优先：</p>
<ul>
<li>快速判断两顶点之间是否有边。时间复杂度为$O(1)$</li>
<li>方便计算各顶点的度。时间复杂度为$O(n)$</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>不便于增删顶点。增删顶点需要改变邻接矩阵的大小，效率较低。</p>
</li>
<li><p>不便与访问所有邻接点。时间复杂度为$O(n^2)$</p>
</li>
<li><p>空间复杂度较高。空间复杂度为$O(n^2)$</p>
</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无向图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大顶点</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVNUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VexType;</span><br><span class="line"><span class="comment">// 边上权值数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMGraph</span> &#123;</span></span><br><span class="line">  VexType Vex[MAXVNUM];</span><br><span class="line">  EdgeType Edge[MAXVNUM][MAXVNUM];</span><br><span class="line">  <span class="comment">// 顶点数 边数</span></span><br><span class="line">  <span class="type">int</span> vexnum, edgenum;</span><br><span class="line">&#125; AMGraph;</span><br><span class="line"></span><br><span class="line">AMGraph* <span class="title function_">createAMGraph</span><span class="params">()</span> &#123;</span><br><span class="line">  AMGraph *G = (AMGraph*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AMGraph));</span><br><span class="line">  <span class="comment">// 顶点数</span></span><br><span class="line">  G-&gt;vexnum = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 边数</span></span><br><span class="line">  G-&gt;edgenum = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 存入顶点信息</span></span><br><span class="line">  G-&gt;Vex[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">2</span>] = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">  <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j ++) &#123;</span><br><span class="line">      G-&gt;Edge[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 边</span></span><br><span class="line">  G-&gt;Edge[<span class="number">0</span>][<span class="number">1</span>] = G-&gt;Edge[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  G-&gt;Edge[<span class="number">1</span>][<span class="number">2</span>] = G-&gt;Edge[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  G-&gt;Edge[<span class="number">0</span>][<span class="number">2</span>] = G-&gt;Edge[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">locatevex</span><span class="params">(AMGraph* G, VexType x)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x == G-&gt;Vex[i]) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAMGraph</span><span class="params">(AMGraph* G)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;邻接矩阵为：\n&quot;</span>);</span><br><span class="line">  <span class="comment">/* printf(&quot;%d\t&quot;, G-&gt;vexnum); */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j ++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, G-&gt;Edge[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  AMGraph *G = createAMGraph();</span><br><span class="line">  printAMGraph(G);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n查找B的下标：%d\n&quot;</span>, locatevex(G, <span class="string">&#x27;B&#x27;</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h1><p>邻接表（Adjacency List）是图的一种链式存储方式。包含顶点和邻接点。订报涵括顶点信息和指向第一个邻接点的指针，邻接点是包括邻接点的存储下标和指向下一个邻接点的指针，顶点$v_i$的所有邻接点构成一个单链表。</p>
<p>邻接表用到两种数据结构：</p>
<ol>
<li>顶点结点，包括顶点信息和指向第一个邻接点的指针，可用一维数组存储。</li>
<li>邻接点结点，包括邻接点的存储下标和指向下一个邻接点的指针。顶点$v_i$的所有邻接点构成一个单链表</li>
</ol>
<p>优点：</p>
<ul>
<li>便于增删顶点</li>
<li>便于访问所有邻接点。时间复杂度为$O(n+e)$。</li>
<li>空间复杂度低。总体空间复杂度为$O(n+e)$</li>
</ul>
<p>缺点：</p>
<ul>
<li>不便于判断两点时间是否有边</li>
<li>不便于计算各顶点的度。无向图中顶点的度为顶点后单链表中的节点数。有向图的出度为顶点后面单链表的节点数，但求入度困难。有向图逆邻接表中，求入度为顶点后面单链表的节点数，但求出度困难</li>
</ul>
<h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><p><img src="https://img.ansore.de/2022/05/01/626e3389066e8.png" alt="image-20200825143616143"></p>
<p><img src="https://img.ansore.de/2022/05/01/626e338dc9c09.png" alt="image-20200825143620515"></p>
<h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><p><img src="https://img.ansore.de/2022/05/01/626e338e1dfe3.png" alt="image-20200825143632417"></p>
<p><img src="https://img.ansore.de/2022/05/01/626e33943b67f.png" alt="image-20200825143634987"></p>
<h4 id="邻接表实现有向图"><a href="#邻接表实现有向图" class="headerlink" title="邻接表实现有向图"></a>邻接表实现有向图</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有向图邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点最大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVNUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span> &#123;</span></span><br><span class="line">  <span class="comment">// 邻接点下标</span></span><br><span class="line">  <span class="type">int</span> v;</span><br><span class="line">  <span class="comment">// 下一个邻接点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; AdjNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span> &#123;</span></span><br><span class="line">  <span class="comment">// 顶点</span></span><br><span class="line">  VexType data;</span><br><span class="line">  <span class="comment">// 指向第一个邻接点</span></span><br><span class="line">  AdjNode *first;</span><br><span class="line">&#125; VexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALGraph</span> &#123;</span></span><br><span class="line">  VexNode *Vex;</span><br><span class="line">  <span class="type">int</span> vexnum, edgenum;</span><br><span class="line">&#125; ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找顶点的下标</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">locatevex</span><span class="params">(ALGraph* G, VexType x)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x == G-&gt;Vex[i].data) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一条边</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertEdge</span><span class="params">(ALGraph* G, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  AdjNode *s = (AdjNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjNode));</span><br><span class="line">  s-&gt;v = j;</span><br><span class="line">  s-&gt;next = G-&gt;Vex[i].first;</span><br><span class="line">  G-&gt;Vex[i].first = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALGraph* <span class="title function_">createALGraph</span><span class="params">()</span> &#123;</span><br><span class="line">  ALGraph *G = (ALGraph*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ALGraph));</span><br><span class="line">  <span class="comment">// 顶点和边</span></span><br><span class="line">  G-&gt;vexnum = <span class="number">3</span>;</span><br><span class="line">  G-&gt;edgenum = <span class="number">3</span>;</span><br><span class="line">  G-&gt;Vex = (VexNode*) <span class="built_in">malloc</span>(G-&gt;vexnum * <span class="keyword">sizeof</span>(VexNode));</span><br><span class="line">  G-&gt;Vex[<span class="number">0</span>].data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">1</span>].data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">2</span>].data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">0</span>].first = <span class="literal">NULL</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">1</span>].first = <span class="literal">NULL</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">2</span>].first = <span class="literal">NULL</span>;</span><br><span class="line">  insertEdge(G, locatevex(G, <span class="string">&#x27;A&#x27;</span>), locatevex(G, <span class="string">&#x27;B&#x27;</span>));</span><br><span class="line">  insertEdge(G, locatevex(G, <span class="string">&#x27;B&#x27;</span>), locatevex(G, <span class="string">&#x27;C&#x27;</span>));</span><br><span class="line">  insertEdge(G, locatevex(G, <span class="string">&#x27;C&#x27;</span>), locatevex(G, <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printALGraph</span><span class="params">(ALGraph* G)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;邻接矩阵为：\n&quot;</span>);</span><br><span class="line">  <span class="comment">/* printf(&quot;%d\t&quot;, G-&gt;vexnum); */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    AdjNode *t = G-&gt;Vex[i].first;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c: &quot;</span>, G-&gt;Vex[i].data);</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot; [%d] &quot;</span>, t-&gt;v);</span><br><span class="line">      t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  ALGraph *G = createALGraph();</span><br><span class="line">  printALGraph(G);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>8.图的搜索</title>
    <url>/posts/d48cb956.html</url>
    <content><![CDATA[<h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>深度优先搜索（Depth First Search，DFS），是最常见的图搜索方法之一。深度优先搜索沿着一条路径一直走下去，无法行进时，回退回退到刚刚访问的结点，似不撞南墙不回头，不到黄河不死心。深度优先遍历是按照深度优先搜索的方式对图进行遍历。</p>
<p><strong>后被访问的顶点，其邻接点先被访问。</strong></p>
<p>根据深度优先遍历秘籍，后来先服务，可以借助于栈实现。递归本身就是使用栈实现的，因此使用递归方法更方便。</p>
<p>算法步骤：</p>
<ol>
<li>初始化图中所有顶点未被访问。</li>
<li>从图中的某个顶点v出发，访问v并标记已访问；</li>
<li>依次检查v的所有邻接点w，如果w未被访问，则从w出发进行深度优先遍历（递归调用，重复2—3步）。</li>
</ol>
<h4 id="基于邻接矩阵的DFS算法"><a href="#基于邻接矩阵的DFS算法" class="headerlink" title="基于邻接矩阵的DFS算法"></a>基于邻接矩阵的DFS算法</h4><p>查找每个顶点的邻接点需要$O(n)$时间，一共n个顶点，总的时间复杂度为$O(n^2)$，使用了一个递归工作栈，空间复杂度为$O(n)$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DFS遍历邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无向图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大顶点</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVNUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VexType;</span><br><span class="line"><span class="comment">// 边上权值数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;</span><br><span class="line"><span class="comment">// 访问标志</span></span><br><span class="line"><span class="type">int</span> visited[MAXVNUM] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMGraph</span> &#123;</span></span><br><span class="line">  VexType Vex[MAXVNUM];</span><br><span class="line">  EdgeType Edge[MAXVNUM][MAXVNUM];</span><br><span class="line">  <span class="comment">// 顶点数 边数</span></span><br><span class="line">  <span class="type">int</span> vexnum, edgenum;</span><br><span class="line">&#125; AMGraph;</span><br><span class="line"></span><br><span class="line">AMGraph* <span class="title function_">createAMGraph</span><span class="params">()</span> &#123;</span><br><span class="line">  AMGraph *G = (AMGraph*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AMGraph));</span><br><span class="line">  <span class="comment">// 顶点数</span></span><br><span class="line">  G-&gt;vexnum = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 边数</span></span><br><span class="line">  G-&gt;edgenum = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 存入顶点信息</span></span><br><span class="line">  G-&gt;Vex[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">2</span>] = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">  <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j ++) &#123;</span><br><span class="line">      G-&gt;Edge[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 边</span></span><br><span class="line">  G-&gt;Edge[<span class="number">0</span>][<span class="number">1</span>] = G-&gt;Edge[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  G-&gt;Edge[<span class="number">1</span>][<span class="number">2</span>] = G-&gt;Edge[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  G-&gt;Edge[<span class="number">0</span>][<span class="number">2</span>] = G-&gt;Edge[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">locatevex</span><span class="params">(AMGraph* G, VexType x)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x == G-&gt;Vex[i]) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAMGraph</span><span class="params">(AMGraph* G)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;邻接矩阵为：\n&quot;</span>);</span><br><span class="line">  <span class="comment">/* printf(&quot;%d\t&quot;, G-&gt;vexnum); */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j ++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, G-&gt;Edge[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfsAM</span><span class="params">(AMGraph* G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, G-&gt;Vex[v]);</span><br><span class="line">  visited[v] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(G-&gt;Edge[v][i] &amp;&amp; !visited[i]) dfsAM(G, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearVisited</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVNUM; i ++) &#123;</span><br><span class="line">    visited[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  AMGraph *G = createAMGraph();</span><br><span class="line">  printAMGraph(G);</span><br><span class="line">  dfsAM(G, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  clearVisited();</span><br><span class="line">  dfsAM(G, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  clearVisited();</span><br><span class="line">  dfsAM(G, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  clearVisited();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于邻接表的DFS算法"><a href="#基于邻接表的DFS算法" class="headerlink" title="基于邻接表的DFS算法"></a>基于邻接表的DFS算法</h4><p>查找顶点$v_i$的邻接点需要$O(d(v_i)$时间，$d(v_i)$为$v_i$的出度（无向图为度），对有向图而言，所有顶点的出度之和等于边数e，对无向图而言，所有顶点的度之和等于2e，因此查找邻接点的时间复杂度为$O(e)$，加上初始化时间$O(n)$，总的时间复杂度为$O(n+e)$，使用了一个递归工作栈，空间复杂度为$O(n)$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DFS有向邻接表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有向图邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点最大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVNUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问标志</span></span><br><span class="line"><span class="type">int</span> visited[MAXVNUM] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span> &#123;</span></span><br><span class="line">  <span class="comment">// 邻接点下标</span></span><br><span class="line">  <span class="type">int</span> v;</span><br><span class="line">  <span class="comment">// 下一个邻接点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; AdjNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span> &#123;</span></span><br><span class="line">  <span class="comment">// 顶点</span></span><br><span class="line">  VexType data;</span><br><span class="line">  <span class="comment">// 指向第一个邻接点</span></span><br><span class="line">  AdjNode *first;</span><br><span class="line">&#125; VexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALGraph</span> &#123;</span></span><br><span class="line">  VexNode *Vex;</span><br><span class="line">  <span class="type">int</span> vexnum, edgenum;</span><br><span class="line">&#125; ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找顶点的下标</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">locatevex</span><span class="params">(ALGraph* G, VexType x)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x == G-&gt;Vex[i].data) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一条边</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertEdge</span><span class="params">(ALGraph* G, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  AdjNode *s = (AdjNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjNode));</span><br><span class="line">  s-&gt;v = j;</span><br><span class="line">  s-&gt;next = G-&gt;Vex[i].first;</span><br><span class="line">  G-&gt;Vex[i].first = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALGraph* <span class="title function_">createALGraph</span><span class="params">()</span> &#123;</span><br><span class="line">  ALGraph *G = (ALGraph*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ALGraph));</span><br><span class="line">  <span class="comment">// 顶点和边</span></span><br><span class="line">  G-&gt;vexnum = <span class="number">3</span>;</span><br><span class="line">  G-&gt;edgenum = <span class="number">3</span>;</span><br><span class="line">  G-&gt;Vex = (VexNode*) <span class="built_in">malloc</span>(G-&gt;vexnum * <span class="keyword">sizeof</span>(VexNode));</span><br><span class="line">  G-&gt;Vex[<span class="number">0</span>].data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">1</span>].data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">2</span>].data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">0</span>].first = <span class="literal">NULL</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">1</span>].first = <span class="literal">NULL</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">2</span>].first = <span class="literal">NULL</span>;</span><br><span class="line">  insertEdge(G, locatevex(G, <span class="string">&#x27;A&#x27;</span>), locatevex(G, <span class="string">&#x27;B&#x27;</span>));</span><br><span class="line">  insertEdge(G, locatevex(G, <span class="string">&#x27;B&#x27;</span>), locatevex(G, <span class="string">&#x27;C&#x27;</span>));</span><br><span class="line">  insertEdge(G, locatevex(G, <span class="string">&#x27;C&#x27;</span>), locatevex(G, <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printALGraph</span><span class="params">(ALGraph* G)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;邻接矩阵为：\n&quot;</span>);</span><br><span class="line">  <span class="comment">/* printf(&quot;%d\t&quot;, G-&gt;vexnum); */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    AdjNode *t = G-&gt;Vex[i].first;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c: &quot;</span>, G-&gt;Vex[i].data);</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot; [%d] &quot;</span>, t-&gt;v);</span><br><span class="line">      t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfsAL</span><span class="params">(ALGraph* G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">  AdjNode *p;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, G-&gt;Vex[v].data);</span><br><span class="line">  visited[v] = <span class="number">1</span>;</span><br><span class="line">  p = G-&gt;Vex[v].first;</span><br><span class="line">  <span class="keyword">while</span>(p) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[p-&gt;v]) &#123;</span><br><span class="line">      dfsAL(G, p-&gt;v);</span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearVisited</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVNUM; i ++) &#123;</span><br><span class="line">    visited[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  ALGraph *G = createALGraph();</span><br><span class="line">  printALGraph(G);</span><br><span class="line">  dfsAL(G, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  clearVisited();</span><br><span class="line">  dfsAL(G, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  clearVisited();</span><br><span class="line">  dfsAL(G, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  clearVisited();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>广度优先搜索（Breadth First Search，BFS），又称为宽度优先搜索，是最常见的图搜索方法之一。广度优先搜索是从某个顶点（源点）出发，一次性访问所有未被访问的邻接点，再依次从这些访问过邻接点出发，…，似水中涟漪，似声音传播，一层层地传播开来。广度优先遍历是按照广度优先搜索的方式对图进行遍历。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e33aa5f591.png" alt="image-20200825153327439"></p>
<p><strong>先被访问的顶点，其邻接点先被访问。</strong></p>
<p>根据广度优先遍历秘籍，先来先服务，可以借助于队列实现。每个结点访问一次且只访问一次，因此可以设置一个辅助数组。</p>
<p>步骤：</p>
<ol>
<li>初始化图中所有顶点未被访问，初始化一个空队列。</li>
<li>从图中的某个顶点v出发，访问v并标记已访问，将v入队；</li>
<li>如果队列非空，则继续执行，否则算法结束；</li>
<li>队头元素v出队，依次访问v的所有未被访问邻接点，标记已访问并入队。转向步骤3；</li>
</ol>
<h4 id="基于邻接矩阵的BFS算法"><a href="#基于邻接矩阵的BFS算法" class="headerlink" title="基于邻接矩阵的BFS算法"></a>基于邻接矩阵的BFS算法</h4><p>查找每个顶点的邻接点需要$O(n)$时间，一共n个顶点，总的时间复杂度为$O(n^2)$，使用了一个辅助队列，最坏的情况下每个顶点入队一次，空间复杂度为$O(n)$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BFS遍历邻接矩阵</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无向图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大顶点</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVNUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VexType;</span><br><span class="line"><span class="comment">// 边上权值数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;</span><br><span class="line"><span class="comment">// 访问标志</span></span><br><span class="line"><span class="type">int</span> visited[MAXVNUM] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMGraph</span> &#123;</span></span><br><span class="line">  VexType Vex[MAXVNUM];</span><br><span class="line">  EdgeType Edge[MAXVNUM][MAXVNUM];</span><br><span class="line">  <span class="comment">// 顶点数 边数</span></span><br><span class="line">  <span class="type">int</span> vexnum, edgenum;</span><br><span class="line">&#125; AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最顶部不保存数据</span></span><br><span class="line">Queue <span class="title function_">initialQueue</span><span class="params">()</span> &#123;</span><br><span class="line">  Queue q = (Queue) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">  <span class="keyword">if</span>(!q) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> q-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue q, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  Queue p = q;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue elem = (Queue) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">  elem-&gt;val = val;</span><br><span class="line">  p-&gt;next = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deQueue</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isEmpty(q)) &#123;</span><br><span class="line">    Queue temp = q-&gt;next;</span><br><span class="line">    q-&gt;next = temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getHead</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(isEmpty(q)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;queue is empty.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> q-&gt;next-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AMGraph* <span class="title function_">createAMGraph</span><span class="params">()</span> &#123;</span><br><span class="line">  AMGraph *G = (AMGraph*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AMGraph));</span><br><span class="line">  <span class="comment">// 顶点数</span></span><br><span class="line">  G-&gt;vexnum = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 边数</span></span><br><span class="line">  G-&gt;edgenum = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 存入顶点信息</span></span><br><span class="line">  G-&gt;Vex[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">2</span>] = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">  <span class="comment">// 初始化邻接矩阵</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j ++) &#123;</span><br><span class="line">      G-&gt;Edge[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 边</span></span><br><span class="line">  G-&gt;Edge[<span class="number">0</span>][<span class="number">1</span>] = G-&gt;Edge[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  G-&gt;Edge[<span class="number">1</span>][<span class="number">2</span>] = G-&gt;Edge[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  G-&gt;Edge[<span class="number">0</span>][<span class="number">2</span>] = G-&gt;Edge[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">locatevex</span><span class="params">(AMGraph* G, VexType x)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x == G-&gt;Vex[i]) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printAMGraph</span><span class="params">(AMGraph* G)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;邻接矩阵为：\n&quot;</span>);</span><br><span class="line">  <span class="comment">/* printf(&quot;%d\t&quot;, G-&gt;vexnum); */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; G-&gt;vexnum; j ++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, G-&gt;Edge[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfsAM</span><span class="params">(AMGraph* G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">  Queue Q = initialQueue();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, G-&gt;Vex[v]);</span><br><span class="line">  visited[v] = <span class="number">1</span>;</span><br><span class="line">  enQueue(Q, v);</span><br><span class="line">  <span class="keyword">while</span>(!isEmpty(Q)) &#123;</span><br><span class="line">    <span class="type">int</span> u = getHead(Q);</span><br><span class="line">    deQueue(Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(G-&gt;Edge[u][i] &amp;&amp; !visited[i]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, G-&gt;Vex[i]);</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        enQueue(Q, i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearVisited</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVNUM; i ++) &#123;</span><br><span class="line">    visited[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  AMGraph *G = createAMGraph();</span><br><span class="line">  printAMGraph(G);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  bfsAM(G, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  clearVisited();</span><br><span class="line">  bfsAM(G, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  clearVisited();</span><br><span class="line">  bfsAM(G, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  clearVisited();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于邻接表的BFS算法"><a href="#基于邻接表的BFS算法" class="headerlink" title="基于邻接表的BFS算法"></a>基于邻接表的BFS算法</h4><p>查找顶点$v_i$的邻接点需要$O(d(v_i))$时间，$d(v_i)$为$v_i$的出度（无向图为度），对有向图而言，所有顶点的出度之和等于边数e，对无向图而言，所有顶点的度之和等于2e，因此查找邻接点的时间复杂度为$O(e)$，加上初始化时间$O(n)$，总的时间复杂度为$O(n+e)$，使用了一个辅助队列，最坏的情况下每个顶点入队一次，空间复杂度为$O(n)$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BFS有向邻接表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有向图邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点最大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVNUM 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问标志</span></span><br><span class="line"><span class="type">int</span> visited[MAXVNUM] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶点数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VexType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span> &#123;</span></span><br><span class="line">  <span class="comment">// 邻接点下标</span></span><br><span class="line">  <span class="type">int</span> v;</span><br><span class="line">  <span class="comment">// 下一个邻接点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; AdjNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span> &#123;</span></span><br><span class="line">  <span class="comment">// 顶点</span></span><br><span class="line">  VexType data;</span><br><span class="line">  <span class="comment">// 指向第一个邻接点</span></span><br><span class="line">  AdjNode *first;</span><br><span class="line">&#125; VexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALGraph</span> &#123;</span></span><br><span class="line">  VexNode *Vex;</span><br><span class="line">  <span class="type">int</span> vexnum, edgenum;</span><br><span class="line">&#125; ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最顶部不保存数据</span></span><br><span class="line">Queue <span class="title function_">initialQueue</span><span class="params">()</span> &#123;</span><br><span class="line">  Queue q = (Queue) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">  <span class="keyword">if</span>(!q) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> q-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enQueue</span><span class="params">(Queue q, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  Queue p = q;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next) &#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  Queue elem = (Queue) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">  elem-&gt;val = val;</span><br><span class="line">  p-&gt;next = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deQueue</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isEmpty(q)) &#123;</span><br><span class="line">    Queue temp = q-&gt;next;</span><br><span class="line">    q-&gt;next = temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getHead</span><span class="params">(Queue q)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(isEmpty(q)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;queue is empty.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> q-&gt;next-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找顶点的下标</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">locatevex</span><span class="params">(ALGraph* G, VexType x)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x == G-&gt;Vex[i].data) <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一条边</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertEdge</span><span class="params">(ALGraph* G, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  AdjNode *s = (AdjNode*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjNode));</span><br><span class="line">  s-&gt;v = j;</span><br><span class="line">  s-&gt;next = G-&gt;Vex[i].first;</span><br><span class="line">  G-&gt;Vex[i].first = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALGraph* <span class="title function_">createALGraph</span><span class="params">()</span> &#123;</span><br><span class="line">  ALGraph *G = (ALGraph*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ALGraph));</span><br><span class="line">  <span class="comment">// 顶点和边</span></span><br><span class="line">  G-&gt;vexnum = <span class="number">3</span>;</span><br><span class="line">  G-&gt;edgenum = <span class="number">3</span>;</span><br><span class="line">  G-&gt;Vex = (VexNode*) <span class="built_in">malloc</span>(G-&gt;vexnum * <span class="keyword">sizeof</span>(VexNode));</span><br><span class="line">  G-&gt;Vex[<span class="number">0</span>].data = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">1</span>].data = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">2</span>].data = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">0</span>].first = <span class="literal">NULL</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">1</span>].first = <span class="literal">NULL</span>;</span><br><span class="line">  G-&gt;Vex[<span class="number">2</span>].first = <span class="literal">NULL</span>;</span><br><span class="line">  insertEdge(G, locatevex(G, <span class="string">&#x27;A&#x27;</span>), locatevex(G, <span class="string">&#x27;B&#x27;</span>));</span><br><span class="line">  insertEdge(G, locatevex(G, <span class="string">&#x27;B&#x27;</span>), locatevex(G, <span class="string">&#x27;C&#x27;</span>));</span><br><span class="line">  insertEdge(G, locatevex(G, <span class="string">&#x27;C&#x27;</span>), locatevex(G, <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> G;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printALGraph</span><span class="params">(ALGraph* G)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;邻接矩阵为：\n&quot;</span>);</span><br><span class="line">  <span class="comment">/* printf(&quot;%d\t&quot;, G-&gt;vexnum); */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G-&gt;vexnum; i ++) &#123;</span><br><span class="line">    AdjNode *t = G-&gt;Vex[i].first;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c: &quot;</span>, G-&gt;Vex[i].data);</span><br><span class="line">    <span class="keyword">while</span>(t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot; [%d] &quot;</span>, t-&gt;v);</span><br><span class="line">      t = t-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bfsAL</span><span class="params">(ALGraph* G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, G-&gt;Vex[v].data);</span><br><span class="line">  visited[v] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  Queue Q = initialQueue();</span><br><span class="line">  enQueue(Q, v);</span><br><span class="line">  AdjNode *p;</span><br><span class="line">  <span class="keyword">while</span>(!isEmpty(Q)) &#123;</span><br><span class="line">    <span class="type">int</span> u = getHead(Q);</span><br><span class="line">    deQueue(Q);</span><br><span class="line">    p = G-&gt;Vex[u].first;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!visited[p-&gt;v]) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, G-&gt;Vex[p-&gt;v].data);</span><br><span class="line">        visited[p-&gt;v] = <span class="number">1</span>;</span><br><span class="line">        enQueue(Q, p-&gt;v);</span><br><span class="line">      &#125;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clearVisited</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVNUM; i ++) &#123;</span><br><span class="line">    visited[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  ALGraph *G = createALGraph();</span><br><span class="line">  printALGraph(G);</span><br><span class="line">  bfsAL(G, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  clearVisited();</span><br><span class="line">  bfsAL(G, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  clearVisited();</span><br><span class="line">  bfsAL(G, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  clearVisited();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>B+树索引和哈希索引的区别</title>
    <url>/posts/a34a215d.html</url>
    <content><![CDATA[<h1 id="B-树索引和哈希索引的区别"><a href="#B-树索引和哈希索引的区别" class="headerlink" title="B+树索引和哈希索引的区别"></a>B+树索引和哈希索引的区别</h1><p>B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接，是有序的，如下图：</p>
<p><img src="https://img.ansore.de/2022/06/19/0158905b946298c96eef2fd1132726dc.png" alt="Untitled"></p>
<p>哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可,是无序的，如下图所示：</p>
<p><img src="https://img.ansore.de/2022/06/19/80aabc18a98a07c7796a0a6390b1df37.png" alt="Untitled"></p>
<p><strong>哈希索引的优势：</strong></p>
<p><strong>等值查询，</strong>哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）</p>
<p><strong>哈希索引不适用的场景：</strong></p>
<ol>
<li>不支持范围查询</li>
<li>不支持索引完成排序</li>
<li>不支持联合索引的最左前缀匹配规则</li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>9.图的连通性</title>
    <url>/posts/3bbe8d56.html</url>
    <content><![CDATA[<h1 id="连通图与连通分量"><a href="#连通图与连通分量" class="headerlink" title="连通图与连通分量"></a>连通图与连通分量</h1><ul>
<li>连通图：无向图中，如果顶点$V_1$到$V_j$都有路径，则称$V_i$和$V_j$是连通的。如果图中任何两个顶点都是连通的，则称G为连通图。</li>
</ul>
<p><img src="https://img.ansore.de/2022/05/01/626e33ba4bbe2.png" alt="Screenshot_20200826_123533"></p>
<ul>
<li>连通分量：无向图G的极大连通子图称为G的连通分量。极大连通子图的意思是：该子图是G连通子图，如果再加一个顶点，该子图不连通。</li>
<li>对于连通图，则其连通分量就是它自己，对于非连通图，则有两个以上连通分量。</li>
</ul>
<p><img src="https://img.ansore.de/2022/05/01/626e33bc2394e.png" alt="Screenshot_20200826_123438"></p>
<p><img src="https://img.ansore.de/2022/05/01/626e33c51eb24.png" alt="Screenshot_20200826_123614"></p>
<h1 id="强连通图和强连通分量"><a href="#强连通图和强连通分量" class="headerlink" title="强连通图和强连通分量"></a>强连通图和强连通分量</h1><ul>
<li>强连通图：有向图中，如果任何两个顶点$V_1$到$V_j$都有路径，且$V_j$到$V_i$也有路径。则称G为强连通图。</li>
<li>强连通分量：有向图G的极大强连通子图称为G的强连通分量。极大连通子图的意思是：该子图是G的强连通子图，如果再加入一个顶点，该子图不再是强连通的。</li>
</ul>
<p><img src="https://img.ansore.de/2022/05/01/626e33c6daa4e.png" alt="Screenshot_20200826_123715"></p>
<p>(a)是强连通图，(b)不是强连通图，(c)是(b)的强连通分量</p>
<h1 id="无向图的桥与割点"><a href="#无向图的桥与割点" class="headerlink" title="无向图的桥与割点"></a>无向图的桥与割点</h1><p><img src="https://img.ansore.de/2022/05/01/626e33d14c035.png" alt="Screenshot_20200826_124028"></p>
<p>如图，去掉边$(5,8)$后图分裂成两个互不连通的子图，边$(5,8)$即为图G的桥。同样边$(5,7)$也为图的桥。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e33d4a941a.png" alt="Screenshot_20200826_124216"></p>
<p><strong>如果去掉无向连通图G中的一条边e，G分裂为两个不连通的子图，那么e为G的桥或割边。</strong> 如图5号节点即为图G的割点。</p>
<p><strong>如果去掉无向图G中的一个点v以及v关联的所有边，G分裂成两个或两个以上不相连的子图，那么v为G的割点</strong></p>
<p><strong>注意：</strong>删除边时，只把该边删除，不删除边关联的点，而删除点时，要删除点以及相关联的所有边。</p>
<p>割点与桥的关系：</p>
<ol>
<li>有割点不一定有桥，有桥一定存在割点</li>
<li>桥一定是割点依附的边</li>
</ol>
<h1 id="无向图的双连通分量"><a href="#无向图的双连通分量" class="headerlink" title="无向图的双连通分量"></a>无向图的双连通分量</h1><p>如果无向图中不存在桥，则称它为<strong>边双连通图</strong>，边连通图中，任意两个点，存在两条或以上路径，且路径上的边互不重复。</p>
<p>如果无向图中不存在割点，则称它为<strong>点双连通图</strong>，点连通图中，如果顶点数大于2,则任意两点间，存在两条或以上路径，且路径上的点互不重复。</p>
<p>无向图的极大边双连通子图成为<strong>边双连通分量</strong>，记为$e-DCC$。</p>
<p>无向图的极大边点连通子图成为<strong>边点连通分量</strong>，记为$v-DCC$。</p>
<h1 id="双连通分量的缩点"><a href="#双连通分量的缩点" class="headerlink" title="双连通分量的缩点"></a>双连通分量的缩点</h1><p>把每一个边双连通分量$e-DCC$看作一个点，把桥看作两个缩点的无向边，得到一个树，这种方法称为$e-DCC$缩点。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e33da9f93e.png" alt="Screenshot_20200826_130809"></p>
<p>如图，图中有两个桥，5-7,5-8,每个桥的边保留，桥两端的边连通分量缩成一个点，这样生成一个树。</p>
<p><strong>注意：</strong>边连通分量就是删除桥之后留下的连通块，但点连通分量并不是删除割点后留下的连通块。</p>
<p>把每个点连通分量$v-DCC$看作一个点，把割点看成一个点，每个割点向包含它$v-DCC$连接一条边，得到一个树，这种方法称$v-DCC$缩点。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e33dc53bb3.png" alt="Screenshot_20200826_131258"></p>
<p>例如图G中有两个割点5、8，前三个点双连通粉来嗯都包含5,因此，5向他们引一条边，后2个点双连通分量都包含8，因此8向他们引一条边。</p>
<h1 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h1><p><strong>时间戳</strong>：dfn[n]表示u结点深度优先遍历的序号。</p>
<p><strong>追溯点</strong>：low[u]表示u结点或u结点或u的子孙能通过非父子边追溯到dfn最小的结点序号。即回到最早的过去。</p>
<p>例如，在深度优先搜索中，每个点的时间戳和追溯点求解过程如下：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e33de7b5c5.png" alt="image-20200827133844831"></p>
<p>初始化时，dfn[u]&#x3D;low[u]，如果该结点的邻接点未被访问，则一直深度优先遍历，1-2-3-5-6-4，此时4的邻接点1已被访问，且1不是被4的父节点，4的父节点是6（深度优先搜索树上的父节点）。那么4号结点能回到最早的过去是1号结点（dfn&#x3D;1），因此low[4]&#x3D;min(low[4],dfn[1])&#x3D;1。返回时，更新路径上所有祖先结点的low值，因为子孙能回到追溯点，其祖先也能回到</p>
<p><img src="https://img.ansore.de/2022/05/01/626e33e17e0b2.png" alt="Screenshot_20200827_134705"></p>
<h2 id="无向图的桥"><a href="#无向图的桥" class="headerlink" title="无向图的桥"></a>无向图的桥</h2><p>桥判定法则：</p>
<p>无向边$(x,y)$是桥，当且仅当搜索树上存在x的一个子节点y，满足：$low[y]&gt;dfn[x]$</p>
<p>就是说，孩子的low值比自己的dfn值大，则该节点到这个孩子的边为桥。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e33e594623.png" alt="Screenshot_20200827_140254"></p>
<p>如图，$(5,7)$，5的子节点7,满足$low[7]&gt;dfn[5]$，则该边为桥。</p>
<h2 id="无向图的割点"><a href="#无向图的割点" class="headerlink" title="无向图的割点"></a>无向图的割点</h2><p>割点判定法则：</p>
<p>若x不是根节点，则x是割点，当且仅当搜索树上存在x的一个子节点y，满足$low[y]&gt;&#x3D;dfn[x]$</p>
<p>若x是根节点，则x是割点，当且仅当搜索树上存在两个子节点，满则上述条件。</p>
<p>就是说，如果不是根，孩子的low值大于等于自己的dfn值，该节点就是割点。如果是根，至少需要两个孩子满足条件。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e33e8a1556.png" alt="Screenshot_20200827_140734"></p>
<p>如图，5的子节点7,满足$low[7]&gt;dfn[5]$，则5为割点。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e33eb2b34e.png" alt="image-20200827163034920"></p>
<p><img src="https://img.ansore.de/2022/05/01/626e33f40fdea.png" alt="image-20200827162657388"></p>
<h2 id="有向图的强连通分量"><a href="#有向图的强连通分量" class="headerlink" title="有向图的强连通分量"></a>有向图的强连通分量</h2><p>算法步骤：</p>
<ol>
<li><p>深度优先遍历结点，第一次访问x时，将x入栈，且$dfn[x]&#x3D;low[x]&#x3D;++num$</p>
</li>
<li><p>遍历x所有的邻接点y</p>
</li>
</ol>
<ul>
<li><p>若y没有被访问，则递归访问y，返回时更新$low[x]&#x3D;min(low[x], low[y])$</p>
</li>
<li><p>若y已经被访问，且在栈中，则令$low[x]&#x3D;min(low[x], dfn[y])$</p>
</li>
</ul>
<ol start="3">
<li>x回溯之前，判断如果$low[x]&#x3D;dfn(x)$，则栈中不断弹出结点，知道x出栈停止弹出的节点就是一个连通分量。</li>
</ol>
<p><img src="https://img.ansore.de/2022/05/01/626e33f750707.png" alt="Screenshot_20200827_163737"></p>
<p><img src="https://img.ansore.de/2022/05/01/626e33f93cee0.png" alt="Screenshot_20200827_163814"></p>
<p><strong>输入顺序不同，输出的强连通分量顺序也不同，但是分量中的结点是一样的</strong></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h4 id="Tarjan求桥"><a href="#Tarjan求桥" class="headerlink" title="Tarjan求桥"></a>Tarjan求桥</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNUM 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结点 结点总数</span></span><br><span class="line"><span class="comment">// head 下标：结点 值：index,指向edge</span></span><br><span class="line"><span class="type">int</span> head[MAXNUM], cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="comment">// 指向的顶点</span></span><br><span class="line">  <span class="type">int</span> to;</span><br><span class="line">  <span class="comment">// 下一个条边的index</span></span><br><span class="line">  <span class="type">int</span> next;</span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边</span></span><br><span class="line">Edge e[MAXNUM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// low数组 dfn数组 num计数</span></span><br><span class="line"><span class="type">int</span> low[MAXNUM], dfn[MAXNUM], num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">  <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line">  <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">  cnt = num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">  cnt ++;</span><br><span class="line">  e[cnt].next = head[u];</span><br><span class="line">  e[cnt].to = v;</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;head:%d\n&quot;</span>, head[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// u 出发点  fa u的父节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> &#123;</span><br><span class="line">  dfn[u] = low[u] = ++num;</span><br><span class="line">  <span class="comment">// u的所有邻接点</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">    <span class="comment">// v是u的邻接点</span></span><br><span class="line">    <span class="type">int</span> v = e[i].to;</span><br><span class="line">    <span class="comment">// 如果结点是其父亲</span></span><br><span class="line">    <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 判断是否被访问过</span></span><br><span class="line">    <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">      <span class="comment">// 递归调用 v的父亲u</span></span><br><span class="line">      tarjan(v, u);</span><br><span class="line">      <span class="comment">// 更新父亲的low值</span></span><br><span class="line">      low[u] = low[u] &lt; low[v] ? low[u] : low[v];</span><br><span class="line">      <span class="comment">// 如果low[v] &gt; dfn[u],则u-v是桥</span></span><br><span class="line">      <span class="keyword">if</span>(low[v] &gt; dfn[u]) <span class="built_in">printf</span>(<span class="string">&quot;%d-%d是桥\n&quot;</span>, u, v);</span><br><span class="line">      <span class="comment">// 如果访问过了，更新low值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> low[u] = low[u] &lt; dfn[v] ? low[u] : dfn[v];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">  add(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">  add(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">  add(<span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">  add(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) tarjan(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Tarjan求割点"><a href="#Tarjan求割点" class="headerlink" title="Tarjan求割点"></a>Tarjan求割点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNUM 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下标：顶点 值：index</span></span><br><span class="line"><span class="type">int</span> head[MAXNUM], cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="comment">// 指向的顶点</span></span><br><span class="line">  <span class="type">int</span> to;</span><br><span class="line">  <span class="comment">// 下一个条边的index</span></span><br><span class="line">  <span class="type">int</span> next;</span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line">Edge e[MAXNUM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> low[MAXNUM], dfn[MAXNUM], num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根结点</span></span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">  <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line">  <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">  num = cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加边</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">  cnt ++;</span><br><span class="line">  e[cnt].next = head[u];</span><br><span class="line">  e[cnt].to = v;</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> &#123;</span><br><span class="line">  low[u] = dfn[u] = ++num;</span><br><span class="line">  <span class="comment">// 子节点</span></span><br><span class="line">  <span class="type">int</span> chidCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">    <span class="type">int</span> v = e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">      <span class="comment">// 深度优先</span></span><br><span class="line">      tarjan(v, u);</span><br><span class="line">      low[u] = low[u] &lt; low[v] ? low[u] : low[v];</span><br><span class="line">      <span class="keyword">if</span>(dfn[u] &lt; low[v]) &#123;</span><br><span class="line">        chidCount ++;</span><br><span class="line">        <span class="keyword">if</span>(u != root || chidCount &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d 是割点\n&quot;</span>, u);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> low[u] = low[u] &gt; dfn[v] ? dfn[v] : low[u];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  addEdge(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  addEdge(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">  addEdge(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">  addEdge(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">  addEdge(<span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">  addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) &#123;</span><br><span class="line">      root = i;</span><br><span class="line">      tarjan(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Tarjan求强连通图"><a href="#Tarjan求强连通图" class="headerlink" title="Tarjan求强连通图"></a>Tarjan求强连通图</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强连通分量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNUM 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下标：顶点 值：index</span></span><br><span class="line"><span class="type">int</span> head[MAXNUM], cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="comment">// 指向的顶点</span></span><br><span class="line">  <span class="type">int</span> to;</span><br><span class="line">  <span class="comment">// 下一个条边的index</span></span><br><span class="line">  <span class="type">int</span> next;</span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> low[MAXNUM], dfn[MAXNUM], num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; *Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最顶部不保存数据</span></span><br><span class="line">Stack <span class="title function_">initialStack</span><span class="params">()</span> &#123;</span><br><span class="line">  Stack s = (Stack) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">  <span class="keyword">if</span>(!s) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> s-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack s, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">  Stack elem = (Stack) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack));</span><br><span class="line">  elem-&gt;val = val;</span><br><span class="line">  elem-&gt;next = s-&gt;next;</span><br><span class="line">  s-&gt;next = elem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isEmpty(s)) &#123;</span><br><span class="line">    Stack temp = s-&gt;next;</span><br><span class="line">    s-&gt;next = temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">top</span><span class="params">(Stack s)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!isEmpty(s)) &#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;next-&gt;val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;stack is empty.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Edge e[MAXNUM &lt;&lt; <span class="number">1</span>];</span><br><span class="line">Stack s;</span><br><span class="line"><span class="type">int</span> ins[MAXNUM];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">  <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line">  <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">  <span class="built_in">memset</span>(ins, <span class="number">0</span>, <span class="keyword">sizeof</span>(ins));</span><br><span class="line">  num = cnt = <span class="number">0</span>;</span><br><span class="line">  s = initialStack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加边</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">  cnt ++;</span><br><span class="line">  e[cnt].next = head[u];</span><br><span class="line">  e[cnt].to = v;</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">  low[u] = dfn[u] = ++num;</span><br><span class="line">  ins[u] = <span class="number">1</span>;</span><br><span class="line">  push(s, u);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">    <span class="type">int</span> v = e[i].to;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">      tarjan(v);</span><br><span class="line">      low[u] = low[u] &lt; low[v] ? low[u] : low[v];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ins[v]) &#123;</span><br><span class="line">      low[u] = low[u] &lt; dfn[v] ? low[u] : dfn[v];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(low[u] == dfn[u]) &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;连通分量:&quot;</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      v = top(s);</span><br><span class="line">      pop(s);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">      ins[v] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(v != u);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  init();</span><br><span class="line">  addEdge(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  addEdge(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  addEdge(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">  addEdge(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  addEdge(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">  addEdge(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">  addEdge(<span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">  addEdge(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) tarjan(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>B树和B+树的区别</title>
    <url>/posts/48268b0.html</url>
    <content><![CDATA[<h1 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h1><p>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null，叶子结点不包含任何关键字信息</p>
<p><img src="https://img.ansore.de/2022/06/19/d5668df2e1fa61a8f17320218458f313.png" alt="Untitled"></p>
<p>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接</p>
<p>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)</p>
<p><strong>为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<p>1、B+的磁盘读写代价更低。</p>
<p>B+的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B树更小。</p>
<p>如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p>
<p>2、B+-tree的查询效率更加稳定。</p>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MyISAM 和 InnoDB 的区别</title>
    <url>/posts/2b5f3609.html</url>
    <content><![CDATA[<h1 id="MyISAM-和-InnoDB-的区别"><a href="#MyISAM-和-InnoDB-的区别" class="headerlink" title="MyISAM 和 InnoDB 的区别"></a>MyISAM 和 InnoDB 的区别</h1><ol>
<li><p>InnoDB支持事务，MyISAM不支持</p>
<p> 对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</p>
</li>
<li><p>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</p>
</li>
<li><p>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。</p>
<p> 但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此主键不应该过大，因为主键太大，其他索引也都会很大。</p>
<p> 而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p>
</li>
<li><p>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p>
</li>
<li><p>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</p>
</li>
</ol>
<h1 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h1><ol>
<li>是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</li>
<li>如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读写也挺频繁，请使用InnoDB</li>
<li>系统奔溃后，MyISAM恢复起来更困难，能否接受；</li>
<li>MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。</li>
</ol>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>最左前缀原则</title>
    <url>/posts/65fd57e0.html</url>
    <content><![CDATA[<h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><p>首先是，这个最左前缀原则是发生在复合索引上的，只有复合索引才会有所谓的左和右之分。</p>
<p>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>悲观锁和乐观锁</title>
    <url>/posts/ec8a5210.html</url>
    <content><![CDATA[<h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p>悲观锁是利用数据库本身的锁机制来实现，会锁记录。</p>
<p>以一种预防的姿态在修改数据之前先把数据锁住，然后再对数据进行操作，在它释放锁之前任何人都不能对其数据进行操作，知道前面一个释放锁，后面才能对数据进行加锁，然后才可以对苏话剧进行操作。</p>
<p>特点：可以保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁，然后再进行操作，最后再解锁，然而加锁释放锁的过程会造成消耗，所以性能不高。</p>
<p>实现方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_table <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>

<p>要使用悲观锁，我们必须关闭MySQL数据库的自动提交属性。因为MySQL默认使用autocommit模式，也就是说，当我们执行一个更新操作后，MySQL会立刻将结果进行提交。（sql语句：set autocommit&#x3D;0）</p>
<p>以下单过程为例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 开始事务</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询商品库存信息</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改商品库存为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 提交事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>在修改id&#x3D;1的记录之前，先用for update进行加锁操作，然后修改</p>
<p>如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id&#x3D;1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p>
<p>MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。</p>
<h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>使用乐观锁就不需要借助数据库的锁机制了，主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是CAS(Compare and Swap)。CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p>扣减库存：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询出商品信息，</span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改商品库存为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> quantity <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据.</p>
<p>但是存在一个问题，即传说中的<strong>ABA问题。</strong></p>
<p>比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中取出库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p>
<p>有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询出商品信息，version<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> items <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改商品库存</span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity <span class="operator">=</span> <span class="number">2</span>, version <span class="operator">=</span> <span class="number">3</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</p>
<p>除了version以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。</p>
<p>以上SQL其实还是有一定的问题的，就是一旦遇上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。</p>
<p>对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。</p>
<p>有一条比较好的建议，可以减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改商品库存</span><br><span class="line"><span class="keyword">update</span> item</span><br><span class="line"><span class="keyword">set</span> quantity <span class="operator">=</span> quantity <span class="operator">-</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> quantity <span class="operator">-</span> <span class="number">1</span> <span class="operator">&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>以上SQL语句中，如果用户下单数为1，则通过quantity - 1 &gt; 0的方式进行乐观锁控制。</p>
<p>以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。</p>
<p>高并发环境下锁粒度把控是一门重要的学问，选择一个好的锁，在保证数据安全的情况下，可以大大提升吞吐率，进而提升性能。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB基本使用</title>
    <url>/posts/f0f6c8c9.html</url>
    <content><![CDATA[<h1 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>, i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i ++) &#123;</span><br><span class="line">    result += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;result[1-100] = %ld n&quot;</span>, result);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;result[1-250] = %d n&quot;</span>, <span class="built_in">func</span>(<span class="number">250</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译生成可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cc -g tst.c -o tst</span><br></pre></td></tr></table></figure>

<p>gdb：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gdb tst  </span><br><span class="line">GNU gdb (GDB) 10.1</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from tst...</span><br><span class="line">(gdb) l <span class="comment"># l命令相当于list,从第一行开始例出原码</span></span><br><span class="line">1       <span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">2</span><br><span class="line">3       int func(int n) &#123;</span><br><span class="line">4         int <span class="built_in">sum</span> = 0, i;</span><br><span class="line">5         <span class="keyword">for</span>(i = 0; i &lt; n; i++) &#123;</span><br><span class="line">6           <span class="built_in">sum</span> += i;</span><br><span class="line">7         &#125;</span><br><span class="line">8         <span class="built_in">return</span> <span class="built_in">sum</span>;</span><br><span class="line">9       &#125;</span><br><span class="line">10</span><br><span class="line">(gdb)  <span class="comment"># 直接回车表示,重复上一次命令</span></span><br><span class="line">11      int main(int argc, char *argv[])</span><br><span class="line">12      &#123;</span><br><span class="line">13        int i;</span><br><span class="line">14        long result = 0;</span><br><span class="line">15        <span class="keyword">for</span> (i = 0; i &lt;= 100; i ++) &#123;</span><br><span class="line">16          result += i;</span><br><span class="line">17        &#125;</span><br><span class="line">18        <span class="built_in">printf</span>(<span class="string">&quot;result[1-100] = %ld \n&quot;</span>, result);</span><br><span class="line">19        <span class="built_in">printf</span>(<span class="string">&quot;result[1-250] = %d \n&quot;</span>, func(250));</span><br><span class="line">20        <span class="built_in">return</span> 0;</span><br><span class="line">(gdb) <span class="built_in">break</span> 13 <span class="comment"># 设置断点,在源程序第13行处</span></span><br><span class="line">Breakpoint 1 at 0x1176: file tst.c, line 14.</span><br><span class="line">(gdb) <span class="built_in">break</span> func <span class="comment"># 设置断点,在函数func()入口处</span></span><br><span class="line">Breakpoint 2 at 0x1140: file tst.c, line 4.</span><br><span class="line">(gdb) info <span class="built_in">break</span> <span class="comment"># 查看断点信息</span></span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000001176 <span class="keyword">in</span> main at tst.c:14</span><br><span class="line">2       breakpoint     keep y   0x0000000000001140 <span class="keyword">in</span> func at tst.c:4</span><br><span class="line">(gdb) r  <span class="comment"># 运行程序,run命令简写</span></span><br><span class="line">Starting program: /home/ansore/study/gdb/tst </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffdcd8) at tst.c:14</span><br><span class="line">14        long result = 0;        <span class="comment"># 在断点处停住</span></span><br><span class="line">(gdb) n  <span class="comment"># 单条语句执行,next命令简写</span></span><br><span class="line">15        <span class="keyword">for</span> (i = 0; i &lt;= 100; i ++) &#123;</span><br><span class="line">(gdb) n</span><br><span class="line">16          result += i;</span><br><span class="line">(gdb) n</span><br><span class="line">15        <span class="keyword">for</span> (i = 0; i &lt;= 100; i ++) &#123;</span><br><span class="line">(gdb) n</span><br><span class="line">16          result += i;</span><br><span class="line">(gdb) c  <span class="comment"># 继续运行程序,continue命令简写</span></span><br><span class="line">Continuing.</span><br><span class="line">result[1-100] = 5050  <span class="comment">#程序输出</span></span><br><span class="line"></span><br><span class="line">Breakpoint 2, func (n=250) at tst.c:4</span><br><span class="line">4         int <span class="built_in">sum</span> = 0, i;</span><br><span class="line">(gdb) n</span><br><span class="line">5         <span class="keyword">for</span>(i = 0; i &lt; n; i++) &#123;</span><br><span class="line">(gdb) p i  <span class="comment"># 打印变量i的值,print命令简写</span></span><br><span class="line"><span class="variable">$1</span> = 32767</span><br><span class="line">(gdb) n</span><br><span class="line">6           <span class="built_in">sum</span> += i;</span><br><span class="line">(gdb) n</span><br><span class="line">5         <span class="keyword">for</span>(i = 0; i &lt; n; i++) &#123;</span><br><span class="line">(gdb) p <span class="built_in">sum</span></span><br><span class="line"><span class="variable">$2</span> = 0</span><br><span class="line">(gdb) n</span><br><span class="line">6           <span class="built_in">sum</span> += i;</span><br><span class="line">(gdb) p i</span><br><span class="line"><span class="variable">$3</span> = 1</span><br><span class="line">(gdb) n</span><br><span class="line">5         <span class="keyword">for</span>(i = 0; i &lt; n; i++) &#123;</span><br><span class="line">(gdb) p <span class="built_in">sum</span></span><br><span class="line"><span class="variable">$4</span> = 1</span><br><span class="line">(gdb) bt <span class="comment"># 查看函数堆栈</span></span><br><span class="line"><span class="comment">#0  func (n=250) at tst.c:5</span></span><br><span class="line"><span class="comment">#1  0x00005555555551bc in main (argc=1, argv=0x7fffffffdcd8) at tst.c:19</span></span><br><span class="line">(gdb) finish  <span class="comment"># 退出函数</span></span><br><span class="line">Run till <span class="built_in">exit</span> from <span class="comment">#0  func (n=250) at tst.c:5</span></span><br><span class="line">0x00005555555551bc <span class="keyword">in</span> main (argc=1, argv=0x7fffffffdcd8) at tst.c:19</span><br><span class="line">19        <span class="built_in">printf</span>(<span class="string">&quot;result[1-250] = %d \n&quot;</span>, func(250));</span><br><span class="line">Value returned is <span class="variable">$5</span> = 31125</span><br><span class="line">(gdb) c  <span class="comment"># 继续运行</span></span><br><span class="line">Continuing.</span><br><span class="line">result[1-250] = 31125  <span class="comment"># 程序输出</span></span><br><span class="line">[Inferior 1 (process 12432) exited normally] <span class="comment"># 程序退出,调试结束</span></span><br><span class="line">(gdb) q <span class="comment"># 退出gdb</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>gdb</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM类加载机制</title>
    <url>/posts/de06556f.html</url>
    <content><![CDATA[<h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><p>JVM类加载机制分为五个部分：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）。然后 使用（Using）、卸载（Unloading）。其中验证、准备和解析统称为连接（Linking）</p>
<h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><p>加载是第一个阶段，这个阶段会在内存中生成这个类的java.lang.Class对象，最为方法区这个类的各种数据的入口。这里并不一定要从class文件中获取，也可以从zip包中读取（jar、war）、运行时生成（动态代理）。</p>
<h3 id="连接（Linking）"><a href="#连接（Linking）" class="headerlink" title="连接（Linking）"></a>连接（Linking）</h3><h4 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h4><p>这一阶段的主要目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全。不同虚拟机对这个阶段的实现可能不同，大致上分为一下四个阶段的校验过程：</p>
<ol>
<li>文件格式验证。验证字节流是否符合class文件格式规范，并且是否能被当前虚拟机所处理</li>
<li>元数据验证。对字节码描述信息进行语义分析，保证其描述的信息符合java语言的规范</li>
<li>字节码验证。也是最复杂的一个阶段，主要对数据流和控制流进行分析。这个阶段对类的方法体进行校验，确保运行时不会危害虚拟机的安全</li>
<li>符号引用验证。最后一个阶段发生在虚拟机将符号引用直接转化为直接引用的时候，这个转化将在连接的第三个阶段（解析）时产生。符号引用校验可以看做是对类自身以外的的信息进行匹配性的校验</li>
</ol>
<h4 id="准备（Preparation）"><a href="#准备（Preparation）" class="headerlink" title="准备（Preparation）"></a>准备（Preparation）</h4><p>准备阶段是正式给类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。</p>
<h4 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h4><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程</p>
<blockquote>
<ul>
<li>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在java虚拟机规范的class文件格式中</li>
<li>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在</li>
</ul>
</blockquote>
<h3 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h3><p>初始化阶段是类加载的最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义加载器以外，其他都是由虚拟机完成的。到了初始阶段，才开始真正执行类中定义的java代码</p>
<p>初始化阶段的执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证执行<client>方法之前，父类的<client>已经执行完毕。如果一个类中没有静态语句块、也没有对静态变量赋值，那么编译器可以不为这个类生成<client>方法。</p>
<h2 id="类加载器和双亲委派模型"><a href="#类加载器和双亲委派模型" class="headerlink" title="类加载器和双亲委派模型"></a>类加载器和双亲委派模型</h2><p>JVM提供的三个类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。</li>
<li>扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</li>
<li>应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。</li>
</ul>
<p>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成任务时，才会执行加载任务</p>
<p> JVM通过双亲委派模型进行类的加载，同时用户也可以通过实现java.lang.ClassLoader实现自定义的类加载器。jdk中ClassLoader实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先通过<code>Class&lt;?&gt; c = findLoadedClass(name);</code>判断一个类是否被加载过</li>
<li>如果类没有被加载过，遵循双亲委派模型，首先会递归从父类加载器开始找，直到父类加载器为Bootstrap ClassLoader为止</li>
<li>最后分局resolve判断这个类是否需要解析</li>
</ol>
<p>最后findClass的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接抛出了一个异常，并且方法是protected的，很明显这是留给开发者自己实现的。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC与Socket</title>
    <url>/posts/dccbf65.html</url>
    <content><![CDATA[<p>前几天做一个项目，项目需求服务器端与手机APP用HTTP协议，与硬件用Socket协议。 服务器后端基于Spring MVC + MyBatis框架，实现与手机APP的通信没问题，但是业务需求中与硬件的交互需要用到Spring的service层的一些东西，首先创建ServerSocket监听某一端口，所以不能用Spring的IOC容器，而且Spring也没有提供这方面的IOC（控制反转），其次在Socket线程中，直接DI（依赖注入）也是不可能的，，因为这个实例都不是IOC容器托管的。 具体解决方案如下： 首先实现一个监听类来创建ServerSocket线程： web.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;!–注册ServerSocket监听器–&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.test.listener.SocketServiceLoader<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>SocketServiceLoader:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听类 启动ServerSocket 线程</span></span><br><span class="line"><span class="comment"> * Created by Ansore on 16-9-12.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServiceLoader</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Socket服务器线程</span></span><br><span class="line">    <span class="keyword">private</span> ServerSocketThread serverSocketThread;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入监听器&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == serverSocketThread) &#123;</span><br><span class="line">            serverSocketThread = <span class="keyword">new</span> <span class="title class_">ServerSocketThread</span>();</span><br><span class="line">            serverSocketThread.start();</span><br><span class="line">            System.out.println(<span class="string">&quot;启动线程&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//结束后销毁线程</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != serverSocketThread) &#123;</span><br><span class="line">            <span class="comment">//释放资源 , 结束线程</span></span><br><span class="line">            serverSocketThread.destroyedServerSocket();</span><br><span class="line">            serverSocketThread.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>创建线程后，实现了端口监听，此时要用到service层的东西，但是service实现类由IOC托管，直接new也显然不行，解决方案就是直接从Spring的IOC容器中直接获取service实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;classpath:spring/spring.xml&quot;</span>);</span><br><span class="line"><span class="type">TestService</span> <span class="variable">testService</span> <span class="operator">=</span> (TestService) applicationContext.getBean(<span class="string">&quot;testServiceImpl&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>加载配置service的xml文件，后面一定要跟service的实现类，不然也会出错 就这样即可得到一个service实例。 这样的方法也同样可以用在其他地方获取service实例。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>java中Thread和Runnable实现多线程的区别</title>
    <url>/posts/b5ea2dc8.html</url>
    <content><![CDATA[<p>java中实现多线程有两种方法：继承Thread类和实现Runnable接口。</p>
<p>一个类如果继承Thread，则不适合资源共享，但是如果实现Runnable接口，则很容易实现资源共享。在程序开发中永远以实现Runnable接口为主。</p>
<p>实现Runnable接口和继承Thread相比，有如下优势：</p>
<ol>
<li>避免java单继承带来的局限性。</li>
<li>增加程序健壮性，代码能被多个线程共享，代码和数据独立</li>
<li>适合多个相同的程序代码去处理同一个资源</li>
<li>线程池中只能放入实现Runnable和Callable类的线程，不能直接放入继承Thread的类</li>
</ol>
<hr>
<p>首先通过继承Thread类的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadImplByThread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;x = &quot;</span>+x);</span><br><span class="line">			x --;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 6</span><br><span class="line">x = 5</span><br><span class="line">x = 4</span><br><span class="line">x = 3</span><br><span class="line">x = 2</span><br><span class="line">x = 1</span><br><span class="line">x = 6</span><br><span class="line">x = 6</span><br><span class="line">x = 5</span><br><span class="line">x = 5</span><br><span class="line">x = 4</span><br><span class="line">x = 3</span><br><span class="line">x = 2</span><br><span class="line">x = 1</span><br><span class="line">x = 4</span><br><span class="line">x = 3</span><br><span class="line">x = 2</span><br><span class="line">x = 1</span><br></pre></td></tr></table></figure>

<p>三个线程分别执行三个对象中的代码，每个线程都完成各自的任务，相互之间独立。</p>
<p>通过实现Runnable接口实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadImplByRunnable</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(mt).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(mt).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(mt).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">			x --;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 6</span><br><span class="line">x = 5</span><br><span class="line">x = 4</span><br><span class="line">x = 3</span><br><span class="line">x = 2</span><br><span class="line">x = 1</span><br></pre></td></tr></table></figure>

<p>这种方法会出现线程不安全的问题，三个Thread对象共同执行一个Runnable对象中的代码，如结果有时也是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 6</span><br><span class="line">x = 6</span><br><span class="line">x = 5</span><br><span class="line">x = 4</span><br><span class="line">x = 3</span><br><span class="line">x = 2</span><br><span class="line">x = 1</span><br></pre></td></tr></table></figure>

<p>可以加入synchronized同步锁解决这个问题。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized底层原理</title>
    <url>/posts/c55fd50b.html</url>
    <content><![CDATA[<h1 id="并发编程中的三个问题"><a href="#并发编程中的三个问题" class="headerlink" title="并发编程中的三个问题"></a>并发编程中的三个问题</h1><h2 id="可见性-Visibility"><a href="#可见性-Visibility" class="headerlink" title="可见性(Visibility)"></a>可见性(Visibility)</h2><p>一个线程对共享变量进行修改，另一个线程立即得到修改后的最新值</p>
<p>演示：一个线程根据boolean类型的标记flag,while循环，另一个线程改变这个flag变量的值，另一个线程并不会停止循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示可见性问题</span></span><br><span class="line"><span class="comment"> * 1.创建一个共享变量</span></span><br><span class="line"><span class="comment"> * 2.创建一条线程不断读取共享变量</span></span><br><span class="line"><span class="comment"> * 3.创建一条线程修改共享变量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VisibilityTest</span> &#123;</span><br><span class="line">	<span class="comment">// 1.创建一个共享变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="comment">// 2.创建一条线程不断读取共享变量</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">while</span>(flag) &#123;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.创建一条线程修改共享变量</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;修改了变量的值为false&quot;</span>);</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子性问题-Atomicity"><a href="#原子性问题-Atomicity" class="headerlink" title="原子性问题(Atomicity)"></a>原子性问题(Atomicity)</h2><p>在一次或多次操作中，要么所有操作都执行并且不会受到其他因素的干扰而终端，要么所有的操作都不执行。</p>
<p>演示：5个线程各执行1000次i++</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示原子性问题</span></span><br><span class="line"><span class="comment"> * 1.定义一个共享变量number</span></span><br><span class="line"><span class="comment"> * 2.对number进行1000次++操作</span></span><br><span class="line"><span class="comment"> * 3.使用5个线程来进行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicityTest</span> &#123;</span><br><span class="line">	<span class="comment">// 1.定义一个共享变量number</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="comment">// 2.对number进行1000次</span></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">increment</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">				number ++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">// 3.使用5个线程来进行</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">			<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(increment);</span><br><span class="line">			t.start();</span><br><span class="line">			list.add(t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Thread t : list) &#123;</span><br><span class="line">			<span class="comment">// 等待线程执行完毕</span></span><br><span class="line">			t.join();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;number=&quot;</span> + number);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="有序性-Ordering"><a href="#有序性-Ordering" class="headerlink" title="有序性(Ordering)"></a>有序性(Ordering)</h2><p>程序中代码的执行顺序，java编译时和运行时会对代码进行优化，从而导致程序最终的执行顺序不一定就是编写代码时的顺序</p>
<p>演示：jcstress是java并发压测工具</p>
<p>修改pom文件，添加啊依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            jcstress version to use with this project.</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jcstress.version</span>&gt;</span>0.5<span class="tag">&lt;/<span class="name">jcstress.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            Java source/target to use for compilation.</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javac.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">javac.target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            Name of the test Uber-JAR to generate.</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uberjar.name</span>&gt;</span>jcstress-learning<span class="tag">&lt;/<span class="name">uberjar.name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filesets</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">fileset</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/results<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">followSymlinks</span>&gt;</span>false<span class="tag">&lt;/<span class="name">followSymlinks</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">fileset</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">include</span>&gt;</span>jcstress-results*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">followSymlinks</span>&gt;</span>false<span class="tag">&lt;/<span class="name">followSymlinks</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">filesets</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-shade-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>main<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>shade<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;uberjar.name&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">transformers</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></span><br><span class="line"><span class="tag">                                         <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.openjdk.jcstress.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">transformer</span></span></span><br><span class="line"><span class="tag">                                         <span class="attr">implementation</span>=<span class="string">&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span>META-INF/TestList<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">transformers</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderingTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程1执行代码</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">            r.r1 = num + num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2执行代码</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="comment">// 这两步进行了重排序，导致产生0</span></span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Observed state   Occurrences              Expectation  Interpretation                                              </span><br><span class="line">0         5,335   ACCEPTABLE_INTERESTING  danger                                                      </span><br><span class="line">1    39,878,419               ACCEPTABLE  ok                                                          </span><br><span class="line">4    39,868,777               ACCEPTABLE  ok                         </span><br></pre></td></tr></table></figure>



<h1 id="java内存模型-JMM"><a href="#java内存模型-JMM" class="headerlink" title="java内存模型(JMM)"></a>java内存模型(JMM)</h1><ul>
<li>主内存，所有线程共享，都能访问。所有共享变量都存储在主内存中嗯</li>
<li>工作内存，每个线程都有自己的工作内存，工作内存只存储该线程对共享变量的副本，线程多变量的所有操作都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量</li>
</ul>
<p><img src="https://img.ansore.de/2022/05/01/626e30e2e19cf.png" alt="Screenshot_20200529_160454"></p>
<h2 id="java内存模型的作用"><a href="#java内存模型的作用" class="headerlink" title="java内存模型的作用"></a>java内存模型的作用</h2><p>java内存模型是一套多线程读写共享数据时，对共享数据的可见性、有序性、原子性的规则和保障。</p>
<p>synchronized,volatile</p>
<h2 id="CPU缓存、内存与java内存模型的关系"><a href="#CPU缓存、内存与java内存模型的关系" class="headerlink" title="CPU缓存、内存与java内存模型的关系"></a>CPU缓存、内存与java内存模型的关系</h2><p><img src="https://img.ansore.de/2022/05/01/626e30d8e13d8.png" alt="Screenshot_20200529_160804"></p>
<h2 id="主内存与工作内存之间的交互"><a href="#主内存与工作内存之间的交互" class="headerlink" title="主内存与工作内存之间的交互"></a>主内存与工作内存之间的交互</h2><p><img src="https://img.ansore.de/2022/05/01/626e30cc0ffa0.png" alt="Screenshot_20200529_162435"></p>
<ol>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值</li>
<li>对一个变量执行unlock操作，必须先把此变量同步到主内存中</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock -&gt; read -&gt; load -&gt; use -&gt; assign -&gt; store -&gt; write -&gt; unlock</span><br></pre></td></tr></table></figure>



<h1 id="Synchronized保证三大特性"><a href="#Synchronized保证三大特性" class="headerlink" title="Synchronized保证三大特性"></a>Synchronized保证三大特性</h1><p>synchronized能够保证在同一时刻最多只有一个线程执行该段代码，已达到保证并发安全的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (锁对象) &#123;</span><br><span class="line">    <span class="comment">// 收保护资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized与原子性"><a href="#Synchronized与原子性" class="headerlink" title="Synchronized与原子性"></a>Synchronized与原子性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtomicityTest</span> &#123;</span><br><span class="line">	<span class="comment">// 1.定义一个共享变量number</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="comment">// 2.对number进行1000次</span></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">increment</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">				<span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">					number ++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">// 3.使用5个线程来进行</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i ++) &#123;</span><br><span class="line">			<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(increment);</span><br><span class="line">			t.start();</span><br><span class="line">			list.add(t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(Thread t : list) &#123;</span><br><span class="line">			<span class="comment">// 等待线程执行完毕</span></span><br><span class="line">			t.join();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;number=&quot;</span> + number);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized与可见性"><a href="#Synchronized与可见性" class="headerlink" title="Synchronized与可见性"></a>Synchronized与可见性</h2><ol>
<li>volatile</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>缓存一致性协议，保证可见性与有序性，不保证原子性</p>
<ol start="2">
<li>Synchronized</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VisibilityTest</span> &#123;</span><br><span class="line">	<span class="comment">// 1.创建一个共享变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="comment">// 2.创建一条线程不断读取共享变量</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">while</span>(flag) &#123;</span><br><span class="line"><span class="comment">//				System.out.println(flag);</span></span><br><span class="line">				<span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.创建一条线程修改共享变量</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;修改了变量的值为false&quot;</span>);</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保证可见性原理：Synchronized对应的lock原子操作会让工作内存变量获取最新值</p>
<p>另外</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure>

<p>也可以。println也用到了Synchronized</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">boolean</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Synchronized与有序性"><a href="#Synchronized与有序性" class="headerlink" title="Synchronized与有序性"></a>Synchronized与有序性</h2><p>为了提高程序的执行效率，编译器和CPU会对程序中的代码进行重排序</p>
<p>as-if-serial语义：不论编译器和CPU如何重排序，必须保证在单线程情况下程序的结果是正确的</p>
<p>以下数据有依赖关系，不能重排序</p>
<p>写后读：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure>

<p>写后写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>读后写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序不会改变执行结果，但是，如果操作之间不存在数据依赖关系，这些操作就有可能被编译器和处理器重排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a和b没有依赖关系</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以重排成这样</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br></pre></td></tr></table></figure>

<p>synchronized保证有序性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;1&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &#123;&quot;4&quot;&#125;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;ok2&quot;)</span></span><br><span class="line"><span class="meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)</span></span><br><span class="line"><span class="meta">@State</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderingTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程1执行代码</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">                r.r1 = num + num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r.r1 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程2执行代码</span></span><br><span class="line">    <span class="meta">@Actor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            num = <span class="number">2</span>;</span><br><span class="line">            ready = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[OK] com.ansore.synchronized_demo.OrderingTest</span><br><span class="line">(JVM args: [])</span><br><span class="line">Observed state   Occurrences              Expectation  Interpretation                                              </span><br><span class="line">0             0   ACCEPTABLE_INTERESTING  danger                                                      </span><br><span class="line">1    16,715,561               ACCEPTABLE  ok                                                          </span><br><span class="line">4    49,060,280   ACCEPTABLE_INTERESTING  ok2  </span><br></pre></td></tr></table></figure>

<p>加synchronized后，依然会发生重排序，只不过同步代码块保证只有一个线程执行同步代码块中的内容</p>
<p>还可以使用volatile可以保证有序性，使两个变量不发生重排序</p>
<h1 id="Synchronized的特性"><a href="#Synchronized的特性" class="headerlink" title="Synchronized的特性"></a>Synchronized的特性</h1><h2 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h2><p>一个线程可以多次执行Synchronized，重复获取同一把锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示synchronized可重入</span></span><br><span class="line"><span class="comment"> * 1.自定义线程类</span></span><br><span class="line"><span class="comment"> * 2.在线程类中使用嵌套的同步代码块</span></span><br><span class="line"><span class="comment"> * 3.使用两个线程来执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (MyThread.class) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;进入同步代码块1&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread.class) &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;进入同步代码块2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-0进入同步代码块1</span><br><span class="line">Thread-0进入同步代码块2</span><br><span class="line">Thread-1进入同步代码块1</span><br><span class="line">Thread-1进入同步代码块2</span><br></pre></td></tr></table></figure>

<p>锁对象中有个计数器（recursions）变量，会记录线程获得几次锁。</p>
<ol>
<li>可以避免死锁</li>
<li>可以更好地封装代码</li>
</ol>
<h3 id="不可中断特性"><a href="#不可中断特性" class="headerlink" title="不可中断特性"></a>不可中断特性</h3><p>一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不是放锁，第二个线程会一直阻塞或等待，不可被中断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示synchronized不可中断</span></span><br><span class="line"><span class="comment"> * 1.定义一个Runnable</span></span><br><span class="line"><span class="comment"> * 2.在Runnable定义同步代码块</span></span><br><span class="line"><span class="comment"> * 3.先开启一个线程来执行同步代码块，保证不退出同步代码块</span></span><br><span class="line"><span class="comment"> * 4.后开启一个线程来执行同步代码块（阻塞状态）</span></span><br><span class="line"><span class="comment"> * 5.强行停止第二个线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Uninterruptible</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1.定义一个Runnable</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="comment">// 2.在Runnable定义同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="comment">// 保证不退出同步代码块</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">                System.out.println(name+<span class="string">&quot;进入同步代码块&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保证不退出同步代码块</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">88888</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 3.先开启一个线程来执行同步代码块，保证不退出同步代码块</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 4.后开启一个线程来执行同步代码块（阻塞状态）</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// * 5.强行停止第二个线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;停止线程前&quot;</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;停止线程后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread-0进入同步代码块</span><br><span class="line">停止线程前</span><br><span class="line">停止线程后</span><br><span class="line">TIMED_WAITING</span><br><span class="line">BLOCKED</span><br></pre></td></tr></table></figure>



<h5 id="ReentrantLock可中断与不可中断"><a href="#ReentrantLock可中断与不可中断" class="headerlink" title="ReentrantLock可中断与不可中断"></a>ReentrantLock可中断与不可中断</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示Lock不可中断和可中断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Interruptible</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lock不可中断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;获得锁，进入锁执行&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">888888</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;停止线程t2前&quot;</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line">        System.out.println(<span class="string">&quot;停止线程t2后&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(t1.getState());</span><br><span class="line">        System.out.println(t2.getState());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 运行结果</span></span><br><span class="line"><span class="comment">         * Thread-0获得锁，进入锁执行</span></span><br><span class="line"><span class="comment">         * 停止线程t2前</span></span><br><span class="line"><span class="comment">         * 停止线程t2后</span></span><br><span class="line"><span class="comment">         * TIMED_WAITING</span></span><br><span class="line"><span class="comment">         * WAITING</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                b = lock.tryLock(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span>(b) &#123;</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;获得锁，进入锁执行&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">888888</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(name+<span class="string">&quot;在指定的时间内，没有获取锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(b) &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 运行结果：</span></span><br><span class="line"><span class="comment">         * Thread-0获得锁，进入锁执行</span></span><br><span class="line"><span class="comment">         * Thread-1在指定的时间内，没有获取锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h1><p>monitor才是真正的锁，JVM会创建一个monitor C++对象</p>
<p>Synchronized的锁对象会关联一个monitor,这个monitor不是主动创建的，而是JVM线程执行到这个同步代码块，发现锁对象没有monitor就会创建monitor</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">monitor</span><br><span class="line">owner:拥有锁的对象</span><br><span class="line">recursions：获取锁的次数</span><br></pre></td></tr></table></figure>

<ul>
<li>monitorenter</li>
</ul>
<ol>
<li>若monitor的进入次数为0，线程可以进入monitor，当前线程为monitor的所有者</li>
<li>托线程已经拥有monitor，允许它重入monitor,则进入monitor的次数+1</li>
<li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，知道monitor的进入数变为0，才能重新尝试获取monitor的所有权</li>
</ol>
<ul>
<li>monitorexit</li>
</ul>
<ol>
<li>能执行monitorexit指令的一定是拥有当前对象的monitor的所有权的线程</li>
<li>执行monitorexit时会将monitor的进入数-1，当monitor进入数为0时，当前线程推出monitor，不再拥有monitor的所有权。此时其他被这个monitor阻塞的线程可以尝试获取这个monitor的所有权</li>
</ol>
<p>synchronized出现异常依然会释放锁</p>
<p>同步方法反汇编之后会增加ACC_SYNCHRONIZED修饰，会隐式调用monitorenter和monitorexit方法，执行同步方法之前会调用monitorenter，执行同步代码块之后会调用monitorexit</p>
<h3 id="synchronized与lock的区别"><a href="#synchronized与lock的区别" class="headerlink" title="synchronized与lock的区别"></a>synchronized与lock的区别</h3><ol>
<li>synchronized是关键字，而lock是接口</li>
<li>synchronized会自动释放锁，而lock必须手动释放锁</li>
<li>synchronized不可中断，lock可中断也可以不中断</li>
<li>通过lock可以知道线程有没有拿到锁，而synchronized不能</li>
<li>synchronized能锁方法和代码块，而lock只能锁代码块</li>
<li>lock可以使用读锁提高多线程读效率</li>
<li>synchronized是非公平锁，ReentrantLock可以控制是否是公平</li>
</ol>
<h1 id="JVM源码"><a href="#JVM源码" class="headerlink" title="JVM源码"></a>JVM源码</h1><h2 id="monitor监视器锁"><a href="#monitor监视器锁" class="headerlink" title="monitor监视器锁"></a>monitor监视器锁</h2><p>monitor由ObjectMonitor实现，源码用C++实现的，位于HotSpot虚拟机源码的src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp下。主要数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initialize the monitor, exception the semaphore, all other fields</span></span><br><span class="line"><span class="comment">// are simple integers or pointers</span></span><br><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">  _header       = <span class="literal">NULL</span>;</span><br><span class="line">  _count        = <span class="number">0</span>;</span><br><span class="line">  _waiters      = <span class="number">0</span>,</span><br><span class="line">  _recursions   = <span class="number">0</span>; <span class="comment">// 线程的重入次数</span></span><br><span class="line">  _object       = <span class="literal">NULL</span>; <span class="comment">// 存储该monitor对象</span></span><br><span class="line">  _owner        = <span class="literal">NULL</span>; <span class="comment">// 标识拥有该monitor的线程</span></span><br><span class="line">  _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 处于wait状态的线程，会被加入到_WaitSet中</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">  _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">  _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">  _cxq          = <span class="literal">NULL</span> ; <span class="comment">// 多线程竞争锁时的单向列表</span></span><br><span class="line">  FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">  _EntryList    = <span class="literal">NULL</span> ; <span class="comment">// 处于等待锁block状态的线程，会被加入该列表</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程在执行过程中，有线程进来，首先会进入_cxq，线程执行完毕以后会竞争锁，为获得锁的线程会被加入_EntryList 处于阻塞状态。</p>
<h2 id="Monitor竞争"><a href="#Monitor竞争" class="headerlink" title="Monitor竞争"></a>Monitor竞争</h2><ol>
<li>执行monitorenter时，会调用InterpreterRuntime.cpp</li>
</ol>
<p>(src&#x2F;share&#x2F;vm&#x2F;interpreter&#x2F;interpreterRuntime.cpp)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Synchronization</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The interpreter&#x27;s synchronization code is factored out so that it can</span></span><br><span class="line"><span class="comment">// be shared by method invocation and synchronized blocks.</span></span><br><span class="line"><span class="comment">//%note synchronization_3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//%note monitor_1</span></span><br><span class="line"><span class="built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="type">void</span>, InterpreterRuntime::<span class="built_in">monitorenter</span>(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::<span class="built_in">inc</span>(BiasedLocking::<span class="built_in">slow_path_entry_count_addr</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  <span class="built_in">assert</span>(Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved_or_null</span>(<span class="built_in">h_obj</span>()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::<span class="built_in">fast_enter</span>(h_obj, elem-&gt;<span class="built_in">lock</span>(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ObjectSynchronizer::<span class="built_in">slow_enter</span>(h_obj, elem-&gt;<span class="built_in">lock</span>(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved_or_null</span>(elem-&gt;<span class="built_in">obj</span>()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对于重量级锁，monitorenter函数会调用ObjectSynchronizer::slow_enter</li>
<li>最终调用ObjectMonitor::enter (位于src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> ATTR <span class="title">ObjectMonitor::enter</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The following code is ordered to check the most common cases first</span></span><br><span class="line">  <span class="comment">// and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors.</span></span><br><span class="line">  Thread * <span class="type">const</span> Self = THREAD ;</span><br><span class="line">  <span class="type">void</span> * cur ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过CAS操作尝试把monitor的_owner字段设置为当前线程</span></span><br><span class="line">  cur = Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="comment">// Either ASSERT _recursions == 0 or explicitly set _recursions = 0.</span></span><br><span class="line">     <span class="built_in">assert</span> (_recursions == <span class="number">0</span>   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span> (_owner      == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="comment">// CONSIDER: set or assert OwnerIsThread == 1</span></span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程重入，_recursions ++</span></span><br><span class="line">  <span class="keyword">if</span> (cur == Self) &#123;</span><br><span class="line">     <span class="comment">// TODO-<span class="doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span></span><br><span class="line">     _recursions ++ ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前线程第一次进入该monitor,设置_recursions = 1 ;_owner为当前线程</span></span><br><span class="line">  <span class="keyword">if</span> (Self-&gt;<span class="built_in">is_lock_owned</span> ((address)cur)) &#123;</span><br><span class="line">    <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;internal state error&quot;</span>);</span><br><span class="line">    _recursions = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">// Commute owner from a thread-specific on-stack BasicLockObject address to</span></span><br><span class="line">    <span class="comment">// a full-fledged &quot;Thread *&quot;.</span></span><br><span class="line">    _owner = Self ;</span><br><span class="line">    OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We&#x27;ve encountered genuine contention.</span></span><br><span class="line">  <span class="built_in">assert</span> (Self-&gt;_Stalled == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  Self-&gt;_Stalled = <span class="built_in">intptr_t</span>(<span class="keyword">this</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try one round of spinning *before* enqueueing Self</span></span><br><span class="line">  <span class="comment">// and before going through the awkward and expensive state</span></span><br><span class="line">  <span class="comment">// transitions.  The following spin is strictly optional ...</span></span><br><span class="line">  <span class="comment">// Note that if we acquire the monitor from an initial spin</span></span><br><span class="line">  <span class="comment">// we forgo posting JVMTI events and firing DTRACE probes.</span></span><br><span class="line">  <span class="keyword">if</span> (Knob_SpinEarly &amp;&amp; <span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">assert</span> (_owner == Self      , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span> (_recursions == <span class="number">0</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span> (((oop)(<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">encode</span>(<span class="keyword">this</span>), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span> (_owner != Self          , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (_succ  != Self          , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (Self-&gt;<span class="built_in">is_Java_thread</span>()  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  JavaThread * jt = (JavaThread *) Self ;</span><br><span class="line">  <span class="built_in">assert</span> (!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (jt-&gt;<span class="built_in">thread_state</span>() != _thread_blocked   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (<span class="keyword">this</span>-&gt;<span class="built_in">object</span>() != <span class="literal">NULL</span>  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (_count &gt;= <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent deflation at STW-time.  See deflate_idle_monitors() and is_busy().</span></span><br><span class="line">  <span class="comment">// Ensure the object-monitor relationship remains stable while there&#x27;s contention.</span></span><br><span class="line">  Atomic::<span class="built_in">inc_ptr</span>(&amp;_count);</span><br><span class="line"></span><br><span class="line">  EventJavaMonitorEnter event;</span><br><span class="line"></span><br><span class="line">  &#123; <span class="comment">// Change java thread status to indicate blocked on monitor enter.</span></span><br><span class="line">    <span class="function">JavaThreadBlockedOnMonitorEnterState <span class="title">jtbmes</span><span class="params">(jt, <span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DTRACE_MONITOR_PROBE</span>(contended__enter, <span class="keyword">this</span>, <span class="built_in">object</span>(), jt);</span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_contended_enter</span>()) &#123;</span><br><span class="line">      JvmtiExport::<span class="built_in">post_monitor_contended_enter</span>(jt, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">OSThreadContendState <span class="title">osts</span><span class="params">(Self-&gt;osthread())</span></span>;</span><br><span class="line">    <span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;</span><br><span class="line"></span><br><span class="line">    Self-&gt;<span class="built_in">set_current_pending_monitor</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO-<span class="doctag">FIXME:</span> change the following for(;;) loop to straight-line code.</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      jt-&gt;<span class="built_in">set_suspend_equivalent</span>();</span><br><span class="line">      <span class="comment">// cleared by handle_special_suspend_equivalent_condition()</span></span><br><span class="line">      <span class="comment">// or java_suspend_self()</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果获取锁失败，则等待锁的释放</span></span><br><span class="line">      <span class="built_in">EnterI</span> (THREAD) ;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">ExitSuspendEquivalent</span>(jt)) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We have acquired the contended monitor, but while we were</span></span><br><span class="line">      <span class="comment">// waiting another thread suspended us. We don&#x27;t want to enter</span></span><br><span class="line">      <span class="comment">// the monitor while suspended because that would surprise the</span></span><br><span class="line">      <span class="comment">// thread that suspended us.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">          _recursions = <span class="number">0</span> ;</span><br><span class="line">      _succ = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="built_in">exit</span> (<span class="literal">false</span>, Self) ;</span><br><span class="line"></span><br><span class="line">      jt-&gt;<span class="built_in">java_suspend_self</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Self-&gt;<span class="built_in">set_current_pending_monitor</span>(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Atomic::<span class="built_in">dec_ptr</span>(&amp;_count);</span><br><span class="line">  <span class="built_in">assert</span> (_count &gt;= <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Must either set _recursions = 0 or ASSERT _recursions == 0.</span></span><br><span class="line">  <span class="built_in">assert</span> (_recursions == <span class="number">0</span>     , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (_owner == Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (_succ  != Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (((oop)(<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">encode</span>(<span class="keyword">this</span>), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The thread -- now the owner -- is back in vm mode.</span></span><br><span class="line">  <span class="comment">// Report the glorious news via TI,DTrace and jvmstat.</span></span><br><span class="line">  <span class="comment">// The probe effect is non-trivial.  All the reportage occurs</span></span><br><span class="line">  <span class="comment">// while we hold the monitor, increasing the length of the critical</span></span><br><span class="line">  <span class="comment">// section.  Amdahl&#x27;s parallel speedup law comes vividly into play.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Another option might be to aggregate the events (thread local or</span></span><br><span class="line">  <span class="comment">// per-monitor aggregation) and defer reporting until a more opportune</span></span><br><span class="line">  <span class="comment">// time -- such as next time some thread encounters contention but has</span></span><br><span class="line">  <span class="comment">// yet to acquire the lock.  While spinning that thread could</span></span><br><span class="line">  <span class="comment">// spinning we could increment JVMStat counters, etc.</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">DTRACE_MONITOR_PROBE</span>(contended__entered, <span class="keyword">this</span>, <span class="built_in">object</span>(), jt);</span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_contended_entered</span>()) &#123;</span><br><span class="line">    JvmtiExport::<span class="built_in">post_monitor_contended_entered</span>(jt, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">    event.<span class="built_in">set_klass</span>(((oop)<span class="keyword">this</span>-&gt;<span class="built_in">object</span>())-&gt;<span class="built_in">klass</span>());</span><br><span class="line">    event.<span class="built_in">set_previousOwner</span>((TYPE_JAVALANGTHREAD)_previous_owner_tid);</span><br><span class="line">    event.<span class="built_in">set_address</span>((TYPE_ADDRESS)(<span class="type">uintptr_t</span>)(<span class="keyword">this</span>-&gt;<span class="built_in">object_addr</span>()));</span><br><span class="line">    event.<span class="built_in">commit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ObjectMonitor::_sync_ContendedLockAttempts != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     ObjectMonitor::_sync_ContendedLockAttempts-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码的流程概括如下：</p>
<ol>
<li>通过CAS尝试吧monitor的owner字段设置为当前线程</li>
<li>如果设置之前的owner指向当前线程，说明当前线程再次进入Monitor，即重入锁，执行_recursions++， 记录重入次数</li>
<li>如果当前线程是第一次进入该monitor，设置recursions为1，owner为当前线程，该线程成功获得锁并返回</li>
<li>如果获取锁失败，则等待锁的释放</li>
</ol>
<h2 id="monitor等待"><a href="#monitor等待" class="headerlink" title="monitor等待"></a>monitor等待</h2><p>竞争失败等待调用的是ObjectMonitor对象中的EnterI方法 (位于src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> ATTR <span class="title">ObjectMonitor::EnterI</span> <span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">    Thread * Self = THREAD ;</span><br><span class="line">    <span class="built_in">assert</span> (Self-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (((JavaThread *) Self)-&gt;<span class="built_in">thread_state</span>() == _thread_blocked   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try the lock - TATAS</span></span><br><span class="line">    <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span> (_succ != Self              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (_owner == Self             , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (_Responsible != Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeferredInitialize</span> () ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We try one round of spinning *before* enqueueing Self.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the _owner is ready but OFFPROC we could use a YieldTo()</span></span><br><span class="line">    <span class="comment">// operation to donate the remainder of this thread&#x27;s quantum</span></span><br><span class="line">    <span class="comment">// to the owner.  This has subtle but beneficial affinity</span></span><br><span class="line">    <span class="comment">// effects.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span> (_owner == Self        , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (_succ != Self         , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (_Responsible != Self  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Spin failed -- Enqueue and park the thread ...</span></span><br><span class="line">    <span class="built_in">assert</span> (_succ  != Self            , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (_owner != Self            , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (_Responsible != Self      , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue &quot;Self&quot; on ObjectMonitor&#x27;s _cxq.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Node acts as a proxy for Self.</span></span><br><span class="line">    <span class="comment">// As an aside, if were to ever rewrite the synchronization code mostly</span></span><br><span class="line">    <span class="comment">// in Java, WaitNodes, ObjectMonitors, and Events would become 1st-class</span></span><br><span class="line">    <span class="comment">// Java objects.  This would avoid awkward lifecycle and liveness issues,</span></span><br><span class="line">    <span class="comment">// as well as eliminate a subset of ABA issues.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> eliminate ObjectWaiter and enqueue either Threads or Events.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程被封装成ObjectWaiter对象node,状态设置为ObjectWaiter::TS_CXQ </span></span><br><span class="line">    <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span> </span>;</span><br><span class="line">    Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">    node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span> ;</span><br><span class="line">    node.TState  = ObjectWaiter::TS_CXQ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push &quot;Self&quot; onto the front of the _cxq.</span></span><br><span class="line">    <span class="comment">// Once on cxq/EntryList, Self stays on-queue until it acquires the lock.</span></span><br><span class="line">    <span class="comment">// Note that spinning tends to reduce the rate at which threads</span></span><br><span class="line">    <span class="comment">// enqueue and dequeue on EntryList|cxq.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过CAS吧node节点push到_cxq列表中</span></span><br><span class="line">    ObjectWaiter * nxt ;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        node._next = nxt = _cxq ;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Interference - the CAS failed because _cxq changed.  Just retry.</span></span><br><span class="line">        <span class="comment">// As an optional optimization we retry the lock.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">assert</span> (_succ != Self         , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            <span class="built_in">assert</span> (_owner == Self        , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            <span class="built_in">assert</span> (_Responsible != Self  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for cxq|EntryList edge transition to non-null.  This indicates</span></span><br><span class="line">    <span class="comment">// the onset of contention.  While contention persists exiting threads</span></span><br><span class="line">    <span class="comment">// will use a ST:MEMBAR:LD 1-1 exit protocol.  When contention abates exit</span></span><br><span class="line">    <span class="comment">// operations revert to the faster 1-0 mode.  This enter operation may interleave</span></span><br><span class="line">    <span class="comment">// (race) a concurrent 1-0 exit operation, resulting in stranding, so we</span></span><br><span class="line">    <span class="comment">// arrange for one of the contending thread to use a timed park() operations</span></span><br><span class="line">    <span class="comment">// to detect and recover from the race.  (Stranding is form of progress failure</span></span><br><span class="line">    <span class="comment">// where the monitor is unlocked but all the contending threads remain parked).</span></span><br><span class="line">    <span class="comment">// That is, at least one of the contended threads will periodically poll _owner.</span></span><br><span class="line">    <span class="comment">// One of the contending threads will become the designated &quot;Responsible&quot; thread.</span></span><br><span class="line">    <span class="comment">// The Responsible thread uses a timed park instead of a normal indefinite park</span></span><br><span class="line">    <span class="comment">// operation -- it periodically wakes and checks for and recovers from potential</span></span><br><span class="line">    <span class="comment">// strandings admitted by 1-0 exit operations.   We need at most one Responsible</span></span><br><span class="line">    <span class="comment">// thread per-monitor at any given moment.  Only threads on cxq|EntryList may</span></span><br><span class="line">    <span class="comment">// be responsible for a monitor.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Currently, one of the contended threads takes on the added role of &quot;Responsible&quot;.</span></span><br><span class="line">    <span class="comment">// A viable alternative would be to use a dedicated &quot;stranding checker&quot; thread</span></span><br><span class="line">    <span class="comment">// that periodically iterated over all the threads (or active monitors) and unparked</span></span><br><span class="line">    <span class="comment">// successors where there was risk of stranding.  This would help eliminate the</span></span><br><span class="line">    <span class="comment">// timer scalability issues we see on some platforms as we&#x27;d only have one thread</span></span><br><span class="line">    <span class="comment">// -- the checker -- parked on a timer.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">16</span>) == <span class="number">0</span> &amp;&amp; nxt == <span class="literal">NULL</span> &amp;&amp; _EntryList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Try to assume the role of responsible thread for the monitor.</span></span><br><span class="line">        <span class="comment">// CONSIDER:  ST vs CAS vs &#123; if (Responsible==null) Responsible=Self &#125;</span></span><br><span class="line">        Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The lock have been released while this thread was occupied queueing</span></span><br><span class="line">    <span class="comment">// itself onto _cxq.  To close the race and avoid &quot;stranding&quot; and</span></span><br><span class="line">    <span class="comment">// progress-liveness failure we must resample-retry _owner before parking.</span></span><br><span class="line">    <span class="comment">// Note the Dekker/Lamport duality: ST cxq; MEMBAR; LD Owner.</span></span><br><span class="line">    <span class="comment">// In this case the ST-MEMBAR is accomplished with CAS().</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Defer all thread state transitions until park-time.</span></span><br><span class="line">    <span class="comment">// Since state transitions are heavy and inefficient we&#x27;d like</span></span><br><span class="line">    <span class="comment">// to defer the state transitions until absolutely necessary,</span></span><br><span class="line">    <span class="comment">// and in doing so avoid some transitions ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">TEVENT</span> (Inflated enter - Contention) ;</span><br><span class="line">    <span class="type">int</span> nWakeups = <span class="number">0</span> ;</span><br><span class="line">    <span class="type">int</span> RecheckInterval = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程在被挂起之前做一下挣扎，看能不能获取到锁</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="built_in">assert</span> (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Responsible == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// park self</span></span><br><span class="line">        <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated enter - park TIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> ((jlong) RecheckInterval) ;</span><br><span class="line">            <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">            RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">            <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated enter - park UNTIMED) ;</span><br><span class="line">            <span class="comment">// 通过park将线程挂起，等待被唤醒</span></span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span>(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The lock is still contested.</span></span><br><span class="line">        <span class="comment">// Keep a tally of the # of futile wakeups.</span></span><br><span class="line">        <span class="comment">// Note that the counter is not protected by a lock or updated by atomics.</span></span><br><span class="line">        <span class="comment">// That is by design - we trade &quot;lossy&quot; counters which are exposed to</span></span><br><span class="line">        <span class="comment">// races during updates for a lower probe effect.</span></span><br><span class="line">        <span class="built_in">TEVENT</span> (Inflated enter - Futile wakeup) ;</span><br><span class="line">        <span class="keyword">if</span> (ObjectMonitor::_sync_FutileWakeups != <span class="literal">NULL</span>) &#123;</span><br><span class="line">           ObjectMonitor::_sync_FutileWakeups-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ nWakeups ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assuming this is not a spurious wakeup we&#x27;ll normally find _succ == Self.</span></span><br><span class="line">        <span class="comment">// We can defer clearing _succ until after the spin completes</span></span><br><span class="line">        <span class="comment">// TrySpin() must tolerate being called with _succ == Self.</span></span><br><span class="line">        <span class="comment">// Try yet another round of adaptive spinning.</span></span><br><span class="line">        <span class="keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="number">1</span>) &amp;&amp; <span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can find that we were unpark()ed and redesignated _succ while</span></span><br><span class="line">        <span class="comment">// we were spinning.  That&#x27;s harmless.  If we iterate and call park(),</span></span><br><span class="line">        <span class="comment">// park() will consume the event and return immediately and we&#x27;ll</span></span><br><span class="line">        <span class="comment">// just spin again.  This pattern can repeat, leaving _succ to simply</span></span><br><span class="line">        <span class="comment">// spin on a CPU.  Enable Knob_ResetEvent to clear pending unparks().</span></span><br><span class="line">        <span class="comment">// Alternately, we can sample fired() here, and if set, forgo spinning</span></span><br><span class="line">        <span class="comment">// in the next iteration.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((Knob_ResetEvent &amp; <span class="number">1</span>) &amp;&amp; Self-&gt;_ParkEvent-&gt;<span class="built_in">fired</span>()) &#123;</span><br><span class="line">           Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">           OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invariant: after clearing _succ a thread *must* retry _owner before parking.</span></span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Egress :</span></span><br><span class="line">    <span class="comment">// Self has acquired the lock -- Unlink Self from the cxq or EntryList.</span></span><br><span class="line">    <span class="comment">// Normally we&#x27;ll find Self on the EntryList .</span></span><br><span class="line">    <span class="comment">// From the perspective of the lock owner (this thread), the</span></span><br><span class="line">    <span class="comment">// EntryList is stable and cxq is prepend-only.</span></span><br><span class="line">    <span class="comment">// The head of cxq is volatile but the interior is stable.</span></span><br><span class="line">    <span class="comment">// In addition, Self.TState is stable.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span> (_owner == Self      , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (<span class="built_in">object</span>() != <span class="literal">NULL</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="comment">// I&#x27;d like to write:</span></span><br><span class="line">    <span class="comment">//   guarantee (((oop)(object()))-&gt;mark() == markOopDesc::encode(this), &quot;invariant&quot;) ;</span></span><br><span class="line">    <span class="comment">// but as we&#x27;re at a safepoint that&#x27;s not safe.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnlinkAfterAcquire</span> (Self, &amp;node) ;</span><br><span class="line">    <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span> (_succ != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (_Responsible == Self) &#123;</span><br><span class="line">        _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>(); <span class="comment">// Dekker pivot-point</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We may leave threads on cxq|EntryList without a designated</span></span><br><span class="line">        <span class="comment">// &quot;Responsible&quot; thread.  This is benign.  When this thread subsequently</span></span><br><span class="line">        <span class="comment">// exits the monitor it can &quot;see&quot; such preexisting &quot;old&quot; threads --</span></span><br><span class="line">        <span class="comment">// threads that arrived on the cxq|EntryList before the fence, above --</span></span><br><span class="line">        <span class="comment">// by LDing cxq|EntryList.  Newly arrived threads -- that is, threads</span></span><br><span class="line">        <span class="comment">// that arrive on cxq after the ST:MEMBAR, above -- will set Responsible</span></span><br><span class="line">        <span class="comment">// non-null and elect a new &quot;Responsible&quot; timer thread.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This thread executes:</span></span><br><span class="line">        <span class="comment">//    ST Responsible=null; MEMBAR    (in enter epilog - here)</span></span><br><span class="line">        <span class="comment">//    LD cxq|EntryList               (in subsequent exit)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Entering threads in the slow/contended path execute:</span></span><br><span class="line">        <span class="comment">//    ST cxq=nonnull; MEMBAR; LD Responsible (in enter prolog)</span></span><br><span class="line">        <span class="comment">//    The (ST cxq; MEMBAR) is accomplished with CAS().</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The MEMBAR, above, prevents the LD of cxq|EntryList in the subsequent</span></span><br><span class="line">        <span class="comment">// exit operation from floating above the ST Responsible=null.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;ve acquired ownership with CAS().</span></span><br><span class="line">    <span class="comment">// CAS is serializing -- it has MEMBAR/FENCE-equivalent semantics.</span></span><br><span class="line">    <span class="comment">// But since the CAS() this thread may have also stored into _succ,</span></span><br><span class="line">    <span class="comment">// EntryList, cxq or Responsible.  These meta-data updates must be</span></span><br><span class="line">    <span class="comment">// visible __before this thread subsequently drops the lock.</span></span><br><span class="line">    <span class="comment">// Consider what could occur if we didn&#x27;t enforce this constraint --</span></span><br><span class="line">    <span class="comment">// STs to monitor meta-data and user-data could reorder with (become</span></span><br><span class="line">    <span class="comment">// visible after) the ST in exit that drops ownership of the lock.</span></span><br><span class="line">    <span class="comment">// Some other thread could then acquire the lock, but observe inconsistent</span></span><br><span class="line">    <span class="comment">// or old monitor meta-data and heap data.  That violates the JMM.</span></span><br><span class="line">    <span class="comment">// To that end, the 1-0 exit() operation must have at least STST|LDST</span></span><br><span class="line">    <span class="comment">// &quot;release&quot; barrier semantics.  Specifically, there must be at least a</span></span><br><span class="line">    <span class="comment">// STST|LDST barrier in exit() before the ST of null into _owner that drops</span></span><br><span class="line">    <span class="comment">// the lock.   The barrier ensures that changes to monitor meta-data and data</span></span><br><span class="line">    <span class="comment">// protected by the lock will be visible before we release the lock, and</span></span><br><span class="line">    <span class="comment">// therefore before some other thread (CPU) has a chance to acquire the lock.</span></span><br><span class="line">    <span class="comment">// See also: http://gee.cs.oswego.edu/dl/jmm/cookbook.html.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Critically, any prior STs to _succ or EntryList must be visible before</span></span><br><span class="line">    <span class="comment">// the ST of null into _owner in the *subsequent* (following) corresponding</span></span><br><span class="line">    <span class="comment">// monitorexit.  Recall too, that in 1-0 mode monitorexit does not necessarily</span></span><br><span class="line">    <span class="comment">// execute a serializing instruction.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SyncFlags &amp; <span class="number">8</span>) &#123;</span><br><span class="line">       OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当线程被唤醒时，会从挂起的点继续执行，通过ObjectMonitor::TryLock尝试获取锁，TryLock方法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ObjectMonitor::TryLock</span> <span class="params">(Thread * Self)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="type">void</span> * own = _owner ;</span><br><span class="line">      <span class="keyword">if</span> (own != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">      <span class="comment">// CAS</span></span><br><span class="line">      <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="comment">// Either guarantee _recursions == 0 or set _recursions = 0.</span></span><br><span class="line">         <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="built_in">assert</span> (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="comment">// CONSIDER: set or assert that OwnerIsThread == 1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The lock had been free momentarily, but we lost the race to the lock.</span></span><br><span class="line">      <span class="comment">// Interference -- the CAS failed.</span></span><br><span class="line">      <span class="comment">// We can either return -1 or retry.</span></span><br><span class="line">      <span class="comment">// Retry doesn&#x27;t make as much sense because the lock was just acquired.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码概括流程如下：</p>
<ol>
<li>当前线程被封装成ObjectWaiter对象node，状态设置为ObjectWaiter::TS_CXQ</li>
<li>在for循环中，通过CAS把node节点Push到_cxq列表中，同一时刻可能有多个线程吧自己的node节点push到 _cxq列表中</li>
<li>node节点push到_cxq列表之后，通过自旋尝试获取锁，如果还是被有获取到锁，则通过Park将当前线程挂起，等待被唤醒</li>
<li>当该线程被唤醒时，会从挂起点继续执行，通过ObjectWaiter::TryLock尝试获取锁</li>
</ol>
<h2 id="monitor释放"><a href="#monitor释放" class="headerlink" title="monitor释放"></a>monitor释放</h2><p>当某个持有锁的线程执行完同步代码块时，会进行锁的释放。通过退出monitor的方式实现锁的释放，并通知被阻塞的线程，具体实现位于ObjectMonitor的exit方法中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> ATTR <span class="title">ObjectMonitor::exit</span><span class="params">(<span class="type">bool</span> not_suspended, TRAPS)</span> </span>&#123;</span><br><span class="line">   Thread * Self = THREAD ;</span><br><span class="line">   <span class="keyword">if</span> (THREAD != _owner) &#123;</span><br><span class="line">     <span class="keyword">if</span> (THREAD-&gt;<span class="built_in">is_lock_owned</span>((address) _owner)) &#123;</span><br><span class="line">       <span class="comment">// Transmute _owner from a BasicLock pointer to a Thread address.</span></span><br><span class="line">       <span class="comment">// We don&#x27;t need to hold _mutex for this transition.</span></span><br><span class="line">       <span class="comment">// Non-null to Non-null is safe as long as all readers can</span></span><br><span class="line">       <span class="comment">// tolerate either flavor.</span></span><br><span class="line">       <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">       _owner = THREAD ;</span><br><span class="line">       _recursions = <span class="number">0</span> ;</span><br><span class="line">       OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// <span class="doctag">NOTE:</span> we need to handle unbalanced monitor enter/exit</span></span><br><span class="line">       <span class="comment">// in native code by throwing an exception.</span></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Throw an IllegalMonitorStateException ?</span></span><br><span class="line">       <span class="built_in">TEVENT</span> (Exit - Throw IMSX) ;</span><br><span class="line">       <span class="built_in">assert</span>(<span class="literal">false</span>, <span class="string">&quot;Non-balanced monitor enter/exit!&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_IllegalMonitorStateException</span>());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (_recursions != <span class="number">0</span>) &#123;</span><br><span class="line">     _recursions--;        <span class="comment">// this is simple recursive enter</span></span><br><span class="line">     <span class="built_in">TEVENT</span> (Inflated exit - recursive) ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Invariant: after setting Responsible=null an thread must execute</span></span><br><span class="line">   <span class="comment">// a MEMBAR or other serializing instruction before fetching EntryList|cxq.</span></span><br><span class="line">   <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INCLUDE_TRACE</span></span><br><span class="line">   <span class="comment">// get the owner&#x27;s thread id for the MonitorEnter event</span></span><br><span class="line">   <span class="comment">// if it is enabled and the thread isn&#x27;t suspended</span></span><br><span class="line">   <span class="keyword">if</span> (not_suspended &amp;&amp; Tracing::<span class="built_in">is_event_enabled</span>(TraceJavaMonitorEnterEvent)) &#123;</span><br><span class="line">     _previous_owner_tid = SharedRuntime::<span class="built_in">get_java_tid</span>(Self);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="built_in">assert</span> (THREAD == _owner, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Knob_ExitPolicy == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// release semantics: prior loads and stores from within the critical section</span></span><br><span class="line">         <span class="comment">// must not float (reorder) past the following store that drops the lock.</span></span><br><span class="line">         <span class="comment">// On SPARC that requires MEMBAR #loadstore|#storestore.</span></span><br><span class="line">         <span class="comment">// But of course in TSO #loadstore|#storestore is not required.</span></span><br><span class="line">         <span class="comment">// I&#x27;d like to write one of the following:</span></span><br><span class="line">         <span class="comment">// A.  OrderAccess::release() ; _owner = NULL</span></span><br><span class="line">         <span class="comment">// B.  OrderAccess::loadstore(); OrderAccess::storestore(); _owner = NULL;</span></span><br><span class="line">         <span class="comment">// Unfortunately OrderAccess::release() and OrderAccess::loadstore() both</span></span><br><span class="line">         <span class="comment">// store into a _dummy variable.  That store is not needed, but can result</span></span><br><span class="line">         <span class="comment">// in massive wasteful coherency traffic on classic SMP systems.</span></span><br><span class="line">         <span class="comment">// Instead, I use release_store(), which is implemented as just a simple</span></span><br><span class="line">         <span class="comment">// ST on x64, x86 and SPARC.</span></span><br><span class="line">         OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;   <span class="comment">// drop the lock</span></span><br><span class="line">         OrderAccess::<span class="built_in">storeload</span>() ;                         <span class="comment">// See if we need to wake a successor</span></span><br><span class="line">         <span class="keyword">if</span> ((<span class="built_in">intptr_t</span>(_EntryList)|<span class="built_in">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated exit - simple egress) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">TEVENT</span> (Inflated exit - complex egress) ;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Normally the exiting thread is responsible for ensuring succession,</span></span><br><span class="line">         <span class="comment">// but if other successors are ready or other entering threads are spinning</span></span><br><span class="line">         <span class="comment">// then this thread can simply store NULL into _owner and exit without</span></span><br><span class="line">         <span class="comment">// waking a successor.  The existence of spinners or ready successors</span></span><br><span class="line">         <span class="comment">// guarantees proper succession (liveness).  Responsibility passes to the</span></span><br><span class="line">         <span class="comment">// ready or running successors.  The exiting thread delegates the duty.</span></span><br><span class="line">         <span class="comment">// More precisely, if a successor already exists this thread is absolved</span></span><br><span class="line">         <span class="comment">// of the responsibility of waking (unparking) one.</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// The _succ variable is critical to reducing futile wakeup frequency.</span></span><br><span class="line">         <span class="comment">// _succ identifies the &quot;heir presumptive&quot; thread that has been made</span></span><br><span class="line">         <span class="comment">// ready (unparked) but that has not yet run.  We need only one such</span></span><br><span class="line">         <span class="comment">// successor thread to guarantee progress.</span></span><br><span class="line">         <span class="comment">// See http://www.usenix.org/events/jvm01/full_papers/dice/dice.pdf</span></span><br><span class="line">         <span class="comment">// section 3.3 &quot;Futile Wakeup Throttling&quot; for details.</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// Note that spinners in Enter() also set _succ non-null.</span></span><br><span class="line">         <span class="comment">// In the current implementation spinners opportunistically set</span></span><br><span class="line">         <span class="comment">// _succ so that exiting threads might avoid waking a successor.</span></span><br><span class="line">         <span class="comment">// Another less appealing alternative would be for the exiting thread</span></span><br><span class="line">         <span class="comment">// to drop the lock and then spin briefly to see if a spinner managed</span></span><br><span class="line">         <span class="comment">// to acquire the lock.  If so, the exiting thread could exit</span></span><br><span class="line">         <span class="comment">// immediately without waking a successor, otherwise the exiting</span></span><br><span class="line">         <span class="comment">// thread would need to dequeue and wake a successor.</span></span><br><span class="line">         <span class="comment">// (Note that we&#x27;d need to make the post-drop spin short, but no</span></span><br><span class="line">         <span class="comment">// shorter than the worst-case round-trip cache-line migration time.</span></span><br><span class="line">         <span class="comment">// The dropped lock needs to become visible to the spinner, and then</span></span><br><span class="line">         <span class="comment">// the acquisition of the lock by the spinner must become visible to</span></span><br><span class="line">         <span class="comment">// the exiting thread).</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// It appears that an heir-presumptive (successor) must be made ready.</span></span><br><span class="line">         <span class="comment">// Only the current lock owner can manipulate the EntryList or</span></span><br><span class="line">         <span class="comment">// drain _cxq, so we need to reacquire the lock.  If we fail</span></span><br><span class="line">         <span class="comment">// to reacquire the lock the responsibility for ensuring succession</span></span><br><span class="line">         <span class="comment">// falls to the new owner.</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">TEVENT</span> (Exit - Reacquired) ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> ((<span class="built_in">intptr_t</span>(_EntryList)|<span class="built_in">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;   <span class="comment">// drop the lock</span></span><br><span class="line">            OrderAccess::<span class="built_in">storeload</span>() ;</span><br><span class="line">            <span class="comment">// Ratify the previously observed values.</span></span><br><span class="line">            <span class="keyword">if</span> (_cxq == <span class="literal">NULL</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">TEVENT</span> (Inflated exit - simple egress) ;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// inopportune interleaving -- the exiting thread (this thread)</span></span><br><span class="line">            <span class="comment">// in the fast-exit path raced an entering thread in the slow-enter</span></span><br><span class="line">            <span class="comment">// path.</span></span><br><span class="line">            <span class="comment">// We have two choices:</span></span><br><span class="line">            <span class="comment">// A.  Try to reacquire the lock.</span></span><br><span class="line">            <span class="comment">//     If the CAS() fails return immediately, otherwise</span></span><br><span class="line">            <span class="comment">//     we either restart/rerun the exit operation, or simply</span></span><br><span class="line">            <span class="comment">//     fall-through into the code below which wakes a successor.</span></span><br><span class="line">            <span class="comment">// B.  If the elements forming the EntryList|cxq are TSM</span></span><br><span class="line">            <span class="comment">//     we could simply unpark() the lead thread and return</span></span><br><span class="line">            <span class="comment">//     without having set _succ.</span></span><br><span class="line">            <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">TEVENT</span> (Inflated exit - reacquired succeeded) ;</span><br><span class="line">               <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated exit - reacquired failed) ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated exit - complex egress) ;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">guarantee</span> (_owner == THREAD, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      ObjectWaiter * w = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="type">int</span> QMode = Knob_QMode ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//QMode == 2 :直接绕过EntryList队列，从cxq中回去线程用于竞争锁</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">2</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// QMode == 2 : cxq has precedence over EntryList.</span></span><br><span class="line">          <span class="comment">// Try to directly wake a successor from the cxq.</span></span><br><span class="line">          <span class="comment">// If successful, the successor will need to unlink itself from cxq.</span></span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">assert</span> (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// QMode == 3 :cxq队列插入EntryList尾部</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">3</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// Aggressively drain cxq into EntryList at the first opportunity.</span></span><br><span class="line">          <span class="comment">// This policy ensure that recently-run threads live at the head of EntryList.</span></span><br><span class="line">          <span class="comment">// Drain _cxq into EntryList - bulk transfer.</span></span><br><span class="line">          <span class="comment">// First, detach _cxq.</span></span><br><span class="line">          <span class="comment">// The following loop is tantamount to: w = swap (&amp;cxq, NULL)</span></span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Append the RATs to the EntryList</span></span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> organize EntryList as a CDLL so we can locate the tail in constant-time.</span></span><br><span class="line">          ObjectWaiter * Tail ;</span><br><span class="line">          <span class="keyword">for</span> (Tail = _EntryList ; Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">          <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">              _EntryList = w ;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Tail-&gt;_next = w ;</span><br><span class="line">              w-&gt;_prev = Tail ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// QMode == 4： cxq队列插入到EntryList头部</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">4</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// Aggressively drain cxq into EntryList at the first opportunity.</span></span><br><span class="line">          <span class="comment">// This policy ensure that recently-run threads live at the head of EntryList.</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// Drain _cxq into EntryList - bulk transfer.</span></span><br><span class="line">          <span class="comment">// First, detach _cxq.</span></span><br><span class="line">          <span class="comment">// The following loop is tantamount to: w = swap (&amp;cxq, NULL)</span></span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Prepend the RATs to the EntryList</span></span><br><span class="line">          <span class="keyword">if</span> (_EntryList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              q-&gt;_next = _EntryList ;</span><br><span class="line">              _EntryList-&gt;_prev = q ;</span><br><span class="line">          &#125;</span><br><span class="line">          _EntryList = w ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到w,执行唤醒</span></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// I&#x27;d like to write: guarantee (w-&gt;_thread != Self).</span></span><br><span class="line">          <span class="comment">// But in practice an exiting thread may find itself on the EntryList.</span></span><br><span class="line">          <span class="comment">// Lets say thread T1 calls O.wait().  Wait() enqueues T1 on O&#x27;s waitset and</span></span><br><span class="line">          <span class="comment">// then calls exit().  Exit release the lock by setting O._owner to NULL.</span></span><br><span class="line">          <span class="comment">// Lets say T1 then stalls.  T2 acquires O and calls O.notify().  The</span></span><br><span class="line">          <span class="comment">// notify() operation moves T1 from O&#x27;s waitset to O&#x27;s EntryList. T2 then</span></span><br><span class="line">          <span class="comment">// release the lock &quot;O&quot;.  T2 resumes immediately after the ST of null into</span></span><br><span class="line">          <span class="comment">// _owner, above.  T2 notices that the EntryList is populated, so it</span></span><br><span class="line">          <span class="comment">// reacquires the lock and then finds itself on the EntryList.</span></span><br><span class="line">          <span class="comment">// Given all that, we have to tolerate the circumstance where &quot;w&quot; is</span></span><br><span class="line">          <span class="comment">// associated with Self.</span></span><br><span class="line">          <span class="built_in">assert</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If we find that both _cxq and EntryList are null then just</span></span><br><span class="line">      <span class="comment">// re-run the exit protocol from the top.</span></span><br><span class="line">      w = _cxq ;</span><br><span class="line">      <span class="keyword">if</span> (w == <span class="literal">NULL</span>) <span class="keyword">continue</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Drain _cxq into EntryList - bulk transfer.</span></span><br><span class="line">      <span class="comment">// First, detach _cxq.</span></span><br><span class="line">      <span class="comment">// The following loop is tantamount to: w = swap (&amp;cxq, NULL)</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">          <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">          w = u ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">TEVENT</span> (Inflated exit - drain cxq into EntryList) ;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      <span class="built_in">assert</span> (_EntryList  == <span class="literal">NULL</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Convert the LIFO SLL anchored by _cxq into a DLL.</span></span><br><span class="line">      <span class="comment">// The list reorganization step operates in O(LENGTH(w)) time.</span></span><br><span class="line">      <span class="comment">// It&#x27;s critical that this step operate quickly as</span></span><br><span class="line">      <span class="comment">// &quot;Self&quot; still holds the outer-lock, restricting parallelism</span></span><br><span class="line">      <span class="comment">// and effectively lengthening the critical section.</span></span><br><span class="line">      <span class="comment">// Invariant: s chases t chases u.</span></span><br><span class="line">      <span class="comment">// TODO-<span class="doctag">FIXME:</span> consider changing EntryList from a DLL to a CDLL so</span></span><br><span class="line">      <span class="comment">// we have faster access to the tail.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// QMode == 1 : drain cxq to EntryList, reversing order</span></span><br><span class="line">         <span class="comment">// We also reverse the order of the list.</span></span><br><span class="line">         ObjectWaiter * s = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * t = w ;</span><br><span class="line">         ObjectWaiter * u = <span class="literal">NULL</span> ;</span><br><span class="line">         <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">             <span class="built_in">guarantee</span> (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">             t-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             u = t-&gt;_next ;</span><br><span class="line">             t-&gt;_prev = u ;</span><br><span class="line">             t-&gt;_next = s ;</span><br><span class="line">             s = t;</span><br><span class="line">             t = u ;</span><br><span class="line">         &#125;</span><br><span class="line">         _EntryList  = s ;</span><br><span class="line">         <span class="built_in">assert</span> (s != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// QMode == 0 or QMode == 2</span></span><br><span class="line">         _EntryList = w ;</span><br><span class="line">         ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * p ;</span><br><span class="line">         <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">             <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             p-&gt;_prev = q ;</span><br><span class="line">             q = p ;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// In 1-0 mode we need: ST EntryList; MEMBAR #storestore; ST _owner = NULL</span></span><br><span class="line">      <span class="comment">// The MEMBAR is satisfied by the release_store() operation in ExitEpilog().</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// See if we can abdicate to a spinner instead of waking a thread.</span></span><br><span class="line">      <span class="comment">// A primary goal of the implementation is to reduce the</span></span><br><span class="line">      <span class="comment">// context-switch rate.</span></span><br><span class="line">      <span class="keyword">if</span> (_succ != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="built_in">guarantee</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>退出同步代码块会让_recursions减1,当_recursions 为0时，说明线程释放了锁。</li>
<li>根据不同策略（由Qmode指定，从cxq或entryList中获取头节点，通过）ObjectMonitor::ExitEpilog方法唤醒该节点封装的线程，唤醒操作最终有unpark完成，实现如下：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectMonitor::ExitEpilog</span> <span class="params">(Thread * Self, ObjectWaiter * Wakee)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">assert</span> (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Exit protocol:</span></span><br><span class="line">   <span class="comment">// 1. ST _succ = wakee</span></span><br><span class="line">   <span class="comment">// 2. membar #loadstore|#storestore;</span></span><br><span class="line">   <span class="comment">// 2. ST _owner = NULL</span></span><br><span class="line">   <span class="comment">// 3. unpark(wakee)</span></span><br><span class="line"></span><br><span class="line">   _succ = Knob_SuccEnabled ? Wakee-&gt;_thread : <span class="literal">NULL</span> ;</span><br><span class="line">   ParkEvent * Trigger = Wakee-&gt;_event ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Hygiene -- once we&#x27;ve set _owner = NULL we can&#x27;t safely dereference Wakee again.</span></span><br><span class="line">   <span class="comment">// The thread associated with Wakee may have grabbed the lock and &quot;Wakee&quot; may be</span></span><br><span class="line">   <span class="comment">// out-of-scope (non-extant).</span></span><br><span class="line">   Wakee  = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Drop the lock</span></span><br><span class="line">   OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">   OrderAccess::<span class="built_in">fence</span>() ;                               <span class="comment">// ST _owner vs LD in unpark()</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (SafepointSynchronize::<span class="built_in">do_call_back</span>()) &#123;</span><br><span class="line">      <span class="built_in">TEVENT</span> (unpark before SAFEPOINT) ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">DTRACE_MONITOR_PROBE</span>(contended__exit, <span class="keyword">this</span>, <span class="built_in">object</span>(), Self);</span><br><span class="line">    <span class="comment">// 唤醒之前被park()挂起的线程</span></span><br><span class="line">   Trigger-&gt;<span class="built_in">unpark</span>() ;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Maintain stats and report events to JVMTI</span></span><br><span class="line">   <span class="keyword">if</span> (ObjectMonitor::_sync_Parks != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ObjectMonitor::_sync_Parks-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被唤醒的线程，会回到ATTR ObjectMonitor::EnterI (TRAPS)继续执行monitor竞争</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// park self</span></span><br><span class="line"><span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="built_in">TEVENT</span> (Inflated enter - park TIMED) ;</span><br><span class="line">    Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> ((jlong) RecheckInterval) ;</span><br><span class="line">    <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">    RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">    <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">TEVENT</span> (Inflated enter - park UNTIMED) ;</span><br><span class="line">    Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span>() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">TryLock</span>(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br></pre></td></tr></table></figure>



<h2 id="monitor是重量级锁"><a href="#monitor是重量级锁" class="headerlink" title="monitor是重量级锁"></a>monitor是重量级锁</h2><p>ObjectMonitor的函数调用中会涉及到Atomic::cmpxchg_ptr，Atimic::inc_ptr等内核函数，执行同步代码块，没有竞争到锁的对象会被park()挂起，竞争到锁的线程会unpark()唤醒。这个时候会存在操作系统用户态和内核态的转换，这个切换会消耗大量的系统资源，所以synchronized是java语言中的一个重量级(Heavyweight)的操作。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e311ad8f1c.png" alt="Screenshot_20200530_171931"></p>
<p>Linux操作系统的体系架构分为：用户空间和内核</p>
<p>内核：本质上可以理解成一种软件，控制计算机硬件资源，提供上层应用程序的运行环境</p>
<p>用户空间：上层应用程序活动的空间，应用程序的执行必须依托与内核提供的资源，包括CPU、存储资源、I&#x2F;O资源等</p>
<p>系统调用：为了使上层应用能访问这些资源，内核必须为上层应用提供访问接口：即系统调用</p>
<p>系统调用过程：</p>
<ol>
<li>用户态程序将一些数值存放寄存器中，或是使用参数创建一个堆栈，以此表明需要操作系统提供服务</li>
<li>用户态程序执行系统调用</li>
<li>CPU切换到内核态，并跳到位于内存指定位置的指令</li>
<li>系统调用处理器(system call handler)会读取程序存放入内存的数据参数，并执行程序请求的服务。</li>
<li>系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果</li>
</ol>
<p>在用户态和内核态的切换过程中，需要传递许多变量，同时内核还需要保存好用户态在切换时的一些寄存器的值、变量等，以备内核态切换回用户态。这种切换会带来巨大的资源消耗</p>
<h1 id="JDK6-Synchronized优化"><a href="#JDK6-Synchronized优化" class="headerlink" title="JDK6  Synchronized优化"></a>JDK6  Synchronized优化</h1><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>Compare And Swap，现在CPU广泛支持的一种对内存中共享数据进行操作的一种特殊指令</p>
<p>CAS可以将比较和交换转换为原子操作，这个原子操作直接由CPU保证，CAS可以保证共享变量赋值时的原子操作。</p>
<p>CAS操作依赖3个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧的预估值X等于内存中值V,就将新的值保存到内存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ansore.cas;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示原子性问题</span></span><br><span class="line"><span class="comment"> * 1.定义一个共享变量number</span></span><br><span class="line"><span class="comment"> * 2.对number进行1000次++操作</span></span><br><span class="line"><span class="comment"> * 3.使用5个线程进行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="comment">// 1.定义一个共享变量number</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 2.对number进行1000次</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">increment</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">                atomicInteger.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        List&lt;Thread&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 3.使用5个线程来进行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i ++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(increment);</span><br><span class="line">            t.start();</span><br><span class="line">            list.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Thread t : list) &#123;</span><br><span class="line">            <span class="comment">// 等待线程执行完毕</span></span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;number=&quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>Unsafe类提供原子操作</p>
<p>Unsafe类可以操作内存空间。同时也带来指针问题，过度使用Unsafe类会使得出错几率变大。Unsafe对象不能直接调用，只能通过反射获得</p>
<p><img src="https://img.ansore.de/2022/05/01/626e312911b39.png" alt="Screenshot_20200530_175229"></p>
<h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>悲观锁，每次拿数据都认为别人会修改，所以在每次拿数据都会上锁，这样别人想拿到数据时就会阻塞。因此synchronized我们也称其为悲观锁，JDK中ReentrantLock也是一种悲观锁。性能较差！</p>
<p>乐观锁，每次去拿数据都会认为别人不会修改，就算修改了也没关系，重试即可，所以不会上锁。但是总是在更新时判断一下在此期间别人有没有去修改这个数据，如果没有则更新，有则重试。</p>
<p>CAS这种机制可以称为乐观锁，综合性能较好。</p>
<p>CAS共享变量时，为了保证该变量的可见性，需要使用volatile修饰，结合CAS和volatile可以实现无锁并发，适合于竞争不激烈、多核CPU的场景下：</p>
<ol>
<li>因为没有synchronized，所以线程不会阻塞，这是效率提升的因素之一</li>
<li>如果竞争激烈，可以想到重试必然会频繁发生，反而效率会受影响</li>
</ol>
<h3 id="Synchronized锁升级过程"><a href="#Synchronized锁升级过程" class="headerlink" title="Synchronized锁升级过程"></a>Synchronized锁升级过程</h3><p>JDK1.6锁升级，包含偏向锁、轻量级锁和适应性自旋、锁消除、锁粗化等。这些技术都是为了线程间更高效的数据共享</p>
<p>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</p>
<h2 id="java对象的布局"><a href="#java对象的布局" class="headerlink" title="java对象的布局"></a>java对象的布局</h2><p>JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e3131c18c3.png" alt="Screenshot_20200530_180450"></p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>HotSpot采用InstanceOopDesc和arrayOopDesc来描述对象头，arrayOopDesc对象用来描述数组类型。InstanceOopDesc的定义的在HotSpot源码中instanceOop.hpp文件中，arrayOopDesc的定义对应arrayOop.hpp。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">instanceOopDesc</span> : <span class="keyword">public</span> oopDesc &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// aligned header size.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">header_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sizeof</span>(instanceOopDesc)/HeapWordSize; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If compressed, the offset of the fields of the instance may not be aligned.</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">base_offset_in_bytes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// offset computation code breaks if UseCompressedClassPointers</span></span><br><span class="line">    <span class="comment">// only is true</span></span><br><span class="line">    <span class="keyword">return</span> (UseCompressedOops &amp;&amp; UseCompressedClassPointers) ?</span><br><span class="line">             <span class="built_in">klass_gap_offset_in_bytes</span>() :</span><br><span class="line">             <span class="built_in">sizeof</span>(instanceOopDesc);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">contains_field_offset</span><span class="params">(<span class="type">int</span> offset, <span class="type">int</span> nonstatic_field_size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> base_in_bytes = <span class="built_in">base_offset_in_bytes</span>();</span><br><span class="line">    <span class="keyword">return</span> (offset &gt;= base_in_bytes &amp;&amp;</span><br><span class="line">            (offset-base_in_bytes) &lt; nonstatic_field_size * heapOopSize);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>继承了oopDesc：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">oopDesc</span> &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">VMStructs</span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> markOop  _mark;</span><br><span class="line">  <span class="keyword">union</span> <span class="title class_">_metadata</span> &#123;</span><br><span class="line">    Klass*      _klass;</span><br><span class="line">    narrowKlass _compressed_klass;</span><br><span class="line">  &#125; _metadata;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fast access to barrier set.  Must be initialized.</span></span><br><span class="line">  <span class="type">static</span> BarrierSet* _bs;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在普通实例对象中，oopDesc的定义包含两个成员：_mark和_metadata</p>
<p>_mark表示对象标记、属于markOop类型，记录了对象和锁有关的信息</p>
<p>_metadata表示类元信息，类元信息存储的是对象指向它的类元数据(Klass)的首地址，其中Klass表示普通指针、_compressed_klass表示压缩类指针</p>
<p>对象头由两部分组成，一部分用于存储自身运行时数据，称之为mark word，另一部分是类型指针，及对象指向它的类元数据的指针。</p>
<h4 id="mark-word"><a href="#mark-word" class="headerlink" title="mark word"></a>mark word</h4><p>mark word用于存储对象自身的运行时数据，如哈希码(HashCode)，GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致，mark word对应的类型是markOop，源码位于markOop.hpp中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread</span></span><br><span class="line"><span class="comment">//    [0           | epoch | age | 1 | 01]       lock is anonymously biased</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  - the two lock bits are used to describe three states: locked/unlocked and monitor.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    [ptr             | 00]  locked             ptr points to real header on stack</span></span><br><span class="line"><span class="comment">//    [header      | 0 | 01]  unlocked           regular object header</span></span><br><span class="line"><span class="comment">//    [ptr             | 10]  monitor            inflated lock (header is wapped out)</span></span><br><span class="line"><span class="comment">//    [ptr             | 11]  marked             used by markSweep to mark an object</span></span><br><span class="line"><span class="comment">//                                               not valid at any other time</span></span><br></pre></td></tr></table></figure>



<p><img src="https://img.ansore.de/2022/05/01/626e313d854a6.png" alt="Screenshot_20200530_183219"></p>
<p>在64位虚拟机下，mark word是64bit大小，其存储结构如下：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e314685eda.png" alt="Screenshot_20200530_183329"></p>
<p>在32位虚拟机下，mark word是32bit大小，其存储结构如下：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e314e04fd7.png" alt="Screenshot_20200530_215527"></p>
<h4 id="klass-pointer"><a href="#klass-pointer" class="headerlink" title="klass pointer"></a>klass pointer</h4><p>这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象良哪个类的实例。该指针的位长度为jVM的一个字大小，即32位的JVM为32位，64位的jVM为64位。</p>
<p>如果应用的对象过多，使用64位指针将大量浪费内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内存，为了节约内存可以使用选项-XX:+UseCompressedOops开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位：</p>
<ol>
<li>每个class的属性指针（即静态变量）</li>
<li>每个对象的属性指针（即对象变量）</li>
<li>普通对象数组的每个元素指针</li>
</ol>
<p>当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等</p>
<p>对象头 &#x3D; Mark Word + 类型指针（未开启指针压缩的情况）</p>
<p>32位系统中，Mark Word &#x3D; 4 byte ，类型指针&#x3D;4 bytes，对象头&#x3D;8bytes &#x3D; 64bits</p>
<p>64位系统中，Mark Word &#x3D; 8 byte ，类型指针&#x3D;8 bytes，对象头&#x3D;16bytes &#x3D; 64bits</p>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>类中定义的成员变量</p>
<h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>对齐填充并不是必然存在的，也没有什么特别的意义，它仅仅起着占位符的作用，由于HotSpot VM的自动内存管理系统要求对象的起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍，而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补充。</p>
<h4 id="查看JAVA对象布局"><a href="#查看JAVA对象布局" class="headerlink" title="查看JAVA对象布局"></a>查看JAVA对象布局</h4><p>pom引入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockObj</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockObj</span> <span class="variable">lockObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockObj</span>();</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(lockObj).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 默认开启指针压缩</span><br><span class="line">com.ansore.object_layout.LockObj object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           43 c1 00 f8 (01000011 11000001 00000000 11111000) (-134168253)</span><br><span class="line">     12     4    int LockObj.x                                 0</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br><span class="line"></span><br><span class="line">// 运行参数去掉指针压缩 -XX:-UseCompressedOops</span><br><span class="line">com.ansore.object_layout.LockObj object internals:</span><br><span class="line"> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4        (object header)                           d8 a4 94 f2 (11011000 10100100 10010100 11110010) (-225139496)</span><br><span class="line">     12     4        (object header)                           92 7f 00 00 (10010010 01111111 00000000 00000000) (32658)</span><br><span class="line">     16     4    int LockObj.x                                 0</span><br><span class="line">     20     4        (loss due to the next object alignment)</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</span><br></pre></td></tr></table></figure>

<p>开启指针压缩的情况下，改变类的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockObj</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.ansore.object_layout.LockObj object internals:</span><br><span class="line"> OFFSET  SIZE      TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4           (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)</span><br><span class="line">      4     4           (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)</span><br><span class="line">      8     4           (object header)                           43 c1 00 f8 (01000011 11000001 00000000 11111000) (-134168253)</span><br><span class="line">     12     4       int LockObj.x                                 0</span><br><span class="line">     16     1   boolean LockObj.b                                 false</span><br><span class="line">     17     7           (loss due to the next object alignment)</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 0 bytes internal + 7 bytes external = 7 bytes total</span><br></pre></td></tr></table></figure>

<p>自动填充了7个字节</p>
<p>HashCode值只有调用hashcode方法的时候才会生成</p>
<p>调用转成16进制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LockObj</span> <span class="variable">lockObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LockObj</span>();</span><br><span class="line">        System.out.println(Integer.toHexString(lockObj.hashCode()));</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(lockObj).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">135fbaa4</span><br><span class="line"></span><br><span class="line">com.ansore.object_layout.LockObj object internals:</span><br><span class="line"> OFFSET  SIZE      TYPE DESCRIPTION                               VALUE</span><br><span class="line">      0     4           (object header)                           01 a4 ba 5f (00000001 10100100 10111010 01011111) (1606067201)</span><br><span class="line">      4     4           (object header)                           13 00 00 00 (00010011 00000000 00000000 00000000) (19)</span><br><span class="line">      8     4           (object header)                           43 c1 00 f8 (01000011 11000001 00000000 11111000) (-134168253)</span><br><span class="line">     12     4       int LockObj.x                                 0</span><br><span class="line">     16     1   boolean LockObj.b                                 false</span><br><span class="line">     17     7           (loss due to the next object alignment)</span><br><span class="line">Instance size: 24 bytes</span><br><span class="line">Space losses: 0 bytes internal + 7 bytes external = 7 bytes total</span><br></pre></td></tr></table></figure>

<p>可以看到hashcode排列是反过来的，出现以上情况的原因是字节排列方式有以下两种情况</p>
<p><img src="https://img.ansore.de/2022/05/01/626e31580473a.png" alt="Screenshot_20200530_221154"></p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程ID，以后该线程进入和推出只需检查是否为偏向锁、锁标志位以及ThreadID即可</p>
<p><img src="https://img.ansore.de/2022/05/01/626e314685eda.png" alt="Screenshot_20200530_183329"></p>
<p>不过一旦出现多个线程竞争时，必须撤销偏向锁，所以撤销偏向锁的性能必须小于之前省下来的CAS原子操作的性能消耗，不然就得不偿失了</p>
<p>适合反复是同一个线程执行的同步代码块</p>
<h3 id="偏向锁实例"><a href="#偏向锁实例" class="headerlink" title="偏向锁实例"></a>偏向锁实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -XX:BiasedLockingStartupDelay=0 关闭延迟</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(object).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的对象最后一个字节如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">00000101</span></span><br></pre></td></tr></table></figure>

<p>此时便为偏向锁</p>
<h3 id="偏向锁原理"><a href="#偏向锁原理" class="headerlink" title="偏向锁原理"></a>偏向锁原理</h3><p>当线程第一次访问同步块并获取锁时，偏向锁处理流程如下：</p>
<ol>
<li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位01</li>
<li>若为可偏向状态，则测试线程ID是否为当前线程ID,如果是，执行同步代码块，否则执行步骤（3）</li>
<li>如果测试线程ID不为当前线程ID，则通过CAS操作将Mark Word的线程ID替换为当前线程ID，执行同步代码块</li>
</ol>
<p>持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。</p>
<h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><ol>
<li>偏向锁的撤销动作必须等待全局安全点</li>
<li>暂时拥有的偏向锁线程，判断锁对象是否处于被锁定状态</li>
<li>撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态</li>
</ol>
<p>偏向锁在java 1.6之后是默认启用的，但在程序启动几秒钟后才激活，可以使用-XX:BiasedLockingStartupDelay&#x3D;0参数关闭延迟，如果确定应用程序中所有的锁通常属于竞争状态，可以使用-XX:-UseBiasedLocking&#x3D;false参数关闭偏向锁</p>
<h3 id="偏向锁的好处"><a href="#偏向锁的好处" class="headerlink" title="偏向锁的好处"></a>偏向锁的好处</h3><p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况，偏向锁可以提高带有同步但无竞争的程序性能。</p>
<p>它同样是有一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序有利，如果程序中大多数锁总是被多个不同的线程访问比如线程池，那偏向模式就是多余的。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>“轻量级”是相对于适用monitor的传统而言，因此传统的锁机制就称为“重量级”锁。轻量级锁并不是替代重量级锁的。</p>
<p>引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁升级成重量级锁，所以轻量级锁的出现并非是要替代重量级锁。</p>
<h3 id="轻量级锁原理"><a href="#轻量级锁原理" class="headerlink" title="轻量级锁原理"></a>轻量级锁原理</h3><p>当关闭偏向锁功能或者多个线程竞争偏向锁都会导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</p>
<ol>
<li>判断当前对象是否处于无锁状态（haskcode, 0, 01），如果是，则JVM首先将在当前线程的栈帧中建立一个锁记录(Lock Record)空间，用于存储锁对象目前的Mark Word的拷贝（官方吧这份拷贝嫁了一个Displaced前缀，即Displaced Mark Word），将对象的Mark Word复制到栈帧中的Lock Record中，将Lock Record的owner指向当前对象。</li>
<li>JVM利用CAS操作尝试将对象的Mard Word更新为指向Lock Record的指针，如果成功表示竞争到锁，则将锁的标志位变为00,执行同步操作</li>
<li>如果失败则判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块;否则只能说明该对象已经被其他线程占用，这时轻量级锁需要膨胀为重量级锁，标志位变成10，后面等待的线程将会进入阻塞状态。</li>
</ol>
<p><img src="https://img.ansore.de/2022/05/01/626e316b64a61.png" alt="Screenshot_20200530_235343"></p>
<h3 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h3><p>轻量级锁的释放也是通过CAS来进行操作的：</p>
<ol>
<li>取出轻量级锁保持你在Displaced Mark Word中的数据</li>
<li>用CAS操作将取出的数据替换为当前对象的Mark Word中，如果成功，则说明锁释放成功</li>
<li>如果CAS操作替换失败，说明名有其他线程尝试获取该锁，则需要将轻量级锁膨胀升级为重量级锁</li>
</ol>
<p>对于轻量级锁，其性能提升的依据是 对于绝大部分的锁，在整个生命周期内都是不会存在竞争的 ，如果打破这个依据，则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢</p>
<h3 id="轻量级锁的好处"><a href="#轻量级锁的好处" class="headerlink" title="轻量级锁的好处"></a>轻量级锁的好处</h3><p>在多线程交替执行同步代码块的情况下，可以避免重量级锁的性能消耗。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>前面我们讨论monitor实现锁的时候，知道monitor会阻塞和唤醒线程，线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执，我们就可以让后面请求锁的那个线程”稍等一下”，但不放弃处理器的执行时间,看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环(自旋)，这项技术就是所谓的自旋锁。</p>
<p>自旋锁在JDK1.4.2中就已经引入，只不过默认是关闭的，可以使用-XX:+UseSpinning参数来开启，JDK6中就已经改为默认开启了。自旋等待不能代誉阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自施次数的默认值是10次，用户可以使用参数-XX:PreBlockSpin来更改。</p>
<h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><p>在JDK 6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越越准确，虚拟机就会变得越来越聪明”了。</p>
<p>自旋锁部分实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ObjectMonitor::TrySpin_VaryDuration</span> <span class="params">(Thread * Self)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> Knob_FixedSpin          = <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">// Dumb, brutal spin.  Good for comparative measurements against adaptive spinning.</span></span><br><span class="line">    <span class="comment">// 自旋次数</span></span><br><span class="line">    <span class="type">int</span> ctr = Knob_FixedSpin ;</span><br><span class="line">    <span class="keyword">if</span> (ctr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (--ctr &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="built_in">SpinPause</span> () ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> Knob_PreSpin            = <span class="number">10</span> ;      <span class="comment">// 20-100 likely better</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 适应性自旋</span></span><br><span class="line">    <span class="keyword">for</span> (ctr = Knob_PreSpin + <span class="number">1</span>; --ctr &gt;= <span class="number">0</span> ; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span>(Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Increase _SpinDuration ...</span></span><br><span class="line">            <span class="comment">// Note that we don&#x27;t clamp SpinDuration precisely at SpinLimit.</span></span><br><span class="line">            <span class="comment">// Raising _SpurDuration to the poverty line is key.</span></span><br><span class="line">            <span class="type">int</span> x = _SpinDuration ;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; Knob_SpinLimit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; Knob_Poverty) x = Knob_Poverty ;</span><br><span class="line">                <span class="comment">// 说明获取锁的可能性较大，增大自旋时间</span></span><br><span class="line">                _SpinDuration = x + Knob_BonusB ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">SpinPause</span> () ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指虚拟机即时编译器 (IT)在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的领进行消除。锁消除的主要判定依据来源于逃递分析的数据支持，如果判新在一段代码中，堆上的所有数据都断会逃逸出去从而被其他线程访问到，那就可以把它们当做上数据对待，认为它们是线程私有的，同步加核自然编无须进行。变量是否逃逸，对于虚拟机来说需要便用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有许多同步指施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。下面这段非常简单的代码仅仅是输出3个字符率相加n的果,无论是源码字面上还是程房语义上都没有同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        contactString(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">contactString</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(s1).append(s2).append(s3).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步方法使用的锁是this,(new StringBuffer())</span></span><br><span class="line"><span class="comment">     * 此时这个synchronized同步方法没必要，所以在编译阶段JVM就自动消除这个同步代码块</span></span><br><span class="line"><span class="comment">     *     <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">     *     public synchronized StringBuffer append(String str) &#123;</span></span><br><span class="line"><span class="comment">     *         toStringCache = null;</span></span><br><span class="line"><span class="comment">     *         super.append(str);</span></span><br><span class="line"><span class="comment">     *         return this;</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuff的append()是一个同步方法，锁就是this也就是(new StringBuffer())。虚拟机发现它的动态作用域被限制在contactString()方法内部。也就是说 new StringBuffer() 对象引用永远不会”逃逸”到contactString()方法之外，其他线程无法访问到它，因此，这里虽然有锁，但是可以安全地被消除，在及时编译之后，这段代码就会忽略掉所有的同步，而直接执行。</p>
<h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>原则上，我们在编写引代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ansore.lock_coarsing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Demo01.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *     <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">         *     public synchronized StringBuffer append(String str) &#123;</span></span><br><span class="line"><span class="comment">         *         toStringCache = null;</span></span><br><span class="line"><span class="comment">         *         super.append(str);</span></span><br><span class="line"><span class="comment">         *         return this;</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         *     这样执行会进行多次加锁、释放锁操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 直接把一连串细小的操作都是用同一个对象加锁，将同步代码块的范围方法，放到这串操作的外面，这样只要加一次锁即可</span></span><br><span class="line"><span class="comment">         *      StringBuffer sb = new StringBuffer();</span></span><br><span class="line"><span class="comment">         *         synchronized (this) &#123;</span></span><br><span class="line"><span class="comment">         *             for (int i = 0; i &lt; 100; i++) &#123;</span></span><br><span class="line"><span class="comment">         *                 sb.append(&quot;aa&quot;);</span></span><br><span class="line"><span class="comment">         *             &#125;</span></span><br><span class="line"><span class="comment">         *         &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接把一连串细小的操作都是用同一个对象加锁，将同步代码块的范围方法，放到这串操作的外面，这样只要加一次锁即可</p>
<h1 id="平时写代码如何对synchronized优化"><a href="#平时写代码如何对synchronized优化" class="headerlink" title="平时写代码如何对synchronized优化"></a>平时写代码如何对synchronized优化</h1><h2 id="减少synchronized的范围"><a href="#减少synchronized的范围" class="headerlink" title="减少synchronized的范围"></a>减少synchronized的范围</h2><p>同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁竞争</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Demo01.class) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="降低synchronized锁的粒度"><a href="#降低synchronized锁的粒度" class="headerlink" title="降低synchronized锁的粒度"></a>降低synchronized锁的粒度</h2><p>将一个锁拆分为多个锁提高并发度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">hs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">hs.put(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>);</span><br><span class="line">hs.put(<span class="string">&quot;xx&quot;</span>, <span class="string">&quot;yy&quot;</span>);</span><br><span class="line"><span class="comment">// Hashtable对所有增删改查的方法都加了锁</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img.ansore.de/2022/05/01/626e2e2ad0c29.png" alt="Screenshot_20200531_012618"></p>
<p><img src="https://img.ansore.de/2022/05/01/626e2c6582b66.png" alt="d1uHilCjs3BYw2x.png"></p>
<p><img src="https://img.ansore.de/2022/05/01/626e319633d70.png" alt="Screenshot_20200531_013112"></p>
<p>LinkedBlockQueue入对和出队使用不同的锁，相对于读写只有一个锁的效率要高</p>
<p><img src="https://img.ansore.de/2022/05/01/626e2e0ea666c.png" alt="cojqrb3udYWElhG"></p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读取时不加锁，写入和删除时加锁</p>
<p>ConcurrentHashMap, CopyOnWriteArraryList和ConyOnWriteSet</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JVM</title>
    <url>/posts/df4b4949.html</url>
    <content><![CDATA[<h2 id="JVM的内存模型"><a href="#JVM的内存模型" class="headerlink" title="JVM的内存模型"></a>JVM的内存模型</h2><p>JVM所管理的内存分为一下几个运行时数据区：</p>
<ul>
<li>程序计数器</li>
<li>java虚拟机栈</li>
<li>本地方法栈</li>
<li>java堆</li>
<li>方法区</li>
</ul>
<h4 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h4><p>一块比较小的内存空间，它是当前线程所执行的字节码的行号指示器，通过该计数器的值来确定下一条需要执行的字节码指令，分支、跳转、循环等都要依赖它来实现。每条线程都有一个独立的程序计数器，各个线程之间的计数器相互独立、互不影响，该区域是线程私有的。</p>
<p>当线程在执行一个java方法是，该计数器记录的是正在执行的虚拟机字节码指令地址，当线程在执行的是Native方法（调用本地操作系统方法）时，该计数器值为空。</p>
<p>该内存区域是唯一一个在java虚拟机中没有规定任何OOM（out of memory）情况的区域</p>
<h4 id="java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="java虚拟机栈（Java Virtual Machine Stacks）"></a>java虚拟机栈（Java Virtual Machine Stacks）</h4><p>该区域也是线程私有的，它的生命周期和线程相同。</p>
<p>虚拟机栈描述的是java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧，栈它用于支持虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。</p>
<p>栈帧用于存储局部变量、操作数栈、动态连接、方法返回地址和一些额外的附加信息。</p>
<p>在编译代码时，栈帧需要多大的局部变量表、多深的操作数栈都已经确定了，并且写入了方法表的code属性中。因此，一个栈帧需要分配多少内存，不会受到程序运行期标量数据的影响，而取决于具体虚拟机的实现。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。</li>
<li>如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemory异常。</li>
</ol>
<h4 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h4><p>该区域与虚拟机栈发挥的作用非常相似。</p>
<p>虚拟机栈为虚拟机执行java方法服务，本地方法栈为使用到本地操作系统（Native）方法服务。</p>
<h4 id="java堆-（java-heap）"><a href="#java堆-（java-heap）" class="headerlink" title="java堆 （java heap）"></a>java堆 （java heap）</h4><p>java heap是java虚拟机所管理内存中最大的一块，是所有线程共享的一块内存。几乎所有的对象实例和数组都在这里分配内存。java heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。</p>
<p>根据java虚拟机规范规定，java堆可以处在物理上不连续的内存空间，只要逻辑上连续即可。如果在堆中没有内存可分配、而且堆也无法扩展时，将会抛出OutOfMemeryError异常。</p>
<h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p>方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>方法区域又被称为“永久代”，但这仅仅对于Sun HotSpot来讲，JRockit和IBM J9虚拟机中并不岑仔永久代这样的概念。</p>
<p>java虚拟机规范把方法区表述为java堆的一个逻辑部分，而且它和java heap一样不需要实现连续内存，可以选择固定大小或可扩展，另外，虚拟机规范允许该区域可以选择不实现垃圾回收。相对而言，垃圾收集行为在这个区域很少出现。该区域的内存回收目标主要是针对废弃常量和无用类的回收。</p>
<p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在加载后存放到方法区的运行时常量池中。运行时常量池相对与Class文件常量池的另一个重要特征是具备动态性，java语言并不要求常量一定只能在编译期产生，也就是非预置入class文件的常量池的内容才能进入方法区的运行时常量池，运行其间也可能将新的常量放入池中。这种特性被开发人员利用较多的是String类的intern() 方法。</p>
<p>根据虚拟机规范的规定，当发放区无法满足内存分配的时候，将抛出OutOfMemoryError异常</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>初识WebService</title>
    <url>/posts/2d791364.html</url>
    <content><![CDATA[<p>WebService，一句话来说就是跨编程语言和操作系统的交互技术，实现了异构平台之间的交互，基于HTTP使用SOAP协议 JAVA自身也提供了一个WebService的实现：JAX-WS(Java API Xml For Web Service) 简单实例： 首先创建一个接口</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.test.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>创建它的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.test.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jws.WebService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebService(endpointInterface = &quot;org.test.service.TestService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">TestService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;max is &quot;</span>+(a&gt;b?a:b));</span><br><span class="line">        <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;min is &quot;</span>+(a&lt;b?a:b));</span><br><span class="line">        <span class="keyword">return</span> a&lt;b?a:b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>创建服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.test.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.ws.Endpoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8888/ab&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Endpoint.publish(address, <span class="keyword">new</span> <span class="title class_">TestServiceImpl</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行该程序，即可创建一个服务，浏览器访问”<a href="http://localhost:8888/ab?wsdl&quot;%EF%BC%8C%E5%8D%B3%E5%8F%AF%E8%AE%BF%E9%97%AE%E8%AF%A5%E6%9C%8D%E5%8A%A1%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%E5%85%AC%E5%BC%80%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E3%80%82">http://localhost:8888/ab?wsdl&quot;，即可访问该服务，这就是公开的服务接口。</a> 然后写一个客户端测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.test.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.namespace.QName;</span><br><span class="line"><span class="keyword">import</span> javax.xml.ws.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8888/ab?wsdl&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">QName</span> <span class="variable">sName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QName</span>(<span class="string">&quot;http://service.test.org/&quot;</span>,<span class="string">&quot;TestServiceImplService&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> Service.create(url,sName);</span><br><span class="line"></span><br><span class="line">            <span class="type">TestService</span> <span class="variable">ms</span> <span class="operator">=</span> service.getPort(TestService.class);</span><br><span class="line"></span><br><span class="line">            System.out.println(ms.max(<span class="number">11</span>, <span class="number">123</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行即可获得执行结果，但是这样做存在一些缺陷，这个客户端测试类依赖了一个TestService类，存在了很多局限性。 java下提供了wsimport这个工具可以实现java类的导入，切换到命令行下输入： wsimport -d d:&#x2F;0001&#x2F; -keep -verbose <a href="http://localhost:8888/ns?wsdl">http://localhost:8888/ns?wsdl</a>  即可在d:&#x2F;0001&#x2F;目录下获得自动生成的java类，导入工程即可，但是生成的java类并不是服务端的接口类。 wsimport参数说明：      -d 指定输出路径      -keep 指定是否生成.java的源文件      -verbose 显示生成的详细过程</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title>select、poll、epoll的原理与区别</title>
    <url>/posts/63893811.html</url>
    <content><![CDATA[<h1 id="select、poll、epoll的原理与区别"><a href="#select、poll、epoll的原理与区别" class="headerlink" title="select、poll、epoll的原理与区别"></a>select、poll、epoll的原理与区别</h1><ol>
<li>select 同步多路IO复用</li>
</ol>
<p><img src="https://img.ansore.de/2022/05/04/62726c8f19252.png" alt="select"></p>
<p>时间复杂度:O(n)</p>
<p>fd_set(监听的端口个数)：32位机默认是1024个，64位机默认是2048。</p>
<p><strong>缺点</strong>：</p>
<p>（1）单进程可以打开fd有限制；</p>
<p>（2）对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低；</p>
<p>（2）用户空间和内核空间的复制非常消耗资源</p>
<ol start="2">
<li>poll</li>
</ol>
<p>同步多路IO复用</p>
<p>调用过程和select类似</p>
<p>时间复杂度:O(n)</p>
<p>其和select不同的地方：采用<strong>链表</strong>的方式替换原有fd_set数据结构,而使其<strong>没有连接数的限制</strong>。</p>
<ol start="3">
<li>epoll</li>
</ol>
<p>同步多路IO复用</p>
<p><img src="https://img.ansore.de/2022/05/04/62726c92eae21.png" alt="select"></p>
<p>时间复杂度:O(1)</p>
<p>epoll的工作方式</p>
<p>epoll的两种工作方式：1.水平触发（LT）2.边缘触发（ET） <br><strong>LT模式</strong>：若就绪的事件一次没有处理完要做的事件，就会一直去处理。即就会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表），一直进行处理。 <br><strong>ET模式</strong>：就绪的事件只能处理一次，若没有处理完会在下次的其它事件就绪时再进行处理。而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。 <br>由此可见：ET模式的效率比LT模式的效率要高很多。只是如果使用ET模式，就要保证每次进行数据处理时，要将其处理完，不能造成数据丢失，这样对编写代码的人要求就比较高。 <br>注意：ET模式只支持非阻塞的读写：为了保证数据的完整性</p>
<p><strong>总结：</strong></p>
<p><strong>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</strong></p>
<p><strong>1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</strong></p>
<p><strong>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</strong></p>
<p>（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p>
<p>（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</p>
]]></content>
      <categories>
        <category>progam</category>
      </categories>
      <tags>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>BF串匹配算法</title>
    <url>/posts/da8e22a5.html</url>
    <content><![CDATA[<blockquote>
<p>BF算法比较简单粗暴，属于蛮力法 原理也比较简单，将主串与模式从第一个字符依次开始匹配，知道完全匹配上或者主串结束，因此最坏情况下时间复杂度为O(m*n)</p>
</blockquote>
<p>C++描述：</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BF</span><span class="params">(<span class="type">char</span> S[], <span class="type">char</span> T[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当主串或者模式都未到达最末尾时候循环</span></span><br><span class="line">    <span class="keyword">while</span>(S[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; T[j] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == T[j]) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            index ++;</span><br><span class="line">            i = index;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(T[j] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> S[] = <span class="string">&quot;sdasaaas&quot;</span>;</span><br><span class="line">    <span class="type">char</span> T[] = <span class="string">&quot;aaas&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; BF(S, T) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/posts/2da0528d.html</url>
    <content><![CDATA[<blockquote>
<p>KMP算法是BF算法的改进算法， 当匹配过程中有不匹配项时，在BF算法中，主串直接回溯到i+1，而模式回溯到第一个字符上重新匹配。KMP算法中，匹配失败时，主串指针i不变，模式指针j回退到next[j]重新进行匹配，当j指针回退到0时，指针i和指针j同时自增1。next中的值是模式的真前缀和真后缀相等的最大字串长度。</p>
</blockquote>
<p>KMP算法C++实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">char</span> T[], <span class="type">int</span> next[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i,j,len;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; T[j] != <span class="string">&#x27;\0&#x27;</span>; j ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(len = j - <span class="number">1</span>; len &gt;= <span class="number">1</span>; len --) &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(T[i] != T[j-len+i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == len) &#123;</span><br><span class="line">                next[j] = len;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(len &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                next[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">char</span> S[], <span class="type">char</span> T[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">80</span>];</span><br><span class="line">    getNext(T, next);</span><br><span class="line">    <span class="keyword">while</span>(S[i] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; T[j] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i] == T[j]) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span>) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T[j] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (i-j+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">char</span> S[] = <span class="string">&quot;sdfasdfads&quot;</span>;</span><br><span class="line">        <span class="type">char</span> T[] = <span class="string">&quot;dfas&quot;</span>;</span><br><span class="line">        <span class="type">int</span> r = KMP(S,T);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;result is &quot;</span> &lt;&lt; r &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一个有getMin功能的栈</title>
    <url>/posts/7be922d9.html</url>
    <content><![CDATA[<p>思路：设计两个栈，一个和正常功能的栈没有区别，另一个保存每一步的最小值，每次弹出时，两个栈同时弹出，这样保证每步都保存了剩余元素的最小值。</p>
<p>java实现代码如下：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack1</span><span class="params">()</span> &#123;</span><br><span class="line">        stackData = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackMin = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyStack1</span> <span class="variable">myStack1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStack1</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myStack1.push(<span class="number">12</span>);</span><br><span class="line">            myStack1.push(<span class="number">5</span>);</span><br><span class="line">            myStack1.push(<span class="number">4</span>);</span><br><span class="line">            myStack1.push(<span class="number">11</span>);</span><br><span class="line">            myStack1.push(<span class="number">2</span>);</span><br><span class="line">            myStack1.push(<span class="number">5</span>);</span><br><span class="line">            myStack1.push(<span class="number">4</span>);</span><br><span class="line">            myStack1.push(<span class="number">11</span>);</span><br><span class="line">            myStack1.push(<span class="number">2</span>);</span><br><span class="line">            myStack1.push(<span class="number">5</span>);</span><br><span class="line">            myStack1.push(<span class="number">11</span>);</span><br><span class="line">            System.out.println(myStack1.getMin());</span><br><span class="line">            System.out.println(myStack1.pop());</span><br><span class="line">            System.out.println(myStack1.pop());</span><br><span class="line">            System.out.println(myStack1.pop());</span><br><span class="line">            System.out.println(myStack1.getMin());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Integer data)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stackMin.push(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(data.intValue() &lt; getMin()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stackMin.push(data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">newValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="built_in">this</span>.getMin());</span><br><span class="line">            <span class="built_in">this</span>.stackMin.push(newValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.stackData.push(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.stackData.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The Stack Is Empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.stackMin.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stackData.pop().intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The Stack Is Empty!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stackMin.peek().intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性Hash算法</title>
    <url>/posts/aca386f3.html</url>
    <content><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>如果有N个缓存服务器，将一个对象缓存到某个服务器上，也许可以这样计算对象的hash值，然后映射到某个cache上：</p>
<blockquote>
<p>hash(object) % N</p>
</blockquote>
<p>这样做存在这两个问题：</p>
<ol>
<li>如果其中一台服务器发生故障或者被移除，则映射到该服务器上的所有对象都会失效，而且映射公式就变为：<code>hash(object) % (N-1)</code></li>
<li>相反，如果缓存已经不满足需求，需要增加缓存服务器时，映射公式变为：<code>hash(object) % (N+1)</code></li>
</ol>
<p>这就意味着几乎所有的cache都会失效，也有两种解决方案：</p>
<ol>
<li>清空所有缓存服务器，重新建立缓存。本来缓存就是为了减小数据库压力而设计的，这样做对后端来说，如同一场灾难，严重的可能会到时数据库崩溃。所以，一般应该不会这样做。</li>
<li>夜深人静，流量最小的时候，使缓存服务器中的数据重新分布。</li>
</ol>
<p>这两种做法的成本都非常大。</p>
<h2 id="一致性hash算法"><a href="#一致性hash算法" class="headerlink" title="一致性hash算法"></a>一致性hash算法</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>简单来说，一致性hash算法主要做的就是在添加或者移除一个缓存服务器的时候，能够尽可能小的改变已存在的映射关系。一致性hash算法用的也是取模的方法，只不过是对2^32取模：</p>
<ol>
<li>先构造一个0～2^32-1的整数环，也称一致性hash环，也可以把它看成一个首尾相接的圆环</li>
<li>根据节点服务器的名称计算hash值，对hash值进行取模，然后将服务器节点放置在hash环上</li>
<li>根据需要缓存数据的key值计算hash值，对hash值进行取模，接着在hash环上顺时针查找离这个值最近的服务器节点</li>
<li>完成映射查找</li>
</ol>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>同样一致性hash算法也有缺点，在实际映射中，有可能缓存服务器会被映射到环上的其中一段弧上，这就造成大部分对象可能会集中缓存到某一台服务器上，这就诞生了虚拟节点。</p>
<p>虚拟节点就是实际节点的一个影子，或者说是复制品，一个实际节点对应多个虚拟节点，同样将虚拟节点映射到hash环上，这样一来缓存的分布就均衡多了，减少hash环的偏斜所带来的影响。</p>
<p>hash环上的节点越多，缓存被均匀分布的概率也就越大</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序算法</title>
    <url>/posts/560dc335.html</url>
    <content><![CDATA[<blockquote>
<p>冒泡排序算法基本思想就是：依次比较相邻两个数，如果前面的数比后面大（降序），则交换两个数，这样的话第一轮遍历结束会浮出最大的数（就像水中的气泡一样，最大的先浮上来），最多经过n-1次，该序列成为有序序列。</p>
</blockquote>
<p>C++实现：</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> b, exchange = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(exchange != <span class="number">0</span>) &#123;</span><br><span class="line">        b = exchange;</span><br><span class="line">        exchange = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[i] &gt; r[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = r[i];</span><br><span class="line">                r[i] = r[i + <span class="number">1</span>];</span><br><span class="line">                r[i + <span class="number">1</span>] = temp;</span><br><span class="line">                exchange = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">53</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    BubbleSort(a,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划总结</title>
    <url>/posts/22f75390.html</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>利用历史记录，避免重复计算</p>
<ol>
<li>定义数组元素含义，用来保存历史数组。</li>
<li>找出元素之间的关系（类似归纳法）</li>
<li>找出初始值</li>
</ol>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="一维DP"><a href="#一维DP" class="headerlink" title="一维DP"></a>一维DP</h2><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<ol>
<li><p>定义$dp[i]$为青蛙跳到地$i$级台阶的总跳法。</p>
</li>
<li><p>青蛙跳到第$i$个台阶有两种跳法，分别是从$i-1$和$i - 2$阶跳过来，所以有$dp[i]&#x3D;dp[i-1]+dp[i-2]$</p>
</li>
<li><p>下标不允许为负，如果$dp[2]&#x3D;dp[1]+dp[0]$，第0个台阶就为0种跳法，$dp[1]&#x3D;1$，此时$dp[2]&#x3D;1$但是如果有两阶应该有两种跳法才对，因此$dp[2]&#x3D;2$也是初始值。</p>
</li>
</ol>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">	<span class="type">int</span> dp[n+<span class="number">1</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维DP-1"><a href="#二维DP-1" class="headerlink" title="二维DP-1"></a>二维DP-1</h2><blockquote>
<p>一个机器人位于一个 m x n 网格的左上角 </p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角</p>
<p>问总共有多少条不同的路径？</p>
</blockquote>
<ol>
<li><p>定义$dp[i][j]$为机器人走到$(i,j)$这个位置时，一共有$dp[i][j]$种路径</p>
</li>
<li><p>机器人要达到$dp[i][j]$有两种走法，分别是从$(i, j-1)$和$(i-1,j)$走到$(i,j)$，所有就有$dp[i][j]&#x3D;dp[i-1][j] + dp[i][j-1]$</p>
</li>
<li><p>保证数组下标不为负数，所以$i$和$j$不为0，所以将最上面一侧和最左面一侧置1</p>
</li>
</ol>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> dp[m][n];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">		dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">			dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二维DP-2"><a href="#二维DP-2" class="headerlink" title="二维DP-2"></a>二维DP-2</h2><blockquote>
<p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line">输入:</span><br><span class="line">arr = [</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>

<ol>
<li><p>从左上角走到$(i, j)$这个位置时，最小的路径和是$dp[i][j]$</p>
</li>
<li><p>要达到$dp[i][j]$有两种走法，分别是从$(i, j-1)$和$(i-1,j)$走到$(i,j)$，但是需要找最小路径和，所有就有$dp[i][j]&#x3D;min(dp[i-1][j] , dp[i][j-1]) + arr[i][j]$</p>
</li>
<li><p>保证数组下标不为负数，所以$i$和$j$不为0，所以将最上面一侧和最左面一侧先计算出来</p>
</li>
</ol>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr.<span class="built_in">size</span>() &lt;= <span class="number">0</span> || arr[<span class="number">0</span>].<span class="built_in">size</span>() &lt;=<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> m = arr.<span class="built_in">size</span>();</span><br><span class="line">	<span class="type">int</span> n = arr[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> dp[m][n];</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++) &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = arr[i][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">		dp[<span class="number">0</span>][i] = arr[<span class="number">0</span>][i] + dp[<span class="number">0</span>][i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">			dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + arr[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><blockquote>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>插入一个字符<br>删除一个字符<br>替换一个字符</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)</span><br><span class="line">rorse -&gt; rose (删除 &#x27;r&#x27;)</span><br><span class="line">rose -&gt; ros (删除 &#x27;e&#x27;)</span><br></pre></td></tr></table></figure>

<p>当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为$dp[i][j]$</p>
<ol>
<li><p>如果$word1[i]$与$word2[j]$相等，这个时候不需要进行任何操作，显然有$dp[i] [j] &#x3D; dp[i-1] [j-1]$。</p>
</li>
<li><p>如果$word1[i]$与$word2[j]$不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下：</p>
</li>
</ol>
<ul>
<li><p>如果把字符$word1[i]$替换成与 word2[j] 相等，则有$dp[i][j] &#x3D; dp[i-1][j-1] + 1$;</p>
</li>
<li><p>如果在字符串$word1$末尾插入一个与 word2[j] 相等的字符，则有 $dp[i][j] &#x3D; dp[i][j-1] + 1$;</p>
</li>
<li><p>如果把字符$word1[i]$删除，则有$dp[i][j] &#x3D; dp[i-1][j] + 1$;</p>
</li>
</ul>
<p>那么我们应该选择一种操作，使得$dp[i][j]$的值最小，显然有</p>
<p>$$dp[i][j] &#x3D; min(dp[i-1][j-1]，dp[i][j-1]，dp[[i-1][j]]) + 1$$</p>
<p>先计算出所有的$dp[0][0….n]$和所有的$dp[0….m][0]$，当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n1 = word1.<span class="built_in">length</span>();</span><br><span class="line">	<span class="type">int</span> n2 = word2.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> dp[n1+<span class="number">1</span>][n2+<span class="number">1</span>];</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++) &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n2; i ++) &#123;</span><br><span class="line">		dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n2; j ++) &#123;</span><br><span class="line">			<span class="comment">// 字符下标少1</span></span><br><span class="line">			<span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/posts/9e8f7e4b.html</url>
    <content><![CDATA[<p>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p>
<table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
<th align="center">排序方式</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">$O(\log(n))$</td>
<td align="center">$O(n\log^2(n))$</td>
<td align="center">$O(n\log^2(n))$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">$O(\log(n))$</td>
<td align="center">$O(\log(n))$</td>
<td align="center">$O(\log(n))$</td>
<td align="center">$O(n)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">$O(\log(n))$</td>
<td align="center">$O(\log(n))$</td>
<td align="center">$O(n^2)$</td>
<td align="center">$O(\log(n))$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">$O(\log(n))$</td>
<td align="center">$O(\log(n))$</td>
<td align="center">$O(\log(n))$</td>
<td align="center">$O(1)$</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(k)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">$O(n……2)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n*k)$</td>
<td align="center">$O(n+k)$</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n：数据规模</span><br><span class="line">k：“桶”的个数</span><br><span class="line">In-place：占用常数内存，不占用额外内存</span><br><span class="line">Out-place：占用额外内存</span><br></pre></td></tr></table></figure>

<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
</li>
</ol>
<p>C++ 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>() - i; j ++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="type">int</span> temp = nums[j];</span><br><span class="line">				nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">				nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ol>
<li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p>
</li>
<li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
</li>
<li><p>重复第二步，直到所有元素均排序完毕。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> minIndex = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j ++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">				minIndex = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(minIndex != i) &#123;</span><br><span class="line">			<span class="type">int</span> temp = nums[minIndex];</span><br><span class="line">			nums[minIndex] = nums[i];</span><br><span class="line">			nums[i] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<ol>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="type">int</span> preIndex = i - <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> current = nums[i];</span><br><span class="line">		<span class="keyword">while</span>(preIndex &gt;= <span class="number">0</span> &amp;&amp; nums[preIndex] &gt; current) &#123;</span><br><span class="line">			nums[preIndex+<span class="number">1</span>] = nums[preIndex];</span><br><span class="line">			preIndex --;</span><br><span class="line">		&#125;</span><br><span class="line">		nums[preIndex+<span class="number">1</span>] = current;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e31ff6ca6c.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> gap = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(gap &lt; nums.<span class="built_in">size</span>() / <span class="number">3</span>) &#123;</span><br><span class="line">		gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = gap; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">			<span class="type">int</span> temp = nums[i];</span><br><span class="line">			<span class="type">int</span> j = i - gap;</span><br><span class="line">			<span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; temp) &#123;</span><br><span class="line">				nums[j+gap] = nums[j];</span><br><span class="line">				j-=gap;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[j+gap] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		gap = gap / <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; left, vector&lt;<span class="type">int</span>&gt; right)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">	<span class="keyword">while</span>(left.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; right.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(left[<span class="number">0</span>] &gt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">			result.<span class="built_in">push_back</span>(right[<span class="number">0</span>]);</span><br><span class="line">			right.<span class="built_in">erase</span>(right.<span class="built_in">begin</span>());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result.<span class="built_in">push_back</span>(left[<span class="number">0</span>]);</span><br><span class="line">			left.<span class="built_in">erase</span>(left.<span class="built_in">begin</span>());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(left.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		result.<span class="built_in">push_back</span>(left[<span class="number">0</span>]);</span><br><span class="line">		left.<span class="built_in">erase</span>(left.<span class="built_in">begin</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(right.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		result.<span class="built_in">push_back</span>(right[<span class="number">0</span>]);</span><br><span class="line">		right.<span class="built_in">erase</span>(right.<span class="built_in">begin</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> nums;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = nums.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(nums.begin(), nums.begin()+mid)</span></span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(nums.begin()+mid, nums.end())</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">mergeSort</span>(left), <span class="built_in">mergeSort</span>(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> basic = nums[left];</span><br><span class="line">	<span class="type">int</span> partitionIndex = left+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i = partitionIndex;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">if</span>(nums[i] &lt; basic) &#123;</span><br><span class="line">			<span class="type">int</span> temp = nums[i];</span><br><span class="line">			nums[i] = nums[partitionIndex];</span><br><span class="line">			nums[partitionIndex] = temp;</span><br><span class="line">			partitionIndex ++;</span><br><span class="line">		&#125;</span><br><span class="line">		i ++;</span><br><span class="line">	&#125;</span><br><span class="line">	nums[left] = nums[partitionIndex - <span class="number">1</span>];</span><br><span class="line">	nums[partitionIndex<span class="number">-1</span>] = basic;</span><br><span class="line">	<span class="keyword">return</span> partitionIndex - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">		<span class="type">int</span> partitionIndex = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">		<span class="built_in">quickSort</span>(nums, left, partitionIndex<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">quickSort</span>(nums, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
<ol>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； $arr[i] &gt;&#x3D; arr[2i+1] &amp;&amp; arr[i] &gt;&#x3D; arr[2i+2]$</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； $arr[i] &lt;&#x3D; arr[2i+1] &amp;&amp; arr[i] &lt;&#x3D; arr[2i+2]$</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjustHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 取出元素i</span></span><br><span class="line">	<span class="type">int</span> temp = nums[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从j节点开始</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = i*<span class="number">2</span>+<span class="number">1</span>; j &lt; length;  j = j*<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 如果左子节点小于右子节点，j指向右子节点</span></span><br><span class="line">		<span class="keyword">if</span>(j+<span class="number">1</span>&lt;length &amp;&amp; nums[j] &lt; nums[j+<span class="number">1</span>]) &#123;</span><br><span class="line">			j ++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果子节点大于父节点，将子节点赋值为父节点</span></span><br><span class="line">		<span class="keyword">if</span>(nums[j] &gt; temp) &#123;</span><br><span class="line">			nums[i] = nums[j];</span><br><span class="line">			i = j;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	nums[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> temp = nums[a];</span><br><span class="line">	nums[a] = nums[b];</span><br><span class="line">	nums[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构建大顶堆</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>()/<span class="number">2</span><span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">		<span class="comment">// 从第一个非叶子节点从下至上，从左至右调整结构</span></span><br><span class="line">		<span class="built_in">adjustHeap</span>(nums, i, nums.<span class="built_in">size</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调整结构，交换堆顶元素与末尾元素</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = nums.<span class="built_in">size</span>()<span class="number">-1</span>; j &gt; <span class="number">0</span>; j --) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(nums, <span class="number">0</span>, j);</span><br><span class="line">		<span class="built_in">adjustHeap</span>(nums, <span class="number">0</span>, j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 得到最大值</span></span><br><span class="line">	<span class="type">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(nums[i] &gt; max) &#123;</span><br><span class="line">			max = nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确定统计数组长度</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countArray</span><span class="params">(max+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 遍历数列，填充</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		countArray[nums[i]] ++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; countArray.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; countArray[i]; j ++) &#123;</span><br><span class="line">			res.<span class="built_in">push_back</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countingSort2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 得到最大值与最小值</span></span><br><span class="line">	<span class="type">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(nums[i] &gt; max) &#123;</span><br><span class="line">			max = nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(nums[i] &lt; min) &#123;</span><br><span class="line">			min = nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确定统计数组长度</span></span><br><span class="line">	<span class="type">int</span> d = max - min;</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countArray</span><span class="params">(d+<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 遍历数列，填充</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		countArray[nums[i] - min] ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 统计数组变形，后面的元素等于前面的元素之和</span></span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; countArray.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">		sum += countArray[i];</span><br><span class="line">		countArray[i] = sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 倒序遍历原始数列，从统计数组找到正确位置，输出到结果数组</span></span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">		res[countArray[nums[i]-min]<span class="number">-1</span>] = nums[i];</span><br><span class="line">		countArray[nums[i]-min] --;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<p>当输入的数据可以均匀的分配到每一个桶中，速度最快。</p>
<p>当输入的数据被分配到了同一个桶中，速度最慢。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> minNum = nums[<span class="number">0</span>];</span><br><span class="line">	<span class="type">int</span> maxNum = nums[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(nums[i] &gt; maxNum) &#123;</span><br><span class="line">			maxNum = nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(nums[i] &lt; minNum) &#123;</span><br><span class="line">			minNum = nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 桶的大小</span></span><br><span class="line">	<span class="type">double</span> bucketRange = (maxNum - minNum)*<span class="number">1.0</span> / nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 桶数组</span></span><br><span class="line">	vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bucketArray</span>(nums.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">		bucketArray[(<span class="type">int</span>)(num-minNum)/bucketRange].<span class="built_in">push_back</span>(num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 桶内排序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketArray.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">		<span class="built_in">sort</span>(bucketArray[i].<span class="built_in">begin</span>(), bucketArray[i].<span class="built_in">end</span>());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">	<span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; num : bucketArray) &#123;</span><br><span class="line">		res.<span class="built_in">insert</span>(res.<span class="built_in">end</span>(), num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>基数排序 vs 计数排序 vs 桶排序</p>
<p>基数排序有两种方法：</p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 初始为个位数</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 最小的位数置为1（包含0）</span></span><br><span class="line">	<span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> maxNum = nums[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span>(nums[i] &gt; maxNum) &#123;</span><br><span class="line">			maxNum = nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 得到最大数是几位数</span></span><br><span class="line">	<span class="keyword">while</span>(maxNum/<span class="number">10</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		n ++;</span><br><span class="line">		maxNum /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(index &lt; n) &#123;</span><br><span class="line">		<span class="comment">// 字典桶</span></span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bucket</span>(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">			<span class="type">int</span> radix = (<span class="type">int</span>) (num / <span class="built_in">pow</span>(<span class="number">10</span>, index))%<span class="number">10</span>;</span><br><span class="line">			bucket[radix].<span class="built_in">push_back</span>(num);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k ++) &#123;</span><br><span class="line">			<span class="comment">// 桶不为空</span></span><br><span class="line">			<span class="keyword">if</span>(bucket[k].<span class="built_in">size</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> num : bucket[k]) &#123;</span><br><span class="line">					nums[j] = num;</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		index ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/posts/fb40efc5.html</url>
    <content><![CDATA[<h3 id="关于拓扑排序"><a href="#关于拓扑排序" class="headerlink" title="关于拓扑排序"></a>关于拓扑排序</h3><p>在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（Topological sorting）。</p>
<ul>
<li>每个顶点出现且只出现一次；</li>
<li>若A在序列中排在B的前面，则在图中不存在从B到A的路径。</li>
</ul>
<p>也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。</p>
<p>在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。</p>
<p>先统计所有节点的入度，对于入度为0的节点就可以分离出来，然后把这个节点指向的节点的入度减一。</p>
<p>一直做改操作，直到所有的节点都被分离出来。</p>
<p>如果最后不存在入度为0的节点，那就说明有环，不存在拓扑排序，也就是很多题目的无解的情况。</p>
<h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大顶点数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单实现栈  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initstack</span><span class="params">(<span class="type">int</span>*<span class="built_in">stack</span>,<span class="type">int</span>*n)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;*n+<span class="number">1</span>;i++)  </span><br><span class="line">        <span class="built_in">stack</span>[i]=<span class="number">-1</span>;  </span><br><span class="line">    *n=<span class="number">0</span>;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span>*<span class="built_in">stack</span>,<span class="type">int</span> *n,<span class="type">int</span> elem)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">stack</span>[*n]=elem;  </span><br><span class="line">    (*n)++;       </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span>*<span class="built_in">stack</span>,<span class="type">int</span> *n)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> temp;  </span><br><span class="line">    (*n)--;  </span><br><span class="line">    temp=<span class="built_in">stack</span>[*n] ;  </span><br><span class="line">    <span class="built_in">stack</span>[*n]=<span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">return</span> temp;     </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">isempty</span><span class="params">(<span class="type">int</span>*<span class="built_in">stack</span>,<span class="type">int</span> *n)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span>(*n)  </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;      </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序函数</span></span><br><span class="line"><span class="comment">// 二维数组第二维给出大小  archnum边数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Topologicalsort</span><span class="params">(<span class="type">int</span> matrix[][N], <span class="type">int</span> vexnum)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//入度矩阵   </span></span><br><span class="line">    <span class="type">int</span> indegree[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//存放最后的拓扑排序 的序列  </span></span><br><span class="line">    <span class="type">int</span> sortorder[N]=&#123;<span class="number">0</span>&#125;; </span><br><span class="line">    <span class="type">int</span> sortordercurse=<span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="built_in">stack</span>[N+<span class="number">1</span>];  </span><br><span class="line">    <span class="type">int</span> curse=N+<span class="number">1</span>;  </span><br><span class="line">    initstack(<span class="built_in">stack</span>,&amp;curse);  </span><br><span class="line">    <span class="comment">//用来指示入度为0的顶点个数 </span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;vexnum;j++)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vexnum;i++)</span><br><span class="line">            indegree[j]+=matrix[i][j];  </span><br><span class="line">        <span class="keyword">if</span>(!(indegree[j]))  </span><br><span class="line">            <span class="comment">//入度为0的顶点入栈     </span></span><br><span class="line">            push(<span class="built_in">stack</span>,&amp;curse,j); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">while</span>(!(isempty(<span class="built_in">stack</span>,&amp;curse))) &#123;  </span><br><span class="line">    <span class="type">int</span> tp;  </span><br><span class="line">    tp=pop(<span class="built_in">stack</span>,&amp;curse);  </span><br><span class="line">    sortorder[sortordercurse++]=tp;   </span><br><span class="line">    count++;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vexnum;i++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>((indegree[i]==<span class="number">1</span>)&amp;&amp;(matrix[tp][i]==<span class="number">1</span>))  </span><br><span class="line">            push(<span class="built_in">stack</span>,&amp;curse,i);  </span><br><span class="line">            <span class="comment">//对出栈的顶点所指向的顶点减一 ，并且将入度为0的顶点入栈。   </span></span><br><span class="line">            indegree[i]-=matrix[tp][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果</span></span><br><span class="line">    <span class="keyword">if</span>(count==vexnum)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n拓扑排序结果为:&quot;</span>);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sortordercurse;i++)  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; V%d &quot;</span>,sortorder[i]+<span class="number">1</span>);&#125;  </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n\n拓扑排序不存在\n&quot;</span>);&#125;                           </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果图有环就不能拓扑排序</span></span><br><span class="line"><span class="comment"> * 拓扑排序:</span></span><br><span class="line"><span class="comment"> * 某个集合上的一个偏序得到的该集合上的一个全序的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 文件输入 略</span></span><br><span class="line"><span class="comment">     * 参考第四题</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顶点数</span></span><br><span class="line">    <span class="type">int</span> vexnum = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">// 构建邻接矩阵</span></span><br><span class="line">    <span class="type">int</span> matrix[N][N]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,  </span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,  </span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,  </span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,  </span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,  </span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//打印矩阵   </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;N;j++)  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %d &quot;</span>,matrix[i][j]);  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    Topologicalsort(matrix, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>求多项式的根</title>
    <url>/posts/e26687da.html</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>求多项式</p>
<p>$$ax^{11}-3x^8-5x^3-1&#x3D;0$$</p>
<p>的根，要求a用屏幕进行输入，根的精度为0.0000001，并且说可能无解。</p>
<span id="more"></span>

<h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 牛顿迭代求根</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//带入原函数后所得的值</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">f</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (a*<span class="built_in">pow</span>(x,<span class="number">11</span>)<span class="number">-3</span>*<span class="built_in">pow</span>(x,<span class="number">8</span>)<span class="number">-5</span>*<span class="built_in">pow</span>(x,<span class="number">3</span>)<span class="number">-1</span>)/<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//带入一阶导函数后所得的值</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">f1</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (a*<span class="number">11</span>*<span class="built_in">pow</span>(x,<span class="number">10</span>)<span class="number">-24</span>*<span class="built_in">pow</span>(x,<span class="number">7</span>)<span class="number">-15</span>*<span class="built_in">pow</span>(x,<span class="number">2</span>))/<span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//牛顿迭代函数</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">F</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">double</span> x1;</span><br><span class="line"> x1=x<span class="number">-1.0</span>*f(a, x)/f1(a, x);</span><br><span class="line"> <span class="keyword">return</span> (x1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ax^11 - 3x^8 - 5x^3 - 1 = 0</span></span><br><span class="line">    <span class="type">double</span> x0=<span class="number">20.0</span>,D_value=<span class="number">0.0</span>,x1=<span class="number">0.0</span>,a=<span class="number">0.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ax^11 - 3x^8 - 5x^3 - 1 = 0\n请输入a: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\na为:%lf&quot;</span>, a);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x1=F(a, x0);</span><br><span class="line">        D_value=<span class="built_in">fabs</span>(x1-x0);</span><br><span class="line">        x0=x1;</span><br><span class="line">    &#125; <span class="keyword">while</span>((D_value&lt;=<span class="number">0.0000001</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n结果为:%lf&quot;</span>, D_value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>求子集问题</title>
    <url>/posts/93ce02fe.html</url>
    <content><![CDATA[<p>问题描述：给定一个集合，求其所有子集。</p>
<blockquote>
<p>解法思路：一个长度为n的集合，共有2^n个子集，每一种可能都用二进制表示，相应的二进制数的0和1对应相应的元素不存在&#x2F;存在，问题解决。</p>
</blockquote>
<p>C++实现：</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用二进制表示元素的存在/不存在</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">findSubset</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//子集个数</span></span><br><span class="line">    <span class="type">int</span> p = (<span class="type">int</span>) <span class="built_in">pow</span>(<span class="number">2</span> ,n);</span><br><span class="line">    <span class="comment">//元素下标</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> j = p;</span><br><span class="line">        <span class="comment">//该种情况下的集合</span></span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> m = j % <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//余数为1存在</span></span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; n) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; r[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//数组越界只有一种情况就是，该集合为空集的时候</span></span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;空集  &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">            j = j / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p--;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    findSubset(a, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>由两个栈组成的队列</title>
    <url>/posts/c7e55458.html</url>
    <content><![CDATA[<p>思路：设计两个栈，一个栈作为压入栈，另一个作为弹出栈。</p>
<ul>
<li><p>压入栈向弹出栈压入数据的时候，必须一次性全部压入</p>
</li>
<li><p>如果弹出栈不为空，绝对不能向弹出栈中压入数据</p>
</li>
<li><p>如果两个栈都为空，则队列就为空</p>
<span id="more"></span></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoStackQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackPush;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackPop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TwoStackQueue</span> <span class="variable">twoStackQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoStackQueue</span>();</span><br><span class="line">        twoStackQueue.add(<span class="number">1</span>);</span><br><span class="line">        twoStackQueue.add(<span class="number">2</span>);</span><br><span class="line">        twoStackQueue.add(<span class="number">3</span>);</span><br><span class="line">        twoStackQueue.add(<span class="number">4</span>);</span><br><span class="line">        twoStackQueue.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span>+twoStackQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span>+twoStackQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span> + twoStackQueue.poll());</span><br><span class="line">        twoStackQueue.add(<span class="number">7</span>);</span><br><span class="line">        twoStackQueue.add(<span class="number">8</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span> + twoStackQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span> + twoStackQueue.peek());</span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span> + twoStackQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span> + twoStackQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span> + twoStackQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span> + twoStackQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span> + twoStackQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span> + twoStackQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span> + twoStackQueue.poll());</span><br><span class="line">        System.out.println(<span class="string">&quot;--&quot;</span> + twoStackQueue.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwoStackQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackPop = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackPush = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stackPush.push(<span class="keyword">new</span> <span class="title class_">Integer</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.stackPop.isEmpty() &amp;&amp; <span class="built_in">this</span>.stackPush.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;the queue is empty!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.stackPop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">this</span>.stackPush.isEmpty()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.stackPop.push(<span class="built_in">this</span>.stackPush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stackPop.pop().intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stackPop.isEmpty() &amp;&amp; <span class="built_in">this</span>.stackPush.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;the queue is empty!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.stackPop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="built_in">this</span>.stackPush.isEmpty()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.stackPop.push(<span class="built_in">this</span>.stackPush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stackPop.peek().intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>由先序遍历和后序遍历推中序遍历</title>
    <url>/posts/c77bb8b4.html</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一棵二叉树的前序遍历和后序遍历，给出一种可能的中序遍历结果</p>
<p>输入示例：</p>
<blockquote>
<p>A B D C E</p>
<p>D B E C A</p>
</blockquote>
<p>输出示例：</p>
<blockquote>
<p>一种可能的中序遍历结果为：D B A E C</p>
</blockquote>
<span id="more"></span>

<h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span>  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span>  </span><br><span class="line">  <span class="type">char</span>  elem;  </span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 截取s字符串子串 n &lt;= x &lt;= m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">getString</span><span class="params">(<span class="type">char</span> * s, <span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    n ++;</span><br><span class="line">    m ++;</span><br><span class="line">    <span class="type">char</span> *r = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (m - n));</span><br><span class="line">    s = s + (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - (n - <span class="number">1</span>); i ++) &#123;</span><br><span class="line">        r[i] = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归中序遍历</span></span><br><span class="line"><span class="comment">// 定义中序遍历结果为全局变量 结果保存到 inorder中</span></span><br><span class="line"><span class="type">int</span> tempIndex = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *inorder;</span><br><span class="line"><span class="type">void</span> <span class="title function_">inTree</span><span class="params">(TreeNode *tree)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(tree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        inTree(tree-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %c &quot;</span>, tree-&gt;elem);</span><br><span class="line">        <span class="keyword">if</span>(tempIndex == <span class="number">0</span>) &#123;</span><br><span class="line">            inorder = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            inorder = (<span class="type">char</span> *) <span class="built_in">realloc</span>(inorder, <span class="keyword">sizeof</span>(<span class="type">char</span>)*(tempIndex+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        inorder[tempIndex] = tree-&gt;elem;</span><br><span class="line">        tempIndex ++;</span><br><span class="line">        <span class="comment">// printf(&quot; --%c-- &quot;, inorder[tempIndex]);</span></span><br><span class="line">        <span class="comment">//right</span></span><br><span class="line">        inTree(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;\n---%d-----\n&quot;, tempIndex);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由先序 后序构造树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeNode * <span class="title function_">buildTree</span><span class="params">(<span class="type">char</span>* preorder, <span class="type">char</span>* postorder)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果长度为 1 证明没有孩子</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(preorder) == <span class="number">1</span> || <span class="built_in">strlen</span>(postorder) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%c &quot;, preorder[0]);</span></span><br><span class="line">        TreeNode * r = (TreeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        r-&gt;elem = preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode *node = (TreeNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    <span class="comment">// 第一个为根节点</span></span><br><span class="line">    node-&gt;elem = preorder[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左右子数都有, 先序第二个元素为左子树根</span></span><br><span class="line">    <span class="keyword">if</span>(preorder[<span class="number">1</span>] != postorder[<span class="built_in">strlen</span>(postorder) - <span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="comment">// m左子树长度 n左子树根</span></span><br><span class="line">        <span class="type">int</span> m=<span class="number">0</span>, n=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(postorder); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">1</span>] == postorder[i]) &#123;</span><br><span class="line">                m = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树先后序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;左子树先后序:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---%s----\n&quot;</span>, getString(postorder, <span class="number">0</span>, m<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---%s----\n&quot;</span>, getString(preorder, n, m));</span><br><span class="line">        <span class="comment">// 右子数先后序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;右子树先后序:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---%s----\n&quot;</span>, getString(preorder, m+<span class="number">1</span>, <span class="built_in">strlen</span>(preorder)<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;---%s----\n&quot;</span>, getString(postorder, m, <span class="built_in">strlen</span>(postorder) - <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        node-&gt;left = buildTree(getString(preorder, n, m),getString(postorder, <span class="number">0</span>, m<span class="number">-1</span>));</span><br><span class="line">        <span class="comment">// printf(&quot;%c &quot;, preorder[0]);</span></span><br><span class="line">        node-&gt;right = buildTree(getString(preorder, m+<span class="number">1</span>, <span class="built_in">strlen</span>(preorder)<span class="number">-1</span>),getString(postorder, m, <span class="built_in">strlen</span>(postorder) - <span class="number">2</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//只有左子数</span></span><br><span class="line">        node-&gt;left = buildTree(getString(preorder, <span class="number">1</span>, <span class="built_in">strlen</span>(preorder)<span class="number">-1</span>),getString(postorder, <span class="number">0</span>, <span class="built_in">strlen</span>(postorder) - <span class="number">2</span>));</span><br><span class="line">        node -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> *pr = <span class="string">&quot;ABDGHECKFIJ&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *po = <span class="string">&quot;GHDEBKJIFCA&quot;</span>;</span><br><span class="line">    TreeNode * t = buildTree(pr,po);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n中序遍历结果为:&quot;</span>);</span><br><span class="line">    inTree(t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表SkipList以及实现</title>
    <url>/posts/891d221b.html</url>
    <content><![CDATA[<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>普通链表查找需要顺序比较，复杂度较高，而折半查找可以将复杂度降到$O(\log n)$，跳表就是利用折半的思想，建立索引，以空间换时间，优化后的空间约为原来所占空间的2倍。</p>
<p><img src="https://img.ansore.de/2022/05/01/626e3217b5ff8.png" alt="Screenshot_20200824_135818"></p>
<p>跳表的结构类似：</p>
<p><img src="https://img.ansore.de/2022/05/01/626e321fc0477.png" alt="Screenshot_20200824_140040"></p>
<h1 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_L 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NEW_NODE生成一个node结构体,同时生成包含n个Node*元素的数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEW_NODE(n) ((Node*) malloc(sizeof(Node) + n*sizeof(Node*)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> keyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> valueType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  keyType key;</span><br><span class="line">  valueType value;</span><br><span class="line">  <span class="comment">// 后继指针数组,可实现结构体变长</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>[1];</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkipList</span> &#123;</span></span><br><span class="line">  <span class="comment">// 层数</span></span><br><span class="line">  <span class="type">int</span> level;</span><br><span class="line">  <span class="comment">// 指向头节点</span></span><br><span class="line">  Node *head;</span><br><span class="line">&#125; SkipList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line"><span class="comment">// level 节点层数</span></span><br><span class="line"><span class="comment">// key 节点关键字</span></span><br><span class="line"><span class="comment">// value 节点值</span></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> level, keyType key, valueType value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建跳表</span></span><br><span class="line">SkipList* <span class="title function_">createSkipList</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素时所占的层数;随机算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="comment">// sl跳表指针</span></span><br><span class="line"><span class="comment">// key节点关键字</span></span><br><span class="line"><span class="comment">// 节点值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(SkipList *sl, keyType key, valueType val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">erase</span><span class="params">(SkipList *sl, keyType key)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找节点</span></span><br><span class="line">valueType* <span class="title function_">search</span><span class="params">(SkipList *sl, keyType key)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从高层逐层打印</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printSkipList</span><span class="params">(SkipList *sl)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放跳表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeSkipList</span><span class="params">(SkipList *sl)</span>;</span><br><span class="line"></span><br><span class="line">Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> level, keyType key, valueType value)</span> &#123;</span><br><span class="line">  Node *p = NEW_NODE(level);</span><br><span class="line">  <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;key = key;</span><br><span class="line">  p-&gt;value = value;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SkipList* <span class="title function_">createSkipList</span><span class="params">()</span> &#123;</span><br><span class="line">  SkipList *sl = (SkipList*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkipList));</span><br><span class="line">  <span class="keyword">if</span>(!sl) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 设置跳表的层,初始为0层,数组从0开始</span></span><br><span class="line">  sl-&gt;level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建头节点</span></span><br><span class="line">  Node *h = createNode(MAX_L, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(!h) &#123;</span><br><span class="line">    <span class="built_in">free</span>(sl);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sl-&gt;head = h;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_L; i ++) h-&gt;next[i] = <span class="literal">NULL</span>;</span><br><span class="line">  srand(time(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">return</span> sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(rand() % <span class="number">2</span>) level ++;</span><br><span class="line">  level = MAX_L&gt;level?level:MAX_L;</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 查找每层待插入的位置,更新update数组</span></span><br><span class="line"><span class="comment">// 2. 随机产生一个层数</span></span><br><span class="line"><span class="comment">// 从高层往下插入,与普通链表完全相同</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(SkipList *sl, keyType key, valueType value)</span> &#123;</span><br><span class="line">  Node *update[MAX_L];</span><br><span class="line">  Node *q = <span class="literal">NULL</span>;</span><br><span class="line">  Node *p = sl-&gt;head;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = sl-&gt;level<span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 1 把降层的节点保存到update数组</span></span><br><span class="line">  <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">    <span class="keyword">while</span>((q = p-&gt;next[i]) &amp;&amp; q-&gt;key &lt; key) p = q;</span><br><span class="line">    update[i] = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// key已经存在</span></span><br><span class="line">  <span class="keyword">if</span>(q &amp;&amp; q-&gt;key == key) &#123;</span><br><span class="line">    q-&gt;value = value;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2 </span></span><br><span class="line">  <span class="type">int</span> level = randomLevel();</span><br><span class="line">  <span class="keyword">if</span>(level &gt; sl-&gt;level) &#123;</span><br><span class="line">    <span class="keyword">for</span>(i = sl-&gt;level; i &lt; level; i ++) update[i] = sl-&gt;head;</span><br><span class="line">    sl-&gt;level = level;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  q = createNode(level, key, value);</span><br><span class="line">  <span class="keyword">if</span>(!q) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 逐层更新</span></span><br><span class="line">  <span class="keyword">for</span>(i = level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">    q-&gt;next[i] = update[i]-&gt;next[i];</span><br><span class="line">    update[i]-&gt;next[i] = q;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">erase</span><span class="params">(SkipList *sl, keyType key)</span> &#123;</span><br><span class="line">  Node *update[MAX_L];</span><br><span class="line">  Node *q = <span class="literal">NULL</span>;</span><br><span class="line">  Node *p = sl-&gt;head;</span><br><span class="line">  <span class="type">int</span> i = sl-&gt;level<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">    <span class="keyword">while</span>((q = p-&gt;next[i]) &amp;&amp; q-&gt;key &lt; key) p = q;</span><br><span class="line">    update[i] = p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否为待删除</span></span><br><span class="line">  <span class="keyword">if</span>(!q || (q &amp;&amp; q-&gt;key != key)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逐层删除</span></span><br><span class="line">  <span class="keyword">for</span>(i = sl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">    <span class="keyword">if</span>(update[i]-&gt;next[i]==q) &#123;</span><br><span class="line">      update[i]-&gt;next[i] = q-&gt;next[i];</span><br><span class="line">      <span class="comment">// 如果删除的是最高层节点,则level--</span></span><br><span class="line">      <span class="keyword">if</span>(sl-&gt;head-&gt;next[i] == <span class="literal">NULL</span>) sl-&gt;level --;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(q);</span><br><span class="line">  q = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line">valueType* <span class="title function_">search</span><span class="params">(SkipList *sl, keyType key)</span> &#123;</span><br><span class="line">  Node *q = <span class="literal">NULL</span>;</span><br><span class="line">  Node *p = sl-&gt;head;</span><br><span class="line">  <span class="type">int</span> i = sl-&gt;level<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">    <span class="keyword">while</span>((q = p-&gt;next[i]) &amp;&amp; q-&gt;key &lt; key) p = q;</span><br><span class="line">    <span class="keyword">if</span>(q &amp;&amp; key == q-&gt;key) <span class="keyword">return</span> &amp;q-&gt;value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printSkipList</span><span class="params">(SkipList *sl)</span> &#123;</span><br><span class="line">  Node *q;</span><br><span class="line">  <span class="type">int</span> i = sl-&gt;level<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">    q = sl-&gt;head-&gt;next[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;level %d:\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;key:%d val:%d\t&quot;</span>, q-&gt;key, q-&gt;value);</span><br><span class="line">      q = q-&gt;next[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeSkipList</span><span class="params">(SkipList *sl)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(!sl) <span class="keyword">return</span>;</span><br><span class="line">  Node *q = sl-&gt;head;</span><br><span class="line">  Node *next;</span><br><span class="line">  <span class="keyword">while</span>(q) &#123;</span><br><span class="line">    next = q-&gt;next[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    q = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  SkipList *sl = createSkipList();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100000</span>; i ++) insert(sl, i, i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">11</span>; i &lt; <span class="number">100000</span>; i ++) erase(sl, i);</span><br><span class="line">  printSkipList(sl);</span><br><span class="line">  <span class="type">int</span> *p = search(sl, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span>(p) <span class="built_in">printf</span>(<span class="string">&quot;search value is %d \n&quot;</span>, *p);</span><br><span class="line">  freeSkipList(sl);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>SkipList</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序算法</title>
    <url>/posts/93b091fb.html</url>
    <content><![CDATA[<blockquote>
<p>选择排序算法基本思想就是，先将整个序列分为有序区和无序区两个部分，有序区为空，每次从无序区查找最小元素与无序区的第一个记录进行交换，这样经过n-1次，整个序列就变成有序了</p>
</blockquote>
<p>C++语言实现：</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span> r[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, index;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i ++) &#123;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[index] &gt; r[j]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; i) &#123;</span><br><span class="line">            <span class="type">int</span> temp = r[index];</span><br><span class="line">            r[index] = r[i];</span><br><span class="line">            r[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">2</span>,<span class="number">3212</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    selectSort(a, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/posts/f1601c3e.html</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式用来保证一个类在运行其间只有一个实例会被创建，另外单例模式还提供全局唯一的访问实例的接口</p>
<h2 id="实现单例模式的方法"><a href="#实现单例模式的方法" class="headerlink" title="实现单例模式的方法"></a>实现单例模式的方法</h2><h3 id="懒加载（线程不安全）"><a href="#懒加载（线程不安全）" class="headerlink" title="懒加载（线程不安全）"></a>懒加载（线程不安全）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">         uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒加载模式，当有多个线程并行调用getInstance()方法的时候，会有多个实例被创建，因此它是线程不安全的，也就是说在多线程下不能正常工作。</p>
<h3 id="懒加载（线程安全）"><a href="#懒加载（线程安全）" class="headerlink" title="懒加载（线程安全）"></a>懒加载（线程安全）</h3><p>该模式在上面的方法上加一个同步锁（synchronized）即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然做到了线程安全，但是效率也受到了影响。因为只有在任何时候只能有一个线程调用getInstance()方法，同步操作有在第一次需要创建实例的时候才需要。这就引出了双重校验锁。</p>
<h3 id="双重校验加锁（线程安全）"><a href="#双重校验加锁（线程安全）" class="headerlink" title="双重校验加锁（线程安全）"></a>双重校验加锁（线程安全）</h3><p>双重检验加锁模式（double checked locking pattern）是一种使用同步块加锁的方法，因为会有两次检查 <code>uniqueInstance == null</code>，　一次实在同步块外，一次是在同步块内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;                         <span class="comment">//Single Checked</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;                 <span class="comment">//Double Checked</span></span><br><span class="line">                uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么要两次检查　uniqueInstance &#x3D;&#x3D; null</p>
<p>因为可能会有两个线程同时进入同步块外的if，如果不进行二次校验的话有可能会生成多个实例</p>
</blockquote>
<p>但是这个依然存在问题，主要是<code>uniqueInstance = new Singleton();</code>不是一个原子性操作，这句话在JVM中大概做了以下三件事：</p>
<ol>
<li>给uniqueInstance分配内存</li>
<li>调用Singleton的构造函数来初始化成员变量</li>
<li>将uniqueInstance对象指向分配的内存空间（uniqueInstance !&#x3D; null）</li>
</ol>
<p>但是JVM的即时编译器存在指令重排优化，也就是说第2、3步的执行顺序不能保证，有可能2先执行，也可能3先执行，如果有两个线程同时执行2和3，然后就理所当然的报错。</p>
<p>只需要将uniqueInstance变量声明成volatile就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance; <span class="comment">//声明成 volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;                         </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>) &#123;       </span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用volatile的一个重要原因是利用volatile禁止指令重排序优化的特性，从【先行发生原则】的角度理解的话，就是对于volatile变量的写操作都发生与后面对这个变量的读操作之前。</p>
<p>特别注意的是java5以前的版本即使使用了volatile的双重校验锁还是有问题的，原因在于java 5以前的JMM（Java Memory Model）存在缺陷，即使将变量声明成volatile也不能完全避免重排序。</p>
<h3 id="急加载static-final-field（线程安全）"><a href="#急加载static-final-field（线程安全）" class="headerlink" title="急加载static final field（线程安全）"></a>急加载static final field（线程安全）</h3><p>这个方法很简单，因为单例的实例都被声明成static和final了，在第一次加载类到内存时就会被初始化，所以本身就是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//类加载时就初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">uniqueInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的缺点就在于它不是一种懒加载模式，即使客户端没有调用getInstance()方法也会创建实例。</p>
<h3 id="静态内部类static-netsted-class-（线程安全）"><a href="#静态内部类static-netsted-class-（线程安全）" class="headerlink" title="静态内部类static netsted class （线程安全）"></a>静态内部类static netsted class （线程安全）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">uniqueInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.uniqueInstance; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法使用JVM本身机制保证了线程安全问题。由于SingletonHolder是私有的，除了getInstance()之外没有办法访问它，因此它是懒加载。同时读取实例的时候不会进行同步，没有性能缺陷，也不依赖jdk版本。</p>
<h3 id="枚举Enum（线程安全）"><a href="#枚举Enum（线程安全）" class="headerlink" title="枚举Enum（线程安全）"></a>枚举Enum（线程安全）</h3><p>非常简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EasySingleton</span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过EasySingleton.INSTANCE来访问实例，创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。而且这比调用getInstance()方法简单多了。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式(Strategy Pattern)</title>
    <url>/posts/5db9b4b7.html</url>
    <content><![CDATA[<p>策略模式是一种定义一系列算法的方法，从概念的角度来讲，算法所做的工作是相同的，只是实现不同而已，它可以用相同的方式调用所有算法，以减少算法类和算法调用类之间的耦合性。 策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承可以析取出这些算法中的公共的功能。 策略模式主要应用需要在不同时间应用不同的业务规则。 任何的需求变更都需要成本，花最小的代价或的最大的收益就是我们要做的，也是学设计模式的目的。 策略模式JAVA语言实现：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyMode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Context context;</span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">AlgonrithmA</span>());</span><br><span class="line">        context.ContextInterface();</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">AlgonrithmB</span>());</span><br><span class="line">        context.ContextInterface();</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> <span class="title class_">Context</span>(<span class="keyword">new</span> <span class="title class_">AlgonrithmC</span>());</span><br><span class="line">        context.ContextInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ContextInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.AlgonrithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">AlgonrithmInterface</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlgonrithmA</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AlgonrithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算法A实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlgonrithmB</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AlgonrithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;算法B实现&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlgonrithmC</span> <span class="keyword">extends</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AlgonrithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算法C实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂模式（Simple Factory Pattern）</title>
    <url>/posts/eaa7cc98.html</url>
    <content><![CDATA[<p>简单工厂模式又叫静态工厂方法模式。目的也很简单，就是提供一个创建对象的接口。 在编程中，我们一般遵循“高内聚低耦合”的原则，工厂模式在一定程度上降低了程序间的耦合性，增加了程序的灵活性、可扩展性。 但由于所有实例逻辑都是由工厂类所创建，所以一旦工厂类出现问题，会导致所有客户端都会受到影响，而且每增加一个产品（客户端），工厂类总是很被动，在工厂类中增加相应的业务逻辑，也违背了开闭原则（对扩展开放、对修改封闭）。 简单工厂模式java实现：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SimpleFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ansore</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Operation operation;</span><br><span class="line">            operation = OperationFactory.CreateOperation(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            operation.setNumA(<span class="number">12</span>);</span><br><span class="line">            operation.setNumB(<span class="number">11</span>);</span><br><span class="line">            System.out.println(operation.getResult());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Create Operation</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OperationFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title function_">CreateOperation</span> <span class="params">(String operate)</span> &#123;</span><br><span class="line">        <span class="type">Operation</span> <span class="variable">operation</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span>(operate) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">            operation = <span class="keyword">new</span> <span class="title class_">AddOpetarion</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            operation = <span class="keyword">new</span> <span class="title class_">SubOperation</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">            operation = <span class="keyword">new</span> <span class="title class_">MulOperation</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            operation = <span class="keyword">new</span> <span class="title class_">DivOperation</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Operation Class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="type">double</span> numA;</span><br><span class="line">    <span class="type">double</span> numB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getNumA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumA</span><span class="params">(<span class="type">double</span> numA)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numA = numA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getNumB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumB</span><span class="params">(<span class="type">double</span> numB)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numB = numB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ADD Operation</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddOpetarion</span> <span class="keyword">extends</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numA + numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Subtract Operation</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubOperation</span> <span class="keyword">extends</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numA - numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Multiply Operation</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulOperation</span> <span class="keyword">extends</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> numA * numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Divide Operation </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivOperation</span> <span class="keyword">extends</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(numB==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;除数不能是0&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> numA / numB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>mxnet数据操作</title>
    <url>/posts/81968f16.html</url>
    <content><![CDATA[<h3 id="创建NDArray"><a href="#创建NDArray" class="headerlink" title="创建NDArray"></a>创建NDArray</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建行向量</span></span><br><span class="line">x = nd.arange(<span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印实例形状</span></span><br><span class="line"><span class="built_in">print</span>(x.shape)</span><br><span class="line"><span class="comment"># 输出 (12,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改变实例形状</span></span><br><span class="line">x = x.reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment"># x = x.reshape((-1,4))</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建各项为0 形状为(2,3,4)的张量</span></span><br><span class="line"><span class="built_in">print</span>(nd.zeros((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建各项为1 形状为(2,3,4)的张量</span></span><br><span class="line"><span class="built_in">print</span>(nd.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建指定元素的张量</span></span><br><span class="line">y = nd.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机生成 形状为(3,4) 每个元素均服从N(0,1)的正态分布</span></span><br><span class="line">z = nd.random.normal(<span class="number">0</span>, <span class="number">1</span>, shape=(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(z)</span><br></pre></td></tr></table></figure>

<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建向量</span></span><br><span class="line">x = nd.arange(<span class="number">12</span>)</span><br><span class="line">x = x.reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">y = nd.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按元素加法运算</span></span><br><span class="line"><span class="built_in">print</span>(x+y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 减法运算</span></span><br><span class="line"><span class="built_in">print</span>(x-y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 乘法运算</span></span><br><span class="line"><span class="built_in">print</span>(x*y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 除法运算</span></span><br><span class="line"><span class="built_in">print</span>(x/y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指数运算</span></span><br><span class="line"><span class="built_in">print</span>(y.exp())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用dot做矩阵运算 x与y的转置相乘 得到3x3的矩阵</span></span><br><span class="line"><span class="built_in">print</span>(nd.dot(x, y.T))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个矩阵连接到一起 在行上 (维度为0)</span></span><br><span class="line"><span class="built_in">print</span>(nd.concat(x, y, dim=<span class="number">0</span>))</span><br><span class="line"><span class="comment"># 在列上 (维度为1)</span></span><br><span class="line"><span class="built_in">print</span>(nd.concat(x, y, dim=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按元素判断是否相等 返回一个新矩阵 (相等为1 不相等为0)</span></span><br><span class="line"><span class="built_in">print</span>(x == y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求和 返回一个元素</span></span><br><span class="line"><span class="built_in">print</span>(x.<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure>

<h3 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h3><p>当对形状不同的两个NDArray按元素操作后，可能会触发广播（broadcasting）机制：先适当复制元素使得两个NDArray形状相同后再按元素操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"></span><br><span class="line">a = nd.arange(<span class="number">3</span>).reshape((<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">b = nd.arange(<span class="number">2</span>).reshape((<span class="number">2</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加法运算</span></span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure>

<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"></span><br><span class="line">x = nd.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下标从0开始</span></span><br><span class="line"><span class="comment"># 按范围截取 截取1,2两行</span></span><br><span class="line"><span class="built_in">print</span>(x[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问单个元素</span></span><br><span class="line">x[<span class="number">1</span>,<span class="number">2</span>] = <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取一部分元素重新赋值</span></span><br><span class="line">x[<span class="number">1</span>:<span class="number">2</span>, :] = <span class="number">24</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<h3 id="运算的内存开销"><a href="#运算的内存开销" class="headerlink" title="运算的内存开销"></a>运算的内存开销</h3><p>对每个操作新开内存来存储运算结果。即使像y &#x3D; x + 这样的运算，都会新建内存，然后y指向新的内存。可以使用python自带的id函数来证明这一点：如果两个实例id一致，那么他们所对应的内存地址相同，反之则不同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建向量</span></span><br><span class="line">x = nd.arange(<span class="number">12</span>)</span><br><span class="line">x = x.reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">y = nd.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">before = <span class="built_in">id</span>(y)</span><br><span class="line">y = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(y) == before)</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定结果到特定内存 创建了临时内存来存储x+y的结果</span></span><br><span class="line">z = y.zeros_like()</span><br><span class="line">before = <span class="built_in">id</span>(z)</span><br><span class="line">z[:] = x + y</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(z) == before)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 避免临时内存开销</span></span><br><span class="line">nd.elemwise_add(x, y, out=z)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(z) == before)</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果x不再被复用 也可以使用x[:] = x + y 或者 x += y来减少内存开销</span></span><br><span class="line">before = <span class="built_in">id</span>(x)</span><br><span class="line">x += y</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(x) == before)</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="NDArray-和-NumPy互相转化"><a href="#NDArray-和-NumPy互相转化" class="headerlink" title="NDArray 和 NumPy互相转化"></a>NDArray 和 NumPy互相转化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> nd</span><br><span class="line"></span><br><span class="line">p = np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">d = nd.array(p)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d.asnumpy())</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>mxnet</tag>
      </tags>
  </entry>
  <entry>
    <title>mxnet自动求梯度</title>
    <url>/posts/7b9a92a9.html</url>
    <content><![CDATA[<h3 id="求梯度实例"><a href="#求梯度实例" class="headerlink" title="求梯度实例"></a>求梯度实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, nd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对函数y=2x(转置)x 求列向量x的梯度</span></span><br><span class="line">x = nd.arange(<span class="number">4</span>).reshape(<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调取attach_grad函数申请计算存储梯度所需的内存</span></span><br><span class="line">x.attach_grad()</span><br><span class="line"></span><br><span class="line"><span class="comment"># record 函数要求mxnet记录求梯度相关的计算</span></span><br><span class="line"><span class="keyword">with</span> autograd.record():</span><br><span class="line">    y = <span class="number">2</span> * nd.dot(x.T, x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用backward自动求梯度</span></span><br><span class="line">y.backward()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度应该为4x 验证梯度是否正确</span></span><br><span class="line"><span class="keyword">assert</span> (x.grad - <span class="number">4</span> * x).norm().asscalar() == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x.grad)</span><br></pre></td></tr></table></figure>

<h3 id="训练模式和预测模式"><a href="#训练模式和预测模式" class="headerlink" title="训练模式和预测模式"></a>训练模式和预测模式</h3><p>调用record函数后，mxnet会记录并计算梯度。此外还将运行模式从预测模式转为训练模式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(autograd.is_training())</span><br><span class="line"><span class="keyword">with</span> autograd.record():</span><br><span class="line">    <span class="built_in">print</span>(autograd.is_training())</span><br></pre></td></tr></table></figure>

<h3 id="对python控制流求梯度"><a href="#对python控制流求梯度" class="headerlink" title="对python控制流求梯度"></a>对python控制流求梯度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mxnet <span class="keyword">import</span> autograd, nd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a</span>):</span><br><span class="line">    b = a * <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> b.norm().asscalar() &lt; <span class="number">1000</span>:</span><br><span class="line">        b = b * <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> b.<span class="built_in">sum</span>().asscalar() &gt; <span class="number">0</span>:</span><br><span class="line">        c = b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        c = <span class="number">100</span> * b</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">a = nd.random.normal(shape=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">a.attach_grad()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> autograd.record():</span><br><span class="line">    c = f(a)</span><br><span class="line"></span><br><span class="line">c.backward()</span><br><span class="line"><span class="built_in">print</span>(a.grad == c / a)</span><br></pre></td></tr></table></figure>

<p>上面定义的函数$f$。给定任意的a，其输出必然是$f(a) &#x3D; x * a$的形式，其中标量西施x的值取决于输入a，由于$c &#x3D; f(a)$有段a的梯度为x，且值为c&#x2F;a。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>mxnet</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux汇编-两个汇编文件的调用</title>
    <url>/posts/cbb560a1.html</url>
    <content><![CDATA[<h1 id="两个汇编文件的调用"><a href="#两个汇编文件的调用" class="headerlink" title="两个汇编文件的调用"></a>两个汇编文件的调用</h1><p>1.asm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .bss</span><br><span class="line">resb 2*32</span><br><span class="line"></span><br><span class="line">section file1data ; 自定义数据段，未使用“传统”的.data</span><br><span class="line"></span><br><span class="line">strHello db &quot;Hello, World&quot;, 0Ah</span><br><span class="line">STRLEN equ $-strHello</span><br><span class="line"></span><br><span class="line">section file1text ; 自定义的代码段，未使用”传统“的.text</span><br><span class="line">extern print ; 声明此函数在别的文件中</span><br><span class="line">						 ; 告诉编译器在编译文件时，找不到此符号也没关系，在链接时会找到</span><br><span class="line"> global _start ; 连接器把_start作为程序的入口</span><br><span class="line"></span><br><span class="line"> _start:</span><br><span class="line">	push STRLEN ; 传入参数，字符长度</span><br><span class="line">	push strHello ; 传入参数，待打印的字符串</span><br><span class="line">	call print ; 此函数定义在2.asm中</span><br><span class="line"></span><br><span class="line">	; 返回系统</span><br><span class="line">	mov ebx, 0; 返回值4</span><br><span class="line">	mov eax, 1; 系统调用号1:sys_exit</span><br><span class="line">	int 0x80 ; 系统调用</span><br></pre></td></tr></table></figure>

<p>2.asm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .text</span><br><span class="line">mov eax, 0x10</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">section file2data ; 自定义数据段</span><br><span class="line"></span><br><span class="line">file2var db 3</span><br><span class="line"></span><br><span class="line">section file2text ; 自定义代码段</span><br><span class="line"></span><br><span class="line">global print ; 导出print供其他模块使用</span><br><span class="line"></span><br><span class="line">print:</span><br><span class="line">  mov edx, [esp+8] ; 字符串长度</span><br><span class="line">	mov ecx, [esp+4] ; 字符串</span><br><span class="line">	</span><br><span class="line">	mov ebx, 1</span><br><span class="line">	mov eax, 4 ; sys_write</span><br><span class="line">	int 0x80 ; 系统调用</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>编译、连接、执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nasm -f elf 1.asm -o 1.o</span><br><span class="line">nasm -f elf 2.asm -o 2.o</span><br><span class="line">ld 1.o 2.o -o 12 -m elf_i386</span><br><span class="line">./12</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux汇编-编写第一个程序</title>
    <url>/posts/fdbe83f0.html</url>
    <content><![CDATA[<h1 id="编写第一个程序"><a href="#编写第一个程序" class="headerlink" title="编写第一个程序"></a>编写第一个程序</h1><h1 id="编程初体验"><a href="#编程初体验" class="headerlink" title="编程初体验"></a>编程初体验</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 目的： 退出并向LINUX内核返回一个状态码</span><br><span class="line"></span><br><span class="line"># 输入： 无</span><br><span class="line"></span><br><span class="line"># 输出： 返回一个状态码。在运行程序后通过输入echo $?来读取状态码</span><br><span class="line"></span><br><span class="line"># 变量：</span><br><span class="line"># %eax 保存系统调用号</span><br><span class="line"># %ebx 保存返回状态</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	movl $1, %eax # 用于退出程序的linux内核命令号（系统调用）</span><br><span class="line">	movl $0, %ebx # 这是返回给操作系统的状态码</span><br><span class="line">								# 改变这个数字，则返回到echo $?值会不同</span><br><span class="line"></span><br><span class="line">	int $0x80  # 唤醒内核，以运行退出命令</span><br></pre></td></tr></table></figure>

<p>汇编程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">as exit.s -o exit.o</span><br></pre></td></tr></table></figure>

<p>上述命令中，as是运行汇编的命令，exit.s是源文件，-o exit.o告诉汇编程序将输出放在文件exit.o中，exit.o称为目标文件。</p>
<p>目标文件的内容通常不完全放在一起。许多大型项目有多个源文件，通常将每个源文件都转换为一个目标文件。链接器将许多目标文件合二为一，并向其中添加信息，使内核知道如何加载和运行该目标文件。</p>
<p>链接exit.o的命令是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ld exit.o -o <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>键入命令运行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./exit</span><br></pre></td></tr></table></figure>

<p>唯一发生的事就是光标进入到下一行。这是因为该程序的功能只是退出。但是如果运行后键入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>屏幕上就会出现一个0。这是因为：每个程序退出时都会返回给linux一个退出状态码，告诉系统一切正常。如果返回0，表示一切正常。如果返回0以外的状态码，就表示失败或其他错误、警告、状态。每个状态码的意义通常由程序员决定。</p>
<h1 id="汇编程序概要"><a href="#汇编程序概要" class="headerlink" title="汇编程序概要"></a>汇编程序概要</h1><p>’#’ 代表注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .data</span><br></pre></td></tr></table></figure>

<p><code>.section</code>指令将程序分成几个部分。<code>.section .data</code>命令是数据段的开始。数据段中要列出程序数据所需的所有内存存储空间。</p>
<figure class="highlight wasm"><table><tr><td class="code"><pre><span class="line">.section .text</span><br></pre></td></tr></table></figure>

<p>这是文本段的开始，是存放指令的部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br></pre></td></tr></table></figure>

<p>这条指令指示汇编程序：_start很重要，必须记住。<code>_start</code>是一个符合，这就是说它将在汇编或链接过程中被其他内容替换掉。</p>
<p><code>.global</code>表示汇编程序不应在汇编之后废弃此符号，因为链接器需要它。<code>_start</code>是个特殊符号，总是用<code>.global</code>来标记，因为它标记了该程序的开始位置。如果不这样标记这个位置，当里算计加载程序时就不知道从哪儿开始运行你的程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_start:</span><br></pre></td></tr></table></figure>

<p>定义_start标签的值。标签定义一个符号的位置。当汇编程序对程序进行汇编时，必须为每个数值和每条指令分配地址。标签告诉汇编程序以该符号的值作为下一条或者下一个数据元素的位置。这样，如果数据或指令的实际物理地址位置更改，你就无需重写其引用，因为符号会自动获得新值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl $1, %eax</span><br></pre></td></tr></table></figure>

<p>将1移如%eax寄存器中。因为我们准备调用linux内核，数字1表示系统调用exit。正常的程序并非无所不能，许多操作如调用其他程序、处理文件以及退出等都必须通过系统调用由操作系统处理，进行系统调用时，必须将系统调用号加载到%eax寄存器。不同的系统调用可能要求其他寄存器也必须含有值。</p>
<p>x86处理器有如下几个通用寄存器：%eax、%ebx、%ecx、%edx、%edi、%esi</p>
<p>除了通用寄存器，还有专用寄存器：%ebp、%esp、%eip、%eflags</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl $0, %ebx</span><br></pre></td></tr></table></figure>

<p>在进行系统调用exit的情况下，操作系统需要将状态码加载到%ebx.稍后这个值被返回给系统，它就是键入echo $? 时提取的值。</p>
<p>将这些数字加载到寄存器本身不会做任何事。系统调用之外的各类事务也要用到寄存器，它们执行加、减、比较等所有逻辑的地方。Linux只需要在系统调用前将某些参数值加载到某些寄存器。通常我们需要将系统调用号加载到%eax，而对于其他寄存器，每个系统调用有不同要求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int $0x80</span><br></pre></td></tr></table></figure>

<p>int 代表中断，0x80是要用到的中断号。中断会中断正常的程序流，把控制权从我们的程序转移到Linux，因此将进行一个系统调用。</p>
<h1 id="为程序做规划"><a href="#为程序做规划" class="headerlink" title="为程序做规划"></a>为程序做规划</h1><p>尝试找到数字列表中的最大值。需要规划包括：</p>
<ul>
<li>原数字列表存放在哪里</li>
<li>要按什么程序来找最大数</li>
<li>要执行程序需要多少存储空间</li>
<li>是要将所有的存储数据都装入寄存器，还是另外使用一部分内存</li>
</ul>
<p>首先，将列表起始地址命名为data_items。假定列表中最后一个数字是0，这样我们就知道在哪里停止，我们还需要保存当前列表元素一级列表的当前最大值，为它们分配寄存器如下：</p>
<ul>
<li>%edi将保存列表的当前位置</li>
<li>%ebx保存列表的当前最大值</li>
<li>%eax将保存当前正在被检测的元素</li>
</ul>
<p>开始运行时，将第一项自动成为当前最大值。然后：</p>
<ol>
<li>检查列表当前元素(%eax)是否为0（终止元素）</li>
<li>如果为0则退出</li>
<li>递增当前位置（%edi）</li>
<li>将列表中的下一个值加载到当前寄存器（%eax）</li>
<li>比较当前值（%eax）与当前最大值（%ebx）</li>
<li>如果当前值大于当前最大值，就以当前值替换当前最大值</li>
<li>重复以上步骤</li>
</ol>
<h1 id="查找最大值"><a href="#查找最大值" class="headerlink" title="查找最大值"></a>查找最大值</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 本程序寻找一组数据项中的最大值</span><br><span class="line"></span><br><span class="line"># 变量： 寄存器有以下用途：</span><br><span class="line"></span><br><span class="line"># %edi - 保存正在检测的数据项索引</span><br><span class="line"># %ebx - 当前已经找到的最大数据项</span><br><span class="line"># %eax - 当前数据项</span><br><span class="line"></span><br><span class="line"># 使用以下内存位置</span><br><span class="line"></span><br><span class="line"># data_items - 包含数据项</span><br><span class="line">#              0 表示数据结束</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line"></span><br><span class="line">	data_items: # 数据项</span><br><span class="line">		.long 3,67,34,222,141,45,5,51,31,12,0</span><br><span class="line"></span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	movl $0, %edi # 将0移入索引寄存器</span><br><span class="line">	movl data_items(, %edi, 4), %eax # 加载数据的第一个字节</span><br><span class="line">	movl %eax, %ebx # 由于第一项，%eax就是最大值</span><br><span class="line"></span><br><span class="line">start_loop: # 开始循环</span><br><span class="line">	cmpl $0, %eax # 检测是否到达数据末尾</span><br><span class="line">	je loop_exit</span><br><span class="line">	incl %edi # 加载下一个值</span><br><span class="line">	movl data_items(, %edi, 4), %eax</span><br><span class="line">	cmpl %ebx, %eax # 比较值</span><br><span class="line">	jle start_loop # 若新数据项不大于原最大值</span><br><span class="line">								 # 则跳到循环起始处</span><br><span class="line">	movl %eax, %ebx # 将新值移入最大值寄存器</span><br><span class="line">	jmp start_loop # 跳到循环起始处</span><br><span class="line"></span><br><span class="line">loop_exit:</span><br><span class="line"># %ebx是系统调用exit的状态码</span><br><span class="line"># 已经存放了最大值</span><br><span class="line">	movl $1, %eax # 1是exit()系统调用</span><br><span class="line">	int $0x80</span><br></pre></td></tr></table></figure>

<p>查看程序运行状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">as maximum.s -o maximum.o</span><br><span class="line">ld maximum.o -o maximum</span><br><span class="line">./maximum</span><br><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>程序返回值是222。</p>
<p>数据段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data_items: # 数据项</span><br><span class="line">	.long 3,67,34,222,141,45,5,51,31,12,0</span><br></pre></td></tr></table></figure>

<p>data_items是一个指代其后位置的标签。接下来是一条指令，该指令以.long开始。这会让汇编程序为.long以后的数字列表保留内存。data_items是指第一个数字的位置。</p>
<p>除了.long，还可以保留几种类型的存储位置：</p>
<ul>
<li>.byte 每个字节类型的数字占用一个存储位置，数字范围是0-255</li>
<li>.int 每个整型数字（这种类型与int指令不同）占用两个存储位置，数字范围是0-65535</li>
<li>.log 长整型占用四个存储位置，与寄存器使用的空间相同，范围0-4294967295</li>
<li>.ascii 将字符输入内存。每个字符占用一个存储位置（字符在内部转换为字节）。</li>
</ul>
]]></content>
      <categories>
        <category>assembly</category>
      </categories>
      <tags>
        <tag>assembly</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之堆、栈、RAII:C++里该如何管理资源</title>
    <url>/posts/8ab7ae33.html</url>
    <content><![CDATA[<h1 id="堆、栈、RAII-C-里该如何管理资源"><a href="#堆、栈、RAII-C-里该如何管理资源" class="headerlink" title="堆、栈、RAII:C++里该如何管理资源?"></a>堆、栈、RAII:C++里该如何管理资源?</h1><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>堆</strong>：英文是 <strong>heap</strong>,在内存管理的语境下,指的是动态分配内存的区域。这个堆跟数据结构里的堆不是一回事。这里的内存，被分配之后需要手工释放，否则就会造成内存泄漏。</p>
<p>C++ 标准里一个相关概念是自由存储区，英文是 free store，特指使用 new 和 delete 来分配和释放内存的区域。一般而言，这是堆的一个子集：</p>
<ul>
<li>new 和 delete 操作的区域是 free store</li>
<li>malloc 和 free 操作的区域是 heap</li>
</ul>
<p>但 new 和 delete 通常底层使用 malloc 和 free 来实现,所以 free store 也是 heap。</p>
<p><strong>栈：</strong>英文是 <strong>stack</strong>，在内存管理的语境下，指的是函数调用过程中产生的本地变量和调用数据的区域。这个栈和数据结构里的栈高度相似，都满足“后进先出”(last-in-first-out 或LIFO)。</p>
<p><strong>RAII</strong>：完整的英文是 <strong>Resource Acquisition Is Initialization</strong>,是 C++ 所特有的资源管理方式。有少量其他语言,如 D、Ada 和 Rust 也采纳了 RAII,但主流的编程语言中, C++是唯一一个依赖 RAII 来做资源管理的。</p>
<p>RAII 依托栈和析构函数，来对所有的资源——包括堆内存在内——进行管理。对 RAII 的使用，使得 C++ 不需要类似于 Java 那样的垃圾收集方法,也能有效地对内存进行管理。RAII 的存在,也是垃圾收集虽然理论上可以在 C++ 使用,但从来没有真正流行过的主要原因。</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>从现代编程的角度来看,使用堆,或者说使用动态内存分配,是一件再自然不过的事情了。下面这样的代码,都会导致在堆上分配内存(并构造对象)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="keyword">auto</span> ptr = <span class="keyword">new</span> std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line">ArrayList&lt;<span class="type">int</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="built_in">list</span> = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure>

<p>动态内存分配实际上是较晚出现的。由于动态内存带来的不确定性——内存分配耗时需要多久?失败了怎么办?等等——至今仍有很多场合会禁用动态内存,尤其在实时性要求比较高的场合,如飞行控制器和电信设备。</p>
<p>在堆上分配内存，有些语言可能使用new 这样的关键字，有些语言则是在对象的构造时隐式分配，不需要特殊关键字。不管哪种情况，程序通常需要牵涉到三个可能的内存管理器的操作：</p>
<ol>
<li>让内存管理器释放一个之前分配的内存块</li>
<li>让内存管理器分配一个某个大小的内存块</li>
<li>让内存管理器进行垃圾收集操作，寻找不再使用的内存块并予以释放</li>
</ol>
<p>C++ 通常会做上面的操作 1 和 2。Java 会做上面的操作 1 和 3。而 Python 会做上面的操作 1、2、3。这是语言的特性和实现方式决定的。（<strong>上面的三个操作都不简单，并且彼此之间是相关的</strong>）</p>
<p>分配过程：</p>
<p><img src="https://img.ansore.de/2022/05/04/627273970823c.png" alt="01"></p>
<p><img src="https://img.ansore.de/2022/05/04/627273b20b94f.png" alt="01"></p>
<p>在图 1e 的状态下，内存管理器是满足不了长度大于 4 的内存分配要求的；而在图 1f 的状态，则长度小于等于 7 的单个内存要求都可以得到满足。</p>
<p>当然，这只是一个简单的示意，只是为了让你能够对这个过程有一个大概的感性认识。在不考虑垃圾收集的情况下，内存需要手工释放；在此过程中，内存可能有碎片化的情况。比如，在图 1d 的情况下，虽然总共剩余内存为 6，但却满足不了长度大于 4 的内存分配要求。</p>
<p>幸运的是，大部分软件开发人员都不需要担心这个问题。内存分配和释放的管理，是内存管理器的任务，一般情况下我们不需要介入。我们只需要正确地使用 new 和 delete。每个 new 出来的对象都应该用 delete 来释放，就是这么简单。</p>
<p>事实说明，漏掉 delete 是一种常见的情况，这叫“内存泄漏”——相信你一定听到过这个说法。为什么呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  bar* ptr = <span class="keyword">new</span> <span class="built_in">bar</span>();</span><br><span class="line">  …</span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个很简单，但是却存在两个问题：</p>
<ol>
<li>中间省略的代码部分也许会抛出异常，导致最后的 delete ptr 得不到执行。</li>
<li>更重要的，这个代码不符合 C++ 的惯用法。在 C++ 里，这种情况下有 99% 的可能性不应该使用堆内存分配，而应使用栈内存分配。</li>
</ol>
<p>而更常见、也更合理的情况，是分配和释放不在一个函数里。比如下面这段示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">bar* <span class="title">make_bar</span><span class="params">(…)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  …</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    bar* ptr = <span class="keyword">new</span> <span class="built_in">bar</span>();</span><br><span class="line">    …</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  …</span><br><span class="line">  bar* ptr = <span class="built_in">make_bar</span>(…)</span><br><span class="line">  …</span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，会漏 delete 的可能性大多了</p>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>我们先来看一段示例代码，来说明 C++ 里函数调用、本地变量是如何使用栈的。当然，这一过程取决于计算机的实际架构，具体细节可能有所不同，但原理上都是相通的，都会使用一个后进先出的结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> a = n + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">foo</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  …</span><br><span class="line">  <span class="built_in">bar</span>(<span class="number">42</span>);</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码执行过程中的栈变化，我画了下面这张图来表示：</p>
<p><img src="https://img.ansore.de/2022/05/04/627273be69cdd.png" alt="0"></p>
<p>在我们的示例中，栈是向上增长的。在包括 x86 在内的大部分计算机体系架构中，栈的增长方向是低地址，因而上方意味着低地址。任何一个函数，根据架构的约定，只能使用进入函数时栈指针向上部分的栈空间。当函数调用另外一个函数时，会把参数也压入栈里（我们此处忽略使用寄存器传递参数的情况），然后把下一行汇编指令的地址压入栈，并跳转到新的函数。新的函数进入后，首先做一些必须的保存工作，然后会调整栈指针，<strong>分配出本地变量所需的空间</strong>，随后执行函数中的代码，并在执行完毕之后，根据调用者压入栈的地址，返回到调用者未执行的代码中继续执行。</p>
<p>本地变量所需的内存就在栈上，跟函数执行所需的其他数据在一起。当函数执行完成之后，这些内存也就自然而然释放掉了。我们可以看到：</p>
<ul>
<li>栈上的分配极为简单，移动一下栈指针而已。</li>
<li>栈上的释放也极为简单，函数执行结束时移动一下栈指针即可。</li>
<li>由于后进先出的执行过程，不可能出现内存碎片。</li>
</ul>
<p>图 2 中每种颜色都表示某个函数占用的栈空间。这部分空间有个特定的术语，叫做栈帧（stack frame）。GCC 和 Clang 的命令行参数中提到 frame 的，如 -fomit-frame-pointer，一般就是指栈帧。</p>
<p>前面例子的本地变量是简单类型，C++ 里称之为 POD 类型（Plain Old Data）。对于有构造和析构函数的非 POD 类型，栈上的内存分配也同样有效，只不过 C++ 编译器会在生成代码的合适位置，插入对构造和析构函数的调用。</p>
<p>这里尤其重要的是：编译器会自动调用析构函数，包括在函数执行发生异常的情况。在发生异常时对析构函数的调用，还有一个专门的术语，叫栈展开（stack unwinding）。事实上，如果你用 MSVC 编译含异常的 C++ 代码，但没有使用上一讲说过的<code>/EHsc</code>参数，编译器就会报告：</p>
<blockquote>
<p>warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify &#x2F;EHsc</p>
</blockquote>
<p>演示栈展开：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Obj</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;Obj()&quot;</span>); &#125;</span><br><span class="line">  ~<span class="built_in">Obj</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~Obj()&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Obj obj;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">42</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;life, the universe and everything&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">41</span>);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* s) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行代码的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Obj()</span><br><span class="line">~Obj()</span><br><span class="line">Obj()</span><br><span class="line">~Obj()</span><br><span class="line">life, the universe and everything</span><br></pre></td></tr></table></figure>

<p>也就是说，不管是否发生了异常，obj 的析构函数都会得到执行。</p>
<p>在 C++ 里，所有的变量缺省都是值语义——如果不使用 * 和 &amp; 的话，变量不会像 Java 或 Python 一样引用一个堆上的对象。对于像智能指针这样的类型，你写 ptr-&gt;call() 和 ptr.get()，语法上都是对的，并且 -&gt; 和 . 有着不同的语法作用。而在大部分其他语言里，访问成员只用 .，但在作用上实际等价于 C++ 的 -&gt;。这种值语义和引用语义的区别，是 C++ 的特点，也是它的复杂性的一个来源。</p>
<h1 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h1><p>C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。比如：</p>
<ul>
<li>对象很大；</li>
<li>对象的大小在编译时不能确定；</li>
<li>对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。</li>
</ul>
<p>常见情况之一是，在工厂方法或其他面向对象编程的情况下，返回值类型是基类。下面的例子，是对工厂方法的简单演示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">shape_type</span> &#123;</span><br><span class="line">  circle,</span><br><span class="line">  triangle,</span><br><span class="line">  rectangle,</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span> &#123; … &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> : <span class="keyword">public</span> shape &#123; … &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">triangle</span> : <span class="keyword">public</span> shape &#123; … &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rectangle</span> : <span class="keyword">public</span> shape &#123; … &#125;;</span><br><span class="line"><span class="function">shape* <span class="title">create_shape</span><span class="params">(shape_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  …</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> shape_type::circle:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">circle</span>(…);</span><br><span class="line">  <span class="keyword">case</span> shape_type::triangle:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">triangle</span>(…);</span><br><span class="line">  <span class="keyword">case</span> shape_type::rectangle:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">rectangle</span>(…);</span><br><span class="line">  …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 <code>create_shape</code> 方法会返回一个 <code>shape</code> 对象，对象的实际类型是某个 <code>shape</code> 的子类，圆啊，三角形啊，矩形啊，等等。这种情况下，函数的返回值只能是指针或其变体形式。如果返回类型是 <code>shape</code>，实际却返回一个 <code>circle</code>，编译器不会报错，但结果多半是错的。这种现象叫<strong>对象切片（object slicing）</strong>，是 C++ 特有的一种编码错误。这种错误不是语法错误，而是一个对象复制相关的语义错误，也算是 C++ 的一个陷阱了，大家需要小心这个问题。</p>
<p>那么，我们怎样才能确保，在使用 <code>create_shape</code> 的返回值时不会发生内存泄漏呢？</p>
<p>答案就在析构函数和它的栈展开行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。一个简单的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shape_wrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">shape_wrapper</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    shape* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">    : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">shape_wrapper</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">shape* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  shape* ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  …</span><br><span class="line">  <span class="function">shape_wrapper <span class="title">ptr_wrapper</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    create_shape(…))</span></span>;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你好奇 <code>delete</code> 空指针会发生什么的话，那答案是，这是一个合法的空操作。在 <code>new</code> 一个对象和 <code>delete</code> 一个指针时编译器需要干不少活的，它们大致可以如下翻译：</p>
<p>new:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new circle(…)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span>* temp = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(circle));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    circle* ptr =</span><br><span class="line">      <span class="built_in">static_cast</span>&lt;circle*&gt;(temp);</span><br><span class="line">    ptr-&gt;<span class="built_in">circle</span>(…);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>delete:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  ptr-&gt;~<span class="built_in">shape</span>();</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，<code>new</code> 的时候先分配内存（失败时整个操作失败并向外抛出异常，通常是 <code>bad_alloc</code>），然后在这个结果指针上构造对象（注意上面示意中的调用构造函数并不是合法的 C++ 代码）；构造成功则 <code>new</code> 操作整体完成，否则释放刚分配的内存并继续向外抛构造函数产生的异常。<code>delete</code> 时则判断指针是否为空，在指针不为空时调用析构函数并释放之前分配的内存。</p>
<p>回到 <code>shape_wrapper</code> 和它的析构行为。在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：</p>
<ul>
<li>关闭文件（fstream 的析构就会这么做）</li>
<li>释放同步锁</li>
<li>释放其他重要的系统资源</li>
</ul>
<p>例如，我们应该使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mtx)</span></span>;</span><br><span class="line">  <span class="comment">//  做需要同步的工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而不是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mtx.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="comment">//  做需要同步的工作……</span></span><br><span class="line">  <span class="comment">//  如果发生异常或提前返回，</span></span><br><span class="line">  <span class="comment">//  下面这句不会自动执行。</span></span><br><span class="line">  mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 shape_wrapper 差不多就是个最简单的智能指针了。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之实现C++的智能指针</title>
    <url>/posts/7ca70fd1.html</url>
    <content><![CDATA[<h1 id="实现C-的智能指针"><a href="#实现C-的智能指针" class="headerlink" title="实现C++的智能指针"></a>实现C++的智能指针</h1><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>下面这个类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shape_wrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">shape_wrapper</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    shape* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">    : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">shape_wrapper</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">shape* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  shape* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个类可以完成智能指针的最基本的功能：对超出作用域的对象进行释放。但它缺了点东西：</p>
<ol>
<li>这个类只适用于 <code>shape</code> 类</li>
<li>该类对象的行为不够像指针</li>
<li>拷贝该类对象会引发程序行为异常</li>
</ol>
<p>下面我们来逐一看一下怎么弥补这些问题。</p>
<h1 id="模板化和易用性"><a href="#模板化和易用性" class="headerlink" title="模板化和易用性"></a>模板化和易用性</h1><p>要让这个类能够包装任意类型的指针，我们需要把它变成一个类模板。这实际上相当容易：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">smart_ptr</span><span class="params">(T* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">    : ptr_(ptr) &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">smart_ptr</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* ptr_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>和 <code>shape_wrapper</code> 比较一下，我们就是在开头增加模板声明<code>template &lt;typename T&gt;</code>，然后把代码中的 <code>shape</code> 替换成模板参数 T 而已。这些修改非常简单自然吧？模板本质上并不是一个很复杂的概念。这个模板使用也很简单，把原来的 <code>shape_wrapper</code> 改成 <code>smart_ptr&lt;shape&gt;</code> 就行。</p>
<p>目前这个 smart_ptr 的行为还是和指针有点差异的：</p>
<ul>
<li>它不能用 * 运算符解引用</li>
<li>它不能用 -&gt; 运算符指向对象成员</li>
<li>它不能像指针一样用在布尔表达式里</li>
</ul>
<p>不过，这些问题也相当容易解决，加几个成员函数就可以：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  …</span><br><span class="line">  T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *ptr_; &#125;</span><br><span class="line">  T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拷贝构造和赋值"><a href="#拷贝构造和赋值" class="headerlink" title="拷贝构造和赋值"></a>拷贝构造和赋值</h1><p>拷贝构造和赋值，我们暂且简称为拷贝，这是个比较复杂的问题了。关键还不是实现问题，而是我们该如何定义其行为。假设有下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">smart_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line">smart_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;</span><br></pre></td></tr></table></figure>

<p>对于第二行，究竟应当让编译时发生错误，还是可以有一个更合理的行为？我们来逐一检查一下各种可能性。</p>
<p>最简单的情况显然是禁止拷贝。我们可以使用下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line">  …</span><br><span class="line">  <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&amp;)</span><br><span class="line">    = <span class="keyword">delete</span>;</span><br><span class="line">  smart_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> smart_ptr&amp;)</span><br><span class="line">    = <span class="keyword">delete</span>;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>禁用这两个函数非常简单，但却解决了一种可能出错的情况。否则，<code>smart_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;</code> 在编译时不会出错，但在运行时却会有未定义行为——由于会对同一内存释放两次，通常情况下会导致程序崩溃。</p>
<p>我们是不是可以考虑在拷贝智能指针时把对象拷贝一份？不行，通常人们不会这么用，因为使用智能指针的目的就是要减少对象的拷贝啊。何况，虽然我们的指针类型是 shape，但实际指向的却应该是 circle 或 triangle 之类的对象。在 C++ 里没有像 Java 的 clone 方法这样的约定；一般而言，并没有通用的方法可以通过基类的指针来构造出一个子类的对象来。</p>
<p>我们要么试试在拷贝时转移指针的所有权？大致实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line">  …</span><br><span class="line">  <span class="built_in">smart_ptr</span>(smart_ptr&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  smart_ptr&amp; <span class="keyword">operator</span>=(smart_ptr&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">smart_ptr</span>(rhs).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  …</span><br><span class="line">  <span class="function">T* <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    T* ptr = ptr_;</span><br><span class="line">    ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(smart_ptr&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(ptr_, rhs.ptr_);</span><br><span class="line">  &#125;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在拷贝构造函数中，通过调用 <code>other</code> 的 <code>release</code> 方法来释放它对指针的所有权。在赋值函数中，则通过拷贝构造产生一个临时对象并调用 <code>swap</code> 来交换对指针的所有权。实现上是不复杂的。</p>
<p>如果你学到的赋值函数还有一个类似于 <code>if (this != &amp;rhs)</code> 的判断的话，那种用法更啰嗦，而且异常安全性不够好——如果在赋值过程中发生异常的话，this 对象的内容可能已经被部分破坏了，对象不再处于一个完整的状态。</p>
<p>目前这种惯用法则保证了强异常安全性：赋值分为拷贝构造和交换两步，异常只可能在第一步发生；而第一步如果发生异常的话，this 对象完全不受任何影响。无论拷贝构造成功与否，结果只有赋值成功和赋值没有效果两种状态，而不会发生因为赋值破坏了当前对象这种场景。</p>
<p>上面实现的最大问题是，它的行为会让程序员非常容易犯错。一不小心把它传递给另外一个 <code>smart_ptr</code>，你就不再拥有这个对象了……</p>
<h1 id="“移动”指针？"><a href="#“移动”指针？" class="headerlink" title="“移动”指针？"></a>“移动”指针？</h1><p>我们需要对代码做两处小修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line">  …</span><br><span class="line">  <span class="built_in">smart_ptr</span>(smart_ptr&amp;&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  smart_ptr&amp; <span class="keyword">operator</span>=(smart_ptr rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    rhs.<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>改了两个地方：</p>
<ul>
<li>把拷贝构造函数中的参数类型 <code>smart_ptr&amp;</code> 改成了 <code>smart_ptr&amp;&amp;；</code>现在它成了移<strong>动构造函数</strong>。</li>
<li>把赋值函数中的参数类型 <code>smart_ptr&amp;</code> 改成了 <code>smart_ptr</code>，在构造参数时直接生成新的智能指针，从而不再需要在函数体中构造临时对象。现在赋值函数的行为是移动还是拷贝，完全依赖于构造参数时走的是移动构造还是拷贝构造。</li>
</ul>
<p>根据 C++ 的规则，如果我提供了移动构造函数而没有手动提供拷贝构造函数，那后者自动被禁用.</p>
<p>于是，我们自然地得到了以下结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">smart_ptr&lt;shape&gt; ptr1&#123;<span class="built_in">create_shape</span>(shape_type::circle)&#125;;</span><br><span class="line">smart_ptr&lt;shape&gt; ptr2&#123;ptr1&#125;;             <span class="comment">//  编译出错</span></span><br><span class="line">smart_ptr&lt;shape&gt; ptr3;</span><br><span class="line">ptr3 = ptr1;                             <span class="comment">//  编译出错</span></span><br><span class="line">ptr3 = std::<span class="built_in">move</span>(ptr1);                  <span class="comment">// OK，可以</span></span><br><span class="line">smart_ptr&lt;shape&gt; ptr4&#123;std::<span class="built_in">move</span>(ptr3)&#125;;  <span class="comment">// OK，可以</span></span><br></pre></td></tr></table></figure>

<h1 id="子类指针向基类指针的转换"><a href="#子类指针向基类指针的转换" class="headerlink" title="子类指针向基类指针的转换"></a>子类指针向基类指针的转换</h1><p>一个 <code>circle*</code> 是可以隐式转换成<code>shape*</code>的，但上面的 <code>smart_ptr&lt;circle&gt;</code> 却无法自动转换成 <code>smart_ptr&lt;shape&gt;</code>。这个行为显然还是不够“自然”。</p>
<p>不过，只需要额外加一点模板代码，就能实现这一行为。在我们目前给出的实现里，只需要修改我们的移动构造函数一处即可——这也算是我们让赋值函数使用拷贝 &#x2F; 移动构造函数的好处了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="built_in">smart_ptr</span>(smart_ptr&lt;U&gt;&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">  ptr_ = other.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们自然而然利用了指针的转换特性：现在 <code>smart_ptr&lt;circle&gt;</code> 可以移动给 <code>smart_ptr&lt;shape&gt;</code>，但不能移动给 <code>smart_ptr&lt;triangle&gt;</code>。不正确的转换会在代码编译时直接报错。</p>
<h1 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h1><p><code>unique_ptr</code> 算是一种较为安全的智能指针了。但是，一个对象只能被单个 <code>unique_ptr</code> 所拥有，这显然不能满足所有使用场合的需求。一种常见的情况是，多个智能指针同时拥有一个对象；当它们全部都失效时，这个对象也同时会被删除。这也就是 <code>shared_ptr</code> 了。</p>
<p><code>unique_ptr</code> 和 <code>shared_ptr</code> 的主要区别如下图所示：</p>
<p><img src="https://img.ansore.de/2022/05/04/627273e7827d6.png" alt="02"></p>
<p>多个不同的 <strong>shared_ptr</strong> 不仅可以共享一个对象，在共享同一对象时也需要同时共享同一个计数。当最后一个指向对象（和共享计数）的 <strong>shared_ptr</strong> 析构时，它需要删除对象和共享计数。我们下面就来实现一下。</p>
<p>先来写出共享计数的接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_count</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">shared_count</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="title">reduce_count</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="title">get_count</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个 <code>shared_count</code> 类除构造函数之外有三个方法：一个增加计数，一个减少计数，一个获取计数。注意上面的接口增加计数不需要返回计数值；但减少计数时需要返回计数值，以供调用者判断是否它已经是最后一个指向共享计数的 <code>shared_ptr</code> 了。由于真正多线程安全的版本需要用到我们目前还没学到的知识，我们目前先实现一个简单化的版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">shared_count</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">shared_count</span>() : <span class="built_in">count_</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span> </span>&#123; ++count_; &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="title">reduce_count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> --count_; &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="title">get_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">long</span> count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们可以实现我们的引用计数智能指针了。首先是构造函数、析构函数和私有成员变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">smart_ptr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span> : ptr_(ptr) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">      shared_count_ = <span class="keyword">new</span> <span class="built_in">shared_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">smart_ptr</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr_ &amp;&amp; !shared_count_-&gt;<span class="built_in">reduce_count</span>()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> ptr_;</span><br><span class="line">      <span class="keyword">delete</span> shared_count_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T *ptr_;</span><br><span class="line">  shared_count *shared_count_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造函数跟之前的主要不同点是会构造一个 <code>shared_count</code> 出来。析构函数在看到 ptr_ 非空时（此时根据代码逻辑，<code>shared_count</code> 也必然非空），需要对引用数减一，并在引用数降到零时彻底删除对象和共享计数。原理就是这样，不复杂。</p>
<p>当然，我们还有些细节要处理。为了方便实现赋值（及其他一些惯用法），我们需要一个新的 swap 成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(smart_ptr &amp;rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(ptr_, rhs.ptr_);</span><br><span class="line">    <span class="built_in">swap</span>(shared_count_, rhs.shared_count_);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>赋值函数可以跟前面一样，保持不变，但拷贝构造和移动构造函数是需要更新一下的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;U&gt; &amp;other) &#123;</span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">      other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">      shared_count_ = other.shared_count_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="built_in">smart_ptr</span>(smart_ptr&lt;U&gt; &amp;&amp;other) &#123;</span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">      shared_count_ = other.shared_count_;</span><br><span class="line">      other.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>除复制指针之外，对于拷贝构造的情况，我们需要在指针非空时把引用数加一，并复制共享计数的指针。对于移动构造的情况，我们不需要调整引用数，直接把 <code>other.ptr</code> 置为空，认为 <code>other</code> 不再指向该共享对象即可。</p>
<p>不过，上面的代码有个问题：它不能正确编译。编译器会报错，像：</p>
<blockquote>
<p>fatal error: ‘ptr_’ is a private member of ‘smart_ptr<circle>’</p>
</blockquote>
<p>错误原因是模板的各个实例间并不天然就有 friend 关系，因而不能互访私有成员 ptr_ 和 shared_count_。我们需要在 smart_ptr 的定义中显式声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">smart_ptr</span>;</span><br></pre></td></tr></table></figure>

<p>此外，我们之前的实现（类似于单一所有权的 <code>unique_ptr</code> ）中用 <code>release</code> 来手工释放所有权。在目前的引用计数实现中，它就不太合适了，应当删除。但我们要加一个对调试非常有用的函数，返回引用计数值。定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">      <span class="keyword">return</span> shared_count_-&gt;<span class="built_in">get_count</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这就差不多是一个比较完整的引用计数智能指针的实现了。我们可以用下面的代码来验证一下它的功能正常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_count</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">shared_count</span>() : <span class="built_in">count_</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add_count</span><span class="params">()</span> </span>&#123; ++count_; &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="title">reduce_count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> --count_; &#125;</span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="title">get_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> count_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">long</span> count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">smart_ptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">smart_ptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">smart_ptr</span><span class="params">(T *ptr = <span class="literal">nullptr</span>)</span> : ptr_(ptr) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">      shared_count_ = <span class="keyword">new</span> <span class="built_in">shared_count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;U&gt; &amp;other) &#123;</span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">      other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">      shared_count_ = other.shared_count_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="built_in">smart_ptr</span>(smart_ptr&lt;U&gt; &amp;&amp;other) &#123;</span><br><span class="line">    ptr_ = other.ptr_;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">      shared_count_ = other.shared_count_;</span><br><span class="line">      other.ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">smart_ptr</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr_ &amp;&amp; !shared_count_-&gt;<span class="built_in">reduce_count</span>()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> ptr_;</span><br><span class="line">      <span class="keyword">delete</span> shared_count_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(smart_ptr &amp;rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="built_in">swap</span>(ptr_, rhs.ptr_);</span><br><span class="line">    <span class="built_in">swap</span>(shared_count_, rhs.shared_count_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">      <span class="keyword">return</span> shared_count_-&gt;<span class="built_in">get_count</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T *ptr_;</span><br><span class="line">  shared_count *shared_count_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">shape</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">circle</span> : <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">circle</span>() &#123; <span class="built_in">puts</span>(<span class="string">&quot;~circle&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">smart_ptr&lt;circle&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> circle())</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;use count of ptr1 is %ld\n&quot;</span>, ptr1.<span class="built_in">use_count</span>());</span><br><span class="line"></span><br><span class="line">  smart_ptr&lt;shape&gt; ptr2;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;use count of ptr2 was %ld\n&quot;</span>, ptr2.<span class="built_in">use_count</span>());</span><br><span class="line"></span><br><span class="line">  ptr2 = ptr1;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;use count of ptr2 is now %ld\n&quot;</span>, ptr2.<span class="built_in">use_count</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ptr1) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ptr1 is not empty&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use count of ptr1 is 1</span><br><span class="line">use count of ptr2 was 0</span><br><span class="line">use count of ptr2 is now 1</span><br><span class="line">ptr1 is not empty</span><br><span class="line">~circle</span><br></pre></td></tr></table></figure>

<p>引用计数的变化，以及最后对象被成功删除。</p>
<h1 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h1><p>对应于 C++ 里的不同的类型强制转换：</p>
<ul>
<li>static_cast</li>
<li>reinterpret_cast</li>
<li>const_cast</li>
<li>dynamic_cast</li>
</ul>
<p>智能指针需要实现类似的函数模板。实现本身并不复杂，但为了实现这些转换，我们需要添加构造函数，允许在对智能指针内部的指针对象赋值时，使用一个现有的智能指针的共享计数。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="built_in">smart_ptr</span>(<span class="type">const</span> smart_ptr&lt;U&gt; &amp;other, T *ptr) &#123;</span><br><span class="line">    ptr_ = ptr;</span><br><span class="line">    <span class="keyword">if</span> (ptr_) &#123;</span><br><span class="line">      other.shared_count_-&gt;<span class="built_in">add_count</span>();</span><br><span class="line">      shared_count_ = other.shared_count_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以实现转换所需的函数模板了。下面实现一个 <code>dynamic_pointer_cast</code> 来示例一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">smart_ptr&lt;T&gt; <span class="title">dynamic_pointer_cast</span><span class="params">(<span class="type">const</span> smart_ptr&lt;U&gt; &amp;other)</span> </span>&#123;</span><br><span class="line">  T *ptr = <span class="built_in">dynamic_cast</span>&lt;T *&gt;(other.<span class="built_in">get</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">smart_ptr</span>&lt;T&gt;(other, ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之std::move和std::forward</title>
    <url>/posts/a3242318.html</url>
    <content><![CDATA[<h1 id="C-11-std-move和std-forward"><a href="#C-11-std-move和std-forward" class="headerlink" title="C++11 std::move和std::forward"></a>C++11 std::move和std::forward</h1><h1 id="引入的新规则"><a href="#引入的新规则" class="headerlink" title="引入的新规则"></a>引入的新规则</h1><p><strong>规则1</strong>（引用折叠规则）：如果间接的创建一个引用的引用，则这些引用就会“折叠”。在所有情况下（除了一个例外），引用折叠成一个普通的左值引用类型。一种特殊情况下，引用会折叠成右值引用，即右值引用的右值引用， T&amp;&amp; &amp;&amp;。即</p>
<ul>
<li>X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp;都折叠成X&amp;</li>
<li>X&amp;&amp; &amp;&amp;折叠为X&amp;&amp;</li>
</ul>
<p><strong>规则2</strong>（右值引用的特殊类型推断规则）：当将一个左值传递给一个参数是右值引用的函数，且此右值引用指向模板类型参数(T&amp;&amp;)时，编译器推断模板参数类型为实参的左值引用，如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">f</span>(i)</span><br></pre></td></tr></table></figure>

<p>上述的模板参数类型T将推断为int&amp;类型，而非int。</p>
<blockquote>
<p>若将规则1和规则2结合起来，则意味着可以传递一个左值int i给f，编译器将推断出T的类型为int&amp;。再根据引用折叠规则 void f(int&amp; &amp;&amp;)将推断为void f(int&amp;)，因此，f将被实例化为: void f&lt;int&amp;&gt;(int&amp;)。</p>
</blockquote>
<p>从上述两个规则可以得出结论：<strong>如果一个函数形参是一个指向模板类型的右值引用，则该参数可以被绑定到一个左值上</strong>，即类似下面的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>规则3</strong>：虽然不能隐式的将一个左值转换为右值引用，但是可以通过static_cast显示地将一个左值转换为一个右值。【C++11中为static_cast新增的转换功能】。</p>
<h1 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h1><h2 id="std-move的使用"><a href="#std-move的使用" class="headerlink" title="std::move的使用"></a>std::move的使用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string member;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy member.</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> std::string&amp; m): <span class="built_in">member</span>(m) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move member.</span></span><br><span class="line">    <span class="built_in">Foo</span>(std::string&amp;&amp; m): <span class="built_in">member</span>(std::<span class="built_in">move</span>(m)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上述<code>Foo(std::string&amp;&amp; member)</code>中的member是rvalue reference，但是member却是一个左值lvalue，因此在初始化列表中需要使用std::move将其转换成rvalue。</p>
<h2 id="std-move-解析"><a href="#std-move-解析" class="headerlink" title="std::move()解析"></a>std::move()解析</h2><p>标准库中move的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type &amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>move函数的参数T&amp;&amp;是一个指向模板类型参数的右值引用【规则2】，通过引用折叠，此参数可以和任何类型的实参匹配，因此move既可以传递一个左值，也可以传递一个右值；</li>
</ul>
<p><code>std::move(string(&quot;hello&quot;))</code>调用解析：</p>
<ul>
<li>首先，根据模板推断规则，确地T的类型为<code>string</code>;</li>
<li><code>typename remove_reference&lt;T&gt;::type &amp;&amp;</code> 的结果为 <code>string &amp;&amp;</code>;</li>
<li><code>move</code>函数的参数类型为<code>string&amp;&amp;</code>;</li>
<li><code>static_cast&lt;string &amp;&amp;&gt;(t)</code>，t已经是<code>string&amp;&amp;</code>，于是类型转换什么都不做，返回<code>string &amp;&amp;</code>;</li>
</ul>
<p>string s1(“hello”); std::move(s1); 调用解析：</p>
<ul>
<li>首先，根据模板推断规则，确定T的类型为<code>string&amp;</code>;</li>
<li><code>typename remove_reference&lt;T&gt;::type &amp;&amp;</code> 的结果为 <code>string&amp;</code></li>
<li>move函数的参数类型为<code>string&amp; &amp;&amp;</code>，引用折叠之后为<strong>string&amp;</strong>;</li>
<li><code>static_cast&lt;string &amp;&amp;&gt;(t)</code>，t是<code>string&amp;</code>，经过<code>static_cast</code>之后转换为<code>string&amp;&amp;</code>, 返回<code>string &amp;&amp;</code>;</li>
</ul>
<blockquote>
<p>从<code>move</code>的定义可以看出，<code>move</code>自身除了做一些参数的推断之外，返回右值引用本质上还是靠<code>static_cast&lt;T&amp;&amp;&gt;</code>完成的。</p>
</blockquote>
<p>因此下面两个调用是等价的，std::move就是个语法糖。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">func</span>(std::<span class="built_in">move</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(b));</span><br></pre></td></tr></table></figure>

<p>std::move执行到右值的无条件转换。就其本身而言，它没有move任何东西。</p>
<h1 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward()"></a>std::forward()</h1><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><blockquote>
<p>完美转发实现了参数在传递过程中保持其值属性的功能，即若是左值，则传递之后仍然是左值，若是右值，则传递之后仍然是右值。</p>
</blockquote>
<blockquote>
<p>C++11 lets us perform perfect forwarding, which means that we can forward the parameters passed to a function template to another function call inside it without losing their own qualifiers (const-ref, ref, value, rvalue, etc.).</p>
</blockquote>
<h2 id="std-forward-解析"><a href="#std-forward-解析" class="headerlink" title="std::forward()解析"></a>std::forward()解析</h2><p>std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string member;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Foo</span><span class="params">(T&amp;&amp; member)</span>: member&#123;</span>std::forward&lt;T&gt;(member)&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>传递一个<code>lvalue</code>或者传递一个<code>const lvaue</code>:</p>
<ul>
<li>传递一个lvalue，模板推导之后 <code>T = std::string&amp;</code></li>
<li>传递一个const lvaue, 模板推导之后<code>T = const std::string&amp;T&amp; &amp;&amp;</code>将折叠为T&amp;，即<code>std::string&amp; &amp;&amp; 折叠为 std::string&amp;</code></li>
<li>最终函数为: <code>Foo(string&amp; member): member&#123;std::forward&lt;string&amp;&gt;(member)&#125; &#123;&#125;</code></li>
<li>std::forward&lt;string&amp;&gt;(member)将返回一个左值，最终调用拷贝构造函数</li>
</ul>
<p>传递一个<code>rvalue</code>:</p>
<ul>
<li>传递一个rvalue，模板推导之后 <code>T = std::string</code></li>
<li>最终函数为: <code>Foo(string&amp;&amp; member): member&#123;std::forward&lt;string&gt;(member)&#125; &#123;&#125;</code></li>
<li><code>std::forward&lt;string&gt;(member)</code> 将返回一个右值，最终调用移动构造函数；</li>
</ul>
<p><code>std::move</code>和<code>std::forward</code>本质都是转换。<code>std::move</code>执行到右值的无条件转换。<code>std::forward</code>只有在它的参数绑定到一个右值上的时候，才转换它的参数到一个右值。</p>
<p><code>std::move</code>没有move任何东西，<code>std::forward</code>没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。</p>
<h1 id="std-move-和std-forward-对比"><a href="#std-move-和std-forward-对比" class="headerlink" title="std::move()和std::forward()对比"></a>std::move()和std::forward()对比</h1><ul>
<li><code>std::move</code>执行到右值的无条件转换。就其本身而言，它没有move任何东西。</li>
<li><code>std::forward</code>只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。</li>
<li><code>std::move</code>和<code>std::forward</code>只不过就是执行类型转换的两个函数；<code>std::move</code>没有move任何东西，<code>std::forward</code>没有转发任何东西。在运行期，它们没有做任何事情。它们没有产生需要执行的代码，一byte都没有。</li>
<li><code>std::forward&lt;T&gt;()</code>不仅可以保持左值或者右值不变，同时还可以保持const、Lreference、Rreference、validate等属性不变；</li>
</ul>
<h1 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> &amp;&amp;n) &#123; cout &lt;&lt; <span class="string">&quot;rvalue overload. n=&quot;</span> &lt;&lt; n &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> &amp;n) &#123; cout &lt;&lt; <span class="string">&quot;lvalue overload. n=&quot;</span> &lt;&lt; n &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>, <span class="keyword">class</span> <span class="title class_">T3</span>&gt;</span><br><span class="line">  <span class="built_in">B</span>(T1 &amp;&amp;t1, T2 &amp;&amp;t2, T3 &amp;&amp;t3)</span><br><span class="line">      : <span class="built_in">a1_</span>(std::forward&lt;T1&gt;(t1)), <span class="built_in">a2_</span>(std::forward&lt;T2&gt;(t2)),</span><br><span class="line">        <span class="built_in">a3_</span>(std::forward&lt;T3&gt;(t3)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  A a1_, a2_, a3_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> p1 = <span class="built_in">make_unique</span>&lt;A&gt;(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">auto</span> p2 = <span class="built_in">make_unique</span>&lt;A&gt;(i);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> j = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">auto</span> p3 = <span class="built_in">make_unique</span>&lt;B&gt;(i, <span class="number">2</span>, j);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rvalue overload. n=2</span><br><span class="line">lvalue overload. n=10</span><br><span class="line">lvalue overload. n=10</span><br><span class="line">rvalue overload. n=2</span><br><span class="line">lvalue overload. n=100</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之Const详解</title>
    <url>/posts/532077f8.html</url>
    <content><![CDATA[<h1 id="Const详解"><a href="#Const详解" class="headerlink" title="Const详解"></a>Const详解</h1><h1 id="const含义"><a href="#const含义" class="headerlink" title="const含义"></a>const含义</h1><p>常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。</p>
<h1 id="const作用"><a href="#const作用" class="headerlink" title="const作用"></a>const作用</h1><ol>
<li>可以定义常量</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>类型检查</li>
</ol>
<p>const常量与#define宏定义常量的区别： <strong>const常量具有类型，编译器可以进行安全检查；#define宏定义没有数据类型，只是简单的字符串替换，不能进行安全检查</strong>。</p>
<ol start="3">
<li>防止修改，起保护作用，增加程序健壮性</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    i++; <span class="comment">//error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>可以节省空间，避免不必要的内存分配</li>
</ol>
<p>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝。</p>
<h1 id="const对象默认为文件局部变量"><a href="#const对象默认为文件局部变量" class="headerlink" title="const对象默认为文件局部变量"></a>const对象默认为文件局部变量</h1><p>非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern</p>
<p>未被const修饰的变量在不同文件的访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="type">int</span> ext</span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * by 光城</span></span><br><span class="line"><span class="comment"> * compile: g++ -o file file2.cpp file1.cpp</span></span><br><span class="line"><span class="comment"> * execute: ./file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;(ext+<span class="number">10</span>)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const常量在不同文件的访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//extern_file1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> ext=<span class="number">12</span>;</span><br><span class="line"><span class="comment">//extern_file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * by 光城</span></span><br><span class="line"><span class="comment"> * compile: g++ -o file const_file2.cpp const_file1.cpp</span></span><br><span class="line"><span class="comment"> * execute: ./file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;ext&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现未被const修饰的变量不需要extern显式声明！而const常量需要显式声明extern，并且需要做初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。</p>
<h1 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">0</span>; <span class="comment">// error: assignment of read-only variable ‘b’</span></span><br><span class="line"><span class="type">const</span> string s = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i,j=<span class="number">0</span> <span class="comment">// error: uninitialized const ‘i’</span></span><br></pre></td></tr></table></figure>

<p>上述有两个错误：</p>
<ol>
<li>b为常量，不可更改</li>
<li>i为常量，必须进行初始化！(因为常量在定义后就不能被修改，所以定义时必须初始化。)</li>
</ol>
<h1 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * a; <span class="comment">//指向const对象的指针或者说指向常量的指针。</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> * a; <span class="comment">//同上</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向类型对象的const指针。或者说常指针、const指针。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> a; <span class="comment">//指向const对象的const指针。</span></span><br></pre></td></tr></table></figure>

<p>如果const位于的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于的右侧，const就是修饰指针本身，即指针本身是常量。</p>
<p>具体使用如下：</p>
<ol>
<li>指向常量的指针</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr;</span><br><span class="line">*ptr = <span class="number">10</span>; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>ptr是一个指向int类型const对象的指针，const定义的是int类型，也就是ptr所指向的对象类型，而不是ptr本身，所以ptr可以不用赋初始值。但是不能通过ptr去修改所指对象的值。</p>
<p>除此之外，也不能使用void指针保存const对象的地址，必须使用const void类型的指针保存const对象的地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">void</span> * vp = &amp;p;</span><br><span class="line"><span class="type">void</span> *vp = &amp;p; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p>另外一个重点是：<strong>允许把非const对象的地址赋给指向const对象的指针。</strong></p>
<p>将非const对象的地址赋给const对象的指针:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr;</span><br><span class="line"><span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">ptr = &amp;val; <span class="comment">//ok</span></span><br></pre></td></tr></table></figure>

<p>我们不能通过ptr指针来修改val的值，即使它指向的是非const对象!</p>
<p>我们不能使用指向const对象的指针修改基础对象，然而如果该指针指向了非const对象，可用其他方式修改其所指的对象。可以修改const指针所指向的值的，但是不能通过const对象指针来进行而已！如下修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptr1 = &amp;val;</span><br><span class="line">*ptr1=<span class="number">4</span>;</span><br><span class="line">cout&lt;&lt;*ptr&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>对于指向常量的指针，不能通过指针来修改对象的值。</p>
<p>也不能使用void<code>*</code>指针保存const对象的地址，必须使用const void<code>*</code>类型的指针保存const对象的地址。</p>
<p>允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。</p>
<ol start="2">
<li>常指针</li>
</ol>
<p>const指针必须进行初始化，且const指针的值不能修改。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> ptr=&amp;num; <span class="comment">//const指针必须初始化！且const指针的值不能修改</span></span><br><span class="line">    <span class="type">int</span> * t = &amp;num;</span><br><span class="line">    *t = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;*ptr&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述修改ptr指针所指向的值，可以通过非const指针来修改。</p>
<p>最后，当把一个const常量的地址赋值给ptr时候，由于ptr指向的是一个变量，而不是const常量，所以会报错，出现：const int * -&gt; int * 错误！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> ptr=&amp;num; <span class="comment">//error! const int* -&gt; int*</span></span><br><span class="line">    cout&lt;&lt;*ptr&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述若改为 const int *ptr或者改为const int *const ptr，都可以正常！</p>
<ol start="3">
<li>指向常量的常指针</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> ptr = &amp;p;</span><br></pre></td></tr></table></figure>

<p>ptr是一个const指针，然后指向了一个int 类型的const对象。</p>
<h1 id="函数中使用const"><a href="#函数中使用const" class="headerlink" title="函数中使用const"></a>函数中使用const</h1><aside>
💡 cost修饰函数返回值

</aside>

<p>这个跟const修饰普通变量以及指针的含义基本相同：</p>
<ol>
<li>const int</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个本身无意义，因为参数返回本身就是赋值给其他的变量！</p>
<ol start="2">
<li>const int*</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">func2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>指针指向的内容不变。</p>
<ol start="3">
<li>int *const</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="type">const</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>指针本身不可变。</p>
<aside>
💡 const修饰函数参数

</aside>

<ol>
<li>传递过来的参数及指针本身在函数内不可变，无意义！</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> var)</span></span>; <span class="comment">// 传递过来的参数不可变</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *<span class="type">const</span> var)</span></span>; <span class="comment">// 指针本身不可变</span></span><br></pre></td></tr></table></figure>

<p>表明参数在函数体内不能被修改，但此处没有任何意义，var本身就是形参，在函数内不会改变。包括传入的形参是指针也是一样。</p>
<p>输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。</p>
<ol start="2">
<li>参数指针所指内容为常量不可变</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StringCopy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。</p>
<ol start="3">
<li>参数为引用，为了增加效率同时防止修改。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> A &amp;a)</span></span></span><br></pre></td></tr></table></figure>

<p>对于非内部数据类型的参数而言，象void func(A a) 这样声明的函数注定效率比较低。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。</p>
<p>为了提高效率，可以将函数声明改为void func(A &amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。但是函数void func(A &amp;a) 存在一个缺点：</p>
<p>“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为 void func(const A &amp;a)。以此类推，是否应将void func(int x) 改写为void func(const int &amp;x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p>
<p><strong>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void func(A a) 改为void func(const A &amp;a)。</strong></p>
<p><strong>对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int &amp;x)。</strong></p>
<p>以上解决了两个面试问题：</p>
<p>（1）如果函数需要传入一个指针，是否需要为该指针加上const，把const加在指针不同的位置有什么区别；</p>
<p>（2）如果写的函数需要传入的参数是一个复杂类型的实例，传入值参数或者引用参数有什么区别，什么时候需要为传入的引用参数加上const。</p>
<h1 id="类中使用const"><a href="#类中使用const" class="headerlink" title="类中使用const"></a>类中使用const</h1><p>在一个类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。使用const关字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字明的成员函数不能用来操作常对象。</p>
<p>对于类中的const成员变量必须通过初始化列表进行初始化，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> people[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Apple</span>(<span class="type">int</span> i); </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> apple_number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Apple::<span class="built_in">Apple</span>(<span class="type">int</span> i):<span class="built_in">apple_number</span>(i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//apple.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> people[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Apple</span>(<span class="type">int</span> i); </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> apple_number;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">take</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;apple.cpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">Apple::<span class="built_in">Apple</span>(<span class="type">int</span> i):<span class="built_in">apple_number</span>(i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Apple::add</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="built_in">take</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Apple::add</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="built_in">take</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Apple::take</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;take func &quot;</span>&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Apple::getCount</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">take</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//    add(); //error</span></span><br><span class="line">    <span class="keyword">return</span> apple_number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Apple <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">getCount</span>()&lt;&lt;endl;</span><br><span class="line">    a.<span class="built_in">add</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="type">const</span> Apple <span class="title">b</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">add</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译： g++ -o main main.cpp apple.cpp</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">take func <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">take func <span class="number">10</span></span><br><span class="line">take func <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>上面getCount()方法中调用了一个add方法，而add方法并非const修饰，所以运行报错。也就是说const对象只能访问const成员函数。而add方法又调用了const修饰的take方法，证明了非const对象可以访问任意的成员函数,包括const成员函数。除此之外，我们也看到add的一个重载函数，也输出了两个结果，说明const对象默认调用const成员函数。我们除了上述的初始化const常量用初始化列表方式外，也可以通过下面方法：</p>
<p>第一：将常量定义与static结合，也就是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number</span><br></pre></td></tr></table></figure>

<p>第二：在外面初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Apple::apple_number=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>当然，如果你使用c++11进行编译，直接可以在定义出初始化，可以直接写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number=<span class="number">10</span>;</span><br><span class="line">或者</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> apple_number=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>编译的时候加上<code>-std=c++11</code>即可！</p>
<p>这里提到了static，下面简单的说一下：</p>
<p>在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。</p>
<p>在类中声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> ap;</span><br></pre></td></tr></table></figure>

<p>在类实现文件中使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> Apple::ap=<span class="number">666</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之inline详解</title>
    <url>/posts/5fed6d8e.html</url>
    <content><![CDATA[<h1 id="inline详解"><a href="#inline详解" class="headerlink" title="inline详解"></a>inline详解</h1><h1 id="类中内联"><a href="#类中内联" class="headerlink" title="类中内联"></a>类中内联</h1><p>头文件中声明方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param x</span></span><br><span class="line"><span class="comment">     * @param y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">///&lt; 定义即隐式内联函数！</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">///&lt; 声明后，要想成为内联函数，必须在定义处加inline关键字。  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现文件中定义内联函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x</span></span><br><span class="line"><span class="comment"> * @param y</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;  <span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">// 函数定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义处加inline关键字，推荐这种写法！</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">A::f1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">Foo</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译器对 inline 函数的处理步骤</span></span><br><span class="line"><span class="comment"> * 将 inline 函数体复制到 inline 函数调用点处；</span></span><br><span class="line"><span class="comment"> * 为所用 inline 函数中的局部变量分配内存空间；</span></span><br><span class="line"><span class="comment"> * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</span></span><br><span class="line"><span class="comment"> * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>内联能提高函数效率，但并不是所有的函数都定义成内联函数！内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。</p>
<ul>
<li>如果执行函数体内代码的时间相比于函数调用的开销较大，那么效率的收货会更少！</li>
<li>每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
</ul>
<p>以下情况不宜用内联：</p>
<ul>
<li>如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高。</li>
<li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li>
</ul>
<h1 id="虚函数（virtual）可以是内联函数（inline）吗"><a href="#虚函数（virtual）可以是内联函数（inline）吗" class="headerlink" title="虚函数（virtual）可以是内联函数（inline）吗"></a>虚函数（virtual）可以是内联函数（inline）吗</h1><ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Base\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am Derived\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">    Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之sizeof详解</title>
    <url>/posts/a13f6528.html</url>
    <content><![CDATA[<h1 id="sizeof-详解"><a href="#sizeof-详解" class="headerlink" title="sizeof 详解"></a>sizeof 详解</h1><h1 id="类大小计算"><a href="#类大小计算" class="headerlink" title="类大小计算"></a>类大小计算</h1><ul>
<li>空类的大小为1字节</li>
<li>一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。</li>
<li>对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。</li>
<li>普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小</li>
<li>虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！</li>
<li>虚继承,继承基类的vptr。</li>
</ul>
<h2 id="原则1"><a href="#原则1" class="headerlink" title="原则1"></a>原则1</h2><p>空类的大小为1字节</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空类的大小为1字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原则2"><a href="#原则2" class="headerlink" title="原则2"></a>原则2</h2><p>静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员，但不影响类的大小。不管这个类产生了多少个实例，还是派生了多少新的类，静态数据成员只有一个实例。静态数据成员，一旦被声明，就已经存在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> b;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> c;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> d;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 16  字节对齐、静态变量不影响类的大小、vptr指针=8</span></span><br><span class="line">  <span class="comment">// |b| ... | virtual void fun |  </span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原则3"><a href="#原则3" class="headerlink" title="原则3"></a>原则3</h2><p>对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="原则4与5"><a href="#原则4与5" class="headerlink" title="原则4与5"></a>原则4与5</h1><ol>
<li>普通单继承,继承就是基类+派生类自身的大小(注意字节对齐)。注意：类的数据成员按其声明顺序加入内存，无访问权限无关，只看声明顺序。</li>
<li>虚单继承，派生类继承基类vptr</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;; <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 此时B按照顺序：</span></span><br><span class="line"><span class="comment"> * char a</span></span><br><span class="line"><span class="comment"> * int b</span></span><br><span class="line"><span class="comment"> * short a</span></span><br><span class="line"><span class="comment"> * long b</span></span><br><span class="line"><span class="comment"> * 根据字节对齐4+4=8+8+8=24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">short</span> a;</span><br><span class="line">  <span class="type">long</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> : <span class="keyword">public</span> A1 &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funA</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B2</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">funB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C2</span> : <span class="keyword">public</span> A2, <span class="keyword">public</span> B2 &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; endl; <span class="comment">// 24</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; endl; <span class="comment">// 12</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 对于虚单函数继承，派生类也继承了基类的vptr，所以是8字节</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(B1) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(C2) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原则6"><a href="#原则6" class="headerlink" title="原则6"></a>原则6</h2><p>虚继承</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A, <span class="keyword">virtual</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 8 8 16  派生类虚继承多个虚函数，会继承所有虚函数的vptr</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(C);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之static详解</title>
    <url>/posts/34ffe6e9.html</url>
    <content><![CDATA[<h1 id="static详解"><a href="#static详解" class="headerlink" title="static详解"></a>static详解</h1><p>使用static关键字：</p>
<p><strong>静态变量：</strong> 函数中的变量，类中的变量</p>
<p><strong>静态类的成员：</strong> 类对象和类中的函数</p>
<h1 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h1><ul>
<li>函数中的静态变量</li>
</ul>
<p>当变量声明为static时，空间将在程序的生命周期内分配。即使多次调用该函数，静态变量的空间也只分配一次，前一次调用中的变量值通过下一次函数调用传递。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// static variable</span></span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// value is update and will be carried to next function calls</span></span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">demp</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure>

<p>值通过函数调用来传递。每次调用函数时，都不会对变量计数进行初始化</p>
<ul>
<li>类中的静态变量</li>
</ul>
<p>类中的静态变量由对象共享。对于不同对对象，不能由相同静态变量的多个副本。也是这个原因，静态变量不能使用构造函数初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Apple</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Apple obj1;</span><br><span class="line">  Apple obj2;</span><br><span class="line"></span><br><span class="line">  obj1.i = <span class="number">2</span>;</span><br><span class="line">  obj2.i = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// print value of i</span></span><br><span class="line">  cout &lt;&lt; obj1.i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; obj2.i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译报错。因此，类中的静态变量应由用户使用嘞外的类名和范围解析运算符显式初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Apple</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Apple::i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Apple obj;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; obj.i &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h1 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h1><ul>
<li>类对象为静态</li>
</ul>
<p>就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。</p>
<p>考虑以下程序，其中对象时非静态的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Apple</span>() &#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inside Constructor\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Apple</span>() &#123; cout &lt;&lt; <span class="string">&quot;Inside Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">    Apple obj;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;End of main\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inside Constructor</span><br><span class="line">Inside Destructor</span><br><span class="line">End of main</span><br></pre></td></tr></table></figure>

<p>以上程序中，对象在if块内声明为非静态。所以，变量范围仅在if块内。因此，当创建对象时，将调用构造函数，并且在if块的控制权越过析构函数的同时调用，因为对象的范围仅在声明它的if块内。</p>
<p>如果我们将对象声明为静态，现在让我们看看输出的变化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Apple</span>() &#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inside Constructor\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Apple</span>() &#123; cout &lt;&lt; <span class="string">&quot;Inside Destructor\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">static</span> Apple obj;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;End of main\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inside Constructor</span><br><span class="line">End of main</span><br><span class="line">Inside Destructor</span><br></pre></td></tr></table></figure>

<p>现在，在main结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期。</p>
<ul>
<li>类中的静态函数</li>
</ul>
<p>就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和’.’来调用静态成员函数。但建议使用类名和范围解析运算符调用静态成员。</p>
<p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// static member function</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printMsg</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Welcome to Apple!&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; Apple::<span class="built_in">printMsg</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Welcome to Apple!</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之this详解</title>
    <url>/posts/8ff26f14.html</url>
    <content><![CDATA[<h1 id="this详解"><a href="#this详解" class="headerlink" title="this详解"></a>this详解</h1><p>this的用处：</p>
<ol>
<li>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。</li>
<li>this作用域时在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含行参，对各成员的访问均可通过this访问。</li>
</ol>
<p>其次，this指针的使用：</p>
<ol>
<li>在类的非静态成员函数中返回类对象本身的时候，直接使用return *this。</li>
<li>当参数与成员变量名相同时，如this-&gt;n &#x3D; n （不能写成n &#x3D; n)。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; BOY = <span class="number">0</span>, GIRL &#125; SexType;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="type">char</span> *n, <span class="type">int</span> a, SexType s) &#123;</span><br><span class="line">    name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(n) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(name, n);</span><br><span class="line">    age = a;</span><br><span class="line">    sex = s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person &amp;<span class="title">add_age</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    age += a;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123; <span class="keyword">delete</span>[] name; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  SexType sex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">20</span>, Person::BOY)</span></span>;</span><br><span class="line">  cout &lt;&lt; p.<span class="built_in">get_age</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; p.<span class="built_in">add_age</span>(<span class="number">10</span>).<span class="built_in">get_age</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p>
<p>上述的get_age函数会被解析成get_age(const A * const this)，add_age函数会被解析成add_age(A* const this,int a)。在C++中类和结构是只有一个区别的：类的成员默认是private，而结构是public。this是类的指针，如果换成结构，那this就是结构的指针了。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>字节对齐详解</title>
    <url>/posts/c447bbf4.html</url>
    <content><![CDATA[<h1 id="字节对其详解"><a href="#字节对其详解" class="headerlink" title="字节对其详解"></a>字节对其详解</h1><h1 id="什么是字节对齐"><a href="#什么是字节对齐" class="headerlink" title="什么是字节对齐"></a>什么是字节对齐</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> y;</span><br><span class="line">&#125; s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(s));  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算机中内存大小的基本单位是字节（byte），理论上来讲，可以从任意地址访问某种基本数据类型，但是实际上，计算机并非逐字节大小读写内存，而是以2,4,或8的 倍数的字节块来读写内存，如此一来就会对基本数据类型的合法地址作出一些限制，即它的地址必须是2，4或8的倍数。那么就要求各种数据类型按照一定的规则在空间上排列，这就是对齐。</p>
<h1 id="对齐准则"><a href="#对齐准则" class="headerlink" title="对齐准则"></a>对齐准则</h1><ul>
<li>结构体变量的首地址能够被其对齐字节数大小所整除。</li>
<li>结构体每个成员相对结构体首地址的偏移都是成员大小的整数倍，如不满足，对前一个成员填充字节以满足。</li>
<li>结构体的总大小为结构体对齐字节数大小的整数倍，如不满足，最后填充字节以满足。</li>
</ul>
<p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n &#x3D; 1,2,4,8,16来改变这一系数。</p>
<p>有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。</p>
<ol>
<li>结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。</li>
<li>结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> c1;</span><br><span class="line">  <span class="type">char</span> c2;</span><br><span class="line">&#125; x1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> c1;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> c2;</span><br><span class="line">&#125; x2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> c1;</span><br><span class="line">  <span class="type">char</span> c2;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125; x3;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(x1)); <span class="comment">// 输出8</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(x2)); <span class="comment">// 输出12</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(x3)); <span class="comment">// 输出8</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>linux下默认#pragma pack(4)，且结构体中最长的数据类型为4个字节，所以有效对齐单位为4字节。</p>
<p>以x2来分析其内存布局：</p>
<p>首先使用规则1，对成员变量进行对齐：</p>
<ol>
<li>sizeof(c1) &#x3D; 1 &lt;&#x3D; 4(有效对齐位)，按照1字节对齐，占用第0单元；</li>
<li>sizeof(i) &#x3D; 4 &lt;&#x3D; 4(有效对齐位)，相对于结构体首地址的偏移要为4的倍数，占用第4，5，6，7单元；</li>
<li>sizeof(c2) &#x3D; 1 &lt;&#x3D; 4(有效对齐位)，相对于结构体首地址的偏移要为1的倍数，占用第8单元；</li>
</ol>
<p>然后使用规则2，对结构体整体进行对齐：</p>
<p>s2中变量i占用内存最大占4字节，而有效对齐单位也为4字节，两者较小值就是4字节。因此整体也是按照4字节对齐。由规则1得到s2占9个字节，此处再按照规则2进行整体的4字节对齐，所以整个结构体占用12个字节。</p>
<p><img src="https://img.ansore.de/2022/05/04/62726fcee9417.png" alt="g"></p>
<p>如果前面加上#pragma pack(2)，有效对齐值为2字节，此时根据对齐规则，三个结构体的大小应为6,8,6。内存分布图如下：</p>
<p><img src="https://img.ansore.de/2022/05/04/62726fc10601a.png" alt="1"></p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> c1;</span><br><span class="line">  <span class="type">char</span> c2;</span><br><span class="line">&#125; x1;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> c1;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> c2;</span><br><span class="line">&#125; x2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> c1;</span><br><span class="line">  <span class="type">char</span> c2;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125; x3;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(x1)); <span class="comment">// 输出6</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(x2)); <span class="comment">// 输出8</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(x3)); <span class="comment">// 输出6</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之纯虚函数和抽象类</title>
    <url>/posts/b2ac274f.html</url>
    <content><![CDATA[<h1 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h1><h1 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h1><p>C++中的纯虚函数(或抽象函数)是我们没有实现的虚函数！我们只需声明它!通过声明中赋值0来声明纯虚函数！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="comment">// Data members of class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Pure Virtual Function</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Other members */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>纯虚函数：没有函数体的虚函数</li>
<li>抽象类：包含纯虚函数的类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>=<span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1. 抽象类只能作为基类来派生新类使用</span></span><br><span class="line"><span class="comment">     * 2. 抽象类的指针和引用-&gt;由抽象类派生出来的类的对象！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    A a; <span class="comment">// error 抽象类，不能创建对象</span></span><br><span class="line"></span><br><span class="line">    A *a1; <span class="comment">// ok 可以定义抽象类的指针</span></span><br><span class="line"></span><br><span class="line">    A *a2 = <span class="keyword">new</span> <span class="built_in">A</span>(); <span class="comment">// error, A是抽象类，不能创建对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象,抽象类的指针和引用-&gt;由抽象类派生出来的类的对象！</p>
<h1 id="实现抽象类"><a href="#实现抽象类" class="headerlink" title="实现抽象类"></a>实现抽象类</h1><p>抽象类中：在成员函数内可以调用纯虚函数，在构造函数&#x2F;析构函数内部不能使用纯虚函数。</p>
<p>如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;<span class="built_in">f</span>(); &#125;</span><br><span class="line">  <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B::f()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.<span class="built_in">g</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="重要点"><a href="#重要点" class="headerlink" title="重要点"></a>重要点</h1><ul>
<li>纯虚函数使一个类变成抽象类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 抽象类至少包含一个纯虚函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  Test t; <span class="comment">// error! 不能创建抽象类的对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象类类型的指针和引用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 抽象类至少包含一个纯虚函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;In Derived \n&quot;</span>; &#125;</span><br><span class="line">  <span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Base b;  //error! 不能创建抽象类的对象</span></span><br><span class="line">  <span class="comment">// Base *b = new Base(); error!</span></span><br><span class="line">  Base *bp = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 抽象类的指针和引用 -&gt; 由抽象类派生出来的类的对象</span></span><br><span class="line">  bp-&gt;<span class="built_in">show</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象类可以有构造函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An abstract class with constructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">Base</span>(<span class="type">int</span> i) &#123; x = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derived</span>(<span class="type">int</span> i, <span class="type">int</span> j) : <span class="built_in">Base</span>(i) &#123; y = j; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">  d.<span class="built_in">fun</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数不能是虚函数，而析构函数可以是虚析构函数。（当基类指针指向派生类对象并删除对象时，我们可能希望调用适当的析构函数。如果析构函数不是虚拟的，则只能调用基类析构函数。）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Constructor: Base&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destructor : Base&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Constructor: Derived&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destructor : Derived&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base *Var = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">  <span class="keyword">delete</span> Var;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor: Base</span><br><span class="line">Constructor: Derived</span><br><span class="line">Destructor : Derived</span><br><span class="line">Destructor : Base</span><br></pre></td></tr></table></figure>

<h1 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h1><p>抽象类由派生类继承实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;fun() called&quot;</span>; &#125; <span class="comment">// 实现了fun()函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  Derived d;</span><br><span class="line">  d.<span class="built_in">fun</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之虚函数的vptr和vtable</title>
    <url>/posts/783ca4e1.html</url>
    <content><![CDATA[<h1 id="虚函数的vptr与vtable"><a href="#虚函数的vptr与vtable" class="headerlink" title="虚函数的vptr与vtable"></a>虚函数的vptr与vtable</h1><p>为了实现虚函数，C ++使用一种称为虚拟表的特殊形式的后期绑定。该虚拟表是用于解决在动态&#x2F;后期绑定方式的函数调用函数的查找表。虚拟表有时会使用其他名称，例如“vtable”，“虚函数表”，“虚方法表”或“调度表”。</p>
<p>首先，<strong>每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚拟表</strong>。该表只是编译器在编译时设置的静态数组。虚拟表包含可由类的对象调用的每个虚函数的一个条目。此表中的每个条目只是一个函数指针，指向该类可访问的派生函数。</p>
<p>其次，编译器还会添加一个隐藏指向基类的指针，我们称之为vptr。vptr在创建类实例时自动设置，以便指向该类的虚拟表。与this指针不同，this指针实际上是编译器用来解析自引用的函数参数，vptr是一个真正的指针。</p>
<p>因此，它使每个类对象的分配大一个指针的大小。这也意味着vptr由派生类继承，这很重要。</p>
<h1 id="实现与内部结构"><a href="#实现与内部结构" class="headerlink" title="实现与内部结构"></a>实现与内部结构</h1><p><img src="https://img.ansore.de/2022/05/04/62726f9dc2795.png" alt="Screenshot"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Fun)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  ~<span class="built_in">Base</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 派生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derived</span>()&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;DerivedClass::fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">  ~<span class="built_in">Derived</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> * 获取vptr地址与func地址,vptr指向的是一块内存，这块内存存放的是虚函数地址，这块内存就是我们所说的虚表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param obj</span></span><br><span class="line"><span class="comment"> * @param offset</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Fun <span class="title">getAddr</span><span class="params">(<span class="type">void</span> *obj, <span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;=======================&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="type">void</span> *vptr_addr =</span><br><span class="line">      (<span class="type">void</span> *)*(<span class="type">unsigned</span> <span class="type">long</span> *)obj; <span class="comment">// 64位操作系统，占8字节，通过*(unsigned</span></span><br><span class="line">                                     <span class="comment">// long *)obj取出前8字节，即vptr指针</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;vptr_addr:%p\n&quot;</span>, vptr_addr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @brief 通过vptr指针访问virtual</span></span><br><span class="line"><span class="comment">   * table，因为虚表中每个元素(虚函数指针)在64位编译器下是8个字节，因此通过*(unsigned</span></span><br><span class="line"><span class="comment">   * long *)vptr_addr取出前8字节， 后面加上偏移量就是每个函数的地址！</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">void</span> *func_addr = (<span class="type">void</span> *)*((<span class="type">unsigned</span> <span class="type">long</span> *)vptr_addr + offset);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;func_addr:%p\n&quot;</span>, func_addr);</span><br><span class="line">  <span class="keyword">return</span> (Fun)func_addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  Base ptr;</span><br><span class="line">  Derived d;</span><br><span class="line">  Base *pt = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 基类指针指向派生类实例</span></span><br><span class="line">  Base &amp;pp = ptr;           <span class="comment">// 基类引用指向基类实例</span></span><br><span class="line">  Base &amp;p = d;              <span class="comment">// 基类引用指向派生类实例</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;基类对象直接调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  ptr.<span class="built_in">fun1</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;基类对象调用基类实例&quot;</span> &lt;&lt; endl;</span><br><span class="line">  pp.<span class="built_in">fun1</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;基类指针指向派生类实例并调用虚函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  pt-&gt;<span class="built_in">fun1</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;基类引用指向派生类实例并调用虚函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">  p.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 手动查找vptr 和 vtable</span></span><br><span class="line">  Fun f1 = <span class="built_in">getAddr</span>(pt, <span class="number">0</span>);</span><br><span class="line">  (*f1)();</span><br><span class="line">  Fun f2 = <span class="built_in">getAddr</span>(pt, <span class="number">1</span>);</span><br><span class="line">  (*f2)();</span><br><span class="line">  <span class="keyword">delete</span> pt;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基类对象直接调用</span><br><span class="line">Base::fun1()</span><br><span class="line">基类对象调用基类实例</span><br><span class="line">Base::fun1()</span><br><span class="line">基类指针指向派生类实例并调用虚函数</span><br><span class="line">Derived::fun1()</span><br><span class="line">基类引用指向派生类实例并调用虚函数</span><br><span class="line">Derived::fun1()</span><br><span class="line">=======================</span><br><span class="line">vptr_addr:0x559376928d50</span><br><span class="line">func_addr:0x55937692656e</span><br><span class="line">Derived::fun1()</span><br><span class="line">=======================</span><br><span class="line">vptr_addr:0x559376928d50</span><br><span class="line">func_addr:0x5593769265a6</span><br><span class="line">DerivedClass::fun2()</span><br></pre></td></tr></table></figure>

<p>C++的动态多态性是通过虚函数来实现的。简单的说，通过virtual函数，指向子类的基类指针可以调用子类的函数。例如，上述通过基类指针指向派生类实例，并调用虚函数，将上述代码简化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base *pt = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 基类指针指向派生类实例</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;基类指针指向派生类实例并调用虚函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">pt-&gt;<span class="built_in">fun1</span>();</span><br></pre></td></tr></table></figure>

<p>首先程序识别出fun1()是个虚函数，其次程序使用pt-&gt;vptr来获取Derived的虚拟表。第三，它查找Derived虚拟表中调用哪个版本的fun1()。这里就可以发现调用的是Derived::fun1()。因此pt-&gt;fun1()被解析为Derived::fun1()!</p>
<p>除此之外，上述代码大家会看到，也包含了手动获取vptr地址，并调用vtable中的函数，那么我们一起来验证一下上述的地址与真正在自动调用vtable中的虚函数，比如上述pt-&gt;fun1()的时候，是否一致！</p>
<p>这里采用gdb调试，在编译的时候记得加上<code>-g</code>。</p>
<p>通过<code>gdb vptr</code>进入gdb调试页面，然后输入<code>b Derived::fun1</code>对fun1打断点，然后通过输入r运行程序到断点处，此时我们需要查看调用栈中的内存地址，通过<code>disassemable fun1</code>可以查看当前有关fun1中的相关汇编代码，我们看到了<code>0x0000000000400ea8</code>，然后再对比上述的结果会发现与手动调用的fun1一致，fun2类似，以此证明代码正确!</p>
<p>gdb调试信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reading symbols from vptr...</span><br><span class="line">(gdb) b Derived::fun1</span><br><span class="line">Breakpoint 1 at 0x157a: file vptr1.cpp, line 28.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/ansore/study/C++/basic_content/vptr/vptr </span><br><span class="line">基类对象直接调用</span><br><span class="line">Base::fun1()</span><br><span class="line">基类对象调用基类实例</span><br><span class="line">Base::fun1()</span><br><span class="line">基类指针指向派生类实例并调用虚函数</span><br><span class="line"></span><br><span class="line">Breakpoint 1, Derived::fun1 (this=0x55555556aeb0) at vptr1.cpp:28</span><br><span class="line">28        void fun1() &#123; cout &lt;&lt; &quot;Derived::fun1()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">(gdb) disassemble fun1</span><br><span class="line">Dump of assembler code for function _ZN7Derived4fun1Ev:</span><br><span class="line">   0x000055555555556e &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x000055555555556f &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x0000555555555572 &lt;+4&gt;:     sub    $0x10,%rsp</span><br><span class="line">   0x0000555555555576 &lt;+8&gt;:     mov    %rdi,-0x8(%rbp)</span><br><span class="line">=&gt; 0x000055555555557a &lt;+12&gt;:    lea    0xaa2(%rip),%rsi        # 0x555555556023</span><br><span class="line">   0x0000555555555581 &lt;+19&gt;:    lea    0x2af8(%rip),%rdi        # 0x555555558080 &lt;_ZSt4cout@GLIBCXX_3.4&gt;</span><br><span class="line">   0x0000555555555588 &lt;+26&gt;:    call   0x555555555050 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;</span><br><span class="line">   0x000055555555558d &lt;+31&gt;:    mov    %rax,%rdx</span><br><span class="line">   0x0000555555555590 &lt;+34&gt;:    mov    0x2a39(%rip),%rax        # 0x555555557fd0</span><br><span class="line">   0x0000555555555597 &lt;+41&gt;:    mov    %rax,%rsi</span><br><span class="line">   0x000055555555559a &lt;+44&gt;:    mov    %rdx,%rdi</span><br><span class="line">   0x000055555555559d &lt;+47&gt;:    call   0x555555555080 &lt;_ZNSolsEPFRSoS_E@plt&gt;</span><br><span class="line">   0x00005555555555a2 &lt;+52&gt;:    nop</span><br><span class="line">   0x00005555555555a3 &lt;+53&gt;:    leave  </span><br><span class="line">   0x00005555555555a4 &lt;+54&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disassemble fun2</span><br><span class="line">Dump of assembler code for function _ZN7Derived4fun2Ev:</span><br><span class="line">   0x00005555555555a6 &lt;+0&gt;:     push   %rbp</span><br><span class="line">   0x00005555555555a7 &lt;+1&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x00005555555555aa &lt;+4&gt;:     sub    $0x10,%rsp</span><br><span class="line">   0x00005555555555ae &lt;+8&gt;:     mov    %rdi,-0x8(%rbp)</span><br><span class="line">   0x00005555555555b2 &lt;+12&gt;:    lea    0xa7a(%rip),%rsi        # 0x555555556033</span><br><span class="line">   0x00005555555555b9 &lt;+19&gt;:    lea    0x2ac0(%rip),%rdi        # 0x555555558080 &lt;_ZSt4cout@GLIBCXX_3.4&gt;</span><br><span class="line">   0x00005555555555c0 &lt;+26&gt;:    call   0x555555555050 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;</span><br><span class="line">   0x00005555555555c5 &lt;+31&gt;:    mov    %rax,%rdx</span><br><span class="line">   0x00005555555555c8 &lt;+34&gt;:    mov    0x2a01(%rip),%rax        # 0x555555557fd0</span><br><span class="line">   0x00005555555555cf &lt;+41&gt;:    mov    %rax,%rsi</span><br><span class="line">   0x00005555555555d2 &lt;+44&gt;:    mov    %rdx,%rdi</span><br><span class="line">   0x00005555555555d5 &lt;+47&gt;:    call   0x555555555080 &lt;_ZNSolsEPFRSoS_E@plt&gt;</span><br><span class="line">   0x00005555555555da &lt;+52&gt;:    nop</span><br><span class="line">   0x00005555555555db &lt;+53&gt;:    leave  </span><br><span class="line">   0x00005555555555dc &lt;+54&gt;:    ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatisPlus简介</title>
    <url>/posts/9f1f12bd.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer 等多种数据库</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 XML 热加载</strong>：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>支持关键词自动转义</strong>：支持数据库关键词（order、key……）自动转义，还可自定义关键词</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
<li><strong>内置 Sql 注入剥离器</strong>：支持 Sql 注入剥离，有效预防 Sql 注入攻击</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatisPlus入门</title>
    <url>/posts/60a47b20.html</url>
    <content><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h1 id="创建并初始化数据库"><a href="#创建并初始化数据库" class="headerlink" title="创建并初始化数据库"></a>创建并初始化数据库</h1><p>创建数据库：demo_mybatis_plus</p>
<p>创建user表并加入数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="初始化工程"><a href="#初始化工程" class="headerlink" title="初始化工程"></a><strong>初始化工程</strong></h1><p>使用 Spring Initializr 快速初始化一个 Spring Boot 工程</p>
<h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a><strong>添加依赖</strong></h1><p>spring-boot-starter、spring-boot-starter-test</p>
<p>添加：mybatis-plus-boot-starter、MySQL、lombok、</p>
<p>idea中安装lombok插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h1><p>在 application.properties 配置文件中添加 MySQL 数据库的相关配置：</p>
<p>mysql5:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysql数据库连接</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/demo_mybatis_plus</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br></pre></td></tr></table></figure>

<ol>
<li>这里的 url 使用了 ?serverTimezone&#x3D;GMT%2B8 后缀，因为Spring Boot 2.1 集成了 8.0版本的jdbc驱动，这个版本的 jdbc 驱动需要添加这个后缀，否则运行测试用例报告如下错误： java.sql.SQLException: The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized or represents more </li>
<li>这里的 driver-class-name 使用了  com.mysql.cj.jdbc.Driver ，在 jdbc 8 中 建议使用这个驱动，之前的 com.mysql.jdbc.Driver 已经被废弃，否则运行测试用例的时候会有 WARN 信息</li>
</ol>
<h1 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h1><p><strong>主类</strong></p>
<p>在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹</p>
<p><strong>注意：</strong>扫描的包名根据实际情况修改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.ansore.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MybatisPlusApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>mapper</strong></p>
<p>继承BaseMapper<User>，基本接口写好了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置日志</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#mybatis日志</span><br><span class="line">mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<p>添加测试类，进行功能测试：</p>
<p>IDEA在 userMapper 处报错，因为找不到注入的对象，因为类是动态创建的，但是程序可以正确的执行。</p>
<p>为了避免报错，可以在 dao 层 的接口上添加 @Repository 注</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;--------select--------&quot;</span>);</span><br><span class="line">    <span class="comment">//UserMapper 中的 selectList() 方法的参数为 MybatisPlus 内置的条件封装器 Wrapper</span></span><br><span class="line">    <span class="comment">//所以不填写就是无任何条件</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User(id=1, name=Jone, age=18, email=test1@baomidou.com)</span><br><span class="line">User(id=2, name=Jack, age=20, email=test2@baomidou.com)</span><br><span class="line">User(id=3, name=Tom, age=28, email=test3@baomidou.com)</span><br><span class="line">User(id=4, name=Sandy, age=21, email=test4@baomidou.com)</span><br><span class="line">User(id=5, name=Billie, age=24, email=test5@baomidou.com)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatisPlus之CRUD</title>
    <url>/posts/2723818a.html</url>
    <content><![CDATA[<h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><h1 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h1><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;--------insert--------&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;123@123.com&quot;</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    <span class="comment">//影响的行数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">    <span class="comment">//id自动回填</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result:1</span><br><span class="line">User(id=1263011719026946049, name=haha, age=18, email=123@123.com)</span><br></pre></td></tr></table></figure>

<p>注意：数据库插入id值默认为：全局唯一id</p>
<h2 id="主键策略"><a href="#主键策略" class="headerlink" title="主键策略"></a>主键策略</h2><h3 id="ID-WORKER"><a href="#ID-WORKER" class="headerlink" title="ID_WORKER"></a><strong>ID_WORKER</strong></h3><p>MyBatis-Plus默认的主键策略是：<strong>ID_WORKER  全局唯一ID</strong></p>
<p>使用IdWorker工具类测试id的生成，了解id生成原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIdWorker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">IdWorker</span> <span class="variable">idWorker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdWorker</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.println(idWorker.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自增策略"><a href="#自增策略" class="headerlink" title="自增策略"></a>自增策略</h3><ul>
<li>要想主键自增需要配置如下主键策略<ul>
<li>需要在创建数据表的时候设置主键自增</li>
<li>实体字段中配置 @TableId(type &#x3D; IdType.AUTO)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure>

<p>要想影响所有实体的配置，可以设置全局主键配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#全局设置主键生成策略</span><br><span class="line">mybatis-plus.global-config.db-config.id-type=auto</span><br></pre></td></tr></table></figure>

<p>其它主键策略：分析 IdType 源码可知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">IdType</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库ID自增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AUTO(<span class="number">0</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该类型为未设置主键类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NONE(<span class="number">1</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户输入ID</span></span><br><span class="line"><span class="comment">     * 该类型可以通过自己注册自动填充插件进行填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INPUT(<span class="number">2</span>),</span><br><span class="line">    <span class="comment">/* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局唯一ID (idWorker)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ID_WORKER(<span class="number">3</span>),</span><br><span class="line">    ASSIGN_ID(<span class="number">3</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局唯一ID (UUID)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UUID(<span class="number">4</span>),</span><br><span class="line">ASSIGN_UUID(<span class="number">4</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串全局唯一ID (idWorker 的字符串表示)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ID_WORKER_STR(<span class="number">3</span>),</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> key;</span><br><span class="line">    IdType(<span class="type">int</span> key) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="update"><a href="#update" class="headerlink" title="update"></a>update</h1><h2 id="根据Id更新操作"><a href="#根据Id更新操作" class="headerlink" title="根据Id更新操作"></a>根据Id更新操作</h2><p>注意：update时生成的sql自动是动态sql：</p>
<p><code>UPDATE user SET age=? WHERE id=?</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">1L</span>);</span><br><span class="line">    user.setAge(<span class="number">28</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h2><p>项目中经常会遇到一些数据，每次都使用相同的方式填充，例如记录的创建时间，更新时间等。</p>
<p>我们可以使用MyBatis Plus的自动填充功能，完成这些字段的赋值工作：</p>
<p><strong>数据库表中添加自动填充字段</strong></p>
<p>在User表中添加datetime类型的新的字段 create_time、update_time</p>
<p><strong>实体上添加注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="comment">//@TableField(fill = FieldFill.UPDATE)</span></span><br><span class="line">    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现元对象处理器接口</strong></p>
<p>注意：不要忘记添加 @Component 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(MyMetaObjectHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;start insert fill ....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;start update fill ....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p><strong>主要适用场景：</strong>当要更新一条记录的时候，希望这条记录没有被别人更新，也就是说实现线程安全的数据更新</p>
<p>乐观锁实现方式：</p>
<ul>
<li>取出记录时，获取当前version</li>
<li>更新时，带上这个version</li>
<li>执行更新时， set version &#x3D; newVersion where version &#x3D; oldVersion</li>
<li>如果version不对，就更新失败</li>
</ul>
<p><strong>数据库中添加version字段</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `version` <span class="type">INT</span></span><br></pre></td></tr></table></figure>

<p><strong>实体类添加version字段</strong></p>
<p>并添加 @Version 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure>

<p><strong>元对象处理器接口添加version的insert默认值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;version&quot;</span>, <span class="number">1</span>, metaObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特别说明:</strong></p>
<ul>
<li>支持的数据类型只有 int,Integer,long,Long,Date,Timestamp,LocalDateTime</li>
<li>整数类型下 newVersion &#x3D; oldVersion + 1</li>
<li>newVersion 会回写到 entity 中</li>
<li>仅支持 updateById(id) 与 update(entity, wrapper) 方法</li>
<li>在 update(entity, wrapper) 方法下, wrapper 不能复用!!!</li>
</ul>
<p><strong>在 MybatisPlusConfig 中注册 Bean</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.ansore.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OptimisticLockerInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OptimisticLockerInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试乐观锁可以修改成功</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOptimisticLocker</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    <span class="comment">//修改数据</span></span><br><span class="line">    user.setName(<span class="string">&quot;Helen Yao&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;1456@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的sql</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE user SET name=?, age=?, email=?, create_time=?, update_time=?, version=? WHERE id=? AND version=? </span><br><span class="line">==&gt; Parameters: Helen Yao(String), 18(Integer), 1456@qq.com(String), 2020-05-21 20:02:39.0(Timestamp), 2020-05-21 20:04:14.007(Timestamp), 2(Integer), 1263440062872309762(Long), 1(Integer)</span><br><span class="line">&lt;==    Updates: 1</span><br></pre></td></tr></table></figure>

<p><strong>测试乐观锁修改失败</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testOptimisticLockerFail</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1263440062872309762L</span>);</span><br><span class="line">    <span class="comment">//修改数据</span></span><br><span class="line">    user.setName(<span class="string">&quot;Helen Yao&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;1456@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出模拟数据后，数据库中version实际数据比取出的值大，即已被其他线程修改并更新了version</span></span><br><span class="line">    user.setVersion(user.getVersion() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行更新</span></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的sql：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE user SET name=?, age=?, email=?, create_time=?, update_time=?, version=? WHERE id=? AND version=? </span><br><span class="line">==&gt; Parameters: Helen Yao(String), 18(Integer), 1456@qq.com(String), 2020-05-21 20:02:39.0(Timestamp), 2020-05-21 20:13:14.86(Timestamp), 2(Integer), 1263440062872309762(Long), 1(Integer)</span><br><span class="line">&lt;==    Updates: 0</span><br></pre></td></tr></table></figure>

<h1 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h1><h2 id="根据id查询记录"><a href="#根据id查询记录" class="headerlink" title="根据id查询记录"></a><strong>根据id查询记录</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="通过多个id批量查询"><a href="#通过多个id批量查询" class="headerlink" title="通过多个id批量查询"></a><strong>通过多个id批量查询</strong></h1><p>完成了动态sql的foreach的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectBatchIds</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单的条件查询"><a href="#简单的条件查询" class="headerlink" title="简单的条件查询"></a><strong>简单的条件查询</strong></h2><p>通过map封装查询条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectByMap</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Helen&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p>
<p><strong>创建配置类</strong></p>
<p>此时可以删除主类中的 <em>@MapperScan</em> 扫描注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分页插件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试selectPage分页</strong></p>
<p><strong>测试：</strong>最终通过page对象获取相关数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectPage</span><span class="params">()</span> &#123;</span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    page.getRecords().forEach(System.out::println);</span><br><span class="line">    System.out.println(page.getCurrent());</span><br><span class="line">    System.out.println(page.getPages());</span><br><span class="line">    System.out.println(page.getSize());</span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">    System.out.println(page.hasNext());</span><br><span class="line">    System.out.println(page.hasPrevious());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台打印的sql:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: SELECT id,name,age,email,create_time,update_time,version FROM user LIMIT ?,? </span><br><span class="line">==&gt; Parameters: 0(Long), 5(Long)</span><br></pre></td></tr></table></figure>

<p><strong>测试selectMapsPage分页：结果集是Map</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testSelectMapsPage() &#123;</span><br><span class="line">    // 3.3.1 后的写法</span><br><span class="line">    IPage&lt;Map&lt;String, Object&gt;&gt; page = new Page&lt;&gt;(1, 5);</span><br><span class="line">    IPage&lt;Map&lt;String, Object&gt;&gt; mapIPage = userMapper.selectMapsPage(page, null);</span><br><span class="line"></span><br><span class="line">    // 注意：此行必须使用mapIPage获取记录列表，否则会有数据类型转换的错误</span><br><span class="line">    mapIPage.getRecords().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(page.getCurrent());</span><br><span class="line">    System.out.println(page.getPages());</span><br><span class="line">    System.out.println(page.getSize());</span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h1><h2 id="根据id删除记录"><a href="#根据id删除记录" class="headerlink" title="根据id删除记录"></a>根据id删除记录</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">5L</span>);</span><br><span class="line">    System.out.println(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteBatchIds</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteBatchIds(Arrays.asList(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单的条件查询删除"><a href="#简单的条件查询删除" class="headerlink" title="简单的条件查询删除"></a>简单的条件查询删除</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteByMap</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a><strong>逻辑删除</strong></h2><ul>
<li>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除数据</li>
<li>逻辑删除：假删除，将对应数据中代表是否被删除字段状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</li>
</ul>
<p><strong>数据库中添加 deleted字段</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `deleted` <span class="type">boolean</span></span><br></pre></td></tr></table></figure>

<p><strong>application.properties 加入配置</strong></p>
<p>此为默认值，如果你的默认值和mp默认的一样,该配置可无</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 逻辑删除字段 </span><br><span class="line">mybatis-plus.global-config.db-config.logic-delete-field=flag</span><br><span class="line"># 已删除默认值</span><br><span class="line">mybatis-plus.global-config.db-config.logic-delete-value=1</span><br><span class="line"># 未删除默认值</span><br><span class="line">mybatis-plus.global-config.db-config.logic-not-delete-value=0</span><br></pre></td></tr></table></figure>

<p><strong>实体类添加deleted 字段</strong></p>
<p>并加上 @TableLogic 注解</p>
<p>全局逻辑删除: begin 3.3.0</p>
<p>如果公司代码比较规范，比如统一了全局都是flag为逻辑删除字段。</p>
<p>使用此配置则不需要在实体类上添加 @TableLogic。</p>
<p>但如果实体类上有 @TableLogic 则以实体上的为准，忽略全局。 即先查找注解再查找全局，都没有则此表没有逻辑删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableLogic</span></span><br><span class="line"><span class="keyword">private</span> Integer deleted;</span><br></pre></td></tr></table></figure>

<p><strong>注册 Bean(3.1.1开始不再需要这一步)：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ISqlInjector <span class="title function_">sqlInjector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LogicSqlInjector</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试逻辑删除</strong></p>
<ul>
<li>测试后发现，数据并没有被删除，deleted字段的值由0变成了1</li>
<li>测试后分析打印的sql语句，是一条update</li>
<li><strong>注意：被删除数据的deleted 字段的值必须是 0，才能被选取出来执行逻辑删除的操作</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLogicDeleteByMap</span><span class="params">()</span> &#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的sql：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt;  Preparing: UPDATE user SET deleted=1 WHERE name = ? AND deleted=0 </span><br><span class="line">==&gt; Parameters: haha(String)</span><br><span class="line">&lt;==    Updates: 20</span><br></pre></td></tr></table></figure>

<p><strong>测试逻辑删除后的查询</strong></p>
<p>MyBatis Plus中查询操作也会自动添加逻辑删除字段的判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试逻辑删除后的查询，不包括撒谎拿出字段的判断</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLogicDeleteSelect</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试后分析打印的sql语句，包含 WHERE deleted&#x3D;0</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,age,email,create_time,update_time,version,deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>性能分析拦截器，用于输出每条 SQL 语句及其执行时间</p>
<p>该插件 3.2.0 以上版本移除</p>
<p>推荐使用第三方扩展 执行SQL分析打印 功能</p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h2><p>参数：maxTime： SQL 执行最大时长，超过自动停止运行，有助于发现问题。</p>
<p>参数：format： SQL是否格式化，默认false。</p>
<h2 id="在-MybatisPlusConfig-中配置"><a href="#在-MybatisPlusConfig-中配置" class="headerlink" title="在 MybatisPlusConfig 中配置"></a>在 MybatisPlusConfig 中配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SQL 执行性能分析插件</span></span><br><span class="line"><span class="comment"> * 开发环境使用，线上不推荐。 maxTime 指的是 sql 最大执行时长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)</span><span class="comment">// 设置 dev test 环境开启</span></span><br><span class="line"><span class="keyword">public</span> PerformanceInterceptor <span class="title function_">performanceInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">PerformanceInterceptor</span> <span class="variable">performanceInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PerformanceInterceptor</span>();</span><br><span class="line">    performanceInterceptor.setMaxTime(<span class="number">100</span>);<span class="comment">//ms，超过此处设置的ms则sql不执行</span></span><br><span class="line">    performanceInterceptor.setFormat(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> performanceInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数：maxTime SQL 执行最大时长，超过自动停止运行，有助于发现问题。</li>
<li>参数：format SQL SQL是否格式化，默认false。</li>
<li>该插件只用于开发环境，不建议生产环境使用。</li>
</ul>
<p><strong>（3）Spring Boot 中设置dev环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#环境设置：dev、test、prod</span><br><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure>

<h1 id="执行SQL分析打印"><a href="#执行SQL分析打印" class="headerlink" title="执行SQL分析打印"></a>执行SQL分析打印</h1><h2 id="p6spy-依赖引入"><a href="#p6spy-依赖引入" class="headerlink" title="p6spy 依赖引入"></a>p6spy 依赖引入</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="application-properties-配置"><a href="#application-properties-配置" class="headerlink" title="application.properties 配置"></a>application.properties 配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.p6spy.engine.spy.P6SpyDriver</span><br><span class="line">spring.datasource.url=jdbc:p6spy:mysql://localhost:3306/demo_mybatis_plus?serverTimezone=GMT%2B8</span><br></pre></td></tr></table></figure>

<h2 id="spy-properties-配置"><a href="#spy-properties-配置" class="headerlink" title="spy.properties 配置"></a>spy.properties 配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#3.2.1以上使用</span><br><span class="line">modulelist=com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory</span><br><span class="line">#3.2.1以下使用或者不配置</span><br><span class="line">#modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory</span><br><span class="line"># 自定义日志打印</span><br><span class="line">logMessageFormat=com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger</span><br><span class="line">#日志输出到控制台</span><br><span class="line">appender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger</span><br><span class="line"># 使用日志系统记录 sql</span><br><span class="line">#appender=com.p6spy.engine.spy.appender.Slf4JLogger</span><br><span class="line"># 设置 p6spy driver 代理</span><br><span class="line">deregisterdrivers=true</span><br><span class="line"># 取消JDBC URL前缀</span><br><span class="line">useprefix=true</span><br><span class="line"># 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.</span><br><span class="line">excludecategories=info,debug,result,commit,resultset</span><br><span class="line"># 日期格式</span><br><span class="line">dateformat=yyyy-MM-dd HH:mm:ss</span><br><span class="line"># 实际驱动可多个</span><br><span class="line">#driverlist=org.h2.Driver</span><br><span class="line"># 是否开启慢SQL记录</span><br><span class="line">outagedetection=true</span><br><span class="line"># 慢SQL记录标准 2 秒</span><br><span class="line">outagedetectioninterval=2</span><br></pre></td></tr></table></figure>

<ul>
<li>driver-class-name 为 p6spy 提供的驱动类</li>
<li>url 前缀为 jdbc:p6spy 跟着冒号为对应数据库连接地址</li>
<li>打印出sql为null,在excludecategories增加commit</li>
<li>批量操作不打印sql,去除excludecategories中的batch</li>
<li>批量操作打印重复的问题请使用MybatisPlusLogFactory (3.2.1新增）</li>
<li>该插件有性能损耗，不建议生产环境使用。</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>打印的sql:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Consume Time：5 ms 2020-05-21 22:29:46</span><br><span class="line"> Execute SQL：INSERT INTO user ( id, name, age, email, create_time, version, deleted ) VALUES ( 1263477085830135810, &#x27;haha&#x27;, 18, &#x27;123@123.com&#x27;, &#x27;2020-05-21T22:29:46.190+0800&#x27;, 1, 0 )</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatisPlus之条件构造器</title>
    <url>/posts/96d74952.html</url>
    <content><![CDATA[<h1 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h1><h1 id="Wapper"><a href="#Wapper" class="headerlink" title="Wapper"></a>Wapper</h1><p><img src="https://img.ansore.de/2022/05/04/627262378e3a3.png" alt="Wapper"></p>
<p>Wrapper ： 条件构造抽象类，最顶端父类</p>
<p>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件</p>
<p>QueryWrapper ： Entity 对象封装操作类，不是用lambda语法</p>
<p>UpdateWrapper ： Update 条件封装，用于Entity对象更新操作</p>
<p>AbstractLambdaWrapper ： Lambda 语法使用 Wrapper统一处理解析 lambda 获取 column。</p>
<p>LambdaQueryWrapper ：看名称也能明白就是用于Lambda语法使用的查询Wrapper</p>
<p>LambdaUpdateWrapper ： Lambda 更新封装Wrapper</p>
<h1 id="AbstractWrapper"><a href="#AbstractWrapper" class="headerlink" title="AbstractWrapper"></a>AbstractWrapper</h1><p><strong>注意：</strong>以下条件构造器的方法入参中的 column 均表示数据库字段</p>
<h2 id="ge、gt、le、lt、isNull、isNotNull"><a href="#ge、gt、le、lt、isNull、isNotNull" class="headerlink" title="ge、gt、le、lt、isNull、isNotNull"></a><strong>ge、gt、le、lt、isNull、isNotNull</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper</span><br><span class="line">            .isNull(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">            .ge(<span class="string">&quot;age&quot;</span>, <span class="number">12</span>)</span><br><span class="line">            .isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.delete(queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;delete return count = &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> deleted<span class="operator">=</span><span class="number">1</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span> <span class="keyword">AND</span> (name <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> age <span class="operator">&gt;=</span> <span class="number">12</span> <span class="keyword">AND</span> email <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>)</span><br></pre></td></tr></table></figure>

<h2 id="eq、ne"><a href="#eq、ne" class="headerlink" title="eq、ne"></a>eq、ne</h2><p>注意：seletOne返回的是一条实体记录，当出现多条时会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// seletOne返回的是一条实体记录，当出现多条时会报错</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectOne</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(queryWrapper);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,age,email,create_time,update_time,version,deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span> <span class="keyword">AND</span> (name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="between、notBetween"><a href="#between、notBetween" class="headerlink" title="between、notBetween"></a>between、notBetween</h2><p>包含大小边界</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectCount</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> userMapper.selectCount(queryWrapper);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>( <span class="number">1</span> ) <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span> <span class="keyword">AND</span> (age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="allEq"><a href="#allEq" class="headerlink" title="allEq"></a>allEq</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;id&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    queryWrapper.allEq(map);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line"></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,age,email,create_time,update_time,version,deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span> <span class="keyword">AND</span> (name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span> <span class="keyword">AND</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h2 id="like、notLike、likeLeft、likeRight"><a href="#like、notLike、likeLeft、likeRight" class="headerlink" title="like、notLike、likeLeft、likeRight"></a>like、notLike、likeLeft、likeRight</h2><p>selectMaps返回Map集合列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectMap</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper</span><br><span class="line">            .notLike(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;e&quot;</span>)</span><br><span class="line">            .likeRight(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;t&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,age,email,create_time,update_time,version,deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span> <span class="keyword">AND</span> (name <span class="keyword">NOT</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%e%&#x27;</span> <span class="keyword">AND</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;t%&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="in、notIn、inSql、notinSql、exists、notExists"><a href="#in、notIn、inSql、notinSql、exists、notExists" class="headerlink" title="in、notIn、inSql、notinSql、exists、notExists"></a>in、notIn、inSql、notinSql、exists、notExists</h2><p>in、notIn：</p>
<ul>
<li>notIn(“age”,{1,2,3})—&gt;age not in (1,2,3)</li>
<li>notIn(“age”, 1, 2, 3)—&gt;age not in (1,2,3)</li>
</ul>
<p>inSql、notinSql：可以实现子查询</p>
<ul>
<li>例: inSql(“age”, “1,2,3,4,5,6”)—&gt;age in (1,2,3,4,5,6)</li>
<li>例: inSql(“id”, “select id from table where id &lt; 3”)—&gt;id in (select id from table where id &lt; 3)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectObjs</span><span class="params">()</span> &#123;</span><br><span class="line">     QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//   queryWrapper.in(&quot;id&quot;, 1, 2, 3, 4);</span></span><br><span class="line">     queryWrapper.inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from user where id &lt; 5&quot;</span>);</span><br><span class="line">     List&lt;Object&gt; objects = userMapper.selectObjs(queryWrapper);</span><br><span class="line">     objects.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,age,email,create_time,update_time,version,deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span> <span class="keyword">AND</span> (id <span class="keyword">IN</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<h2 id="or、and"><a href="#or、and" class="headerlink" title="or、and"></a>or、and</h2><p><strong>注意：</strong>这里使用的是 UpdateWrapper</p>
<p>不调用or则默认为使用 and 连</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdate1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 修改值</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">99</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;Helen&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改条件</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; userUpdateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    userUpdateWrapper</span><br><span class="line">            .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;h&quot;</span>)</span><br><span class="line">            .or()</span><br><span class="line">            .between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, userUpdateWrapper);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;Helen&#x27;</span>, age<span class="operator">=</span><span class="number">99</span>, update_time<span class="operator">=</span><span class="string">&#x27;2020-05-21T23:49:15.357+0800&#x27;</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span> <span class="keyword">AND</span> (name <span class="keyword">LIKE</span> <span class="string">&#x27;%h%&#x27;</span> <span class="keyword">OR</span> age <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h2 id="嵌套or、嵌套and"><a href="#嵌套or、嵌套and" class="headerlink" title="嵌套or、嵌套and"></a>嵌套or、嵌套and</h2><p>这里使用了lambda表达式，or中的表达式最后翻译成sql时会被加上圆括号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdate2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 修改值</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">88</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;Andy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改条件</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; userUpdateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    userUpdateWrapper</span><br><span class="line">            .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;h&quot;</span>)</span><br><span class="line">            .or(i -&gt; i.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Helen&quot;</span>).ne(<span class="string">&quot;age&quot;</span>, <span class="number">99</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, userUpdateWrapper);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;Andy&#x27;</span>, age<span class="operator">=</span><span class="number">88</span>, update_time<span class="operator">=</span><span class="string">&#x27;2020-05-21T23:54:24.215+0800&#x27;</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span> <span class="keyword">AND</span> (name <span class="keyword">LIKE</span> <span class="string">&#x27;%h%&#x27;</span> <span class="keyword">OR</span> (name <span class="operator">=</span> <span class="string">&#x27;Helen&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&lt;&gt;</span> <span class="number">99</span>))</span><br></pre></td></tr></table></figure>

<h2 id="orderBy、orderByDesc、orderByAs"><a href="#orderBy、orderByDesc、orderByAs" class="headerlink" title="orderBy、orderByDesc、orderByAs"></a>orderBy、orderByDesc、orderByAs</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectListOrderBy</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.orderByDesc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,age,email,create_time,update_time,version,deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>直接拼接到 sql 的最后</p>
<p><strong>注意：</strong>只能调用一次,多次调用以最后一次为准 有sql注入的风险,请谨慎使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectListLast</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.last(<span class="string">&quot;limit 1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,age,email,create_time,update_time,version,deleted <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span> limit <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="指定要查询的列"><a href="#指定要查询的列" class="headerlink" title="指定要查询的列"></a>指定要查询的列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSelectListColumn</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,name,age <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="set、setSql"><a href="#set、setSql" class="headerlink" title="set、setSql"></a>set、setSql</h2><p>最终的sql会合并 user.setAge()，以及 userUpdateWrapper.set() 和 setSql() 中 的字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateSet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 修改值</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">99</span>);</span><br><span class="line">    <span class="comment">// 修改条件</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; userUpdateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    userUpdateWrapper</span><br><span class="line">            .like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;h&quot;</span>)</span><br><span class="line">            .set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Andy&quot;</span>) <span class="comment">// 除了可以查询还可以使用set设置修改的字段</span></span><br><span class="line">            .setSql(<span class="string">&quot;email=&#x27;1456@qq.com&#x27;&quot;</span>); <span class="comment">// 可以有子查询</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, userUpdateWrapper);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">99</span>, update_time<span class="operator">=</span><span class="string">&#x27;2020-05-22T00:10:29.631+0800&#x27;</span>, name<span class="operator">=</span><span class="string">&#x27;Andy&#x27;</span>,email<span class="operator">=</span><span class="string">&#x27;1456@qq.com&#x27;</span> <span class="keyword">WHERE</span> deleted<span class="operator">=</span><span class="number">0</span> <span class="keyword">AND</span> (name <span class="keyword">LIKE</span> <span class="string">&#x27;%h%&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>（一）SpringBoot-HelloWorld</title>
    <url>/posts/c0180c51.html</url>
    <content><![CDATA[<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><h3 id="1、创建maven工程，导入依赖"><a href="#1、创建maven工程，导入依赖" class="headerlink" title="1、创建maven工程，导入依赖"></a>1、创建maven工程，导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Add typical dependencies for a web application --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、编写主程序，启动Spring-boot应用"><a href="#2、编写主程序，启动Spring-boot应用" class="headerlink" title="2、编写主程序，启动Spring boot应用"></a>2、编写主程序，启动Spring boot应用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、编写相关Controller、Service"><a href="#3、编写相关Controller、Service" class="headerlink" title="3、编写相关Controller、Service"></a>3、编写相关Controller、Service</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、简化部署"><a href="#4、简化部署" class="headerlink" title="4、简化部署"></a>4、简化部署</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个插件，可以将应用打包成一个可执行的jar包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5、运行主程序测试"><a href="#5、运行主程序测试" class="headerlink" title="5、运行主程序测试"></a>5、运行主程序测试</h3><p>应用打成jar包，直接使用java -jar的命令进行执行</p>
<h3 id="6、HelloWorld探究"><a href="#6、HelloWorld探究" class="headerlink" title="6、HelloWorld探究"></a>6、HelloWorld探究</h3><h4 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h4><p>父项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它的父项目是</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它真正管理Spring Boot应用里面的所有依赖，是Spring boot的版本仲裁中心。以后不需要写版本号（没有在dependencies里面管理的依赖自然需要声明版本号）</p>
<h4 id="启动器"><a href="#启动器" class="headerlink" title="启动器"></a>启动器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>spring-boot-starter-web</strong></p>
<p><strong>spring-boot-starter</strong>：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；<br>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter<br>相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p>
<h4 id="主程序类"><a href="#主程序类" class="headerlink" title="主程序类"></a>主程序类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@SpringBootApplication</strong>: Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot<br>就应该运行这个类的main方法来启动SpringBoot应用；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication</span><br></pre></td></tr></table></figure>



<p><strong>@SpringBootConfiguration</strong>:Spring Boot的配置类；标注在某个类上，表示这是一个Spring Boot的配置类；</p>
<p><strong>@Configuration</strong>:配置类上来标注这个注解；配置类 —– 配置文件；配置类也是容器中的一个组件；@Component</p>
<p><strong>@EnableAutoConfiguration</strong>：开启自动配置功能；以前我们需要配置的东西，Spring Boot帮我们自动配置；</p>
<p><strong>@EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure>

<p><strong>@AutoConfigurationPackage</strong>：自动配置包</p>
<p><strong>@Import</strong>(AutoConfigurationPackages.Registrar.class)：Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；给定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">     AutoConfigurationPackages.register(registry, (<span class="keyword">new</span> <span class="title class_">AutoConfigurationPackages</span>.PackageImport(metadata)).getPackageName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</p>
<p><strong>@Import</strong>(EnableAutoConfigurationImportSelector.class):给容器中导入组件。 <strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；        会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；</p>
<p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p>
<p>SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p>
<p>Spring Boot在启动的时候从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们；</p>
<h3 id="7、使用Spring-Initializer快速创建Spring-Boot项目"><a href="#7、使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="7、使用Spring Initializer快速创建Spring Boot项目"></a>7、使用Spring Initializer快速创建Spring Boot项目</h3><h4 id="IDEA：使用-Spring-Initializer快速创建项目"><a href="#IDEA：使用-Spring-Initializer快速创建项目" class="headerlink" title="IDEA：使用 Spring Initializer快速创建项目"></a>IDEA：使用 Spring Initializer快速创建项目</h4><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p>
<p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p>
<p>默认生成的Spring Boot项目；</p>
<ul>
<li>主程序已经生成好了，我们只需要我们自己的逻辑</li>
<li>resources文件夹中目录结构<ul>
<li>static：保存所有的静态资源； js css  images；</li>
<li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li>
<li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>（二）SpringBoot-Config</title>
    <url>/posts/ccebc559.html</url>
    <content><![CDATA[<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h3><p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p>
<p>•application.properties</p>
<p>•application.yml</p>
<p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p>
<p>YAML（YAML Ain’t Markup Language）</p>
<p>​    YAML  A Markup Language：是一个标记语言</p>
<p>​    YAML   isn’t Markup Language：不是一个标记语言；</p>
<p>标记语言：</p>
<p>​    以前的配置文件；大多都使用的是  <strong>xxxx.xml</strong>文件；</p>
<p>​    YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件；</p>
<p>​    YAML：配置例子</p>
<h3 id="2、YAML语法"><a href="#2、YAML语法" class="headerlink" title="2、YAML语法"></a>2、YAML语法</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>k:(空格)v：表示一对键值对（空格必须有）；</p>
<p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p>
<p>属性和值也是大小写敏感；</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure>

<h4 id="值的写法"><a href="#值的写法" class="headerlink" title="值的写法"></a>值的写法</h4><p>k: v：字面直接来写；</p>
<p>字符串默认不用加上单引号或者双引号；</p>
<p>“”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p>
<p>​      name:   “zhangsan \n lisi”：输出；zhangsan 换行  lisi</p>
<p>‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p>
<p>​        name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</p>
<h4 id="对象、Map（属性和值）（键值对）："><a href="#对象、Map（属性和值）（键值对）：" class="headerlink" title="对象、Map（属性和值）（键值对）："></a>对象、Map（属性和值）（键值对）：</h4><p>k: v：在下一行来写对象的属性和值的关系；注意缩进</p>
<p>​        对象还是k: v的方式</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line">	<span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">	<span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>行内写法：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span> &#123;<span class="attr">lastName:</span> <span class="string">zhangsan</span>,<span class="attr">age:</span> <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组（List、Set）："><a href="#数组（List、Set）：" class="headerlink" title="数组（List、Set）："></a>数组（List、Set）：</h4><p>用- 值表示数组中的一个元素</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure>

<p>行内写法</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span> [<span class="string">cat</span>,<span class="string">dog</span>,<span class="string">pig</span>]</span><br></pre></td></tr></table></figure>

<h4 id="配置文件值注入"><a href="#配置文件值注入" class="headerlink" title="配置文件值注入"></a>配置文件值注入</h4><p>配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">    <span class="attr">lastName:</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">    <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line">    <span class="attr">maps:</span> &#123;<span class="attr">k1:</span> <span class="string">v1</span>,<span class="attr">k2:</span> <span class="number">12</span>&#125;</span><br><span class="line">    <span class="attr">lists:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zhaoliu</span></span><br><span class="line">    <span class="attr">dog:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">小狗</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>javaBean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以导入配置文件处理器，以后编写配置就有提示了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>properties配置文件在idea中默认utf-8可能会乱码</li>
<li>@Value获取值和@ConfigurationProperties获取值比较</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定</td>
</tr>
<tr>
<td>松散绑定（松散语法）</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>配置文件yml还是properties他们都能获取到值；</p>
<p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p>
<p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p>
<ul>
<li>配置文件注入值数据校验</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class=&quot;Person&quot;&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name=&quot;lastName&quot; value=&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="comment">//@Value(&quot;$&#123;person.last-name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value(&quot;#&#123;11*2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value(&quot;true&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>

<h4 id="PropertySource-amp-ImportResource-amp-Bean"><a href="#PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="@PropertySource&amp;@ImportResource&amp;@Bean"></a>@PropertySource&amp;@ImportResource&amp;@Bean</h4><p><strong>@PropertySource</strong>：加载指定的配置文件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@ConfigurationProperties</span>(prefix = &quot;person&quot;)默认从全局配置文件中获取值；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span></span><br><span class="line"><span class="comment">//@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class=&quot;Person&quot;&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name=&quot;lastName&quot; value=&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;&quot;&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">   <span class="comment">// @Email</span></span><br><span class="line">    <span class="comment">//@Value(&quot;$&#123;person.last-name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value(&quot;#&#123;11*2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value(&quot;true&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br></pre></td></tr></table></figure>

<p><strong>@ImportResource</strong>：导入Spring的配置文件，让配置文件里面的内容生效；</p>
<p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p>
<p>想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource(locations = &#123;&quot;classpath:beans.xml&quot;&#125;)</span></span><br></pre></td></tr></table></figure>

<p>导入Spring的配置文件让其生效</p>
<p>不来编写Spring的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.springboot.service.HelloService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p>
<p>1、配置类**@Configuration**——&gt;Spring配置文件</p>
<p>2、使用**@Bean**给容器中添加组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HelloService <span class="title function_">helloService02</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;配置类@Bean给容器中添加组件了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HelloService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置文件占位符</li>
</ul>
<p>随机数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.<span class="type">int</span>&#125;、$&#123;random.<span class="type">long</span>&#125;</span><br><span class="line">$&#123;random.<span class="type">int</span>(<span class="number">10</span>)&#125;、$&#123;random.<span class="type">int</span>[<span class="number">1024</span>,<span class="number">65536</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>占位符获取之前配置的值，如果没有可以是用:指定默认值</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">person.last-name</span>=<span class="string">张三$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="attr">person.age</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="attr">person.birth</span>=<span class="string">2017/12/15</span></span><br><span class="line"><span class="attr">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="attr">person.maps.k2</span>=<span class="string">14</span></span><br><span class="line"><span class="attr">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="attr">person.dog.name</span>=<span class="string">$&#123;person.hello:hello&#125;_dog</span></span><br><span class="line"><span class="attr">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure>

<h4 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h4><ul>
<li>多Profile文件</li>
</ul>
<p>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties&#x2F;yml</p>
<p>默认使用application.properties的配置；</p>
<p>yml支持多文档块方式</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span>  <span class="comment">#指定属于哪个环境</span></span><br></pre></td></tr></table></figure>

<ul>
<li>激活指定profile</li>
</ul>
<p>​    1、在配置文件中指定  spring.profiles.active&#x3D;dev</p>
<p>​    2、命令行：</p>
<p>​        java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active&#x3D;dev；</p>
<p>​        可以直接在测试的时候，配置传入命令行参数</p>
<p>​    3、虚拟机参数；</p>
<p>​        -Dspring.profiles.active&#x3D;dev</p>
<h4 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h4><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p>
<p>–file:.&#x2F;config&#x2F;</p>
<p>–file:.&#x2F;</p>
<p>–classpath:&#x2F;config&#x2F;</p>
<p>–classpath:&#x2F;</p>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
<p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p>
<h4 id="外部配置加载顺序"><a href="#外部配置加载顺序" class="headerlink" title="外部配置加载顺序"></a>外部配置加载顺序</h4><p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p>
<p><strong>1.命令行参数</strong></p>
<p>所有的配置都可以在命令行上进行指定</p>
<p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port&#x3D;8087  –server.context-path&#x3D;&#x2F;abc</p>
<p>多个配置用空格分开； –配置项&#x3D;值</p>
<p>2.来自java:comp&#x2F;env的JNDI属性</p>
<p>3.Java系统属性（System.getProperties()）</p>
<p>4.操作系统环境变量</p>
<p>5.RandomValuePropertySource配置的random.*属性值</p>
<p><strong>由jar包外向jar包内进行寻找；</strong></p>
<p><strong>优先加载带profile</strong></p>
<p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p>
<p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p>
<p><strong>再来加载不带profile</strong></p>
<p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p>
<p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p>
<p>10.@Configuration注解类上的@PropertySource</p>
<p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p>
<p>所有支持的配置加载来源；</p>
<h4 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h4><ol>
<li><p>SpringBoot启动的时候加载主配置类，开启了自动配置功能**@EnableAutoConfiguration**</p>
</li>
<li><p>@EnableAutoConfiguration 作用</p>
</li>
</ol>
<ul>
<li><p>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</p>
</li>
<li><p>可以查看selectImports()方法的内容；</p>
</li>
<li><p>List&lt;String&gt; configurations &#x3D; getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames()</span><br></pre></td></tr></table></figure>

<p>扫描所有jar包类路径下  META-INF&#x2F;spring.factories<br>把扫描到的这些文件的内容包装成properties对象<br>从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</p>
<p><strong>将 类路径下  META-INF&#x2F;spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p>
<ol start="3">
<li><p>每一个自动配置类进行自动配置功能；</p>
</li>
<li><p>以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HttpEncodingProperties.class)</span>  <span class="comment">//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">//Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnClass(CharacterEncodingFilter.class)</span>  <span class="comment">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</span>  <span class="comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpEncodingAutoConfiguration</span> &#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//他已经和SpringBoot的配置文件映射了</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.properties = properties;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(CharacterEncodingFilter.class)</span> <span class="comment">//判断容器没有这个组件？</span></span><br><span class="line">	<span class="keyword">public</span> CharacterEncodingFilter <span class="title function_">characterEncodingFilter</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderedCharacterEncodingFilter</span>();</span><br><span class="line">		filter.setEncoding(<span class="built_in">this</span>.properties.getCharset().name());</span><br><span class="line">		filter.setForceRequestEncoding(<span class="built_in">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">		filter.setForceResponseEncoding(<span class="built_in">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">		<span class="keyword">return</span> filter;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>根据当前不同的条件判断，决定这个配置类是否生效？</p>
<p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p>
<ol start="5">
<li>所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)</span>  <span class="comment">//从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpEncodingProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">DEFAULT_CHARSET</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>精髓：</strong></p>
<p>​    <strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p>
<p>​    <strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p>
<p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p>
<p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p>
<p>xxxxAutoConfigurartion：自动配置类；</p>
<p>给容器中添加组件</p>
<p>xxxxProperties:封装配置文件中相关属性；</p>
<p><strong>细节</strong></p>
<h4 id="Conditional派生注解（Spring注解版原生的-Conditional作用）"><a href="#Conditional派生注解（Spring注解版原生的-Conditional作用）" class="headerlink" title="@Conditional派生注解（Spring注解版原生的@Conditional作用）"></a>@Conditional派生注解（Spring注解版原生的@Conditional作用）</h4><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<table>
<thead>
<tr>
<th>@Conditional扩展注解</th>
<th>作用（判断是否满足当前指定条件）</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnJava</td>
<td>系统的java版本是否符合要求</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足SpEL表达式指定</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>系统中有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>系统中没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定的属性是否有指定的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定资源文件</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前是web环境</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前不是web环境</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody></table>
<p><strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p>我们可以通过启用  debug&#x3D;true属性；来让控制台打印自动配置报告</p>
<p>，这样我们就可以很方便的知道哪些自动配置类生效；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">=========================</span><br><span class="line">AUTO-<span class="type">CONFIGURATION</span> <span class="variable">REPORT</span></span><br><span class="line"><span class="operator">=</span>========================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Positive matches:（自动配置类启用的）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   DispatcherServletAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required class <span class="string">&#x27;org.springframework.web.servlet.DispatcherServlet&#x27;</span>; <span class="meta">@ConditionalOnMissingClass</span> did not find unwanted <span class="title function_">class</span> <span class="params">(OnClassCondition)</span></span><br><span class="line">      - <span class="meta">@ConditionalOnWebApplication</span> (required) found <span class="title function_">StandardServletEnvironment</span> <span class="params">(OnWebApplicationCondition)</span></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">Negative matches:（没有启动，没有匹配成功的自动配置类）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   ActiveMQAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - <span class="meta">@ConditionalOnClass</span> did not find required classes <span class="string">&#x27;javax.jms.ConnectionFactory&#x27;</span>, <span class="string">&#x27;org.apache.activemq.ActiveMQConnectionFactory&#x27;</span> (OnClassCondition)</span><br><span class="line"></span><br><span class="line">   AopAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - <span class="meta">@ConditionalOnClass</span> did not find required classes <span class="string">&#x27;org.aspectj.lang.annotation.Aspect&#x27;</span>, <span class="string">&#x27;org.aspectj.lang.reflect.Advice&#x27;</span> (OnClassCondition)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>（三）SpringBoot-Log</title>
    <url>/posts/5f650119.html</url>
    <content><![CDATA[<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="1、日志框架"><a href="#1、日志框架" class="headerlink" title="1、日志框架"></a>1、日志框架</h3><p>​        1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？</p>
<p>​        2、框架来记录系统的一些运行时信息；日志框架 ；  zhanglogging.jar；</p>
<p>​        3、高大上的几个功能？异步模式？自动归档？xxxx？  zhanglogging-good.jar？</p>
<p>​        4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；</p>
<p>​        5、JDBC—数据库驱动；</p>
<p>​            写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；</p>
<p>​            给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；</p>
<p><strong>市面上的日志框架：</strong>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p>
<table>
<thead>
<tr>
<th>日志门面  （日志的抽象层）</th>
<th>日志实现</th>
</tr>
</thead>
<tbody><tr>
<td><del>JCL（Jakarta  Commons Logging）</del>    <strong>SLF4j（Simple  Logging Facade for Java）</strong>    <del>jboss-logging</del></td>
<td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td>
</tr>
</tbody></table>
<p>左边选一个门面（抽象层）、右边来选一个实现；</p>
<p>日志门面：  SLF4J；</p>
<p>日志实现：Logback；</p>
<p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘</p>
<p>​    <strong>SpringBoot选用 SLF4j和logback</strong></p>
<h3 id="2-SLF4J使用"><a href="#2-SLF4J使用" class="headerlink" title="2.SLF4J使用"></a>2.SLF4J使用</h3><h4 id="如何在系统中使用SLF4j"><a href="#如何在系统中使用SLF4j" class="headerlink" title="如何在系统中使用SLF4j"></a>如何在系统中使用SLF4j</h4><p> <a href="https://www.slf4j.org/">https://www.slf4j.org</a></p>
<p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p>
<p>给系统里面导入slf4j的jar和  logback的实现jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    logger.info(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，**配置文件还是做成日志实现框架自己本身的配置文件；</p>
<h4 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h4><p>a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p>
<p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p>
<p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p>
<p><strong>1、将系统中其他日志框架先排除出去</strong></p>
<p><strong>2、用中间包来替换原有的日志框架</strong></p>
<p><strong>3、我们导入slf4j其他的实现</strong></p>
<h3 id="3、SpringBoot日志关系"><a href="#3、SpringBoot日志关系" class="headerlink" title="3、SpringBoot日志关系"></a>3、SpringBoot日志关系</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SpringBoot使用它来做日志功能；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li><p>SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p>
</li>
<li><p>SpringBoot也把其他的日志都替换成了slf4j；</p>
</li>
<li><p>中间替换包？</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LogFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J</span> <span class="operator">=</span> <span class="string">&quot;http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">LogFactory</span> <span class="variable">logFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SLF4JLogFactory</span>();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</li>
</ol>
<p>​    Spring框架用的是commons-logging；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可</strong></p>
<h3 id="4、日志使用"><a href="#4、日志使用" class="headerlink" title="4、日志使用"></a>4、日志使用</h3><h4 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h4><p>SpringBoot默认帮我们配置好了日志；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录器</span></span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//System.out.println();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//日志的级别；</span></span><br><span class="line">	<span class="comment">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line">	<span class="comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span></span><br><span class="line">	logger.trace(<span class="string">&quot;这是trace日志...&quot;</span>);</span><br><span class="line">	logger.debug(<span class="string">&quot;这是debug日志...&quot;</span>);</span><br><span class="line">	<span class="comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span></span><br><span class="line">	logger.info(<span class="string">&quot;这是info日志...&quot;</span>);</span><br><span class="line">	logger.warn(<span class="string">&quot;这是warn日志...&quot;</span>);</span><br><span class="line">	logger.error(<span class="string">&quot;这是error日志...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<pre><code>日志输出格式：
    %d表示日期时间，
    %thread表示线程名，
    %-5level：级别从左显示5个字符宽度
    %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 
    %msg：日志消息，
    %n是换行符
--&gt;
%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n
</code></pre>
</blockquote>
<p>SpringBoot修改日志的默认配置（Spring 2.x已舍弃部分）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.level.com.atguigu</span>=<span class="string">trace</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#logging.path=</span></span><br><span class="line"><span class="comment"># 不指定路径在当前项目下生成springboot.log日志</span></span><br><span class="line"><span class="comment"># 可以指定完整的路径；</span></span><br><span class="line"><span class="comment">#logging.file=G:/springboot.log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span></span><br><span class="line"><span class="attr">logging.path</span>=<span class="string">/spring/log</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#  在控制台输出的日志的格式</span></span><br><span class="line"><span class="attr">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment"># 指定文件中日志输出的格式</span></span><br><span class="line"><span class="attr">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>logging.file</th>
<th>logging.path</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>(none)</td>
<td>(none)</td>
<td></td>
<td>只在控制台输出</td>
</tr>
<tr>
<td>指定文件名</td>
<td>(none)</td>
<td>my.log</td>
<td>输出日志到my.log文件</td>
</tr>
<tr>
<td>(none)</td>
<td>指定目录</td>
<td>&#x2F;var&#x2F;log</td>
<td>输出到指定目录的 spring.log 文件中</td>
</tr>
</tbody></table>
<h4 id="指定配置"><a href="#指定配置" class="headerlink" title="指定配置"></a>指定配置</h4><p>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p>
<table>
<thead>
<tr>
<th>Logging System</th>
<th>Customization</th>
</tr>
</thead>
<tbody><tr>
<td>Logback</td>
<td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code></td>
</tr>
<tr>
<td>Log4j2</td>
<td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td>
</tr>
<tr>
<td>JDK (Java Util Logging)</td>
<td><code>logging.properties</code></td>
</tr>
</tbody></table>
<p><strong>logback.xml：直接就被日志框架识别了</strong></p>
<p><strong>logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active 可以指定某段配置只在某个环境下生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;stdout&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        日志输出格式：</span></span><br><span class="line"><span class="comment">			%d表示日期时间，</span></span><br><span class="line"><span class="comment">			%thread表示线程名，</span></span><br><span class="line"><span class="comment">			%-5level：级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">			%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="comment">			%msg：日志消息，</span></span><br><span class="line"><span class="comment">			%n是换行符</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;!dev&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误</p>
<p> <code>no applicable action for [springProfile]</code></p>
<h3 id="5、切换日志框架（不推荐）"><a href="#5、切换日志框架（不推荐）" class="headerlink" title="5、切换日志框架（不推荐）"></a>5、切换日志框架（不推荐）</h3><p>可以按照slf4j的日志适配图，进行相关的切换；</p>
<p>slf4j+log4j的方式；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>切换为log4j2:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>（四）SpringBoot-web</title>
    <url>/posts/361ceb0d.html</url>
    <content><![CDATA[<h2 id="四、Web开发"><a href="#四、Web开发" class="headerlink" title="四、Web开发"></a>四、Web开发</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>使用SpringBoot；</p>
<ol>
<li><p>创建SpringBoot应用，选中我们需要的模块</p>
</li>
<li><p>SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来</p>
</li>
<li><p>自己编写业务代码；</p>
</li>
</ol>
<p><strong>自动配置原理？</strong></p>
<p>这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx</p>
<blockquote>
<p>xxxxAutoConfiguration：帮我们给容器中自动配置组件；<br>xxxxProperties:配置类来封装配置文件的内容；</p>
</blockquote>
<h3 id="2、SpringBoot对静态资源的映射规则"><a href="#2、SpringBoot对静态资源的映射规则" class="headerlink" title="2、SpringBoot对静态资源的映射规则"></a>2、SpringBoot对静态资源的映射规则</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceProperties</span> <span class="keyword">implements</span> <span class="title class_">ResourceLoaderAware</span> &#123;</span><br><span class="line">  <span class="comment">//可以设置和静态资源有关的参数，缓存时间等</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebMvcAuotConfiguration：</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">cachePeriod</span> <span class="operator">=</span> <span class="built_in">this</span>.resourceProperties.getCachePeriod();</span><br><span class="line">		<span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">&quot;/webjars/**&quot;</span>)) &#123;</span><br><span class="line">			customizeResourceHandlerRegistration(</span><br><span class="line">					registry.addResourceHandler(<span class="string">&quot;/webjars/**&quot;</span>)</span><br><span class="line">							.addResourceLocations(</span><br><span class="line">									<span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>)</span><br><span class="line">					.setCachePeriod(cachePeriod));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">String</span> <span class="variable">staticPathPattern</span> <span class="operator">=</span> <span class="built_in">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">         	<span class="comment">//静态资源文件夹映射</span></span><br><span class="line">		<span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">			customizeResourceHandlerRegistration(</span><br><span class="line">					registry.addResourceHandler(staticPathPattern)</span><br><span class="line">							.addResourceLocations(</span><br><span class="line">									<span class="built_in">this</span>.resourceProperties.getStaticLocations())</span><br><span class="line">					.setCachePeriod(cachePeriod));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//配置欢迎页映射</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> WelcomePageHandlerMapping <span class="title function_">welcomePageHandlerMapping</span><span class="params">(</span></span><br><span class="line"><span class="params">			ResourceProperties resourceProperties)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WelcomePageHandlerMapping</span>(resourceProperties.getWelcomePage(),</span><br><span class="line">				<span class="built_in">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//配置喜欢的图标</span></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty(value = &quot;spring.mvc.favicon.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">FaviconConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">FaviconConfiguration</span><span class="params">(ResourceProperties resourceProperties)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title function_">faviconHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="type">SimpleUrlHandlerMapping</span> <span class="variable">mapping</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleUrlHandlerMapping</span>();</span><br><span class="line">			mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">             	<span class="comment">//所有  **/favicon.ico </span></span><br><span class="line">			mapping.setUrlMap(Collections.singletonMap(<span class="string">&quot;**/favicon.ico&quot;</span>,</span><br><span class="line">					faviconRequestHandler()));</span><br><span class="line">			<span class="keyword">return</span> mapping;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">faviconRequestHandler</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="type">ResourceHttpRequestHandler</span> <span class="variable">requestHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">			requestHandler</span><br><span class="line">					.setLocations(<span class="built_in">this</span>.resourceProperties.getFaviconLocations());</span><br><span class="line">			<span class="keyword">return</span> requestHandler;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ol>
<li>所有 &#x2F;webjars&#x2F;** ，都去 classpath:&#x2F;META-INF&#x2F;resources&#x2F;webjars&#x2F; 找资源</li>
</ol>
<p>webjars：以jar包的方式引入静态资源；</p>
<p><a href="http://www.webjars.org/">http://www.webjars.org/</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入jquery-webjar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>localhost:8080&#x2F;webjars&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.js</p>
<ol start="2">
<li>“&#x2F;**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;, </span><br><span class="line">&quot;classpath:/resources/&quot;,</span><br><span class="line">&quot;classpath:/static/&quot;, </span><br><span class="line">&quot;classpath:/public/&quot; </span><br><span class="line">&quot;/&quot;：当前项目的根路径</span><br></pre></td></tr></table></figure>

<p>localhost:8080&#x2F;abc—————-去静态资源文件夹里面找abc</p>
<ol start="3">
<li>欢迎页： 静态资源文件夹下的所有index.html页面；被”&#x2F;**”映射</li>
</ol>
<p>​    localhost:8080&#x2F;   找index页面</p>
<ol start="4">
<li>所有的 **&#x2F;favicon.ico  都是在静态资源文件下找；</li>
</ol>
<p><strong>配置静态资源文件夹</strong>：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.resources.static-locations</span>=<span class="string">classpath:/hello,classpath:/static/</span></span><br></pre></td></tr></table></figure>

<h3 id="3、模板引擎"><a href="#3、模板引擎" class="headerlink" title="3、模板引擎"></a>3、模板引擎</h3><p>JSP、Velocity、Freemarker、Thymeleaf</p>
<p>SpringBoot推荐的Thymeleaf；</p>
<p>语法更简单，功能更强大</p>
<h4 id="引入thymeleaf"><a href="#引入thymeleaf" class="headerlink" title="引入thymeleaf"></a>引入thymeleaf</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring-boot 2.x 默认使用 thymeleaf 3</p>
<h3 id="Thymeleaf使用"><a href="#Thymeleaf使用" class="headerlink" title="Thymeleaf使用"></a>Thymeleaf使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThymeleafProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">DEFAULT_ENCODING</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MimeType</span> <span class="variable">DEFAULT_CONTENT_TYPE</span> <span class="operator">=</span> MimeType.valueOf(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;classpath:/templates/&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_SUFFIX</span> <span class="operator">=</span> <span class="string">&quot;.html&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>只要我们把HTML页面放在classpath:&#x2F;templates&#x2F;，thymeleaf就能自动渲染</p>
<p>使用：</p>
<ol>
<li>导入thymeleaf的名称空间</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用thymeleaf语法</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>成功！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--th:text 将div里面的文本内容设置为 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;hello&#125;&quot;</span>&gt;</span>这是显示欢迎信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><p>th:text：改变当前元素里面的文本内容</p>
<p>th：任意html属性；来替换原生属性的值</p>
<table>
<thead>
<tr>
<th>Order</th>
<th>Feature</th>
<th>Mean</th>
<th>Attribute</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Fragment inclusion</td>
<td>片段包含；jsp:include</td>
<td>th:insert、th:replace</td>
</tr>
<tr>
<td>2</td>
<td>Fragment iteration</td>
<td>遍历；c:forEach</td>
<td>th:each</td>
</tr>
<tr>
<td>3</td>
<td>Conditional evaluation</td>
<td>条件判断；c:if</td>
<td>th:if、th:unless、th:switch、th:case</td>
</tr>
<tr>
<td>4</td>
<td>Local variable definition</td>
<td>声明变量；c:set</td>
<td>th:object、th:with</td>
</tr>
<tr>
<td>5</td>
<td>General attribute modification</td>
<td>任意属性修改</td>
<td>th:attr、th:attrprepend、th:attrappend</td>
</tr>
<tr>
<td>6</td>
<td>Specific attribute modification</td>
<td>修改指定属性默认值</td>
<td>th:value、th:href、th:src、……</td>
</tr>
<tr>
<td>7</td>
<td>Text(tag body modification)</td>
<td>修改标签体美容</td>
<td>th:text（转义特殊字符）、th:utext（不转义特殊字符）</td>
</tr>
<tr>
<td>8</td>
<td>Fragment specification</td>
<td>声明片段</td>
<td>th:fragment</td>
</tr>
<tr>
<td>9</td>
<td>Fragment removal</td>
<td></td>
<td>th:remove</td>
</tr>
</tbody></table>
<p>表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Simple expressions:（表达式语法）</span><br><span class="line">    Variable Expressions: $&#123;...&#125;：获取变量值；OGNL；</span><br><span class="line">    		1）、获取对象的属性、调用方法</span><br><span class="line">    		2）、使用内置的基本对象：</span><br><span class="line">    			#ctx : the context object.</span><br><span class="line">    			#vars: the context variables.</span><br><span class="line">                #locale : the context locale.</span><br><span class="line">                #request : (only in Web Contexts) the HttpServletRequest object.</span><br><span class="line">                #response : (only in Web Contexts) the HttpServletResponse object.</span><br><span class="line">                #session : (only in Web Contexts) the HttpSession object.</span><br><span class="line">                #servletContext : (only in Web Contexts) the ServletContext object.</span><br><span class="line">                </span><br><span class="line">                $&#123;session.foo&#125;</span><br><span class="line">            3）、内置的一些工具对象：</span><br><span class="line">#execInfo : information about the template being processed.</span><br><span class="line">#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.</span><br><span class="line">#uris : methods for escaping parts of URLs/URIs</span><br><span class="line">#conversions : methods for executing the configured conversion service (if any).</span><br><span class="line">#dates : methods for java.util.Date objects: formatting, component extraction, etc.</span><br><span class="line">#calendars : analogous to #dates , but for java.util.Calendar objects.</span><br><span class="line">#numbers : methods for formatting numeric objects.</span><br><span class="line">#strings : methods for String objects: contains, startsWith, prepending/appending, etc.</span><br><span class="line">#objects : methods for objects in general.</span><br><span class="line">#bools : methods for boolean evaluation.</span><br><span class="line">#arrays : methods for arrays.</span><br><span class="line">#lists : methods for lists.</span><br><span class="line">#sets : methods for sets.</span><br><span class="line">#maps : methods for maps.</span><br><span class="line">#aggregates : methods for creating aggregates on arrays or collections.</span><br><span class="line">#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Selection Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样；</span><br><span class="line">    	补充：配合 th:object=&quot;$&#123;session.user&#125;：</span><br><span class="line">   &lt;div th:object=&quot;$&#123;session.user&#125;&quot;&gt;</span><br><span class="line">    &lt;p&gt;Name: &lt;span th:text=&quot;*&#123;firstName&#125;&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Surname: &lt;span th:text=&quot;*&#123;lastName&#125;&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Nationality: &lt;span th:text=&quot;*&#123;nationality&#125;&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">    Message Expressions: #&#123;...&#125;：获取国际化内容</span><br><span class="line">    Link URL Expressions: @&#123;...&#125;：定义URL；</span><br><span class="line">    		@&#123;/order/process(execId=$&#123;execId&#125;,execType=&#x27;FAST&#x27;)&#125;</span><br><span class="line">    Fragment Expressions: ~&#123;...&#125;：片段引用表达式</span><br><span class="line">    		&lt;div th:insert=&quot;~&#123;commons :: main&#125;&quot;&gt;...&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">Literals（字面量）</span><br><span class="line">      Text literals: &#x27;one text&#x27; , &#x27;Another one!&#x27; ,…</span><br><span class="line">      Number literals: 0 , 34 , 3.0 , 12.3 ,…</span><br><span class="line">      Boolean literals: true , false</span><br><span class="line">      Null literal: null</span><br><span class="line">      Literal tokens: one , sometext , main ,…</span><br><span class="line">Text operations:（文本操作）</span><br><span class="line">    String concatenation: +</span><br><span class="line">    Literal substitutions: |The name is $&#123;name&#125;|</span><br><span class="line">Arithmetic operations:（数学运算）</span><br><span class="line">    Binary operators: + , - , * , / , %</span><br><span class="line">    Minus sign (unary operator): -</span><br><span class="line">Boolean operations:（布尔运算）</span><br><span class="line">    Binary operators: and , or</span><br><span class="line">    Boolean negation (unary operator): ! , not</span><br><span class="line">Comparisons and equality:（比较运算）</span><br><span class="line">    Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</span><br><span class="line">    Equality operators: == , != ( eq , ne )</span><br><span class="line">Conditional operators:条件运算（三元运算符）</span><br><span class="line">    If-then: (if) ? (then)</span><br><span class="line">    If-then-else: (if) ? (then) : (else)</span><br><span class="line">    Default: (value) ?: (defaultvalue)</span><br><span class="line">Special tokens:</span><br><span class="line">    No-Operation: _ </span><br></pre></td></tr></table></figure>

<h3 id="4、SpringMVC自动配置"><a href="#4、SpringMVC自动配置" class="headerlink" title="4、SpringMVC自动配置"></a>4、SpringMVC自动配置</h3><h4 id="Spring-MVC-auto-configuration"><a href="#Spring-MVC-auto-configuration" class="headerlink" title="Spring MVC auto-configuration"></a>Spring MVC auto-configuration</h4><p>Spring Boot 自动配置好了SpringMVC</p>
<p>以下是SpringBoot对SpringMVC的默认配置:<strong>（WebMvcAutoConfiguration）</strong></p>
<ul>
<li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p>
<ul>
<li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li>
<li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li>
<li><strong>如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来</strong></li>
</ul>
</li>
<li><p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p>
</li>
<li><p>Static <code>index.html</code> support. 静态首页访问</p>
</li>
<li><p>Custom <code>Favicon</code> support (see below).  favicon.ico</p>
</li>
<li><p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p>
<ul>
<li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li>
<li><code>Formatter</code>  格式化器；  2017.12.17&#x3D;&#x3D;&#x3D;Date；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)</span><span class="comment">//在文件中配置日期格式化的规则</span></span><br><span class="line"><span class="keyword">public</span> Formatter&lt;Date&gt; <span class="title function_">dateFormatter</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DateFormatter</span>(<span class="built_in">this</span>.mvcProperties.getDateFormat());<span class="comment">//日期格式化组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    &#x3D;&#x3D;自己添加的格式化器转换器，我们只需要放在容器中即可&#x3D;&#x3D;</p>
<ul>
<li><p>Support for <code>HttpMessageConverters</code> (see below).</p>
<ul>
<li><p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</p>
</li>
<li><p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p>
<p>&#x3D;&#x3D;自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）&#x3D;&#x3D;</p>
</li>
</ul>
</li>
<li><p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p>
</li>
<li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p>
<p>&#x3D;&#x3D;我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）&#x3D;&#x3D;</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化WebDataBinder；</span><br><span class="line">请求数据=====JavaBean；</span><br></pre></td></tr></table></figure>

<p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p>
<p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p>
<h4 id="扩展SpringMVC"><a href="#扩展SpringMVC" class="headerlink" title="扩展SpringMVC"></a>扩展SpringMVC</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;success&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/hello&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc</strong></p>
<p>既保留了所有的自动配置，也能用我们扩展的配置；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用WebMvcConfigurer可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/an&quot;</span>).setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p>​    1. WebMvcAutoConfiguration是SpringMVC的自动配置类</p>
<p>​    2. 在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">DelegatingWebMvcConfiguration</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WebMvcConfigurerComposite</span> <span class="variable">configurers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurerComposite</span>();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//从容器中获取所有的WebMvcConfigurer</span></span><br><span class="line">     <span class="meta">@Autowired(required = false)</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">             <span class="built_in">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">           	<span class="comment">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span></span><br><span class="line">           	<span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line">             <span class="comment">//    for (WebMvcConfigurer delegate : this.delegates) &#123;</span></span><br><span class="line">              <span class="comment">//       delegate.addViewControllers(registry);</span></span><br><span class="line">              <span class="comment">//   &#125;</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    3. 容器中所有的WebMvcConfigurer都会一起起作用；</p>
<p>​    4. 我们的配置类也会被调用；</p>
<p>​    效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p>
<h4 id="全面接管SpringMVC"><a href="#全面接管SpringMVC" class="headerlink" title="全面接管SpringMVC"></a>全面接管SpringMVC</h4><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了（不推荐）</p>
<p><strong>我们需要在配置类中添加@EnableWebMvc即可</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addViewController(<span class="string">&quot;/an&quot;</span>).setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p>为什么@EnableWebMvc自动配置就失效了；</p>
<p>1）@EnableWebMvc的核心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(DelegatingWebMvcConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br></pre></td></tr></table></figure>

<p>2）、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br></pre></td></tr></table></figure>

<p>3）、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class,</span></span><br><span class="line"><span class="meta">		WebMvcConfigurerAdapter.class &#125;)</span></span><br><span class="line"><span class="comment">//容器中没有这个组件的时候，这个自动配置类才生效</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">		ValidationAutoConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br></pre></td></tr></table></figure>

<p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p>
<p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p>
<h3 id="5、如何修改SpringBoot的默认配置"><a href="#5、如何修改SpringBoot的默认配置" class="headerlink" title="5、如何修改SpringBoot的默认配置"></a>5、如何修改SpringBoot的默认配置</h3><p>模式：</p>
<p>​    1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</p>
<p>​    2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p>
<p>​    3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p>
<h3 id="6、RestfulCRUD"><a href="#6、RestfulCRUD" class="headerlink" title="6、RestfulCRUD"></a>6、RestfulCRUD</h3><h4 id="默认访问首页"><a href="#默认访问首页" class="headerlink" title="默认访问首页"></a>默认访问首页</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&#123;&quot;/&quot;, &quot;/index.html&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有的WebMvcConfigurer都会一起起作用</span></span><br><span class="line"><span class="meta">@Bean</span>  <span class="comment">// 将组件在容器中注册</span></span><br><span class="line"><span class="keyword">public</span> WebMvcConfigurer <span class="title function_">indexConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">WebMvcConfigurer</span> <span class="variable">mvcConfigurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">            registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">            registry.addViewController(<span class="string">&quot;/index&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">            registry.addViewController(<span class="string">&quot;/index.html&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> mvcConfigurer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>引用静态资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">th:src=<span class="string">&quot;@&#123;/webjars/bootstrap/4.4.1/css/bootstrap.css&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>改变环境路径时不用配置</p>
<h4 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h4><ol>
<li>编写国际化配置文件</li>
<li>使用ResourceBundleMessageSource管理国际化资源文件</li>
<li>在页面中使用fmt:message取出国际化内容</li>
</ol>
<p>步骤：</p>
<ol>
<li>编写国际化配置文件，抽取页面需要显示的国际化消息</li>
</ol>
<p>login.properties :</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">login.btn</span>=<span class="string">登录</span></span><br><span class="line"><span class="attr">login.password</span>=<span class="string">密码</span></span><br><span class="line"><span class="attr">login.remember</span>=<span class="string">记住我</span></span><br><span class="line"><span class="attr">login.tip</span>=<span class="string">请登录</span></span><br><span class="line"><span class="attr">login.username</span>=<span class="string">用户名</span></span><br></pre></td></tr></table></figure>

<p>login_en_US.properties :</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">login.btn</span>=<span class="string">Sign in</span></span><br><span class="line"><span class="attr">login.password</span>=<span class="string">Password</span></span><br><span class="line"><span class="attr">login.remember</span>=<span class="string">Remember Me</span></span><br><span class="line"><span class="attr">login.tip</span>=<span class="string">Please sign in</span></span><br><span class="line"><span class="attr">login.username</span>=<span class="string">Username</span></span><br></pre></td></tr></table></figure>

<p>login_zh_CN.properties :</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">login.btn</span>=<span class="string">登录</span></span><br><span class="line"><span class="attr">login.password</span>=<span class="string">密码</span></span><br><span class="line"><span class="attr">login.remember</span>=<span class="string">记住我</span></span><br><span class="line"><span class="attr">login.tip</span>=<span class="string">请登录</span></span><br><span class="line"><span class="attr">login.username</span>=<span class="string">用户名</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>SpringBoot自动配置好了管理国际化资源文件的组件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.messages&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageSourceAutoConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Comma-separated list of basenames (essentially a fully-qualified classpath</span></span><br><span class="line"><span class="comment">	 * location), each following the ResourceBundle convention with relaxed support for</span></span><br><span class="line"><span class="comment">	 * slash based locations. If it doesn&#x27;t contain a package qualifier (such as</span></span><br><span class="line"><span class="comment">	 * &quot;org.mypackage&quot;), it will be resolved from the classpath root.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">basename</span> <span class="operator">=</span> <span class="string">&quot;messages&quot;</span>;  </span><br><span class="line">    <span class="comment">//我们的配置文件可以直接放在类路径下叫messages.properties；</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> MessageSource <span class="title function_">messageSource</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">ResourceBundleMessageSource</span> <span class="variable">messageSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceBundleMessageSource</span>();</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.basename)) &#123;</span><br><span class="line">            <span class="comment">//设置国际化资源文件的基础名（去掉语言国家代码的）</span></span><br><span class="line">			messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">					StringUtils.trimAllWhitespace(<span class="built_in">this</span>.basename)));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.encoding != <span class="literal">null</span>) &#123;</span><br><span class="line">			messageSource.setDefaultEncoding(<span class="built_in">this</span>.encoding.name());</span><br><span class="line">		&#125;</span><br><span class="line">		messageSource.setFallbackToSystemLocale(<span class="built_in">this</span>.fallbackToSystemLocale);</span><br><span class="line">		messageSource.setCacheSeconds(<span class="built_in">this</span>.cacheSeconds);</span><br><span class="line">		messageSource.setAlwaysUseMessageFormat(<span class="built_in">this</span>.alwaysUseMessageFormat);</span><br><span class="line">		<span class="keyword">return</span> messageSource;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>去页面获取国际化的值</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Signin Template for Bootstrap<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Bootstrap core CSS --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;asserts/css/bootstrap.min.css&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/webjars/bootstrap/4.4.1/css/bootstrap.css&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Custom styles for this template --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;asserts/css/signin.css&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/asserts/css/signin.css&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-signin&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/user/login&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;mb-4&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/asserts/img/bootstrap-solid.svg&#125;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;asserts/img/bootstrap-solid.svg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;72&quot;</span> <span class="attr">height</span>=<span class="string">&quot;72&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;h3 mb-3 font-weight-normal&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;login.tip&#125;&quot;</span>&gt;</span>Please sign in<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;sr-only&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;login.username&#125;&quot;</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span> <span class="attr">required</span>=<span class="string">&quot;&quot;</span> <span class="attr">autofocus</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;sr-only&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;login.password&#125;&quot;</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span> <span class="attr">required</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;checkbox mb-3&quot;</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;remember-me&quot;</span>&gt;</span> [[#&#123;login.remember&#125;]]</span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-lg btn-primary btn-block&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;login.btn&#125;&quot;</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;mt-5 mb-3 text-muted&quot;</span>&gt;</span>© 2017-2018<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/index.html(l=zh_CN)&#125;&quot;</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/index.html(l=en_US)&#125;&quot;</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：根据浏览器语言设置的信息切换了国际化；</p>
<p>原理：</p>
<p>​    国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">		<span class="meta">@ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;)</span></span><br><span class="line">		<span class="keyword">public</span> LocaleResolver <span class="title function_">localeResolver</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.mvcProperties</span><br><span class="line">					.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FixedLocaleResolver</span>(<span class="built_in">this</span>.mvcProperties.getLocale());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">AcceptHeaderLocaleResolver</span> <span class="variable">localeResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AcceptHeaderLocaleResolver</span>();</span><br><span class="line">			localeResolver.setDefaultLocale(<span class="built_in">this</span>.mvcProperties.getLocale());</span><br><span class="line">			<span class="keyword">return</span> localeResolver;</span><br><span class="line">		&#125;</span><br><span class="line">默认的就是根据请求头带来的区域信息获取Locale进行国际化</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>点击链接切换国际化</li>
</ol>
<p>index.html :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;a class=<span class="string">&quot;btn btn-sm&quot;</span> th:href=<span class="string">&quot;@&#123;/index.html(l=zh_CN)&#125;&quot;</span>&gt;中文&lt;/a&gt;</span><br><span class="line">&lt;a class=<span class="string">&quot;btn btn-sm&quot;</span> th:href=<span class="string">&quot;@&#123;/index.html(l=en_US)&#125;&quot;</span>&gt;English&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>MyLocalResolver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ansore.springboot.compoment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.LocaleResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接上携带区域信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLocalResolver</span> <span class="keyword">implements</span> <span class="title class_">LocaleResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Locale <span class="title function_">resolveLocale</span><span class="params">(HttpServletRequest httpServletRequest)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">l</span> <span class="operator">=</span> httpServletRequest.getParameter(<span class="string">&quot;l&quot;</span>);</span><br><span class="line">        <span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> Locale.getDefault();</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(l)) &#123;</span><br><span class="line">            String split[] = l.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">            locale = <span class="keyword">new</span> <span class="title class_">Locale</span>(split[<span class="number">0</span>], split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLocale</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加入容器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> LocaleResolver <span class="title function_">localeResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyLocalResolver</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>开发期间模板引擎页面修改以后，要实时生效</p>
<ol>
<li>禁用模板引擎的缓存</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 禁用模板引擎缓存</span></span><br><span class="line"><span class="attr">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>页面修改完成以后ctrl+f9：重新编译；</li>
</ol>
<p>防止表单重复提交，重定向到主页</p>
<p>登陆错误消息的显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;msg&#125;&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;not #strings.isEmpty(msg)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="拦截器进行登录检查"><a href="#拦截器进行登录检查" class="headerlink" title="拦截器进行登录检查"></a>拦截器进行登录检查</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginHandleInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标方法执行之前</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> request.getSession().getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 未登录， 返回登录页面</span></span><br><span class="line">            request.setAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;没有权限，请先登录&quot;</span>);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/index.html&quot;</span>).forward(request, response);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已登录 放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有的WebMvcConfigurer都会一起起作用</span></span><br><span class="line"><span class="meta">@Bean</span>  <span class="comment">// 将组件在容器中注册</span></span><br><span class="line"><span class="keyword">public</span> WebMvcConfigurer <span class="title function_">indexConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">WebMvcConfigurer</span> <span class="variable">mvcConfigurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;</span><br><span class="line">            registry.addViewController(<span class="string">&quot;/&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">            registry.addViewController(<span class="string">&quot;/index&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">            registry.addViewController(<span class="string">&quot;/index.html&quot;</span>).setViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">            registry.addViewController(<span class="string">&quot;/main.html&quot;</span>).setViewName(<span class="string">&quot;dashboard&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册拦截器</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">            <span class="comment">// 添加拦截器</span></span><br><span class="line">            <span class="comment">// SpringBoot已经做好了拦截器资源映射</span></span><br><span class="line">            registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginHandleInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                    .excludePathPatterns(<span class="string">&quot;/index.html&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;/user/login&quot;</span>, <span class="string">&quot;/asserts/**&quot;</span>, <span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> mvcConfigurer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CRUD-员工列表"><a href="#CRUD-员工列表" class="headerlink" title="CRUD-员工列表"></a>CRUD-员工列表</h4><p>RestfulCRUD：CRUD满足Rest风格；</p>
<p>URI：  &#x2F;资源名称&#x2F;资源标识       HTTP请求方式区分对资源CRUD操作</p>
<table>
<thead>
<tr>
<th></th>
<th>普通CRUD（uri来区分操作）</th>
<th>RestfulCRUD</th>
</tr>
</thead>
<tbody><tr>
<td>查询</td>
<td>getEmp</td>
<td>emp—GET</td>
</tr>
<tr>
<td>添加</td>
<td>addEmp?xxx</td>
<td>emp—POST</td>
</tr>
<tr>
<td>修改</td>
<td>updateEmp?id&#x3D;xxx&amp;xxx&#x3D;xx</td>
<td>emp&#x2F;{id}—PUT</td>
</tr>
<tr>
<td>删除</td>
<td>deleteEmp?id&#x3D;1</td>
<td>emp&#x2F;{id}—DELETE</td>
</tr>
</tbody></table>
<p>实验的请求架构;</p>
<table>
<thead>
<tr>
<th>实验功能</th>
<th>请求URI</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>查询所有员工</td>
<td>emps</td>
<td>GET</td>
</tr>
<tr>
<td>查询某个员工(来到修改页面)</td>
<td>emp&#x2F;1</td>
<td>GET</td>
</tr>
<tr>
<td>来到添加页面</td>
<td>emp</td>
<td>GET</td>
</tr>
<tr>
<td>添加员工</td>
<td>emp</td>
<td>POST</td>
</tr>
<tr>
<td>来到修改页面（查出员工进行信息回显）</td>
<td>emp&#x2F;1</td>
<td>GET</td>
</tr>
<tr>
<td>修改员工</td>
<td>emp</td>
<td>PUT</td>
</tr>
<tr>
<td>删除员工</td>
<td>emp&#x2F;1</td>
<td>DELETE</td>
</tr>
</tbody></table>
<p>员工列表：</p>
<p>thymeleaf公共页面元素抽取</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1、抽取公共片段</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">&quot;copy&quot;</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2、引入公共片段</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;~&#123;footer :: copy&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">~&#123;templatename::selector&#125;：模板名::选择器</span><br><span class="line">~&#123;templatename::fragmentname&#125;:模板名::片段名</span><br><span class="line"></span><br><span class="line">3、默认效果：</span><br><span class="line">insert的公共片段在div标签中</span><br><span class="line">如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：</span><br><span class="line">行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]；</span><br></pre></td></tr></table></figure>

<p>三种引入公共片段的th属性：</p>
<p><strong>th:insert</strong>：将公共片段整个插入到声明引入的元素中</p>
<p><strong>th:replace</strong>：将声明引入的元素替换为公共片段</p>
<p><strong>th:include</strong>：将被引入的片段的内容包含进这个标签中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">th:fragment</span>=<span class="string">&quot;copy&quot;</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">引入方式</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;footer :: copy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;footer :: copy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:include</span>=<span class="string">&quot;footer :: copy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">效果</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>引入片段的时候传入参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;col-md-2 d-none d-md-block bg-light sidebar&quot;</span> <span class="attr">id</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sidebar-sticky&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav flex-column&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link active&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">th:class</span>=<span class="string">&quot;$&#123;activeUri==&#x27;main.html&#x27;?&#x27;nav-link active&#x27;:&#x27;nav-link&#x27;&#125;&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/main.html&#125;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;24&quot;</span> <span class="attr">height</span>=<span class="string">&quot;24&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 24 24&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;currentColor&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;2&quot;</span> <span class="attr">stroke-linecap</span>=<span class="string">&quot;round&quot;</span> <span class="attr">stroke-linejoin</span>=<span class="string">&quot;round&quot;</span> <span class="attr">class</span>=<span class="string">&quot;feather feather-home&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;9 22 9 12 15 12 15 22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Dashboard <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;sr-only&quot;</span>&gt;</span>(current)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入侧边栏;传入参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">&quot;commons/bar::#sidebar(activeUri=&#x27;emps&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="CRUD-员工添加"><a href="#CRUD-员工添加" class="headerlink" title="CRUD-员工添加"></a>CRUD-员工添加</h4><p>添加页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;zhangsan@atguigu.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>4<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>5<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>提交的数据格式不对：生日：日期；</p>
<p>2017-12-12；2017&#x2F;12&#x2F;12；2017.12.12；</p>
<p>日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型;</p>
<p>2017-12-12—Date； 类型转换，格式化;</p>
<p>默认日期是按照&#x2F;的方式；</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.mvc.date-format</span>=<span class="string">yyyy-MM-dd</span></span><br></pre></td></tr></table></figure>

<h4 id="CRUD-员工修改"><a href="#CRUD-员工修改" class="headerlink" title="CRUD-员工修改"></a>CRUD-员工修改</h4><p>修改添加二合一表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--需要区分是员工修改还是添加；--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/emp&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发送put请求修改员工数据--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）</span></span><br><span class="line"><span class="comment">2、页面创建一个post表单</span></span><br><span class="line"><span class="comment">3、创建一个input项，name=&quot;_method&quot;;值就是我们指定的请求方式</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;emp!=null&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;emp!=null&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;emp.id&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;zhangsan&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;zhangsan@atguigu.com&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;emp!=null&#125;?$&#123;emp.email&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">th:checked</span>=<span class="string">&quot;$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-check form-check-inline&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-check-input&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">th:checked</span>=<span class="string">&quot;$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;form-check-label&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--提交的是部门的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">name</span>=<span class="string">&quot;department.id&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:selected</span>=<span class="string">&quot;$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;dept.id&#125;&quot;</span> <span class="attr">th:each</span>=<span class="string">&quot;dept:$&#123;depts&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;dept.departmentName&#125;&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;birth&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;zhangsan&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, &#x27;yyyy-MM-dd HH:mm&#x27;)&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp!=null&#125;?&#x27;修改&#x27;:&#x27;添加&#x27;&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.mvc.hiddenmethod.filter.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>



<h4 id="CRUD-员工删除"><a href="#CRUD-员工删除" class="headerlink" title="CRUD-员工删除"></a>CRUD-员工删除</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;emp:$&#123;emps&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[$&#123;emp.lastName&#125;]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.gender&#125;==0?&#x27;女&#x27;:&#x27;男&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;emp.department.departmentName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(emp.birth, &#x27;yyyy-MM-dd HH:mm&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm btn-primary&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/emp/&#125;+$&#123;emp.id&#125;&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">th:attr</span>=<span class="string">&quot;del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-sm btn-danger deleteBtn&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;.deleteBtn&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//删除当前员工的</span></span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#deleteEmpForm&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;action&quot;</span>,$(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&quot;del_uri&quot;</span>)).<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7、错误处理机制"><a href="#7、错误处理机制" class="headerlink" title="7、错误处理机制"></a>7、错误处理机制</h3><h4 id="SpringBoot默认的错误处理机制"><a href="#SpringBoot默认的错误处理机制" class="headerlink" title="SpringBoot默认的错误处理机制"></a>SpringBoot默认的错误处理机制</h4><p>默认效果：</p>
<p>​    1. 浏览器，返回一个默认的错误页面</p>
<p>​    2. 如果是其他客户端，默认响应一个json数据</p>
<p>原理：</p>
<p>​    可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；</p>
<p>​    给容器中添加了以下组件</p>
<ol>
<li>DefaultErrorAttributes：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">帮我们在页面共享信息；</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes,</span></span><br><span class="line"><span class="params">			<span class="type">boolean</span> includeStackTrace)</span> &#123;</span><br><span class="line">		Map&lt;String, Object&gt; errorAttributes = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, Object&gt;();</span><br><span class="line">		errorAttributes.put(<span class="string">&quot;timestamp&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">		addStatus(errorAttributes, requestAttributes);</span><br><span class="line">		addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);</span><br><span class="line">		addPath(errorAttributes, requestAttributes);</span><br><span class="line">		<span class="keyword">return</span> errorAttributes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>BasicErrorController：处理默认&#x2F;error请求</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicErrorController</span> <span class="keyword">extends</span> <span class="title class_">AbstractErrorController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(produces = &quot;text/html&quot;)</span><span class="comment">//产生html类型的数据；浏览器发送的请求来到这个方法处理</span></span><br><span class="line">	<span class="keyword">public</span> ModelAndView <span class="title function_">errorHtml</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">			HttpServletResponse response)</span> &#123;</span><br><span class="line">		<span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> getStatus(request);</span><br><span class="line">		Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(</span><br><span class="line">				request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));</span><br><span class="line">		response.setStatus(status.value());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//去哪个页面作为错误页面；包含页面地址和页面内容</span></span><br><span class="line">		<span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> resolveErrorView(request, response, status, model);</span><br><span class="line">		<span class="keyword">return</span> (modelAndView == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>, model) : modelAndView);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span></span><br><span class="line">	<span class="meta">@ResponseBody</span>    <span class="comment">//产生json数据，其他客户端来到这个方法处理；</span></span><br><span class="line">	<span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">error</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">		Map&lt;String, Object&gt; body = getErrorAttributes(request,</span><br><span class="line">				isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">		<span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> getStatus(request);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Map&lt;String, Object&gt;&gt;(body, status);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ErrorPageCustomizer：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;error.path:/error&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/error&quot;</span>;  系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>DefaultErrorViewResolver：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> ModelAndView <span class="title function_">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpStatus status,</span></span><br><span class="line"><span class="params">			Map&lt;String, Object&gt; model)</span> &#123;</span><br><span class="line">		<span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> resolve(String.valueOf(status), model);</span><br><span class="line">		<span class="keyword">if</span> (modelAndView == <span class="literal">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;</span><br><span class="line">			modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ModelAndView <span class="title function_">resolve</span><span class="params">(String viewName, Map&lt;String, Object&gt; model)</span> &#123;</span><br><span class="line">        <span class="comment">//默认SpringBoot可以去找到一个页面？  error/404</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">errorViewName</span> <span class="operator">=</span> <span class="string">&quot;error/&quot;</span> + viewName;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模板引擎可以解析这个页面地址就用模板引擎解析</span></span><br><span class="line">		<span class="type">TemplateAvailabilityProvider</span> <span class="variable">provider</span> <span class="operator">=</span> <span class="built_in">this</span>.templateAvailabilityProviders</span><br><span class="line">				.getProvider(errorViewName, <span class="built_in">this</span>.applicationContext);</span><br><span class="line">		<span class="keyword">if</span> (provider != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//模板引擎可用的情况下返回到errorViewName指定的视图地址</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(errorViewName, model);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html</span></span><br><span class="line">		<span class="keyword">return</span> resolveResource(errorViewName, model);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>步骤：</p>
<p>​        一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到&#x2F;error请求；就会被<strong>BasicErrorController</strong>处理；</p>
<p>响应页面；去哪个页面是由<strong>DefaultErrorViewResolver</strong>解析得到的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">resolveErrorView</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model)</span> &#123;</span><br><span class="line">    <span class="comment">//所有的ErrorViewResolver得到ModelAndView</span></span><br><span class="line">   <span class="keyword">for</span> (ErrorViewResolver resolver : <span class="built_in">this</span>.errorViewResolvers) &#123;</span><br><span class="line">      <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> resolver.resolveErrorView(request, status, model);</span><br><span class="line">      <span class="keyword">if</span> (modelAndView != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> modelAndView;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定制错误响应"><a href="#定制错误响应" class="headerlink" title="定制错误响应"></a>定制错误响应</h4><ol>
<li>定制错误的页面</li>
</ol>
<p>有模板引擎的情况下；error&#x2F;状态码;</p>
<p>【将错误页面命名为  错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到  对应的页面；</p>
<p>我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；</p>
<p>​    </p>
<p>​            页面能获取的信息；</p>
<p>​                timestamp：时间戳</p>
<p>​                status：状态码</p>
<p>​                error：错误提示</p>
<p>​                exception：异常对象</p>
<p>​                message：异常消息</p>
<p>​                errors：JSR303数据校验的错误都在这里</p>
<p>没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；</p>
<p>以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面；</p>
<ol start="2">
<li>定制错误的json数据</li>
</ol>
<p>自定义异常处理&amp;返回定制json数据；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(UserNotExistException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">handleException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;code&quot;</span>,<span class="string">&quot;user.notexist&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;message&quot;</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有自适应效果...</span></span><br></pre></td></tr></table></figure>

<p>转发到&#x2F;error进行自适应响应效果处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(UserNotExistException.class)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">handleException</span><span class="params">(Exception e, HttpServletRequest request)</span>&#123;</span><br><span class="line">       Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="comment">//传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Integer statusCode = (Integer) request</span></span><br><span class="line"><span class="comment">        .getAttribute(&quot;javax.servlet.error.status_code&quot;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       request.setAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>,<span class="number">500</span>);</span><br><span class="line">       map.put(<span class="string">&quot;code&quot;</span>,<span class="string">&quot;user.notexist&quot;</span>);</span><br><span class="line">       map.put(<span class="string">&quot;message&quot;</span>,e.getMessage());</span><br><span class="line">       <span class="comment">//转发到/error</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;forward:/error&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>将我们的定制数据携带出去；</p>
<p>出现错误以后，会来到&#x2F;error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；</p>
<p>​    1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；</p>
<p>​    2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到；</p>
<p>​            容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；</p>
<p>自定义ErrorAttributes</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给容器中加入我们自己定义的ErrorAttributes</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyErrorAttributes</span> <span class="keyword">extends</span> <span class="title class_">DefaultErrorAttributes</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">getErrorAttributes</span><span class="params">(WebRequest webRequest, <span class="type">boolean</span> includeStackTrace)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="built_in">super</span>.getErrorAttributes(webRequest, includeStackTrace);</span><br><span class="line">        map.put(<span class="string">&quot;company&quot;</span>,<span class="string">&quot;ansore&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之template</title>
    <url>/posts/223a0ee3.html</url>
    <content><![CDATA[<h1 id="template"><a href="#template" class="headerlink" title="template"></a>template</h1><p><code>template</code>的使用大大提高了代码的复用性, 抽象性</p>
<ol>
<li><strong>类模板实例化时并不是每个成员函数都实例化了, 而是使用到了哪个成员函数, 那个成员函数才实例化</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ***** 1 *******/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">point</span>() : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">		<span class="built_in">point</span>(T x, T y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">		<span class="function">T <span class="title">getX</span><span class="params">()</span> <span class="type">const</span>   </span>&#123; x = y;  <span class="keyword">return</span> x; &#125;	<span class="comment">// 一般是无法通过编译的, x不允许被修改, 但是这里并没有报错</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		T x;</span><br><span class="line">		T y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* ***** 2 *******/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T int</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">point</span>() : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">		<span class="built_in">point</span>(T x, T y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">		<span class="function">T <span class="title">getX</span><span class="params">()</span> <span class="type">const</span>   </span>&#123; x = y;  <span class="keyword">return</span> x; &#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		T x; T y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员函数getX()应该无法通过编译, 就像实例2一样, 但是因为模板中没有使用到函数getX(), 也就没有实例化getX, 所以就没有出现编译报错. 实例2必须在编译的时候就要检查所有的成员即函数.</p>
<p><strong>不是所有的模板都只能在运行时才会被实例化, 比如非类型模板参数就能在编译时期就已经实例化了, 这里主要说的是类模板, 不要混淆了</strong></p>
<ol start="2">
<li><strong>可以把类模板和函数模板结合起来, 定义一个含有成员函数模板的类模板</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">point</span>() : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">		<span class="built_in">point</span>(T x, T y) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;	<span class="comment">// 定义了另一个的模板参数类型</span></span><br><span class="line">			<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(U x)</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		T x;</span><br><span class="line">		T y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里两个都要写出来</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line"><span class="type">void</span> point&lt;T&gt;::<span class="built_in">print</span>(U x)</span><br><span class="line">&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="keyword">this</span>-&gt;x + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	point&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	p.<span class="built_in">print</span>(<span class="number">3.14</span>);	<span class="comment">// 因为是模板函数, 所以交给编译器自行推导</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 类模板中可以声明static成员, 在类外定义的时候要增加template相关的关键词, 并且需要注意每个不同的模板实例都会有一个独有的static成员对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">tmp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">static</span> T t;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T tmp&lt;T&gt;::t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  tmp&lt;<span class="type">int</span>&gt; t1;</span><br><span class="line">  tmp&lt;<span class="type">int</span>&gt; t2;</span><br><span class="line">  tmp&lt;<span class="type">double</span>&gt; t3;</span><br><span class="line">  t1.t = <span class="number">1</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;t1.t = &quot;</span> &lt;&lt; t1.t &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;t2.t = &quot;</span> &lt;&lt; t2.t &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;t3.t = &quot;</span> &lt;&lt; t3.t &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t1.t = 1</span><br><span class="line">t2.t = 1</span><br><span class="line">t3.t = 0</span><br></pre></td></tr></table></figure>

<p><strong>模板中的<code>static</code>是在每个不同的类型实例化一个, 相同类型的实例化对象共享同一个参数。</strong>所以这里的t1, t2中哦t都是同一个实例化变量, 是共享的。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之template之类相关</title>
    <url>/posts/1c53e8be.html</url>
    <content><![CDATA[<h1 id="template之类相关"><a href="#template之类相关" class="headerlink" title="template之类相关"></a>template之类相关</h1><h1 id="虚函数模板"><a href="#虚函数模板" class="headerlink" title="虚函数模板"></a>虚函数模板</h1><p>在我们使用模板从来都没有将虚函数与模板进行套用, 那么这两者能不能同时连用呢?</p>
<p>这个直接来写代码验证才知道.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">virtual</span> T <span class="title">getX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure>

<p>分别用了g++和clang编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// g++</span><br><span class="line">virtual_template.cpp:17:4: error: templates may not be ‘virtual’</span><br><span class="line">    virtual T getX()</span><br><span class="line">// clang</span><br><span class="line">virtual_template.cpp:17:4: error: &#x27;virtual&#x27; cannot be specified on member function templates</span><br><span class="line">                        virtual T getX()</span><br></pre></td></tr></table></figure>

<p>可以看出来clang更加准确的指出了virtual不能是member function templates.</p>
<p>为什么虚函数不能是模板函数?</p>
<ul>
<li>编译器在编译类的定义的时候就必须确定该类的虚表大小.</li>
<li>模板只有在运行调用时才能确认其大小, 两者冲突. 结果显而易见.</li>
</ul>
<h1 id="模板拷贝构造函数"><a href="#模板拷贝构造函数" class="headerlink" title="模板拷贝构造函数"></a>模板拷贝构造函数</h1><p>模板与不同模板之间不能直接的赋值(强制转换), 毕竟模板一般都是类和函数都不是普通的类型. 但是类有拷贝构造函数, 所以我们可以对类的构造函数进行修改, 也就成了模板构造函数.</p>
<p>模板拷贝构造函数与一般的拷贝构造函数没有什么区别, 仅仅实在加了一个模板作为返回值类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">tmp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">tmp</span>() : <span class="built_in">x</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">tmp</span>(<span class="type">const</span> tmp&lt;U&gt; &amp;t) &#123; x = t.x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  tmp&lt;<span class="type">int</span>&gt; t1;</span><br><span class="line">  tmp&lt;<span class="type">char</span>&gt; t2;</span><br><span class="line">  t1 = t2;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之template之非类型模板参数</title>
    <url>/posts/f9d830d4.html</url>
    <content><![CDATA[<h1 id="template之非类型模板参数"><a href="#template之非类型模板参数" class="headerlink" title="template之非类型模板参数"></a>template之非类型模板参数</h1><p><strong>非类型参数, 可用在模板中自定义为整型类型, 指针或引用, 不能定义为浮点数等其他类型.</strong></p>
<p>非类型模板参数在编译期间就已经实例化, 所以其模板实参必须是常量表达式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;; 	<span class="comment">// N是编译时就确定的常量表达式</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N, <span class="type">size_t</span> M&gt;;	<span class="comment">// N,M是编译时就确定的常量表达式</span></span><br></pre></td></tr></table></figure>

<p>可能就是会觉得没有用, 毕竟使用模板就是要用他的模板参数类型啊, 没有这个那还怎么用. 这里就来先看一个例子.</p>
<blockquote>
<p>要求: 实现一个函数返回一个数组的真实大小, 如 : int a[100]; ArrSize(a);返回100</p>
</blockquote>
<p>讲道理传入函数中a就转换为指针了, 怎么用指针能获取其表示范围? 这里就要用到template的非类型参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 这里的N是编译时期就知道了, 所以可以加上constexpr关键字</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, std::<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> <span class="title">ArrSize</span><span class="params">(T (&amp;a)[N])</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a[<span class="number">100</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">ArrSize</span>(a) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数模板通过传入a后会自动推导出 T 的类型为 int, N 的大小为 100, 函数通过引用, 所以传入的是一个a而不是一个指针</p>
<p>重点在于模板参数N能自动推导传入数组的大小.</p>
<p>同样我们可以将<strong>strcmp</strong>做一个封装, 实现一个字符串比较的模板函数.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;a)[N], <span class="type">const</span> <span class="type">char</span> (&amp;b)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用template的非类型参数可以自动帮我们获取参数的大小, 省去手动传入参数大小的麻烦等问题. 记住 : <strong>非类型模板参数在编译期间就已经实例化, 所以其模板实参必须是常量表达式.</strong></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之new实现</title>
    <url>/posts/98a6c896.html</url>
    <content><![CDATA[<h1 id="new实现"><a href="#new实现" class="headerlink" title="new实现"></a>new实现</h1><h1 id="new-operator用法"><a href="#new-operator用法" class="headerlink" title="new operator用法"></a>new operator用法</h1><p>其实new operator我们经常在使用, 就是我们直接向堆申请一块内存大小, 然后对该内存进行构造和析构.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">point</span> &#123;</span><br><span class="line">  T x;</span><br><span class="line">  T y;</span><br><span class="line">&#125;;</span><br><span class="line">point&lt;<span class="type">int</span>&gt; *p = <span class="keyword">new</span> point&lt;<span class="type">int</span>&gt;[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>这就是new operator的用法. 其实在使用它的时候, 它会做两步事情.</p>
<ol>
<li>向堆申请一块大小的内存.</li>
<li>对其有构造函数的执行构造函数</li>
</ol>
<p>其实剩下的两种用法就是将 new operator 的两个功能分开做.</p>
<h1 id="operator-new用法"><a href="#operator-new用法" class="headerlink" title="operator new用法"></a>operator new用法</h1><p><code>operator new</code>申请一块空间, 但是申请完了就什么都不做. 这感觉就很像<code>malloc</code>函数啊. 对, 没错. 其实<code>operator new</code>就是间接性的调用了 <code>malloc</code>函数. 我们直接来看源码部分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *__CRTDECL <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> <span class="type">const</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">void</span> *<span class="type">const</span> block = <span class="built_in">malloc</span>(size)) &#123;</span><br><span class="line">      <span class="keyword">return</span> block;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_callnewh(size) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (size == SIZE_MAX) &#123;</span><br><span class="line">        __scrt_throw_std_bad_array_new_length();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __scrt_throw_std_bad_alloc();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很清楚的可以看出来5行的确是直接的调用了malloc函数, 然后除了申请的大小判断就没有了, 那为什么我们不直接用malloc函数而要用operator new??? 主要是new的封装, 可重载吧, 毕竟我们常说<strong>new不是函数, 而是操作符也是有原因的</strong>. 接下来就是最后一个了.</p>
<h1 id="placement-new用法"><a href="#placement-new用法" class="headerlink" title="placement new用法"></a>placement new用法</h1><p><code>placement new</code>是在已经申请的内存上构建对象. 这就是我们调用new的时候会调用对象的构造函数的原因. 有一点, 刚说了可以在已经申请的内存上构建对象, 难不成不只是堆, 连栈上也能构建对象.</p>
<p>这也是我们内存池经常用的方法, 使用<code>placement new</code>在已经申请的内存上构建对象</p>
<p>它的用法就很灵活了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> buff[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">new</span>(buff) <span class="built_in">int</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这样我们就在已分配空间的buff中重新构建对象了, 传入的buff代表的是地址, 后面括号代表的初始化的值. 这个例子也证实了我们可以在栈中分配对象, 因为buff就在栈中. 而buff[0]与p都指向的同一块地址.</p>
<p><strong>我们用buff地址开始申请的对象, 就尽量不要用buff了, 因为buff的数据被重新的修改了, 使用buff可能就会出现奇怪的数据</strong></p>
<p><img src="https://img.ansore.de/2022/05/04/6272719d4fce7.png" alt="new"></p>
<p><img src="/new%E5%AE%9E%E7%8E%B0%202f66fa759e2840af87a98909d7813fa5/Untitled%201.png" alt="new"></p>
<p>同时, buff的长度要足够装下对象的大小, 否则就会出现数据覆盖的危险.</p>
<p><strong>new操作符的实现是两步就可概括为先申请了空间, 再调用构造函数.</strong></p>
<h1 id="new的重载实现"><a href="#new的重载实现" class="headerlink" title="new的重载实现"></a>new的重载实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">point</span>(T i) : <span class="built_in">i</span>(i) &#123; std::cout &lt;&lt; <span class="string">&quot;point constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span> *p, <span class="type">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;operator new&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;new&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="built_in">sizeof</span>(point&lt;<span class="type">int</span>&gt;)];</span><br><span class="line">  point&lt;<span class="type">int</span>&gt; *pc = <span class="built_in">new</span> (buf, <span class="string">&quot;first new&quot;</span>) <span class="built_in">point</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的, <code>delete</code>的实现也是跟<code>new</code>有很多相似的, <code>delete</code>事先调用析构函数, 然后再调用<code>free</code>函数释放内存, 同样是可以将析构和释放内存分开调用, 也可以进行重载, 这里就不细讲了. 至于为什么<code>new</code>的对象一定要用<code>delete</code>来释放也容易想明白, 因为<code>delete</code>会默认调用其析构函数, 而<code>free</code>仅仅只是释放空间而没有调用析构. 如果是普通变量用<code>new</code>或<code>malloc</code>申请内存都是可以用<code>delete</code>释放, 毕竟没有析构的就默认什么也不做然后释放内存.</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之一级配置器</title>
    <url>/posts/c694dc2d.html</url>
    <content><![CDATA[<h1 id="一级配置器"><a href="#一级配置器" class="headerlink" title="一级配置器"></a>一级配置器</h1><p>一级配置器的类. 它无template型别参数. 这里我将public定义的函数和私有成员函数成对分离出来讲解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一级配置器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt; <span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span> &#123;</span><br><span class="line">  <span class="comment">// 这里private里面的函数都是在内存不足的时候进行调用的</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>;          <span class="comment">// 分配不足</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span> *, <span class="type">size_t</span>)</span></span>; <span class="comment">// 重新分配不足</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STL_STATIC_TEMPLATE_MEMBER_BUG</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      *__malloc_alloc_oom_handler)</span><span class="params">()</span></span>; <span class="comment">// 内存不足设置的处理例程, 默认设置的是0,</span></span><br><span class="line">                                      <span class="comment">// 表示没有设置处理例程,</span></span><br><span class="line">                                      <span class="comment">// 这个处理例程是由用户手动设置的</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>唯一比较麻烦的就是<code>set_malloc_handler</code> 它就是接受一个函数指针, 用来保存用户自定义的处理函数, 如果用户没有设置的话, 默认就设置为0. 因为处理函数会跟后面的内存不足有关系</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是模仿c++的set_new_handler. 是由用户自己定义的处理函数, 没有设置默认为0</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(*set_malloc_handler(<span class="type">void</span> (*f)()))</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">void</span> (*old)() = __malloc_alloc_oom_handler;</span><br><span class="line">  __malloc_alloc_oom_handler = f;</span><br><span class="line">  <span class="keyword">return</span> (old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认将处理例程设置为0, 只有用户自己设置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="built_in">void</span> (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h1 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h1><p><code>allocate</code> : 很明显, 这里直接调用<code>malloc</code>分配内存, 当内存不足的时候, 程序继续调用<code>oom_malloc</code>来选择抛出异常还是一直申请内存, 直到申请内存成功.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在分配和再次分配中, 都会检查内存不足, 在不足的时候直接调用private中相应的函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span> *result = <span class="built_in">malloc</span>(n);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == result)</span><br><span class="line">    result = <span class="built_in">oom_malloc</span>(n);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>oom_malloc</code>函数功能 : 除非用户自定义了处理例程, 否则当内存不足的时候直接输出内存不足的提示然后直接调用<code>exit(1);</code><br>用户定义了处理程序, 函数会一直进行内存申请, 直到申请到内存为止</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt; <span class="type">void</span> *__malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n) &#123;</span><br><span class="line">  <span class="built_in">void</span> (*my_malloc_handler)();</span><br><span class="line">  <span class="type">void</span> *result;</span><br><span class="line">  <span class="comment">// 用户自定义处理例程, 就一直申请内存, 否则抛出异常</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123;</span><br><span class="line">      __THROW_BAD_ALLOC;</span><br><span class="line">    &#125;</span><br><span class="line">    (*my_malloc_handler)();</span><br><span class="line">    result = <span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">      <span class="keyword">return</span> (result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h1><p>一级配置器直接调用free释放内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* n */</span>)</span> </span>&#123; <span class="built_in">free</span>(p); &#125;</span><br></pre></td></tr></table></figure>

<h1 id="reallocate"><a href="#reallocate" class="headerlink" title="reallocate"></a>reallocate</h1><p>下面的函数都是很简单的或是重复的功能, 就一笔带过.</p>
<p>这里<code>reallocate</code>和<code>oom_realloc</code>和上面<code>allocate</code>一样的, 这里就不做过多的解释了.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">reallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* old_sz */</span>, <span class="type">size_t</span> new_sz)</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span> *result = <span class="built_in">realloc</span>(p, new_sz);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == result)</span><br><span class="line">    result = <span class="built_in">oom_realloc</span>(p, new_sz);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> *__malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_realloc</span>(<span class="type">void</span> *p, <span class="type">size_t</span> n) &#123;</span><br><span class="line">  <span class="built_in">void</span> (*my_malloc_handler)();</span><br><span class="line">  <span class="type">void</span> *result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123;</span><br><span class="line">      __THROW_BAD_ALLOC;</span><br><span class="line">    &#125;</span><br><span class="line">    (*my_malloc_handler)();</span><br><span class="line">    result = <span class="built_in">realloc</span>(p, n);</span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">      <span class="keyword">return</span> (result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序默认定义<code>mallo_alloc</code>函数, 并且设置统一的调用接口, 默认的的接口为第二级配置器</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认将malloc_alloc设为0;</span></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br></pre></td></tr></table></figure>

<h1 id="统一的接口"><a href="#统一的接口" class="headerlink" title="统一的接口"></a>统一的接口</h1><p>定义符合STL规格的配置器接口, 不管是一级配置器还是二级配置器都是使用这个接口进行分配的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义符合STL规格的配置器接口,</span></span><br><span class="line"><span class="comment">// 不管是一级配置器还是二级配置器都是使用这个接口进行分配的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == n ? <span class="number">0</span> : (T *)Alloc::<span class="built_in">allocate</span>(n * <span class="built_in">sizeof</span>(T));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; <span class="keyword">return</span> (T *)Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != n)</span><br><span class="line">      Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in">sizeof</span>(T));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span> </span>&#123; Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>STL对malloc和free用函数重新进行了封装, 同时一级还是二级都做了统一的接口. 接下来我们继续分析第二级配置器.</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之二级配置器</title>
    <url>/posts/bd40a17b.html</url>
    <content><![CDATA[<h1 id="二级配置器"><a href="#二级配置器" class="headerlink" title="二级配置器"></a>二级配置器</h1><p>第一级是直接调用<code>malloc</code>分配空间, 调用<code>free</code>释放空间, 第二级三就是建立一个内存池, 小于128字节的申请都直接在内存池申请, 不直接调用<code>malloc</code>和<code>free</code>. 本节分析第二级空间配置器, STL将第二级配置器设置为默认的配置器, 所以只要一次申请的空间不超过128字节就默认在内存池中申请空间, 超过才会调用第一级配置器.</p>
<p>首先先来介绍3个常量</p>
<ol>
<li><code>__ALIGN</code>: 以8字节进行对齐</li>
<li><code>__MAX_BYTES</code> : 二级分配器最大分配的内存大小</li>
<li><code>__NFREELISTS</code> : 128字节能分配的的链表个数, 并且从每个链表保存的内存大小都是8的倍数, 而且都比前一个大8字节, 也就是分别是8, 16, 32…128字节</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二级配置器</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__ALIGN = <span class="number">8</span>&#125;; <span class="comment">// 设置对齐要求. 对齐为8字节, 没有8字节自动补齐</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__MAX_BYTES = <span class="number">128</span>&#125;;   <span class="comment">// 第二级配置器的最大一次性申请大小, 大于128就直接调用第一级配置器</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__NFREELISTS = __MAX_BYTES/__ALIGN&#125;;  <span class="comment">// 链表个数, 分别代表8, 16, 32....字节的链表</span></span><br></pre></td></tr></table></figure>

<p>再介绍一个宏操作, 这是进行对齐操作, 将不满8的倍数的填充成8的倍数.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="type">size_t</span> bytes)</span> \</span></span><br><span class="line"><span class="function"></span>&#123;\</span><br><span class="line">    <span class="keyword">return</span> (((bytes) + ALIGN<span class="number">-1</span>) / __ALIGN - <span class="number">1</span>);\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="从allocate先切入分析"><a href="#从allocate先切入分析" class="headerlink" title="从allocate先切入分析"></a>从allocate先切入分析</h1><ol>
<li>先判断申请的字节大小是不是大于128字节, 是, 则交给第一级配置器来处理. 否, 继续往下执行</li>
<li>找到分配的地址对齐后分配的是第几个大小的链表.</li>
<li>获得该链表指向的首地址, 如果链表没有多余的内存, 就先填充链表.</li>
<li>返回链表的首地址, 和一块能容纳一个对象的内存, 并更新链表的首地址</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> * <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      obj * __VOLATILE * my_free_list;</span><br><span class="line">      obj * __RESTRICT result;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>) __MAX_BYTES) </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span>(malloc_alloc::<span class="built_in">allocate</span>(n));</span><br><span class="line">      &#125;</span><br><span class="line">      my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">      result = *my_free_list;</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="number">0</span>) 	<span class="comment">// 没有多余的内存, 就先填充链表.</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">void</span> *r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n));</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">      &#125;</span><br><span class="line">      *my_free_list = result -&gt; free_list_link;</span><br><span class="line">      <span class="keyword">return</span> (result);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>refill</code>内存填充:</p>
<ol>
<li>向内存池申请空间的起始地址</li>
<li>如果只申请到一个对象的大小, 就直接返回一个内存的大小, 如果有更多的内存, 就继续执行</li>
<li>从第二个块内存开始, 把从内存池里面分配的内存用链表给串起来, 并返回一个块内存的地址给用户</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存填充</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">refill</span>(<span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="type">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">  	<span class="type">char</span> * chunk = <span class="built_in">chunk_alloc</span>(n, nobjs);             <span class="comment">// 向内存池申请空间的起始地址</span></span><br><span class="line">  	obj * __VOLATILE * my_free_list;</span><br><span class="line">  	obj * result;</span><br><span class="line">  	obj * current_obj, * next_obj;</span><br><span class="line">  	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 如果只申请到一个对象的大小, 就直接返回一个内存的大小</span></span><br><span class="line">  	<span class="keyword">if</span> (<span class="number">1</span> == nobjs) <span class="keyword">return</span>(chunk);</span><br><span class="line">  	my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 申请的大小不只一个对象的大小的时候</span></span><br><span class="line">  	result = (obj *)chunk;</span><br><span class="line">  	<span class="comment">// my_free_list指向内存池返回的地址的下一个对齐后的地址</span></span><br><span class="line">  	*my_free_list = next_obj = (obj *)(chunk + n);</span><br><span class="line">  	<span class="comment">// 这里从第二个开始的原因主要是第一块地址返回给了用户, 现在需要把从内存池里面分配的内存用链表给串起来</span></span><br><span class="line">  	<span class="keyword">for</span> (i = <span class="number">1</span>; ; i++) </span><br><span class="line">  	&#123;</span><br><span class="line">	    current_obj = next_obj;</span><br><span class="line">    	next_obj = (obj *)((<span class="type">char</span> *)next_obj + n);</span><br><span class="line">	    <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) </span><br><span class="line">        &#123;</span><br><span class="line">			current_obj -&gt; free_list_link = <span class="number">0</span>;</span><br><span class="line">      		<span class="keyword">break</span>;</span><br><span class="line">    	&#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">      		current_obj -&gt; free_list_link = next_obj;</span><br><span class="line">    	&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  	<span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="统一的接口"><a href="#统一的接口" class="headerlink" title="统一的接口"></a>统一的接口</h1><p>定义符合STL规格的配置器接口, 不管是一级配置器还是二级配置器都是使用这个接口进行分配的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义符合STL规格的配置器接口, 不管是一级配置器还是二级配置器都是使用这个接口进行分配的</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::<span class="built_in">allocate</span>(n * <span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> (T*) Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">    </span>&#123; Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in">sizeof</span> (T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用链表来保存不同字节大小的内存块, 就很容易的进行维护, 而且每次的内存分配都直接可以从链表或者内存池中获得, 提升了我们申请内存的效率, 毕竟每次调用malloc和free效率是很低的, 特别是很小内存的时候.</p>
<p><strong>STL默认的就是第二级配置器, 它会自动判断我们使用哪一个配置器.</strong></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++空间构造器的内存池</title>
    <url>/posts/28e2f3b8.html</url>
    <content><![CDATA[<h1 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h1><h1 id="static-data-template的初始化"><a href="#static-data-template的初始化" class="headerlink" title="static data template的初始化"></a><strong>static data template的初始化</strong></h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>;	<span class="comment">// 内存池的首地址</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;	<span class="comment">// 内存池的结束地址</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;	<span class="comment">// 多次调用内存池, 就会更多的是给链表分配内存, 这就是一个增量.</span></span><br></pre></td></tr></table></figure>

<ol>
<li>内存池的大小大于需要的空间, 直接返回起始地址(nobjs默认设置为20, 所以每次调用都会给链表额外的19个内存块)</li>
<li>内存池的内存不足以马上分配那么多内存, 但是还能满足分配一个即以上的大小, 那就全部分配出去</li>
<li>如果一个对象的大小都已经提供不了了, 先将零碎的内存块给一个小内存的链表来保存, 然后就准备调用malloc申请40块+额外大小的内存块(额外内存块就由heap_size决定), 如果申请失败跳转到步骤4, 成功跳转到步骤6</li>
<li>充分利用更大内存的链表, 通过递归来调用他们的内存块</li>
<li>如果还是没有内存块, 直接调用一级配置器来申请内存, 还是失败就抛出异常, 成功申请就继续执行</li>
<li>重新修改内存起始地址和结束地址为当前申请的地址块, 重新调用chunk_alloc分配内存</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存池</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span>* __default_alloc_template&lt;threads, inst&gt;::<span class="built_in">chunk_alloc</span>(<span class="type">size_t</span> size, <span class="type">int</span>&amp; nobjs)</span><br><span class="line">&#123;</span><br><span class="line">  	<span class="type">char</span> * result;</span><br><span class="line">  	<span class="type">size_t</span> total_bytes = size * nobjs;            <span class="comment">// 链表需要申请的内存大小</span></span><br><span class="line">  	<span class="type">size_t</span> bytes_left = end_free - start_free;    <span class="comment">// 内存池里面总共还有多少内存空间</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 内存池的大小大于需要的空间, 直接返回起始地址</span></span><br><span class="line">  	<span class="keyword">if</span> (bytes_left &gt;= total_bytes) </span><br><span class="line">  	&#123;</span><br><span class="line">	    result = start_free;</span><br><span class="line">    	start_free += total_bytes;  <span class="comment">// 内存池的首地址往后移</span></span><br><span class="line">	    <span class="keyword">return</span>(result);</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="comment">// 内存池的内存不足以马上分配那么多内存, 但是还能满足分配一个即以上的大小, 那就按对齐方式全部分配出去</span></span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) </span><br><span class="line">  	&#123;</span><br><span class="line">	    nobjs = bytes_left/size;</span><br><span class="line">    	total_bytes = size * nobjs;</span><br><span class="line">    	result = start_free;</span><br><span class="line">    	start_free += total_bytes;  <span class="comment">// 内存池的首地址往后移</span></span><br><span class="line">    	<span class="keyword">return</span>(result);</span><br><span class="line">  	&#125; </span><br><span class="line">  	<span class="keyword">else</span> </span><br><span class="line">  	&#123; </span><br><span class="line">	    <span class="comment">// 如果一个对象的大小都已经提供不了了, 那就准备调用malloc申请两倍+额外大小的内存</span></span><br><span class="line">	    <span class="type">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    	<span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">    	<span class="comment">// 内存池还剩下的零头内存分给给其他能利用的链表, 也就是绝不浪费一点.</span></span><br><span class="line">    	<span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) </span><br><span class="line">    	&#123;</span><br><span class="line">      		<span class="comment">// 链表指向申请内存的地址</span></span><br><span class="line">      		obj * __VOLATILE * my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line">      		((obj *)start_free) -&gt; free_list_link = *my_free_list;</span><br><span class="line">      		*my_free_list = (obj *)start_free;</span><br><span class="line">    	&#125;</span><br><span class="line">    	start_free = (<span class="type">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">    	<span class="comment">// 内存不足了</span></span><br><span class="line">    	<span class="keyword">if</span> (<span class="number">0</span> == start_free) </span><br><span class="line">    	&#123;</span><br><span class="line">      		<span class="type">int</span> i;</span><br><span class="line">      		obj * __VOLATILE * my_free_list, *p;</span><br><span class="line">      		<span class="comment">// 充分利用剩余链表的内存, 通过递归来申请</span></span><br><span class="line">      		<span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) </span><br><span class="line">      		&#123;	</span><br><span class="line">	        	my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i);</span><br><span class="line">	        	p = *my_free_list;</span><br><span class="line">	        	<span class="keyword">if</span> (<span class="number">0</span> != p) </span><br><span class="line">	            &#123;</span><br><span class="line">	          		*my_free_list = p -&gt; free_list_link;</span><br><span class="line">          			start_free = (<span class="type">char</span> *)p;</span><br><span class="line">	          		end_free = start_free + i;</span><br><span class="line">          			<span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">    	    	&#125;</span><br><span class="line">      		&#125;</span><br><span class="line">      		<span class="comment">// 如果一点内存都没有了的话, 就只有调用一级配置器来申请内存了, 并且用户没有设置处理例程就抛出异常</span></span><br><span class="line">      		end_free = <span class="number">0</span>;	<span class="comment">// In case of exception.</span></span><br><span class="line">      		start_free = (<span class="type">char</span> *)malloc_alloc::<span class="built_in">allocate</span>(bytes_to_get);</span><br><span class="line">	    &#125;</span><br><span class="line">	    	<span class="comment">// 申请内存成功后重新修改内存起始地址和结束地址, 重新调用chunk_alloc分配内存</span></span><br><span class="line">	    	heap_size += bytes_to_get;</span><br><span class="line">	    	end_free = start_free + bytes_to_get;</span><br><span class="line">    		<span class="keyword">return</span>(<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">  	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存池的存在就是为了能快速的提供我们做需要的内存并且保存多余的空间, 让STL分配空间不再每次都进行malloc和free的操作, 效率又很有保障. 有时用户申请的块更小, 我们也能充分的利用起来. 唯一可能不足的是我们每次只申请<code>char</code>个大小, 但是内存池获得的确是8字节的大小.</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之空间配置器</title>
    <url>/posts/79d2cb62.html</url>
    <content><![CDATA[<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><h1 id="“new”的实现"><a href="#“new”的实现" class="headerlink" title="“new”的实现"></a>“new”的实现</h1><p>这里直接我们直接来看STL的<code>construct</code>实现吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的construct调用的是placement new, 在一个已经获得的内存里建立一个对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">construct</span><span class="params">(T1* p, <span class="type">const</span> T2&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">new</span> (p) <span class="built_in">T1</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以明白这里就只是一个<code>placement new</code>的调用, 只是用了泛型来实现一个对象分配的模板, 并实现初始化.</p>
<p>既然已经看到了对象的分配, 那再接再厉看看空间的分配, 充分了解STL是怎么将new分开执行的. allocate函数实现空间的申请, 但是这里有一点看不出来, <strong>申请内存是有分为一级配置器和二级配置器, 分配的空间小于128字节的就调用二级配置器, 大于就直接使用一级配置器, 一级配置器直接调用<code>malloc</code>申请, 二级使用内存池.</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> T *<span class="title">allocate</span><span class="params">(<span class="type">ptrdiff_t</span> size, T *)</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">  T *tmp = (T *)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size * <span class="built_in">sizeof</span>(T))));</span><br><span class="line">  <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;out of memort&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new_handler，顾名思义就是一个处理程序，当程序向内存的分配请求无法满足时将有两种可能:</p>
<ol>
<li>抛出异常</li>
<li>设置一个异常处理函数，这就是所谓的new_handler（类似于中断机制，本质上来说就是一个函数指针）</li>
</ol>
<p>当第二种情况发生以后，我们可以通过new_handler删除无用的内存，以及设置新的new_handler,而这个set_new_handler就是来进行设置的。</p>
<p><code>set_new_handler(0)</code>主要是为了卸载目前的内存分配异常处理函数，这样一来一旦分配内存失败的话，C++就会强制性抛出<code>std:bad_alloc</code>异常，而不是跑到处理某个异常处理函数去处理。</p>
<p><code>::</code>访问符放到最前面的意思是使用全局版本</p>
<p><code>new</code>一共有三兄弟：</p>
<ol>
<li><code>new operator</code> (就是我们常用的new)</li>
<li><code>operator new</code></li>
<li><code>placement new</code></li>
</ol>
<p>先说说这个<code>new</code>，我们在程序中使用<code>new</code>的时候，实际上做了两件事情：申请内存和构造对象<br>简单的理解，<code>new</code>完成了一套比较完备的服务，而<code>operator new</code>，只是申请内存，<code>placement new</code>是在申请的内存中进行构造对象，第2、3中形式就是对<code>new</code>的拆分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> _construct(T1* p, <span class="type">const</span> T2&amp; value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span>(p)<span class="built_in">T1</span>(value);<span class="comment">//placement new,invoke constuctor of t1</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里p指向一块内存，我们直接在这个内存上构造对象（调用T1的构造函数），即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p-&gt;T1::<span class="built_in">T1</span>(value)</span><br></pre></td></tr></table></figure>

<p>内存分配果然是调用<code>operator new</code>来执行空间分配, 这里<code>allocate</code>和<code>construct</code>都只是简单的对<code>operator new</code>进行封装</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::allocator&lt;std::string&gt; alloc;</span><br><span class="line">  <span class="keyword">auto</span> str_ve = alloc.<span class="built_in">allocate</span>(N);</span><br><span class="line">  <span class="keyword">auto</span> p = str_ve; <span class="comment">// vector&lt;string&gt; *p = str_ve;</span></span><br><span class="line">  alloc.<span class="built_in">construct</span>(p++);</span><br><span class="line">  alloc.<span class="built_in">construct</span>(p++, <span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  alloc.<span class="built_in">construct</span>(p++, <span class="string">&quot;construct&quot;</span>);</span><br><span class="line">  std::cout &lt;&lt; str_ve[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; str_ve[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; str_ve[<span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p != str_ve) &#123;</span><br><span class="line">    alloc.<span class="built_in">destroy</span>(--p);</span><br><span class="line">  &#125;</span><br><span class="line">  alloc.<span class="built_in">deallocate</span>(str_ve, N);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">aaaaaaaaaa</span><br><span class="line">construct</span><br></pre></td></tr></table></figure>

<p>这个程序首先调用<code>allocate</code>申请N个大小的空间, 在依次<code>construct</code>调用构造函数, 这里就先初始化3个结构, 紧接着通过<code>destory</code>调用析构函数, 最后<code>deallocate</code>释放申请的空间. 整个过程很容易理解, 但是这里还要深入是dealllocate和destroy两个函数.</p>
<h1 id="“delete”实现"><a href="#“delete”实现" class="headerlink" title="“delete”实现"></a>“delete”实现</h1><p>先是看<code>destroy</code>调用析构函数. 而destroy有两个版本.</p>
<p><strong>版本一:</strong></p>
<p>需要传入的参数 : <strong>一个指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一版本, 接收指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(T* pointer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pointer-&gt;~<span class="built_in">T</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>版本一直接就调用了析构函数, 不用过多的分析.</p>
<p><strong>版本二:</strong></p>
<p>需要传入的参数 : <strong>两个迭代器</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二个版本的, 接受两个迭代器, 并设法找出元素的类型. 通过__type_trais&lt;&gt; 找出最佳措施</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __destroy(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受两个迭代器, 以__type_trais&lt;&gt; 判断是否有traival destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>, <span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy(ForwardIterator first, ForwardIterator last, T*)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor;</span><br><span class="line">  __destroy_aux(first, last, <span class="built_in">trivial_destructor</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>destroy直接调用<code>__destroy</code>, 前者只是一个接口, 所以重点是在后者.</p>
<p>分析<code>__type_traits&lt;&gt;</code> : 它是用于获取迭代器所指对象的类型,运用traits技法实现的.只要记住我们用来获取对对象类型就可以了. 然后通过类型的不一样选择执行不同的析构调用.</p>
<p>第二版本接受first和last两个迭代器，将两个迭代器范围内的对象析构掉。在第二版本中运用了traits编程技法，traits会得到当前对象的一些特性，再根据特性的不同分别对不同特性的对象调用相应的方法。在第二版本中，STL会分析迭代器所指对象的<code>has_trivial_destructor</code>特性的类型(只有两种：<code>_true_type</code>和<code>__false_type</code>)，如果是__true_type，STL就什么第一不做；如果是false_type，就会调用每个对象的析构函数来销毁这组对象。</p>
<p>当<code>__type_traits</code>为<code>__false_type</code>时, 调用的是下面这个函数, 通过迭代所有的对象并调用版本一的函数执行析构函数进行析构. 而这个是被称为<code>non-travial destructor</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有non-travial destructor </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first &lt; last; ++first)</span><br><span class="line">    <span class="built_in">destroy</span>(&amp;*first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>__type_traits</code>为<code>__true_type</code>时, 什么也不做, 因为这样效率很高效, 并不需要执行析构函数. 而这个是被称为<code>travial destructor</code>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有travial destructor</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt; </span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __destroy_aux(ForwardIterator, ForwardIterator, __true_type) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>最后是版本二的特化版, 同样也什么都不用做, 没有必要做析构.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>*)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(<span class="type">wchar_t</span>*, <span class="type">wchar_t</span>*)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>destroy分为这么几个版本和几个不同的函数执行都是为了提升效率, 较小的调用并不能看出什么, 但是如果是范围析构的话这样不同的选择析构能很节约时间和效率.</p>
<h1 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _JJALLOC_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _JJALLOC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> JJ &#123;</span><br><span class="line"><span class="comment">// 使用operator new分配空间</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">inline</span> T *_allocte(<span class="type">ptrdiff_t</span> size, T *) &#123;</span><br><span class="line">  std::<span class="built_in">set_new_handler</span>(<span class="number">0</span>);</span><br><span class="line">  T *tmp = (T *)(::<span class="keyword">operator</span> <span class="built_in">new</span>((<span class="type">size_t</span>)(size * <span class="built_in">sizeof</span>(T))));</span><br><span class="line">  <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;out of memory&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用operator delete回收空间</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">inline</span> <span class="type">void</span> _deallocate(T *buffer) &#123;</span><br><span class="line">  ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定内存上构造一个对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">inline</span> <span class="type">void</span> _construct(T1 *p, <span class="type">const</span> T2 &amp;value) &#123;</span><br><span class="line">  <span class="comment">// placement new</span></span><br><span class="line">  <span class="keyword">new</span> (p) <span class="built_in">T1</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构一个对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">inline</span> <span class="type">void</span> _destroy(T *ptr) &#123; ptr-&gt;~<span class="built_in">T</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遵循allocator的标准定义相关结构</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">allocator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> T *pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> T *const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> T &amp;reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> T &amp;const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> sizt_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="keyword">struct</span> <span class="title class_">rebind</span> &#123; <span class="keyword">typedef</span> allocator&lt;U&gt; other; &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">pointer <span class="title">allocate</span><span class="params">(sizt_type n, <span class="type">const</span> <span class="type">void</span> *hint = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _allocte((difference_type)n, (pointer)<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer p, sizt_type n)</span> </span>&#123; _deallocate(p); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer p, sizt_type n)</span> </span>&#123; _destroy(p); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span> </span>&#123; _destroy(p); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">const_pointer <span class="title">const_address</span><span class="params">(const_reference x)</span> </span>&#123; <span class="keyword">return</span> (const_pointer)&amp;x; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">sizt_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sizt_type</span>(UINT_MAX / <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace JJ</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ifndef _JJALLOC_H_ */</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之迭代器</title>
    <url>/posts/61f1a409.html</url>
    <content><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是将算法和容器两个独立的泛型进行调和的一个接口. 使我们不需要关系中间的转化是怎么样的就都能直接使用迭代器进行数据访问. 而迭代器最重要的就是对<code>operator *</code>和<code>operator-&gt;</code>进行重载, 使它表现的像一个指针.</p>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a><strong>类型</strong></h1><p>迭代器根据移动特性和实施操作被分为5类</p>
<ol>
<li>input iterator(输入迭代器) : 迭代器所指的内容不能被修改, <strong>只读且只能执行一次读操作.</strong></li>
<li>output iterator(输出迭代器) : 只写并且一次只能执行一次写操作.</li>
<li>forward iterator(正向迭代器) : 支持读写操作且支持多次读写操作.</li>
<li>bidirectional iterator(双向迭代器) : 支持双向的移动且支持多次读写操作.</li>
<li>random access iterator(随即访问迭代器) : 支持双向移动且支持多次读写操作. p+n, p-n等.</li>
</ol>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><strong>源码分析</strong></h1><p><strong>category的五类迭代器以及继承关系</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这五个类都是空类, 只是为了之后调用时通过类选择不同的重载函数. <strong>继承是为了可以使用传递调用，当不存在某种迭代器类型匹配时编译器会依据继承层次向上查找进行传递</strong>, 就可以通过继承关系来决定选择最优的调用. 我们通过用<code>distance</code>来讲最优.</p>
<p><code>distance</code>是用于计算连个迭代器之间的距离, 因为重载就可以通过不同的迭代器类型选择不同的函数来提高效率.</p>
<p>这里<code>distance</code>的<code>iterator_category</code>函数是每个迭代器自己定义的, 它能通过<code>first</code>参数推断出是哪一类的迭代器从而选择调用哪一个函数.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">distance</span><span class="params">(InputIterator first, InputIterator last, Distance&amp; n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	__distance(first, last, n, <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __distance(InputIterator first, InputIterator last, Distance&amp; n, </span><br><span class="line">                       input_iterator_tag) </span><br><span class="line">&#123;</span><br><span class="line">  	<span class="keyword">while</span> (first != last) </span><br><span class="line">    &#123; ++first; ++n; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __distance(RandomAccessIterator first, RandomAccessIterator last, </span><br><span class="line">                       Distance&amp; n, random_access_iterator_tag) </span><br><span class="line">&#123;</span><br><span class="line">  	n += last - first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五类迭代器源码"><a href="#五类迭代器源码" class="headerlink" title="五类迭代器源码"></a>五类迭代器源码</h1><p>五类迭代器的结构体, 可以看出来每个类都定义了相同的变量名. 但是每个名的类型不一定一样, 提供统一的名是为了<code>traits</code>进行类型萃取. 每个类的<code>iterator_category</code>都是代表了不同的迭代器, 通过它来选择该迭代器执行的函数.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; <span class="keyword">struct</span> <span class="title class_">input_iterator</span> </span><br><span class="line">&#123;</span><br><span class="line">  	<span class="keyword">typedef</span> input_iterator_tag iterator_category;</span><br><span class="line">  	<span class="keyword">typedef</span> T                  value_type;</span><br><span class="line">  	<span class="keyword">typedef</span> Distance           difference_type;</span><br><span class="line">  	<span class="keyword">typedef</span> T*                 pointer;</span><br><span class="line">  	<span class="keyword">typedef</span> T&amp;                 reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> output_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">void</span>                reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; <span class="keyword">struct</span> <span class="title class_">forward_iterator</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T                    value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Distance             difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> T*                   pointer;</span><br><span class="line">  <span class="keyword">typedef</span> T&amp;                   reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; <span class="keyword">struct</span> <span class="title class_">bidirectional_iterator</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Distance                   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> T*                         pointer;</span><br><span class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt; <span class="keyword">struct</span> <span class="title class_">random_access_iterator</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Distance                   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> T*                         pointer;</span><br><span class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>iterator_category</code>判断传入迭代器的类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">category</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之typename与class</title>
    <url>/posts/73063487.html</url>
    <content><![CDATA[<h1 id="typename与class"><a href="#typename与class" class="headerlink" title="typename与class"></a>typename与class</h1><h1 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h1><p>一般对模板参数类型<code>typename</code>和<code>class</code>认为是一样的. 这两者在参数类型中确实是一样的. 你可以写成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以写成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">point</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这两者都是一样的, 没有区别. 两者<code>typename</code>和<code>class</code>在<strong>参数类型</strong>中没有不同</p>
<p><em>既然相同又为什么定义这两个符号呢?</em></p>
<ol>
<li>最开始定义定义模板的方法就是template<class T> , 但是class毕竟都认为是一个类, 在使用时难免会有些点混淆, 也就定义了typename来标志参数类型</li>
<li>最重要关于 typename可以使用嵌套依赖类型, 也就是类型可以嵌套使用. 这也是两个的不同之处.</li>
</ol>
<h1 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h1><p><code>typename</code>可以用在嵌套依赖中, 并且表示其类型, 而<code>class</code>并没有这样的功能.</p>
<p><em>什么是嵌套依赖?</em> 我们以一个简单的实例来看</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> T	value_type;</span><br><span class="line">		<span class="keyword">typedef</span> T*	pointer;</span><br><span class="line">		<span class="keyword">typedef</span> T&amp;	reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">man</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> T::value_type	value_type;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> T::pointer		pointer;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> T::reference	reference;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;man&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	man&lt;people&lt;<span class="type">int</span>&gt;&gt; Man;</span><br><span class="line">	Man.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是<code>typename</code>的嵌套使用. <code>typename</code>告诉编译器这不是一个函数, 也不是一个变量而是一个类型. 这里使用typedef又将参数类型重新定义一次, 1. 增加了一层间接性, 2. 使用的时候也不需要在写很长的代码.</p>
<p>这里<code>typename</code>是对people类中定义的类型进行了一次提取, 这里将<code>typename</code>改为<code>class</code>就会出错.</p>
<p><code>typename</code>主要的作用:</p>
<ul>
<li><strong>对于模板参数是类的时候, <code>typename</code>能够提取出该类所定义的参数类型.</strong></li>
</ul>
<p>并不是所有的嵌套依赖类型都要加上<code>typename</code>, 有一个例外 : <strong>当继承列表或成员初始化列表中对基类进行初始化的时候, 可以去掉<code>typename</code>关键字</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">man</span>(<span class="type">int</span> x) : T::<span class="built_in">value_type</span>(x) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这里对<code>typename</code>做了一个浅显的分析, 这也足够我们可以分析<code>traits</code>编程的基础了. 我再将以上的分析做一个归纳.</p>
<ol>
<li><code>typename</code>和<code>class</code>在作为参数类型时用法一样, 没有区别</li>
<li><code>typename</code>主要用于对嵌套依赖类型进行提取(萃取). 而<code>class</code>没有这样的功能.</li>
<li><code>typename</code>提取的一个例外是在继承或成员初始化列表中对基类进行初始化时不用加<code>typename</code>关键字</li>
</ol>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之traits萃取器</title>
    <url>/posts/53f909d4.html</url>
    <content><![CDATA[<h1 id="traits萃取器"><a href="#traits萃取器" class="headerlink" title="traits萃取器"></a>traits萃取器</h1><p>前面我们分析了迭代器的五类, 而迭代器所指向对象的型别被称为<code>value type</code>. 传入参数的类型可以通过编译器自行推断出来, 但是如果是函数的返回值的话, 就无法通过<code>value type</code>让编译器自行推断出来了. 而<code>traits</code>就解决了函数返回值类型. 同样原生指针不能内嵌型别声明，所以内嵌型别在这里不适用, 迭代器无法表示原生指针(int *, char *等称为原生指针). 这个问题就通过<code>traits</code>偏特化技术解决的. 这一篇我们就主要探讨<code>traits</code>是怎么实现这些没有能解决的问题.</p>
<h1 id="iterator-traits结构"><a href="#iterator-traits结构" class="headerlink" title="iterator_traits结构"></a>iterator_traits结构</h1><p><code>iterator_traits</code>结构体就是使用<code>typename</code>对参数类型的提取(萃取), 并且对参数类型在进行一次命名, 看上去对参数类型的使用有了一层间接性. 以下就是它的定义.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;	<span class="comment">//迭代器类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type        value_type;			<span class="comment">// 迭代器所指对象的类型</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type   difference_type;		<span class="comment">// 两个迭代器之间的距离</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer           pointer;				<span class="comment">// 迭代器所指对象的类型指针</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference         reference;			<span class="comment">// 迭代器所指对象的类型引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在五类迭代器对模板对象的类型重新定义一次. 这里提取(萃取)出来的参数类型名都是统一的, 也就说明每个要使用<code>traits</code>编程的类必须以此类型名为标准, 而且需要自己对类定义这些类型名.</p>
<p>上面的<code>traits</code>结构体并没有对原生指针做处理, 所以还要为特化, 偏特化版本(即原生指针)做统一. 以下便是iterator_traits 的特化和偏特化实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对原生指针 T* 生成的 traits 偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> T*                         pointer;</span><br><span class="line">  <span class="keyword">typedef</span> T&amp;                         reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 针对原生指针 const T* 生成的 traits 偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T                          value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>                  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> T*                   pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> T&amp;                   reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样不管是函数返回值类型还是原生指针都能通过萃取器萃取出来, <code>typename I::类型</code>进行类型萃取.</p>
<p>前面也分析了一下<code>iterator_category</code>函数, 现在再来看一下就能明白, 该函数是通过<code>iterator_traits</code>萃取的类型的<code>iterrator_category</code>确定该迭代器的类型的, 五类迭代器都设置了不同的<code>iterator_category</code>的值, 最后调用<code>category()</code>函数确定传入参数的类型.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category category;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">category</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// category的五类类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>继续看<code>distance</code>函数, <code>__distance</code>接受的前三个参数都是一样, 唯一不一样的就是最后一个参数, 通过<code>iterator_category</code>函数萃取出迭代器的类型从而根据类型而执行其对应的<code>__distance</code>函数.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据第三个参数的类型调用相应的重载函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">distance</span><span class="params">(InputIterator first, InputIterator last, Distance&amp; n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	__distance(first, last, n, <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __distance(InputIterator first, InputIterator last, Distance&amp; n, </span><br><span class="line">                       input_iterator_tag) </span><br><span class="line">&#123;</span><br><span class="line">  	<span class="keyword">while</span> (first != last) </span><br><span class="line">    &#123; ++first; ++n; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">Distance</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> __distance(RandomAccessIterator first, RandomAccessIterator last, </span><br><span class="line">                       Distance&amp; n, random_access_iterator_tag) </span><br><span class="line">&#123;</span><br><span class="line">  	n += last - first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又列出了两个类型的实现, <strong>这里用到了0可以转换成指针的性质, 相当于返回一个空指针, 但是可以通过它们确定不同的参数类型</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type*</span></span><br><span class="line"><span class="function"><span class="title">distance_type</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type*</span></span><br><span class="line"><span class="function"><span class="title">value_type</span><span class="params">(<span class="type">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value_type在空间配置器的时有提过, 就是关于destory的第二个版本.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二个版本的, 接受两个迭代器, 并设法找出元素的类型. 通过__type_trais&lt;&gt; 找出最佳措施</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">ForwardIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __destroy(first, last, <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>traits编程使用typename和特化, 偏特化将迭代器没能支持原生指针, 不能推导出函数返回值的问题完善了. 同时traits编程技法对迭代器加以规范, 提前知道了对象的类型相关信息, 从而选择最优的函数执行, 少了类型转化, 提高了执行效率.</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之全特化和偏特化</title>
    <url>/posts/e8cccb2e.html</url>
    <content><![CDATA[<h1 id="全特化和偏特化"><a href="#全特化和偏特化" class="headerlink" title="全特化和偏特化"></a>全特化和偏特化</h1><h1 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h1><p><strong>全特化的模板参数列表应该是为空, 函数和类都可以实现全特化.</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T a)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;fun a = &quot;</span> &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;fun1 a = &quot;</span> &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fun</span>(<span class="number">3.3</span>);</span><br><span class="line">  <span class="built_in">fun</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun a = 3.3</span><br><span class="line">fun1 a = 3</span><br></pre></td></tr></table></figure>

<p>这就是函数全特化, 根据传入的参数让编译器自动推导参数的类型来调用其特殊的函数.</p>
<ol>
<li><strong>函数的全特化不是重载, 不是重载.</strong></li>
<li><strong>全特化的参数列表要为空, 为空</strong></li>
<li>第二点成立是因为我们要实现一个相同的模板, 一个相同的模板</li>
</ol>
<p>同样, 类的全特化也是一样的, 只要满足上面的三点就行了.</p>
<h1 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h1><p><strong>函数不能偏特化, 类可以偏特化.</strong></p>
<p>偏特化需要在运行实例化的时候才能推导确定使用哪一个模板类. 偏特化也是以<code>template</code>来声明的，需要给出剩余的”模板形参”和必要的”模板实参”.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Point&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Point</span>&lt;<span class="type">const</span> T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const Point&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Point&lt;<span class="type">double</span>&gt; b;</span><br><span class="line">  b.<span class="built_in">Print</span>();</span><br><span class="line">  Point&lt;<span class="type">const</span> <span class="type">int</span>&gt; c;</span><br><span class="line">  c.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Point</span><br><span class="line">const Point</span><br></pre></td></tr></table></figure>

<p>偏特化的重点 :</p>
<ol>
<li>函数不能偏特化, 因为函数可以重载, 也就可以实现类型偏特化一样的功, 而类不可以重载.</li>
<li>偏特化只是针对一些特殊的参数类型.</li>
<li>偏特化实现了类的”重载”.</li>
</ol>
<p>还有<strong>除了可以特化类模板之外, 还可以对类模板中的成员函数和普通静态成员变量进行特化</strong>.</p>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><p>上面全特化和偏特化还有一点没有谈论到, 关于优先级. 现在我们就来看一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这是上面的一个实例</span><br><span class="line">fun(3.3);</span><br><span class="line">fun(3);</span><br></pre></td></tr></table></figure>

<p><code>fun(3)</code>的函数不是调用<code>template&lt;class T&gt; void fun(T a)</code>而优先调用的是<code>&lt;int&gt;</code>的全特化模板.</p>
<p>同样偏特化的的例子也能证明这一点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point&lt;<span class="type">double</span>&gt; b;</span><br><span class="line">b.<span class="built_in">Print</span>();</span><br><span class="line">Point&lt;<span class="type">const</span> <span class="type">int</span>&gt; c;</span><br><span class="line">c.<span class="built_in">Print</span>();</span><br></pre></td></tr></table></figure>

<p>类优先调用了最合适的模板.</p>
<p>上面就可以归纳为:</p>
<p>全特化&#x2F;偏特化, 普通模板(优先级从左到右依次减小)</p>
<p>现在我们再实现一个普通没有模板的fun函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果继续调用<code>fun(3)</code>, 你会发现此时没有任何输出. 那是不是没有实现的模板函数和类的实例会优先被调用呢? 确实如此.</p>
<p>以上就可以归纳为 :</p>
<ol>
<li><strong>全特化&#x2F;偏特化, 普通模板(优先级从左到右依次减小)</strong></li>
<li><strong>无模板函数优先级最高</strong></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>函数只能全特化, 不能偏特化, 类既可以全特化, 也可以偏特化.</strong>  函数不能偏特化但是可以重载, 类不能进行重载.</p>
<p><strong>优先级 : 无模板函数 &gt; 全特化&#x2F;偏特化 &gt; 普通模板</strong></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之type_traits型别</title>
    <url>/posts/68abfc82.html</url>
    <content><![CDATA[<h1 id="type-traits型别"><a href="#type-traits型别" class="headerlink" title="__type_traits型别"></a>__type_traits型别</h1><p><code>traits</code>是为了将迭代器没能完善的原生指针, <code>traits</code>用特化和偏特化编程来完善. 这一篇准备探讨<code>__type_traits</code>, 为了将我们在空间配置器里面的提过的<code>__true_type</code>和<code>false_type</code>进行解答. 而<code>type_traits</code>型别对我们STL的效率又有什么影响, 有什么好处?</p>
<h1 id="type-traits介绍"><a href="#type-traits介绍" class="headerlink" title="__type_traits介绍"></a>__type_traits介绍</h1><p>前面介绍的Traits技术在STL中弥补了C++模板的不足，但是Traits技术只是用来规范迭代器，对于迭代器之外的东西没有加以规范。因此，SGI将该技术扩展到迭代器之外，称为<code>__type_traits</code>。iterator_traits是萃取迭代器的特性，而__type_traits是萃取型别的特性。萃取的型别如下：</p>
<ul>
<li>是否具备non-trivial default ctor?</li>
<li>是否具备non-trivial copy ctor?</li>
<li>是否具备non-trivial assignment operator?</li>
<li>是否具备non-trivial dtor?</li>
<li>是否为POD（plain old data）型别？</li>
</ul>
<p>其中non-trivial意指非默认的相应函数，编译器会为每个类构造以上四种默认的函数，如果没有定义自己的，就会用编译器默认函数，如果使用默认的函数，我们可以使用memcpy(),memmove(),malloc()等函数来加快速度，提高效率.</p>
<p>且<code>__iterator_traits</code>允许针对不同的型别属性在编译期间决定执行哪个重载函数而不是在运行时才处理, 这大大提升了运行效率. 这就需要STL提前做好选择的准备. 是否为<strong>POD, non-trivial型别</strong>用<code>__true_type</code>和<code>__false_type</code> 来区分.</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>template</tag>
        <tag>stl</tag>
      </tags>
  </entry>
</search>
